<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/readelf/readelf.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;capsicum_helpers.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dwarf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libdwarf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelftc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libcasper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;casper/cap_fileargs.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"_elftc.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>ELFTC_VCSID</name><argument_list>(<argument><expr><literal type="string">"$Id: readelf.c 3769 2019-06-29 15:15:02Z emaste $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STB_GNU_UNIQUE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STB_GNU_UNIQUE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STT_SPARC_REGISTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STT_SPARC_REGISTER</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_AA</name></cpp:macro> <cpp:value>0x00000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_C</name></cpp:macro> <cpp:value>0x00000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_DD</name></cpp:macro> <cpp:value>0x00000004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_D</name></cpp:macro> <cpp:value>0x00000008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_G</name></cpp:macro> <cpp:value>0x00000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_H</name></cpp:macro> <cpp:value>0x00000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_II</name></cpp:macro> <cpp:value>0x00000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_I</name></cpp:macro> <cpp:value>0x00000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_L</name></cpp:macro> <cpp:value>0x00000100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_NN</name></cpp:macro> <cpp:value>0x00000200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_N</name></cpp:macro> <cpp:value>0x00000400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_P</name></cpp:macro> <cpp:value>0x00000800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_R</name></cpp:macro> <cpp:value>0x00001000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_SS</name></cpp:macro> <cpp:value>0x00002000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_S</name></cpp:macro> <cpp:value>0x00004000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_T</name></cpp:macro> <cpp:value>0x00008000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_U</name></cpp:macro> <cpp:value>0x00010000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_VV</name></cpp:macro> <cpp:value>0x00020000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_WW</name></cpp:macro> <cpp:value>0x00040000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_W</name></cpp:macro> <cpp:value>0x00080000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_X</name></cpp:macro> <cpp:value>0x00100000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RE_Z</name></cpp:macro> <cpp:value>0x00200000</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_A</name></cpp:macro> <cpp:value>0x00000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_FF</name></cpp:macro> <cpp:value>0x00000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_F</name></cpp:macro> <cpp:value>0x00000004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_I</name></cpp:macro> <cpp:value>0x00000008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_LL</name></cpp:macro> <cpp:value>0x00000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_L</name></cpp:macro> <cpp:value>0x00000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_M</name></cpp:macro> <cpp:value>0x00000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_O</name></cpp:macro> <cpp:value>0x00000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_P</name></cpp:macro> <cpp:value>0x00000100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_RR</name></cpp:macro> <cpp:value>0x00000200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_R</name></cpp:macro> <cpp:value>0x00000400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_S</name></cpp:macro> <cpp:value>0x00000800</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DW_DEFAULT_OPTIONS</name></cpp:macro> <cpp:value>(DW_A | DW_F | DW_I | DW_L | DW_O | DW_P | DW_R | DW_RR | DW_S)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPLAY_FILENAME</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>




<struct>struct <name>section</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>entsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>link</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>info</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>dumpop</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>si</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl>;</decl_stmt>
}</block> <decl><name>u</name></decl>;</union>
<enum>enum <block>{
<decl><name>DUMP_BY_INDEX</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>DUMP_BY_NAME</name></decl>
}</block> <decl><name>type</name></decl>;</enum>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEX_DUMP</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_DUMP</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>op</name></decl>;</decl_stmt>
<macro><name>STAILQ_ENTRY</name><argument_list>(<argument>dumpop</argument>)</argument_list></macro> <expr_stmt><expr><name>dumpop_list</name></expr>;</expr_stmt>
}</block>;</struct>

<struct>struct <name>symver</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block>;</struct>




<struct>struct <name>readelf</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>ar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>cu_psize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>cu_osize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>cu_ver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>vd_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>vn_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>vs_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>vs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>vs_sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>symver</name></name> <modifier>*</modifier></type><name>ver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ver_sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
<macro><name>STAILQ_HEAD</name><argument_list>(<argument/>, <argument>dumpop</argument>)</argument_list></macro> <expr_stmt><expr><name>v_dumpop</name></expr>;</expr_stmt>
<function_decl><type><name>uint64_t</name></type> (<modifier>*</modifier><name>dw_read</name>)<parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uint64_t</name></type> (<modifier>*</modifier><name>dw_decode</name>)<parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<enum>enum <name>options</name>
<block>{
<decl><name>OPTION_DEBUG_DUMP</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>longopts</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"arch-specific"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'A'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"archive-index"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'c'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"debug-dump"</literal></expr>, <expr><name>optional_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>OPTION_DEBUG_DUMP</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"decompress"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'z'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"dynamic"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'d'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"file-header"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"full-section-name"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"headers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'H'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"hex-dump"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"histogram"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'I'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"notes"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'n'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"program-headers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"relocs"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"sections"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"section-headers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"section-groups"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'g'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"section-details"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"segments"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"string-dump"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"symbols"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"syms"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"unwind"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'u'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"use-dynamic"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"version-info"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'v'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"wide"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct>struct <name>eflags_desc</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>flag_desc</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>flag_desc_list</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>flag_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>mips_option</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>loc_at</name> <block>{
<decl_stmt><decl><type><name>Dwarf_Attribute</name></type> <name>la_at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>la_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>la_lowpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>la_cu_psize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>la_cu_osize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>la_cu_ver</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_dumpop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>si</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_adv_simd_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>simd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_align_needed</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>an</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_align_preserved</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_arm_isa</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ai</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_cpu_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>arch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_cpu_arch_profile</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>pf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_div</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>du</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_enum_size</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>es</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_16bit_format</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp16</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_denormal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_exceptions</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_hpext</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fh</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_number_model</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_optm_goal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_rounding</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_hardfp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>hfp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_mpext</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>mp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_optm_goal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>og</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_config</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>pcs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_got</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>got</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_r9</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>r9</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_ro</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ro</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_rw</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>rw</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_pcs_wchar_t</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_t2ee</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>t2ee</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_thumb_isa</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_fp_user_exceptions</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fu</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_unaligned_access</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ua</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_vfp_args</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>va</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_virtual</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>vt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_wmmx_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wmmx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aeabi_wmmx_args</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wa</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_class</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_endian</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>endian</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_machine</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_osabi</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>abi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>elf_ver</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ver</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dt_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>dtype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dump_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_arm_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>dump_compatibility_tag</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_abbrev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_aranges</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_block</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_die</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_frame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>alt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_frame_inst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Cie</name></type> <name>cie</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>insts</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>caf</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Signed</name></type> <name>daf</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Addr</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>dump_dwarf_frame_regtable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Fde</name></type> <name>fde</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Addr</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>func_len</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>cie_ra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_frame_section</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>alt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Bool</name></type> <name>is_info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_macinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_line_decoded</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_loc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Loc</name> <modifier>*</modifier></type><name>lr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_loclist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_pubnames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_ranges</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_ranges_foreach</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Addr</name></type> <name>base</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dwarf_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_eflags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>e_flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>flag_desc</name></name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dyn_val</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>GElf_Dyn</name> <modifier>*</modifier></type><name>dyn</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>stab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_dynamic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_liblist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_abiflags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_odk_reginfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_option_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mips_option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_reginfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_mips_specific_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_notes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_notes_content</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_notes_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_svr4_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_svr4_hash64</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_gnu_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_gnu_property_type_0</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_phdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_ppc_attributes</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_section_groups</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_symtab</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_symtabs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>dump_unknown_tag</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_ver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_verdef</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_verneed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_versym</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dwarf_reg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dwarf_regname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>dumpop</name></name> <modifier>*</modifier></type><name>find_dumpop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>si</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_ent_count</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ent_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_mips_register_size</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_regoff_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>reg</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Addr</name></type> <name>off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_string</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strtab</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_symbol_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>get_symbol_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>loc_at_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>la1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>la2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mips_abi_fp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_name</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>et</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_freebsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_freebsd_core</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_go</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_gnu</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_linux_core</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_netbsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_openbsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_unknown</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>note_type_xen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option_kind</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>phdr_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ppc_abi_fp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ppc_abi_vector</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>vec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readelf_usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readelf_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>search_loclist_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>lowpc</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>loc_at</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>la_list</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>la_list_len</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>la_list_cap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>search_ver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>stype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_cu_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>psize</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Half</name></type> <name>osize</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>ver</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>st_bind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sbind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>st_shndx</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>shndx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>st_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>os</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>stype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>st_vis</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>svis</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>top_tag</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unload_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_read_lsb</name><parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsetp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_read_msb</name><parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsetp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_decode_lsb</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_decode_msb</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64_t</name></type> <name>_decode_sleb128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dpe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>_decode_uleb128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dpe</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eflags_desc</name></name></type> <name><name>arm_eflags_desc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>EF_ARM_RELEXEC</name></expr>, <expr><literal type="string">"relocatable executable"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_HASENTRY</name></expr>, <expr><literal type="string">"has entry point"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_SYMSARESORTED</name></expr>, <expr><literal type="string">"sorted symbol tables"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_DYNSYMSUSESEGIDX</name></expr>, <expr><literal type="string">"dynamic symbols use segment index"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_MAPSYMSFIRST</name></expr>, <expr><literal type="string">"mapping symbols precede others"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_BE8</name></expr>, <expr><literal type="string">"BE8"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_LE8</name></expr>, <expr><literal type="string">"LE8"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_INTERWORK</name></expr>, <expr><literal type="string">"interworking enabled"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_APCS_26</name></expr>, <expr><literal type="string">"uses APCS/26"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_APCS_FLOAT</name></expr>, <expr><literal type="string">"uses APCS/float"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_PIC</name></expr>, <expr><literal type="string">"position independent"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_ALIGN8</name></expr>, <expr><literal type="string">"8 bit structure alignment"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_NEW_ABI</name></expr>, <expr><literal type="string">"uses new ABI"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_OLD_ABI</name></expr>, <expr><literal type="string">"uses old ABI"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_SOFT_FLOAT</name></expr>, <expr><literal type="string">"software FP"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_VFP_FLOAT</name></expr>, <expr><literal type="string">"VFP"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_ARM_MAVERICK_FLOAT</name></expr>, <expr><literal type="string">"Maverick FP"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eflags_desc</name></name></type> <name><name>mips_eflags_desc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>EF_MIPS_NOREORDER</name></expr>, <expr><literal type="string">"noreorder"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_PIC</name></expr>, <expr><literal type="string">"pic"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_CPIC</name></expr>, <expr><literal type="string">"cpic"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_UCODE</name></expr>, <expr><literal type="string">"ugen_reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_ABI2</name></expr>, <expr><literal type="string">"abi2"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_OPTIONS_FIRST</name></expr>, <expr><literal type="string">"odk first"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_ARCH_ASE_MDMX</name></expr>, <expr><literal type="string">"mdmx"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_MIPS_ARCH_ASE_M16</name></expr>, <expr><literal type="string">"mips16"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eflags_desc</name></name></type> <name><name>powerpc_eflags_desc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>EF_PPC_EMB</name></expr>, <expr><literal type="string">"emb"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_PPC_RELOCATABLE</name></expr>, <expr><literal type="string">"relocatable"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_PPC_RELOCATABLE_LIB</name></expr>, <expr><literal type="string">"relocatable-lib"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eflags_desc</name></name></type> <name><name>riscv_eflags_desc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>EF_RISCV_RVC</name></expr>, <expr><literal type="string">"RVC"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_RISCV_RVE</name></expr>, <expr><literal type="string">"RVE"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_RISCV_TSO</name></expr>, <expr><literal type="string">"TSO"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eflags_desc</name></name></type> <name><name>sparc_eflags_desc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>EF_SPARC_32PLUS</name></expr>, <expr><literal type="string">"v8+"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_SPARC_SUN_US1</name></expr>, <expr><literal type="string">"ultrasparcI"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_SPARC_HAL_R1</name></expr>, <expr><literal type="string">"halr1"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>EF_SPARC_SUN_US3</name></expr>, <expr><literal type="string">"ultrasparcIII"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_osabi</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>abi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_abi</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>abi</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFOSABI_NONE</name></expr>:</case> <return>return <expr><literal type="string">"NONE"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_HPUX</name></expr>:</case> <return>return <expr><literal type="string">"HPUX"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_NETBSD</name></expr>:</case> <return>return <expr><literal type="string">"NetBSD"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_GNU</name></expr>:</case> <return>return <expr><literal type="string">"GNU"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_HURD</name></expr>:</case> <return>return <expr><literal type="string">"HURD"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_86OPEN</name></expr>:</case> <return>return <expr><literal type="string">"86OPEN"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_SOLARIS</name></expr>:</case> <return>return <expr><literal type="string">"Solaris"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_AIX</name></expr>:</case> <return>return <expr><literal type="string">"AIX"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_IRIX</name></expr>:</case> <return>return <expr><literal type="string">"IRIX"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_FREEBSD</name></expr>:</case> <return>return <expr><literal type="string">"FreeBSD"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_TRU64</name></expr>:</case> <return>return <expr><literal type="string">"TRU64"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_MODESTO</name></expr>:</case> <return>return <expr><literal type="string">"MODESTO"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_OPENBSD</name></expr>:</case> <return>return <expr><literal type="string">"OpenBSD"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_OPENVMS</name></expr>:</case> <return>return <expr><literal type="string">"OpenVMS"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_NSK</name></expr>:</case> <return>return <expr><literal type="string">"NSK"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_CLOUDABI</name></expr>:</case> <return>return <expr><literal type="string">"CloudABI"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_ARM_AEABI</name></expr>:</case> <return>return <expr><literal type="string">"ARM EABI"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_ARM</name></expr>:</case> <return>return <expr><literal type="string">"ARM"</literal></expr>;</return>
<case>case <expr><name>ELFOSABI_STANDALONE</name></expr>:</case> <return>return <expr><literal type="string">"StandAlone"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_abi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_abi</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>abi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_abi</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_machine</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_mach</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_NONE</name></expr>:</case> <return>return <expr><literal type="string">"Unknown machine"</literal></expr>;</return>
<case>case <expr><name>EM_M32</name></expr>:</case> <return>return <expr><literal type="string">"AT&amp;T WE32100"</literal></expr>;</return>
<case>case <expr><name>EM_SPARC</name></expr>:</case> <return>return <expr><literal type="string">"Sun SPARC"</literal></expr>;</return>
<case>case <expr><name>EM_386</name></expr>:</case> <return>return <expr><literal type="string">"Intel i386"</literal></expr>;</return>
<case>case <expr><name>EM_68K</name></expr>:</case> <return>return <expr><literal type="string">"Motorola 68000"</literal></expr>;</return>
<case>case <expr><name>EM_IAMCU</name></expr>:</case> <return>return <expr><literal type="string">"Intel MCU"</literal></expr>;</return>
<case>case <expr><name>EM_88K</name></expr>:</case> <return>return <expr><literal type="string">"Motorola 88000"</literal></expr>;</return>
<case>case <expr><name>EM_860</name></expr>:</case> <return>return <expr><literal type="string">"Intel i860"</literal></expr>;</return>
<case>case <expr><name>EM_MIPS</name></expr>:</case> <return>return <expr><literal type="string">"MIPS R3000 Big-Endian only"</literal></expr>;</return>
<case>case <expr><name>EM_S370</name></expr>:</case> <return>return <expr><literal type="string">"IBM System/370"</literal></expr>;</return>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS R3000 Little-Endian"</literal></expr>;</return>
<case>case <expr><name>EM_PARISC</name></expr>:</case> <return>return <expr><literal type="string">"HP PA-RISC"</literal></expr>;</return>
<case>case <expr><name>EM_VPP500</name></expr>:</case> <return>return <expr><literal type="string">"Fujitsu VPP500"</literal></expr>;</return>
<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case> <return>return <expr><literal type="string">"SPARC v8plus"</literal></expr>;</return>
<case>case <expr><name>EM_960</name></expr>:</case> <return>return <expr><literal type="string">"Intel 80960"</literal></expr>;</return>
<case>case <expr><name>EM_PPC</name></expr>:</case> <return>return <expr><literal type="string">"PowerPC 32-bit"</literal></expr>;</return>
<case>case <expr><name>EM_PPC64</name></expr>:</case> <return>return <expr><literal type="string">"PowerPC 64-bit"</literal></expr>;</return>
<case>case <expr><name>EM_S390</name></expr>:</case> <return>return <expr><literal type="string">"IBM System/390"</literal></expr>;</return>
<case>case <expr><name>EM_V800</name></expr>:</case> <return>return <expr><literal type="string">"NEC V800"</literal></expr>;</return>
<case>case <expr><name>EM_FR20</name></expr>:</case> <return>return <expr><literal type="string">"Fujitsu FR20"</literal></expr>;</return>
<case>case <expr><name>EM_RH32</name></expr>:</case> <return>return <expr><literal type="string">"TRW RH-32"</literal></expr>;</return>
<case>case <expr><name>EM_RCE</name></expr>:</case> <return>return <expr><literal type="string">"Motorola RCE"</literal></expr>;</return>
<case>case <expr><name>EM_ARM</name></expr>:</case> <return>return <expr><literal type="string">"ARM"</literal></expr>;</return>
<case>case <expr><name>EM_SH</name></expr>:</case> <return>return <expr><literal type="string">"Hitachi SH"</literal></expr>;</return>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case> <return>return <expr><literal type="string">"SPARC v9 64-bit"</literal></expr>;</return>
<case>case <expr><name>EM_TRICORE</name></expr>:</case> <return>return <expr><literal type="string">"Siemens TriCore embedded processor"</literal></expr>;</return>
<case>case <expr><name>EM_ARC</name></expr>:</case> <return>return <expr><literal type="string">"Argonaut RISC Core"</literal></expr>;</return>
<case>case <expr><name>EM_H8_300</name></expr>:</case> <return>return <expr><literal type="string">"Hitachi H8/300"</literal></expr>;</return>
<case>case <expr><name>EM_H8_300H</name></expr>:</case> <return>return <expr><literal type="string">"Hitachi H8/300H"</literal></expr>;</return>
<case>case <expr><name>EM_H8S</name></expr>:</case> <return>return <expr><literal type="string">"Hitachi H8S"</literal></expr>;</return>
<case>case <expr><name>EM_H8_500</name></expr>:</case> <return>return <expr><literal type="string">"Hitachi H8/500"</literal></expr>;</return>
<case>case <expr><name>EM_IA_64</name></expr>:</case> <return>return <expr><literal type="string">"Intel IA-64 Processor"</literal></expr>;</return>
<case>case <expr><name>EM_MIPS_X</name></expr>:</case> <return>return <expr><literal type="string">"Stanford MIPS-X"</literal></expr>;</return>
<case>case <expr><name>EM_COLDFIRE</name></expr>:</case> <return>return <expr><literal type="string">"Motorola ColdFire"</literal></expr>;</return>
<case>case <expr><name>EM_68HC12</name></expr>:</case> <return>return <expr><literal type="string">"Motorola M68HC12"</literal></expr>;</return>
<case>case <expr><name>EM_MMA</name></expr>:</case> <return>return <expr><literal type="string">"Fujitsu MMA"</literal></expr>;</return>
<case>case <expr><name>EM_PCP</name></expr>:</case> <return>return <expr><literal type="string">"Siemens PCP"</literal></expr>;</return>
<case>case <expr><name>EM_NCPU</name></expr>:</case> <return>return <expr><literal type="string">"Sony nCPU"</literal></expr>;</return>
<case>case <expr><name>EM_NDR1</name></expr>:</case> <return>return <expr><literal type="string">"Denso NDR1 microprocessor"</literal></expr>;</return>
<case>case <expr><name>EM_STARCORE</name></expr>:</case> <return>return <expr><literal type="string">"Motorola Star*Core processor"</literal></expr>;</return>
<case>case <expr><name>EM_ME16</name></expr>:</case> <return>return <expr><literal type="string">"Toyota ME16 processor"</literal></expr>;</return>
<case>case <expr><name>EM_ST100</name></expr>:</case> <return>return <expr><literal type="string">"STMicroelectronics ST100 processor"</literal></expr>;</return>
<case>case <expr><name>EM_TINYJ</name></expr>:</case> <return>return <expr><literal type="string">"Advanced Logic Corp. TinyJ processor"</literal></expr>;</return>
<case>case <expr><name>EM_X86_64</name></expr>:</case> <return>return <expr><literal type="string">"Advanced Micro Devices x86-64"</literal></expr>;</return>
<case>case <expr><name>EM_PDSP</name></expr>:</case> <return>return <expr><literal type="string">"Sony DSP Processor"</literal></expr>;</return>
<case>case <expr><name>EM_FX66</name></expr>:</case> <return>return <expr><literal type="string">"Siemens FX66 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_ST9PLUS</name></expr>:</case> <return>return <expr><literal type="string">"STMicroelectronics ST9+ 8/16 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_ST7</name></expr>:</case> <return>return <expr><literal type="string">"STmicroelectronics ST7 8-bit microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_68HC16</name></expr>:</case> <return>return <expr><literal type="string">"Motorola MC68HC16 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_68HC11</name></expr>:</case> <return>return <expr><literal type="string">"Motorola MC68HC11 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_68HC08</name></expr>:</case> <return>return <expr><literal type="string">"Motorola MC68HC08 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_68HC05</name></expr>:</case> <return>return <expr><literal type="string">"Motorola MC68HC05 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_SVX</name></expr>:</case> <return>return <expr><literal type="string">"Silicon Graphics SVx"</literal></expr>;</return>
<case>case <expr><name>EM_ST19</name></expr>:</case> <return>return <expr><literal type="string">"STMicroelectronics ST19 8-bit mc"</literal></expr>;</return>
<case>case <expr><name>EM_VAX</name></expr>:</case> <return>return <expr><literal type="string">"Digital VAX"</literal></expr>;</return>
<case>case <expr><name>EM_CRIS</name></expr>:</case> <return>return <expr><literal type="string">"Axis Communications 32-bit embedded processor"</literal></expr>;</return>
<case>case <expr><name>EM_JAVELIN</name></expr>:</case> <return>return <expr><literal type="string">"Infineon Tech. 32bit embedded processor"</literal></expr>;</return>
<case>case <expr><name>EM_FIREPATH</name></expr>:</case> <return>return <expr><literal type="string">"Element 14 64-bit DSP Processor"</literal></expr>;</return>
<case>case <expr><name>EM_ZSP</name></expr>:</case> <return>return <expr><literal type="string">"LSI Logic 16-bit DSP Processor"</literal></expr>;</return>
<case>case <expr><name>EM_MMIX</name></expr>:</case> <return>return <expr><literal type="string">"Donald Knuth's educational 64-bit proc"</literal></expr>;</return>
<case>case <expr><name>EM_HUANY</name></expr>:</case> <return>return <expr><literal type="string">"Harvard University MI object files"</literal></expr>;</return>
<case>case <expr><name>EM_PRISM</name></expr>:</case> <return>return <expr><literal type="string">"SiTera Prism"</literal></expr>;</return>
<case>case <expr><name>EM_AVR</name></expr>:</case> <return>return <expr><literal type="string">"Atmel AVR 8-bit microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_FR30</name></expr>:</case> <return>return <expr><literal type="string">"Fujitsu FR30"</literal></expr>;</return>
<case>case <expr><name>EM_D10V</name></expr>:</case> <return>return <expr><literal type="string">"Mitsubishi D10V"</literal></expr>;</return>
<case>case <expr><name>EM_D30V</name></expr>:</case> <return>return <expr><literal type="string">"Mitsubishi D30V"</literal></expr>;</return>
<case>case <expr><name>EM_V850</name></expr>:</case> <return>return <expr><literal type="string">"NEC v850"</literal></expr>;</return>
<case>case <expr><name>EM_M32R</name></expr>:</case> <return>return <expr><literal type="string">"Mitsubishi M32R"</literal></expr>;</return>
<case>case <expr><name>EM_MN10300</name></expr>:</case> <return>return <expr><literal type="string">"Matsushita MN10300"</literal></expr>;</return>
<case>case <expr><name>EM_MN10200</name></expr>:</case> <return>return <expr><literal type="string">"Matsushita MN10200"</literal></expr>;</return>
<case>case <expr><name>EM_PJ</name></expr>:</case> <return>return <expr><literal type="string">"picoJava"</literal></expr>;</return>
<case>case <expr><name>EM_OPENRISC</name></expr>:</case> <return>return <expr><literal type="string">"OpenRISC 32-bit embedded processor"</literal></expr>;</return>
<case>case <expr><name>EM_ARC_A5</name></expr>:</case> <return>return <expr><literal type="string">"ARC Cores Tangent-A5"</literal></expr>;</return>
<case>case <expr><name>EM_XTENSA</name></expr>:</case> <return>return <expr><literal type="string">"Tensilica Xtensa Architecture"</literal></expr>;</return>
<case>case <expr><name>EM_VIDEOCORE</name></expr>:</case> <return>return <expr><literal type="string">"Alphamosaic VideoCore processor"</literal></expr>;</return>
<case>case <expr><name>EM_TMM_GPP</name></expr>:</case> <return>return <expr><literal type="string">"Thompson Multimedia General Purpose Processor"</literal></expr>;</return>
<case>case <expr><name>EM_NS32K</name></expr>:</case> <return>return <expr><literal type="string">"National Semiconductor 32000 series"</literal></expr>;</return>
<case>case <expr><name>EM_TPC</name></expr>:</case> <return>return <expr><literal type="string">"Tenor Network TPC processor"</literal></expr>;</return>
<case>case <expr><name>EM_SNP1K</name></expr>:</case> <return>return <expr><literal type="string">"Trebia SNP 1000 processor"</literal></expr>;</return>
<case>case <expr><name>EM_ST200</name></expr>:</case> <return>return <expr><literal type="string">"STMicroelectronics ST200 microcontroller"</literal></expr>;</return>
<case>case <expr><name>EM_IP2K</name></expr>:</case> <return>return <expr><literal type="string">"Ubicom IP2xxx microcontroller family"</literal></expr>;</return>
<case>case <expr><name>EM_MAX</name></expr>:</case> <return>return <expr><literal type="string">"MAX Processor"</literal></expr>;</return>
<case>case <expr><name>EM_CR</name></expr>:</case> <return>return <expr><literal type="string">"National Semiconductor CompactRISC microprocessor"</literal></expr>;</return>
<case>case <expr><name>EM_F2MC16</name></expr>:</case> <return>return <expr><literal type="string">"Fujitsu F2MC16"</literal></expr>;</return>
<case>case <expr><name>EM_MSP430</name></expr>:</case> <return>return <expr><literal type="string">"TI embedded microcontroller msp430"</literal></expr>;</return>
<case>case <expr><name>EM_BLACKFIN</name></expr>:</case> <return>return <expr><literal type="string">"Analog Devices Blackfin (DSP) processor"</literal></expr>;</return>
<case>case <expr><name>EM_SE_C33</name></expr>:</case> <return>return <expr><literal type="string">"S1C33 Family of Seiko Epson processors"</literal></expr>;</return>
<case>case <expr><name>EM_SEP</name></expr>:</case> <return>return <expr><literal type="string">"Sharp embedded microprocessor"</literal></expr>;</return>
<case>case <expr><name>EM_ARCA</name></expr>:</case> <return>return <expr><literal type="string">"Arca RISC Microprocessor"</literal></expr>;</return>
<case>case <expr><name>EM_UNICORE</name></expr>:</case> <return>return <expr><literal type="string">"Microprocessor series from PKU-Unity Ltd"</literal></expr>;</return>
<case>case <expr><name>EM_AARCH64</name></expr>:</case> <return>return <expr><literal type="string">"AArch64"</literal></expr>;</return>
<case>case <expr><name>EM_RISCV</name></expr>:</case> <return>return <expr><literal type="string">"RISC-V"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_mach</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_mach</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>mach</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_mach</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_class</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_class</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>class</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFCLASSNONE</name></expr>:</case> <return>return <expr><literal type="string">"none"</literal></expr>;</return>
<case>case <expr><name>ELFCLASS32</name></expr>:</case> <return>return <expr><literal type="string">"ELF32"</literal></expr>;</return>
<case>case <expr><name>ELFCLASS64</name></expr>:</case> <return>return <expr><literal type="string">"ELF64"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_class</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_class</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_class</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_endian</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>endian</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_endian</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>endian</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFDATANONE</name></expr>:</case> <return>return <expr><literal type="string">"none"</literal></expr>;</return>
<case>case <expr><name>ELFDATA2LSB</name></expr>:</case> <return>return <expr><literal type="string">"2's complement, little endian"</literal></expr>;</return>
<case>case <expr><name>ELFDATA2MSB</name></expr>:</case> <return>return <expr><literal type="string">"2's complement, big endian"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_endian</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_endian</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>endian</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_endian</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_type</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ET_NONE</name></expr>:</case> <return>return <expr><literal type="string">"NONE (None)"</literal></expr>;</return>
<case>case <expr><name>ET_REL</name></expr>:</case> <return>return <expr><literal type="string">"REL (Relocatable file)"</literal></expr>;</return>
<case>case <expr><name>ET_EXEC</name></expr>:</case> <return>return <expr><literal type="string">"EXEC (Executable file)"</literal></expr>;</return>
<case>case <expr><name>ET_DYN</name></expr>:</case> <return>return <expr><literal type="string">"DYN (Shared object file)"</literal></expr>;</return>
<case>case <expr><name>ET_CORE</name></expr>:</case> <return>return <expr><literal type="string">"CORE (Core file)"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>ET_LOPROC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;proc: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>ET_LOOS</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>&lt;=</operator> <name>ET_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;os: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_type</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_ver</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ver</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ver</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EV_CURRENT</name></expr>:</case> <return>return <expr><literal type="string">"(current)"</literal></expr>;</return>
<case>case <expr><name>EV_NONE</name></expr>:</case> <return>return <expr><literal type="string">"(none)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ver</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ver</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>ver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ver</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>phdr_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ptype</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>&gt;=</operator> <name>PT_LOPROC</name> <operator>&amp;&amp;</operator> <name>ptype</name> <operator>&lt;=</operator> <name>PT_HIPROC</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_ARM</name></expr>:</case>
<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_ARM_ARCHEXT</name></expr>:</case> <return>return <expr><literal type="string">"ARM_ARCHEXT"</literal></expr>;</return>
<case>case <expr><name>PT_ARM_EXIDX</name></expr>:</case> <return>return <expr><literal type="string">"ARM_EXIDX"</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ptype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ptype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LOPROC+%#x"</literal></expr></argument>,
<argument><expr><name>ptype</name> <operator>-</operator> <name>PT_LOPROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ptype</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
<case>case <expr><name>PT_LOAD</name></expr>:</case> <return>return <expr><literal type="string">"LOAD"</literal></expr>;</return>
<case>case <expr><name>PT_DYNAMIC</name></expr>:</case> <return>return <expr><literal type="string">"DYNAMIC"</literal></expr>;</return>
<case>case <expr><name>PT_INTERP</name></expr>:</case> <return>return <expr><literal type="string">"INTERP"</literal></expr>;</return>
<case>case <expr><name>PT_NOTE</name></expr>:</case> <return>return <expr><literal type="string">"NOTE"</literal></expr>;</return>
<case>case <expr><name>PT_SHLIB</name></expr>:</case> <return>return <expr><literal type="string">"SHLIB"</literal></expr>;</return>
<case>case <expr><name>PT_PHDR</name></expr>:</case> <return>return <expr><literal type="string">"PHDR"</literal></expr>;</return>
<case>case <expr><name>PT_TLS</name></expr>:</case> <return>return <expr><literal type="string">"TLS"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_EH_FRAME</name></expr>:</case> <return>return <expr><literal type="string">"GNU_EH_FRAME"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_STACK</name></expr>:</case> <return>return <expr><literal type="string">"GNU_STACK"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_RELRO</name></expr>:</case> <return>return <expr><literal type="string">"GNU_RELRO"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_RANDOMIZE</name></expr>:</case> <return>return <expr><literal type="string">"OPENBSD_RANDOMIZE"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_WXNEEDED</name></expr>:</case> <return>return <expr><literal type="string">"OPENBSD_WXNEEDED"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_BOOTDATA</name></expr>:</case> <return>return <expr><literal type="string">"OPENBSD_BOOTDATA"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>&gt;=</operator> <name>PT_LOOS</name> <operator>&amp;&amp;</operator> <name>ptype</name> <operator>&lt;=</operator> <name>PT_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ptype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ptype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LOOS+%#x"</literal></expr></argument>,
<argument><expr><name>ptype</name> <operator>-</operator> <name>PT_LOOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ptype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ptype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_ptype</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>section_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>stype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_stype</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stype</name> <operator>&gt;=</operator> <name>SHT_LOPROC</name> <operator>&amp;&amp;</operator> <name>stype</name> <operator>&lt;=</operator> <name>SHT_HIPROC</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_ARM</name></expr>:</case>
<switch>switch <condition>(<expr><name>stype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_ARM_EXIDX</name></expr>:</case> <return>return <expr><literal type="string">"ARM_EXIDX"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_PREEMPTMAP</name></expr>:</case> <return>return <expr><literal type="string">"ARM_PREEMPTMAP"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_ATTRIBUTES</name></expr>:</case> <return>return <expr><literal type="string">"ARM_ATTRIBUTES"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_DEBUGOVERLAY</name></expr>:</case> <return>return <expr><literal type="string">"ARM_DEBUGOVERLAY"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_OVERLAYSECTION</name></expr>:</case> <return>return <expr><literal type="string">"ARM_OVERLAYSECTION"</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_X86_64</name></expr>:</case>
<switch>switch <condition>(<expr><name>stype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_X86_64_UNWIND</name></expr>:</case> <return>return <expr><literal type="string">"X86_64_UNWIND"</literal></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>
<switch>switch <condition>(<expr><name>stype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_MIPS_LIBLIST</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_LIBLIST"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_MSYM</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_MSYM"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_CONFLICT</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_CONFLICT"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_GPTAB</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_GPTAB"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_UCODE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_UCODE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DEBUG</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DEBUG"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_REGINFO</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_REGINFO"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_PACKAGE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_PACKAGE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_PACKSYM</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_PACKSYM"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_RELD</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_RELD"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_IFACE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_IFACE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_CONTENT</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_CONTENT"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_OPTIONS</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_OPTIONS"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DELTASYM</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DELTASYM"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DELTAINST</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DELTAINST"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DELTACLASS</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DELTACLASS"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DWARF</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DWARF"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_DELTADECL</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_DELTADECL"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_SYMBOL_LIB</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_SYMBOL_LIB"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_EVENTS</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_EVENTS"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_TRANSLATE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_TRANSLATE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_PIXIE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_PIXIE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_XLATE</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_XLATE"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_XLATE_DEBUG</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_XLATE_DEBUG"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_WHIRL</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_WHIRL"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_EH_REGION</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_EH_REGION"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_XLATE_OLD</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_XLATE_OLD"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_PDR_EXCEPTION</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_PDR_EXCEPTION"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_ABIFLAGS</name></expr>:</case> <return>return <expr><literal type="string">"MIPS_ABIFLAGS"</literal></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LOPROC+%#x"</literal></expr></argument>,
<argument><expr><name>stype</name> <operator>-</operator> <name>SHT_LOPROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_stype</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>stype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
<case>case <expr><name>SHT_PROGBITS</name></expr>:</case> <return>return <expr><literal type="string">"PROGBITS"</literal></expr>;</return>
<case>case <expr><name>SHT_SYMTAB</name></expr>:</case> <return>return <expr><literal type="string">"SYMTAB"</literal></expr>;</return>
<case>case <expr><name>SHT_STRTAB</name></expr>:</case> <return>return <expr><literal type="string">"STRTAB"</literal></expr>;</return>
<case>case <expr><name>SHT_RELA</name></expr>:</case> <return>return <expr><literal type="string">"RELA"</literal></expr>;</return>
<case>case <expr><name>SHT_HASH</name></expr>:</case> <return>return <expr><literal type="string">"HASH"</literal></expr>;</return>
<case>case <expr><name>SHT_DYNAMIC</name></expr>:</case> <return>return <expr><literal type="string">"DYNAMIC"</literal></expr>;</return>
<case>case <expr><name>SHT_NOTE</name></expr>:</case> <return>return <expr><literal type="string">"NOTE"</literal></expr>;</return>
<case>case <expr><name>SHT_NOBITS</name></expr>:</case> <return>return <expr><literal type="string">"NOBITS"</literal></expr>;</return>
<case>case <expr><name>SHT_REL</name></expr>:</case> <return>return <expr><literal type="string">"REL"</literal></expr>;</return>
<case>case <expr><name>SHT_SHLIB</name></expr>:</case> <return>return <expr><literal type="string">"SHLIB"</literal></expr>;</return>
<case>case <expr><name>SHT_DYNSYM</name></expr>:</case> <return>return <expr><literal type="string">"DYNSYM"</literal></expr>;</return>
<case>case <expr><name>SHT_INIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"INIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_FINI_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"FINI_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_PREINIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"PREINIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_GROUP</name></expr>:</case> <return>return <expr><literal type="string">"GROUP"</literal></expr>;</return>
<case>case <expr><name>SHT_SYMTAB_SHNDX</name></expr>:</case> <return>return <expr><literal type="string">"SYMTAB_SHNDX"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_dof</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_dof"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_cap</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_cap"</literal></expr>;</return>
<case>case <expr><name>SHT_GNU_HASH</name></expr>:</case> <return>return <expr><literal type="string">"GNU_HASH"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_ANNOTATE</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_ANNOTATE"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_DEBUGSTR</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_DEBUGSTR"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_DEBUG</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_DEBUG"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_move</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_move"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_COMDAT</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_COMDAT"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_syminfo</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_syminfo"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_verdef</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_verdef"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_verneed</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_verneed"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_versym</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_versym"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>stype</name> <operator>&gt;=</operator> <name>SHT_LOOS</name> <operator>&amp;&amp;</operator> <name>stype</name> <operator>&lt;=</operator> <name>SHT_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LOOS+%#x"</literal></expr></argument>,
<argument><expr><name>stype</name> <operator>-</operator> <name>SHT_LOOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>stype</name> <operator>&gt;=</operator> <name>SHT_LOUSER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"LOUSER+%#x"</literal></expr></argument>,
<argument><expr><name>stype</name> <operator>-</operator> <name>SHT_LOUSER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>stype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_stype</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dt_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>dtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_dtype</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
<case>case <expr><name>DT_NEEDED</name></expr>:</case> <return>return <expr><literal type="string">"NEEDED"</literal></expr>;</return>
<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case> <return>return <expr><literal type="string">"PLTRELSZ"</literal></expr>;</return>
<case>case <expr><name>DT_PLTGOT</name></expr>:</case> <return>return <expr><literal type="string">"PLTGOT"</literal></expr>;</return>
<case>case <expr><name>DT_HASH</name></expr>:</case> <return>return <expr><literal type="string">"HASH"</literal></expr>;</return>
<case>case <expr><name>DT_STRTAB</name></expr>:</case> <return>return <expr><literal type="string">"STRTAB"</literal></expr>;</return>
<case>case <expr><name>DT_SYMTAB</name></expr>:</case> <return>return <expr><literal type="string">"SYMTAB"</literal></expr>;</return>
<case>case <expr><name>DT_RELA</name></expr>:</case> <return>return <expr><literal type="string">"RELA"</literal></expr>;</return>
<case>case <expr><name>DT_RELASZ</name></expr>:</case> <return>return <expr><literal type="string">"RELASZ"</literal></expr>;</return>
<case>case <expr><name>DT_RELAENT</name></expr>:</case> <return>return <expr><literal type="string">"RELAENT"</literal></expr>;</return>
<case>case <expr><name>DT_STRSZ</name></expr>:</case> <return>return <expr><literal type="string">"STRSZ"</literal></expr>;</return>
<case>case <expr><name>DT_SYMENT</name></expr>:</case> <return>return <expr><literal type="string">"SYMENT"</literal></expr>;</return>
<case>case <expr><name>DT_INIT</name></expr>:</case> <return>return <expr><literal type="string">"INIT"</literal></expr>;</return>
<case>case <expr><name>DT_FINI</name></expr>:</case> <return>return <expr><literal type="string">"FINI"</literal></expr>;</return>
<case>case <expr><name>DT_SONAME</name></expr>:</case> <return>return <expr><literal type="string">"SONAME"</literal></expr>;</return>
<case>case <expr><name>DT_RPATH</name></expr>:</case> <return>return <expr><literal type="string">"RPATH"</literal></expr>;</return>
<case>case <expr><name>DT_SYMBOLIC</name></expr>:</case> <return>return <expr><literal type="string">"SYMBOLIC"</literal></expr>;</return>
<case>case <expr><name>DT_REL</name></expr>:</case> <return>return <expr><literal type="string">"REL"</literal></expr>;</return>
<case>case <expr><name>DT_RELSZ</name></expr>:</case> <return>return <expr><literal type="string">"RELSZ"</literal></expr>;</return>
<case>case <expr><name>DT_RELENT</name></expr>:</case> <return>return <expr><literal type="string">"RELENT"</literal></expr>;</return>
<case>case <expr><name>DT_PLTREL</name></expr>:</case> <return>return <expr><literal type="string">"PLTREL"</literal></expr>;</return>
<case>case <expr><name>DT_DEBUG</name></expr>:</case> <return>return <expr><literal type="string">"DEBUG"</literal></expr>;</return>
<case>case <expr><name>DT_TEXTREL</name></expr>:</case> <return>return <expr><literal type="string">"TEXTREL"</literal></expr>;</return>
<case>case <expr><name>DT_JMPREL</name></expr>:</case> <return>return <expr><literal type="string">"JMPREL"</literal></expr>;</return>
<case>case <expr><name>DT_BIND_NOW</name></expr>:</case> <return>return <expr><literal type="string">"BIND_NOW"</literal></expr>;</return>
<case>case <expr><name>DT_INIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"INIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_FINI_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"FINI_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_INIT_ARRAYSZ</name></expr>:</case> <return>return <expr><literal type="string">"INIT_ARRAYSZ"</literal></expr>;</return>
<case>case <expr><name>DT_FINI_ARRAYSZ</name></expr>:</case> <return>return <expr><literal type="string">"FINI_ARRAYSZ"</literal></expr>;</return>
<case>case <expr><name>DT_RUNPATH</name></expr>:</case> <return>return <expr><literal type="string">"RUNPATH"</literal></expr>;</return>
<case>case <expr><name>DT_FLAGS</name></expr>:</case> <return>return <expr><literal type="string">"FLAGS"</literal></expr>;</return>
<case>case <expr><name>DT_PREINIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"PREINIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_PREINIT_ARRAYSZ</name></expr>:</case> <return>return <expr><literal type="string">"PREINIT_ARRAYSZ"</literal></expr>;</return>
<case>case <expr><name>DT_MAXPOSTAGS</name></expr>:</case> <return>return <expr><literal type="string">"MAXPOSTAGS"</literal></expr>;</return>
<case>case <expr><name>DT_SUNW_AUXILIARY</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_AUXILIARY"</literal></expr>;</return>
<case>case <expr><name>DT_SUNW_RTLDINF</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_RTLDINF"</literal></expr>;</return>
<case>case <expr><name>DT_SUNW_FILTER</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_FILTER"</literal></expr>;</return>
<case>case <expr><name>DT_SUNW_CAP</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_CAP"</literal></expr>;</return>
<case>case <expr><name>DT_SUNW_ASLR</name></expr>:</case> <return>return <expr><literal type="string">"SUNW_ASLR"</literal></expr>;</return>
<case>case <expr><name>DT_CHECKSUM</name></expr>:</case> <return>return <expr><literal type="string">"CHECKSUM"</literal></expr>;</return>
<case>case <expr><name>DT_PLTPADSZ</name></expr>:</case> <return>return <expr><literal type="string">"PLTPADSZ"</literal></expr>;</return>
<case>case <expr><name>DT_MOVEENT</name></expr>:</case> <return>return <expr><literal type="string">"MOVEENT"</literal></expr>;</return>
<case>case <expr><name>DT_MOVESZ</name></expr>:</case> <return>return <expr><literal type="string">"MOVESZ"</literal></expr>;</return>
<case>case <expr><name>DT_FEATURE</name></expr>:</case> <return>return <expr><literal type="string">"FEATURE"</literal></expr>;</return>
<case>case <expr><name>DT_POSFLAG_1</name></expr>:</case> <return>return <expr><literal type="string">"POSFLAG_1"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINSZ</name></expr>:</case> <return>return <expr><literal type="string">"SYMINSZ"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINENT</name></expr>:</case> <return>return <expr><literal type="string">"SYMINENT"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_HASH</name></expr>:</case> <return>return <expr><literal type="string">"GNU_HASH"</literal></expr>;</return>
<case>case <expr><name>DT_TLSDESC_PLT</name></expr>:</case> <return>return <expr><literal type="string">"DT_TLSDESC_PLT"</literal></expr>;</return>
<case>case <expr><name>DT_TLSDESC_GOT</name></expr>:</case> <return>return <expr><literal type="string">"DT_TLSDESC_GOT"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_CONFLICT</name></expr>:</case> <return>return <expr><literal type="string">"GNU_CONFLICT"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_LIBLIST</name></expr>:</case> <return>return <expr><literal type="string">"GNU_LIBLIST"</literal></expr>;</return>
<case>case <expr><name>DT_CONFIG</name></expr>:</case> <return>return <expr><literal type="string">"CONFIG"</literal></expr>;</return>
<case>case <expr><name>DT_DEPAUDIT</name></expr>:</case> <return>return <expr><literal type="string">"DEPAUDIT"</literal></expr>;</return>
<case>case <expr><name>DT_AUDIT</name></expr>:</case> <return>return <expr><literal type="string">"AUDIT"</literal></expr>;</return>
<case>case <expr><name>DT_PLTPAD</name></expr>:</case> <return>return <expr><literal type="string">"PLTPAD"</literal></expr>;</return>
<case>case <expr><name>DT_MOVETAB</name></expr>:</case> <return>return <expr><literal type="string">"MOVETAB"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINFO</name></expr>:</case> <return>return <expr><literal type="string">"SYMINFO"</literal></expr>;</return>
<case>case <expr><name>DT_VERSYM</name></expr>:</case> <return>return <expr><literal type="string">"VERSYM"</literal></expr>;</return>
<case>case <expr><name>DT_RELACOUNT</name></expr>:</case> <return>return <expr><literal type="string">"RELACOUNT"</literal></expr>;</return>
<case>case <expr><name>DT_RELCOUNT</name></expr>:</case> <return>return <expr><literal type="string">"RELCOUNT"</literal></expr>;</return>
<case>case <expr><name>DT_FLAGS_1</name></expr>:</case> <return>return <expr><literal type="string">"FLAGS_1"</literal></expr>;</return>
<case>case <expr><name>DT_VERDEF</name></expr>:</case> <return>return <expr><literal type="string">"VERDEF"</literal></expr>;</return>
<case>case <expr><name>DT_VERDEFNUM</name></expr>:</case> <return>return <expr><literal type="string">"VERDEFNUM"</literal></expr>;</return>
<case>case <expr><name>DT_VERNEED</name></expr>:</case> <return>return <expr><literal type="string">"VERNEED"</literal></expr>;</return>
<case>case <expr><name>DT_VERNEEDNUM</name></expr>:</case> <return>return <expr><literal type="string">"VERNEEDNUM"</literal></expr>;</return>
<case>case <expr><name>DT_AUXILIARY</name></expr>:</case> <return>return <expr><literal type="string">"AUXILIARY"</literal></expr>;</return>
<case>case <expr><name>DT_USED</name></expr>:</case> <return>return <expr><literal type="string">"USED"</literal></expr>;</return>
<case>case <expr><name>DT_FILTER</name></expr>:</case> <return>return <expr><literal type="string">"FILTER"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_PRELINKED</name></expr>:</case> <return>return <expr><literal type="string">"GNU_PRELINKED"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_CONFLICTSZ</name></expr>:</case> <return>return <expr><literal type="string">"GNU_CONFLICTSZ"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_LIBLISTSZ</name></expr>:</case> <return>return <expr><literal type="string">"GNU_LIBLISTSZ"</literal></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>dtype</name> <operator>&gt;=</operator> <name>DT_LOPROC</name> <operator>&amp;&amp;</operator> <name>dtype</name> <operator>&lt;=</operator> <name>DT_HIPROC</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_ARM</name></expr>:</case>
<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_ARM_SYMTABSZ</name></expr>:</case>
<return>return <expr><literal type="string">"ARM_SYMTABSZ"</literal></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>
<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_MIPS_RLD_VERSION</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_RLD_VERSION"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_TIME_STAMP</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_TIME_STAMP"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_ICHECKSUM</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_ICHECKSUM"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_IVERSION</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_IVERSION"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_FLAGS</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_FLAGS"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_BASE_ADDRESS</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_BASE_ADDRESS"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_CONFLICT</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_CONFLICT"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_LIBLIST</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_LIBLIST"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_LOCAL_GOTNO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_LOCAL_GOTNO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_CONFLICTNO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_CONFLICTNO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_LIBLISTNO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_LIBLISTNO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_SYMTABNO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_SYMTABNO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_UNREFEXTNO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_UNREFEXTNO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_GOTSYM</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_GOTSYM"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_HIPAGENO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_HIPAGENO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_RLD_MAP</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_RLD_MAP"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_CLASS</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_CLASS"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_CLASS_NO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_CLASS_NO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_INSTANCE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_INSTANCE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_INSTANCE_NO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_INSTANCE_NO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_RELOC</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_RELOC"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_RELOC_NO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_RELOC_NO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_SYM</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_SYM"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_SYM_NO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_SYM_NO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_CLASSSYM</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_CLASSSYM"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DELTA_CLASSSYM_NO</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DELTA_CLASSSYM_NO"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_CXX_FLAGS</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_CXX_FLAGS"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_PIXIE_INIT</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_PIXIE_INIT"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_SYMBOL_LIB</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_SYMBOL_LIB"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_LOCALPAGE_GOTIDX</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_LOCALPAGE_GOTIDX"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_LOCAL_GOTIDX</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_LOCAL_GOTIDX"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_HIDDEN_GOTIDX</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_HIDDEN_GOTIDX"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_PROTECTED_GOTIDX</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_PROTECTED_GOTIDX"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_OPTIONS</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_OPTIONS"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_INTERFACE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_INTERFACE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_DYNSTR_ALIGN</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_DYNSTR_ALIGN"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_INTERFACE_SIZE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_INTERFACE_SIZE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_RLD_TEXT_RESOLVE_ADDR</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_RLD_TEXT_RESOLVE_ADDR"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_PERF_SUFFIX</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_PERF_SUFFIX"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_COMPACT_SIZE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_COMPACT_SIZE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_GP_VALUE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_GP_VALUE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_AUX_DYNAMIC</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_AUX_DYNAMIC"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_PLTGOT</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_PLTGOT"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_RLD_OBJ_UPDATE</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_RLD_OBJ_UPDATE"</literal></expr>;</return>
<case>case <expr><name>DT_MIPS_RWPLT</name></expr>:</case>
<return>return <expr><literal type="string">"MIPS_RWPLT"</literal></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_SPARC</name></expr>:</case>
<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case>
<switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_SPARC_REGISTER</name></expr>:</case>
<return>return <expr><literal type="string">"DT_SPARC_REGISTER"</literal></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_dtype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_dtype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>dtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_dtype</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_bind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_sbind</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sbind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STB_LOCAL</name></expr>:</case> <return>return <expr><literal type="string">"LOCAL"</literal></expr>;</return>
<case>case <expr><name>STB_GLOBAL</name></expr>:</case> <return>return <expr><literal type="string">"GLOBAL"</literal></expr>;</return>
<case>case <expr><name>STB_WEAK</name></expr>:</case> <return>return <expr><literal type="string">"WEAK"</literal></expr>;</return>
<case>case <expr><name>STB_GNU_UNIQUE</name></expr>:</case> <return>return <expr><literal type="string">"UNIQUE"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOOS</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"OS"</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOPROC</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIPROC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"PROC"</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_sbind</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_sbind</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>sbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_sbind</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>os</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>stype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_stype</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>stype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STT_NOTYPE</name></expr>:</case> <return>return <expr><literal type="string">"NOTYPE"</literal></expr>;</return>
<case>case <expr><name>STT_OBJECT</name></expr>:</case> <return>return <expr><literal type="string">"OBJECT"</literal></expr>;</return>
<case>case <expr><name>STT_FUNC</name></expr>:</case> <return>return <expr><literal type="string">"FUNC"</literal></expr>;</return>
<case>case <expr><name>STT_SECTION</name></expr>:</case> <return>return <expr><literal type="string">"SECTION"</literal></expr>;</return>
<case>case <expr><name>STT_FILE</name></expr>:</case> <return>return <expr><literal type="string">"FILE"</literal></expr>;</return>
<case>case <expr><name>STT_COMMON</name></expr>:</case> <return>return <expr><literal type="string">"COMMON"</literal></expr>;</return>
<case>case <expr><name>STT_TLS</name></expr>:</case> <return>return <expr><literal type="string">"TLS"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>stype</name> <operator>&gt;=</operator> <name>STT_LOOS</name> <operator>&amp;&amp;</operator> <name>stype</name> <operator>&lt;=</operator> <name>STT_HIOS</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>os</name> <operator>==</operator> <name>ELFOSABI_GNU</name> <operator>||</operator> <name>os</name> <operator>==</operator> <name>ELFOSABI_FREEBSD</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name>stype</name> <operator>==</operator> <name>STT_GNU_IFUNC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"IFUNC"</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"OS+%#x"</literal></expr></argument>,
<argument><expr><name>stype</name> <operator>-</operator> <name>STT_LOOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>stype</name> <operator>&gt;=</operator> <name>STT_LOPROC</name> <operator>&amp;&amp;</operator> <name>stype</name> <operator>&lt;=</operator> <name>STT_HIPROC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mach</name> <operator>==</operator> <name>EM_SPARCV9</name> <operator>&amp;&amp;</operator> <name>stype</name> <operator>==</operator> <name>STT_SPARC_REGISTER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"REGISTER"</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"PROC+%#x"</literal></expr></argument>,
<argument><expr><name>stype</name> <operator>-</operator> <name>STT_LOPROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_stype</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_stype</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>stype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_stype</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_vis</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>svis</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_svis</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>svis</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STV_DEFAULT</name></expr>:</case> <return>return <expr><literal type="string">"DEFAULT"</literal></expr>;</return>
<case>case <expr><name>STV_INTERNAL</name></expr>:</case> <return>return <expr><literal type="string">"INTERNAL"</literal></expr>;</return>
<case>case <expr><name>STV_HIDDEN</name></expr>:</case> <return>return <expr><literal type="string">"HIDDEN"</literal></expr>;</return>
<case>case <expr><name>STV_PROTECTED</name></expr>:</case> <return>return <expr><literal type="string">"PROTECTED"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_svis</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_svis</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>svis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_svis</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_shndx</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>shndx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_shndx</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>shndx</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHN_UNDEF</name></expr>:</case> <return>return <expr><literal type="string">"UND"</literal></expr>;</return>
<case>case <expr><name>SHN_ABS</name></expr>:</case> <return>return <expr><literal type="string">"ABS"</literal></expr>;</return>
<case>case <expr><name>SHN_COMMON</name></expr>:</case> <return>return <expr><literal type="string">"COM"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>shndx</name> <operator>&gt;=</operator> <name>SHN_LOPROC</name> <operator>&amp;&amp;</operator> <name>shndx</name> <operator>&lt;=</operator> <name>SHN_HIPROC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"PRC"</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>shndx</name> <operator>&gt;=</operator> <name>SHN_LOOS</name> <operator>&amp;&amp;</operator> <name>shndx</name> <operator>&lt;=</operator> <name>SHN_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"OS"</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_shndx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_shndx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>shndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_shndx</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
}</block> <decl><name><name>section_flag</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"WRITE"</literal></expr>, <expr><literal type="char">'W'</literal></expr>, <expr><name>SHF_WRITE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"ALLOC"</literal></expr>, <expr><literal type="char">'A'</literal></expr>, <expr><name>SHF_ALLOC</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"EXEC"</literal></expr>, <expr><literal type="char">'X'</literal></expr>, <expr><name>SHF_EXECINSTR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"MERGE"</literal></expr>, <expr><literal type="char">'M'</literal></expr>, <expr><name>SHF_MERGE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"STRINGS"</literal></expr>, <expr><literal type="char">'S'</literal></expr>, <expr><name>SHF_STRINGS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"INFO LINK"</literal></expr>, <expr><literal type="char">'I'</literal></expr>, <expr><name>SHF_INFO_LINK</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"OS NONCONF"</literal></expr>, <expr><literal type="char">'O'</literal></expr>, <expr><name>SHF_OS_NONCONFORMING</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"GROUP"</literal></expr>, <expr><literal type="char">'G'</literal></expr>, <expr><name>SHF_GROUP</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"TLS"</literal></expr>, <expr><literal type="char">'T'</literal></expr>, <expr><name>SHF_TLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"COMPRESSED"</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><name>SHF_COMPRESSED</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>et</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"LINUX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<name>et</name> <operator>==</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_linux_core</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>et</name> <operator>==</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_freebsd_core</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_freebsd</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"GNU"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>et</name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_gnu</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"Go"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>et</name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_go</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"NetBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>et</name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_netbsd</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>et</name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_openbsd</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"Xen"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>et</name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>note_type_xen</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_freebsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FREEBSD_ABI_TAG"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FREEBSD_NOINIT_TAG"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FREEBSD_ARCH_TAG"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FREEBSD_FEATURE_CTL"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_freebsd_core</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PRSTATUS"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FPREGSET"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PRPSINFO"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"NT_THRMISC"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_PROC"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_FILES"</literal></expr>;</return>
<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_VMMAP"</literal></expr>;</return>
<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_GROUPS"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_UMASK"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_RLIMIT"</literal></expr>;</return>
<case>case <expr><literal type="number">14</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_OSREL"</literal></expr>;</return>
<case>case <expr><literal type="number">15</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_PSSTRINGS"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PROCSTAT_AUXV"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PTLWPINFO"</literal></expr>;</return>
<case>case <expr><literal type="number">0x100</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PPC_VMX (ppc Altivec registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x102</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PPC_VSX (ppc VSX registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x202</literal></expr>:</case> <return>return <expr><literal type="string">"NT_X86_XSTATE (x86 XSAVE extended state)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x400</literal></expr>:</case> <return>return <expr><literal type="string">"NT_ARM_VFP (arm VFP registers)"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_linux_core</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PRSTATUS (Process status)"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FPREGSET (Floating point information)"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PRPSINFO (Process information)"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"NT_TASKSTRUCT (Task structure)"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"NT_AUXV (Auxiliary vector)"</literal></expr>;</return>
<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PSTATUS (Linux process status)"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FPREGS (Linux floating point regset)"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PSINFO (Linux process information)"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"NT_LWPSTATUS (Linux lwpstatus_t type)"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"NT_LWPSINFO (Linux lwpinfo_t type)"</literal></expr>;</return>
<case>case <expr><literal type="number">18</literal></expr>:</case> <return>return <expr><literal type="string">"NT_WIN32PSTATUS (win32_pstatus structure)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x100</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PPC_VMX (ppc Altivec registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x102</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PPC_VSX (ppc VSX registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x202</literal></expr>:</case> <return>return <expr><literal type="string">"NT_X86_XSTATE (x86 XSAVE extended state)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x300</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_HIGH_GPRS (s390 upper register halves)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x301</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_TIMER (s390 timer register)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x302</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_TODCMP (s390 TOD comparator register)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x303</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_TODPREG (s390 TOD programmable register)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x304</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_CTRS (s390 control registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x305</literal></expr>:</case> <return>return <expr><literal type="string">"NT_S390_PREFIX (s390 prefix register)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x400</literal></expr>:</case> <return>return <expr><literal type="string">"NT_ARM_VFP (arm VFP registers)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x46494c45UL</literal></expr>:</case> <return>return <expr><literal type="string">"NT_FILE (mapped files)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x46E62B7FUL</literal></expr>:</case> <return>return <expr><literal type="string">"NT_PRXFPREG (Linux user_xfpregs structure)"</literal></expr>;</return>
<case>case <expr><literal type="number">0x53494749UL</literal></expr>:</case> <return>return <expr><literal type="string">"NT_SIGINFO (siginfo_t data)"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_gnu</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_GNU_ABI_TAG"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"NT_GNU_HWCAP (Hardware capabilities)"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"NT_GNU_BUILD_ID (Build id set by ld(1))"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"NT_GNU_GOLD_VERSION (GNU gold version)"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"NT_GNU_PROPERTY_TYPE_0"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_go</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"elfGoBuildIDTag"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_netbsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_NETBSD_IDENT"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_openbsd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NT_OPENBSD_IDENT"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_unknown</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_nt</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_nt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_nt</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><ternary><condition><expr><name>nt</name> <operator>&gt;=</operator> <literal type="number">0x100</literal></expr> ?</condition><then> <expr><literal type="string">"&lt;unknown: 0x%x&gt;"</literal></expr> </then><else>: <expr><literal type="string">"&lt;unknown: %u&gt;"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_nt</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>note_type_xen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>nt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_INFO"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_ENTRY"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_HYPERCALL_PAGE"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_VIRT_BASE"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_PADDR_OFFSET"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_XEN_VERSION"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_GUEST_OS"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_GUEST_VERSION"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_LOADER"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_PAE_MODE"</literal></expr>;</return>
<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_FEATURES"</literal></expr>;</return>
<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_BSD_SYMTAB"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_HV_START_LOW"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_L1_MFN_VALID"</literal></expr>;</return>
<case>case <expr><literal type="number">14</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_SUSPEND_CANCEL"</literal></expr>;</return>
<case>case <expr><literal type="number">15</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_INIT_P2M"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_MOD_START_PFN"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_SUPPORTED_FEATURES"</literal></expr>;</return>
<case>case <expr><literal type="number">18</literal></expr>:</case> <return>return <expr><literal type="string">"XEN_ELFNOTE_PHYS32_ENTRY"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><call><name>note_type_unknown</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
}</block> <decl><name><name>l_flag</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"EXACT_MATCH"</literal></expr>, <expr><name>LL_EXACT_MATCH</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"IGNORE_INT_VER"</literal></expr>, <expr><name>LL_IGNORE_INT_VER</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"REQUIRE_MINOR"</literal></expr>, <expr><name>LL_REQUIRE_MINOR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"EXPORTS"</literal></expr>, <expr><name>LL_EXPORTS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"DELAY_LOAD"</literal></expr>, <expr><name>LL_DELAY_LOAD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"DELTA"</literal></expr>, <expr><name>LL_DELTA</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mips_option</name></name></type> <name><name>mips_exceptions_option</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>OEX_PAGE0</name></expr>, <expr><literal type="string">"PAGE0"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OEX_SMM</name></expr>, <expr><literal type="string">"SMM"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OEX_PRECISEFP</name></expr>, <expr><literal type="string">"PRECISEFP"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OEX_DISMISS</name></expr>, <expr><literal type="string">"DISMISS"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mips_option</name></name></type> <name><name>mips_pad_option</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>OPAD_PREFIX</name></expr>, <expr><literal type="string">"PREFIX"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OPAD_POSTFIX</name></expr>, <expr><literal type="string">"POSTFIX"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OPAD_SYMBOL</name></expr>, <expr><literal type="string">"SYMBOL"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mips_option</name></name></type> <name><name>mips_hwpatch_option</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>OHW_R4KEOP</name></expr>, <expr><literal type="string">"R4KEOP"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OHW_R8KPFETCH</name></expr>, <expr><literal type="string">"R8KPFETCH"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OHW_R5KEOP</name></expr>, <expr><literal type="string">"R5KEOP"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OHW_R5KCVTL</name></expr>, <expr><literal type="string">"R5KCVTL"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mips_option</name></name></type> <name><name>mips_hwa_option</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>OHWA0_R4KEOP_CHECKED</name></expr>, <expr><literal type="string">"R4KEOP_CHECKED"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>OHWA0_R4KEOP_CLEAN</name></expr>, <expr><literal type="string">"R4KEOP_CLEAN"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>mips_option</name></name></type> <name><name>mips_hwo_option</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><name>OHWO0_FIXADE</name></expr>, <expr><literal type="string">"FIXADE"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>option_kind</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_kind</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ODK_NULL</name></expr>:</case> <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
<case>case <expr><name>ODK_REGINFO</name></expr>:</case> <return>return <expr><literal type="string">"REGINFO"</literal></expr>;</return>
<case>case <expr><name>ODK_EXCEPTIONS</name></expr>:</case> <return>return <expr><literal type="string">"EXCEPTIONS"</literal></expr>;</return>
<case>case <expr><name>ODK_PAD</name></expr>:</case> <return>return <expr><literal type="string">"PAD"</literal></expr>;</return>
<case>case <expr><name>ODK_HWPATCH</name></expr>:</case> <return>return <expr><literal type="string">"HWPATCH"</literal></expr>;</return>
<case>case <expr><name>ODK_FILL</name></expr>:</case> <return>return <expr><literal type="string">"FILL"</literal></expr>;</return>
<case>case <expr><name>ODK_TAGS</name></expr>:</case> <return>return <expr><literal type="string">"TAGS"</literal></expr>;</return>
<case>case <expr><name>ODK_HWAND</name></expr>:</case> <return>return <expr><literal type="string">"HWAND"</literal></expr>;</return>
<case>case <expr><name>ODK_HWOR</name></expr>:</case> <return>return <expr><literal type="string">"HWOR"</literal></expr>;</return>
<case>case <expr><name>ODK_GP_GROUP</name></expr>:</case> <return>return <expr><literal type="string">"GP_GROUP"</literal></expr>;</return>
<case>case <expr><name>ODK_IDENT</name></expr>:</case> <return>return <expr><literal type="string">"IDENT"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_kind</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_kind</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %u&gt;"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_kind</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>top_tag</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_top_tag</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"File Attributes"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Section Attributes"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Symbol Attributes"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_top_tag</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_top_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown tag: %u"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_top_tag</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_cpu_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>arch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_cpu_arch</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>arch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Pre-V4"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v4"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v4T"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v5T"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v5TE"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v5TEJ"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6KZ"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6T2"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6K"</literal></expr>;</return>
<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v7"</literal></expr>;</return>
<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6-M"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v6S-M"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"ARM v7E-M"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_cpu_arch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_cpu_arch</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_cpu_arch</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_cpu_arch_profile</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>pf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_arch_profile</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>pf</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><literal type="string">"Not applicable"</literal></expr>;</return>
<case>case <expr><literal type="number">0x41</literal></expr>:</case>
<return>return <expr><literal type="string">"Application Profile"</literal></expr>;</return>
<case>case <expr><literal type="number">0x52</literal></expr>:</case>
<return>return <expr><literal type="string">"Real-Time Profile"</literal></expr>;</return>
<case>case <expr><literal type="number">0x4D</literal></expr>:</case>
<return>return <expr><literal type="string">"Microcontroller Profile"</literal></expr>;</return>
<case>case <expr><literal type="number">0x53</literal></expr>:</case>
<return>return <expr><literal type="string">"Application or Real-Time Profile"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_arch_profile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_arch_profile</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Unknown (%ju)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>pf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_arch_profile</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_arm_isa</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ai</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ai</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ai</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Yes"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ai</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ai</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ai</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_thumb_isa</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ti</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ti</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"16-bit Thumb"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"32-bit Thumb"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ti</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ti</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ti</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_arch</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv1"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv2"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv3"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv3-D16"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv4"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv4-D16"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_arch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_arch</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_arch</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_wmmx_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wmmx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_wmmx</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>wmmx</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"WMMXv1"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"WMMXv2"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_wmmx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_wmmx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>wmmx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_wmmx</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_adv_simd_arch</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>simd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_simd</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>simd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"NEONv1"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"NEONv2"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_simd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_simd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>simd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_simd</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_config</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>pcs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_pcs</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>pcs</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Bare platform"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Linux"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Linux DSO"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"Palm OS 2004"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"Palm OS (future)"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"Symbian OS 2004"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"Symbian OS (future)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_pcs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_pcs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>pcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_pcs</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_r9</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>r9</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_r9</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>r9</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"V6"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"SB"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"TLS pointer"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_r9</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_r9</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>r9</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_r9</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_rw</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>rw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_rw</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>rw</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Absolute"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"PC-relative"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"SB-relative"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_rw</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_rw</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_rw</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_ro</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ro</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ro</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ro</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Absolute"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"PC-relative"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ro</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ro</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ro</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_got</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>got</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_got</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>got</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"direct"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"indirect via GOT"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_got</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_got</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_got</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_pcs_wchar_t</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_wt</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>wt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"wchar_t size 2"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"wchar_t size 4"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_wt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_wt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>wt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_wt</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_enum_size</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>es</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_es</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>es</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"smallest"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"32-bit"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"visible 32-bit"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_es</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_es</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_es</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_align_needed</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>an</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_align_n</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>an</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"8-byte align"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"4-byte align"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Reserved"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>an</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>an</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_align_n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_align_n</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"8-byte align"</literal>
<literal type="string">" and up to 2^%ju-byte extended align"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>an</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_align_n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_align_n</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>an</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_align_n</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_align_preserved</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_align_p</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ap</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"8-byte align"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"8-byte align and SP % 8 == 0"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Reserved"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>ap</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_align_p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_align_p</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"8-byte align"</literal>
<literal type="string">" and SP %% 8 == 0 and up to 2^%ju-byte extended"</literal>
<literal type="string">" align"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_align_p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_align_p</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_align_p</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_rounding</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_r</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Needed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_r</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_r</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_denormal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_d</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Needed"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Sign Only"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_d</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_d</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_exceptions</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_e</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fe</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Needed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_e</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_e</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_user_exceptions</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fu</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_u</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fu</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Needed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_u</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_u</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_u</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_number_model</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_n</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fn</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Unused"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"IEEE 754 normal"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"RTABI"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"IEEE 754"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_n</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_n</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_16bit_format</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp16</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fp_16</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fp16</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"IEEE 754"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"VFPv3/Advanced SIMD (alternative format)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fp_16</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fp_16</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fp16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fp_16</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_mpext</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>mp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_mp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Not allowed"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Allowed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_mp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_mp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_mp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_div</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>du</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_du</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>du</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Yes (V7-R/V7-M)"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Yes (V7-A)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_du</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_du</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>du</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_du</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_t2ee</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>t2ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_t2ee</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>t2ee</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Not allowed"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Allowed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_t2ee</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_t2ee</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>t2ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_t2ee</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_hardfp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>hfp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_hfp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>hfp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Tag_FP_arch"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"only SP"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"only DP"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"both SP and DP"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_hfp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_hfp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>hfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_hfp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_vfp_args</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>va</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_va</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>va</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"AAPCS (base variant)"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"AAPCS (VFP variant)"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"toolchain-specific"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_va</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_va</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_va</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_wmmx_args</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>wa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_wa</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>wa</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"AAPCS (base variant)"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Intel WMMX"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"toolchain-specific"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_wa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_wa</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>wa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_wa</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_unaligned_access</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>ua</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ua</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ua</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Not allowed"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Allowed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ua</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ua</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ua</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ua</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_hpext</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fh</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fh</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"Not allowed"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Allowed"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fh</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fh</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fh</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_optm_goal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>og</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_og</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>og</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Speed"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Speed aggressive"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Space"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"Space aggressive"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"Debugging"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"Best Debugging"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_og</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_og</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>og</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_og</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_fp_optm_goal</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_fog</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fog</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"None"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Speed"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Speed aggressive"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Space"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"Space aggressive"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"Accurary"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"Best Accurary"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_fog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_fog</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_fog</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>aeabi_virtual</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>vt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_virtual</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>vt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"No"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"TrustZone"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Virtualization extension"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"TrustZone and virtualization extension"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_virtual</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_virtual</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_virtual</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_tag</name></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>get_desc</name>)<parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name><name>aeabi_tags</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="string">"Tag_CPU_raw_name"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="string">"Tag_CPU_name"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="string">"Tag_CPU_arch"</literal></expr>, <expr><name>aeabi_cpu_arch</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="string">"Tag_CPU_arch_profile"</literal></expr>, <expr><name>aeabi_cpu_arch_profile</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="string">"Tag_ARM_ISA_use"</literal></expr>, <expr><name>aeabi_arm_isa</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="string">"Tag_THUMB_ISA_use"</literal></expr>, <expr><name>aeabi_thumb_isa</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="string">"Tag_FP_arch"</literal></expr>, <expr><name>aeabi_fp_arch</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="string">"Tag_WMMX_arch"</literal></expr>, <expr><name>aeabi_wmmx_arch</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="string">"Tag_Advanced_SIMD_arch"</literal></expr>, <expr><name>aeabi_adv_simd_arch</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">13</literal></expr>, <expr><literal type="string">"Tag_PCS_config"</literal></expr>, <expr><name>aeabi_pcs_config</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="string">"Tag_ABI_PCS_R9_use"</literal></expr>, <expr><name>aeabi_pcs_r9</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="string">"Tag_ABI_PCS_RW_data"</literal></expr>, <expr><name>aeabi_pcs_rw</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="string">"Tag_ABI_PCS_RO_data"</literal></expr>, <expr><name>aeabi_pcs_ro</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">17</literal></expr>, <expr><literal type="string">"Tag_ABI_PCS_GOT_use"</literal></expr>, <expr><name>aeabi_pcs_got</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">18</literal></expr>, <expr><literal type="string">"Tag_ABI_PCS_wchar_t"</literal></expr>, <expr><name>aeabi_pcs_wchar_t</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">19</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_rounding"</literal></expr>, <expr><name>aeabi_fp_rounding</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_denormal"</literal></expr>, <expr><name>aeabi_fp_denormal</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">21</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_exceptions"</literal></expr>, <expr><name>aeabi_fp_exceptions</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">22</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_user_exceptions"</literal></expr>, <expr><name>aeabi_fp_user_exceptions</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">23</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_number_model"</literal></expr>, <expr><name>aeabi_fp_number_model</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">24</literal></expr>, <expr><literal type="string">"Tag_ABI_align_needed"</literal></expr>, <expr><name>aeabi_align_needed</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">25</literal></expr>, <expr><literal type="string">"Tag_ABI_align_preserved"</literal></expr>, <expr><name>aeabi_align_preserved</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">26</literal></expr>, <expr><literal type="string">"Tag_ABI_enum_size"</literal></expr>, <expr><name>aeabi_enum_size</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">27</literal></expr>, <expr><literal type="string">"Tag_ABI_HardFP_use"</literal></expr>, <expr><name>aeabi_hardfp</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">28</literal></expr>, <expr><literal type="string">"Tag_ABI_VFP_args"</literal></expr>, <expr><name>aeabi_vfp_args</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">29</literal></expr>, <expr><literal type="string">"Tag_ABI_WMMX_args"</literal></expr>, <expr><name>aeabi_wmmx_args</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">30</literal></expr>, <expr><literal type="string">"Tag_ABI_optimization_goals"</literal></expr>, <expr><name>aeabi_optm_goal</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">31</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_optimization_goals"</literal></expr>, <expr><name>aeabi_fp_optm_goal</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">32</literal></expr>, <expr><literal type="string">"Tag_compatibility"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">34</literal></expr>, <expr><literal type="string">"Tag_CPU_unaligned_access"</literal></expr>, <expr><name>aeabi_unaligned_access</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">36</literal></expr>, <expr><literal type="string">"Tag_FP_HP_extension"</literal></expr>, <expr><name>aeabi_fp_hpext</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">38</literal></expr>, <expr><literal type="string">"Tag_ABI_FP_16bit_format"</literal></expr>, <expr><name>aeabi_fp_16bit_format</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">42</literal></expr>, <expr><literal type="string">"Tag_MPextension_use"</literal></expr>, <expr><name>aeabi_mpext</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">44</literal></expr>, <expr><literal type="string">"Tag_DIV_use"</literal></expr>, <expr><name>aeabi_div</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">64</literal></expr>, <expr><literal type="string">"Tag_nodefaults"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">65</literal></expr>, <expr><literal type="string">"Tag_also_compatible_with"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">66</literal></expr>, <expr><literal type="string">"Tag_T2EE_use"</literal></expr>, <expr><name>aeabi_t2ee</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">67</literal></expr>, <expr><literal type="string">"Tag_conformance"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">68</literal></expr>, <expr><literal type="string">"Tag_Virtualization_use"</literal></expr>, <expr><name>aeabi_virtual</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">70</literal></expr>, <expr><literal type="string">"Tag_MPextension_use"</literal></expr>, <expr><name>aeabi_mpext</name></expr>}</block></expr>,
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>mips_abi_fp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_mips_abi_fp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"N/A"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Hard float (double precision)"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Hard float (single precision)"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Soft float"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"64-bit float (-mips32r2 -mfp64)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_mips_abi_fp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_mips_abi_fp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_mips_abi_fp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ppc_abi_fp</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ppc_abi_fp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"N/A"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Hard float (double precision)"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"Soft float"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"Hard float (single precision)"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ppc_abi_fp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ppc_abi_fp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ppc_abi_fp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ppc_abi_vector</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>vec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_vec</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>vec</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"N/A"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"Generic purpose registers"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"AltiVec registers"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"SPE registers"</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_vec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_vec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown(%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_vec</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dwarf_reg</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_386</name></expr>:</case>
<case>case <expr><name>EM_IAMCU</name></expr>:</case>
<switch>switch <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"eax"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"ecx"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"edx"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"ebx"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"esp"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"ebp"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"esi"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"edi"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"eip"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="string">"eflags"</literal></expr>;</return>
<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="string">"st0"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"st1"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"st2"</literal></expr>;</return>
<case>case <expr><literal type="number">14</literal></expr>:</case> <return>return <expr><literal type="string">"st3"</literal></expr>;</return>
<case>case <expr><literal type="number">15</literal></expr>:</case> <return>return <expr><literal type="string">"st4"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"st5"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"st6"</literal></expr>;</return>
<case>case <expr><literal type="number">18</literal></expr>:</case> <return>return <expr><literal type="string">"st7"</literal></expr>;</return>
<case>case <expr><literal type="number">21</literal></expr>:</case> <return>return <expr><literal type="string">"xmm0"</literal></expr>;</return>
<case>case <expr><literal type="number">22</literal></expr>:</case> <return>return <expr><literal type="string">"xmm1"</literal></expr>;</return>
<case>case <expr><literal type="number">23</literal></expr>:</case> <return>return <expr><literal type="string">"xmm2"</literal></expr>;</return>
<case>case <expr><literal type="number">24</literal></expr>:</case> <return>return <expr><literal type="string">"xmm3"</literal></expr>;</return>
<case>case <expr><literal type="number">25</literal></expr>:</case> <return>return <expr><literal type="string">"xmm4"</literal></expr>;</return>
<case>case <expr><literal type="number">26</literal></expr>:</case> <return>return <expr><literal type="string">"xmm5"</literal></expr>;</return>
<case>case <expr><literal type="number">27</literal></expr>:</case> <return>return <expr><literal type="string">"xmm6"</literal></expr>;</return>
<case>case <expr><literal type="number">28</literal></expr>:</case> <return>return <expr><literal type="string">"xmm7"</literal></expr>;</return>
<case>case <expr><literal type="number">29</literal></expr>:</case> <return>return <expr><literal type="string">"mm0"</literal></expr>;</return>
<case>case <expr><literal type="number">30</literal></expr>:</case> <return>return <expr><literal type="string">"mm1"</literal></expr>;</return>
<case>case <expr><literal type="number">31</literal></expr>:</case> <return>return <expr><literal type="string">"mm2"</literal></expr>;</return>
<case>case <expr><literal type="number">32</literal></expr>:</case> <return>return <expr><literal type="string">"mm3"</literal></expr>;</return>
<case>case <expr><literal type="number">33</literal></expr>:</case> <return>return <expr><literal type="string">"mm4"</literal></expr>;</return>
<case>case <expr><literal type="number">34</literal></expr>:</case> <return>return <expr><literal type="string">"mm5"</literal></expr>;</return>
<case>case <expr><literal type="number">35</literal></expr>:</case> <return>return <expr><literal type="string">"mm6"</literal></expr>;</return>
<case>case <expr><literal type="number">36</literal></expr>:</case> <return>return <expr><literal type="string">"mm7"</literal></expr>;</return>
<case>case <expr><literal type="number">37</literal></expr>:</case> <return>return <expr><literal type="string">"fcw"</literal></expr>;</return>
<case>case <expr><literal type="number">38</literal></expr>:</case> <return>return <expr><literal type="string">"fsw"</literal></expr>;</return>
<case>case <expr><literal type="number">39</literal></expr>:</case> <return>return <expr><literal type="string">"mxcsr"</literal></expr>;</return>
<case>case <expr><literal type="number">40</literal></expr>:</case> <return>return <expr><literal type="string">"es"</literal></expr>;</return>
<case>case <expr><literal type="number">41</literal></expr>:</case> <return>return <expr><literal type="string">"cs"</literal></expr>;</return>
<case>case <expr><literal type="number">42</literal></expr>:</case> <return>return <expr><literal type="string">"ss"</literal></expr>;</return>
<case>case <expr><literal type="number">43</literal></expr>:</case> <return>return <expr><literal type="string">"ds"</literal></expr>;</return>
<case>case <expr><literal type="number">44</literal></expr>:</case> <return>return <expr><literal type="string">"fs"</literal></expr>;</return>
<case>case <expr><literal type="number">45</literal></expr>:</case> <return>return <expr><literal type="string">"gs"</literal></expr>;</return>
<case>case <expr><literal type="number">48</literal></expr>:</case> <return>return <expr><literal type="string">"tr"</literal></expr>;</return>
<case>case <expr><literal type="number">49</literal></expr>:</case> <return>return <expr><literal type="string">"ldtr"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>EM_RISCV</name></expr>:</case>
<switch>switch <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"zero"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"ra"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"sp"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"gp"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"tp"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"t0"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"t1"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"t2"</literal></expr>;</return>
<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"s0"</literal></expr>;</return>
<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><literal type="string">"s1"</literal></expr>;</return>
<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><literal type="string">"a0"</literal></expr>;</return>
<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><literal type="string">"a1"</literal></expr>;</return>
<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><literal type="string">"a2"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><literal type="string">"a3"</literal></expr>;</return>
<case>case <expr><literal type="number">14</literal></expr>:</case> <return>return <expr><literal type="string">"a4"</literal></expr>;</return>
<case>case <expr><literal type="number">15</literal></expr>:</case> <return>return <expr><literal type="string">"a5"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"a6"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"a7"</literal></expr>;</return>
<case>case <expr><literal type="number">18</literal></expr>:</case> <return>return <expr><literal type="string">"s2"</literal></expr>;</return>
<case>case <expr><literal type="number">19</literal></expr>:</case> <return>return <expr><literal type="string">"s3"</literal></expr>;</return>
<case>case <expr><literal type="number">20</literal></expr>:</case> <return>return <expr><literal type="string">"s4"</literal></expr>;</return>
<case>case <expr><literal type="number">21</literal></expr>:</case> <return>return <expr><literal type="string">"s5"</literal></expr>;</return>
<case>case <expr><literal type="number">22</literal></expr>:</case> <return>return <expr><literal type="string">"s6"</literal></expr>;</return>
<case>case <expr><literal type="number">23</literal></expr>:</case> <return>return <expr><literal type="string">"s7"</literal></expr>;</return>
<case>case <expr><literal type="number">24</literal></expr>:</case> <return>return <expr><literal type="string">"s8"</literal></expr>;</return>
<case>case <expr><literal type="number">25</literal></expr>:</case> <return>return <expr><literal type="string">"s9"</literal></expr>;</return>
<case>case <expr><literal type="number">26</literal></expr>:</case> <return>return <expr><literal type="string">"s10"</literal></expr>;</return>
<case>case <expr><literal type="number">27</literal></expr>:</case> <return>return <expr><literal type="string">"s11"</literal></expr>;</return>
<case>case <expr><literal type="number">28</literal></expr>:</case> <return>return <expr><literal type="string">"t3"</literal></expr>;</return>
<case>case <expr><literal type="number">29</literal></expr>:</case> <return>return <expr><literal type="string">"t4"</literal></expr>;</return>
<case>case <expr><literal type="number">30</literal></expr>:</case> <return>return <expr><literal type="string">"t5"</literal></expr>;</return>
<case>case <expr><literal type="number">31</literal></expr>:</case> <return>return <expr><literal type="string">"t6"</literal></expr>;</return>
<case>case <expr><literal type="number">32</literal></expr>:</case> <return>return <expr><literal type="string">"ft0"</literal></expr>;</return>
<case>case <expr><literal type="number">33</literal></expr>:</case> <return>return <expr><literal type="string">"ft1"</literal></expr>;</return>
<case>case <expr><literal type="number">34</literal></expr>:</case> <return>return <expr><literal type="string">"ft2"</literal></expr>;</return>
<case>case <expr><literal type="number">35</literal></expr>:</case> <return>return <expr><literal type="string">"ft3"</literal></expr>;</return>
<case>case <expr><literal type="number">36</literal></expr>:</case> <return>return <expr><literal type="string">"ft4"</literal></expr>;</return>
<case>case <expr><literal type="number">37</literal></expr>:</case> <return>return <expr><literal type="string">"ft5"</literal></expr>;</return>
<case>case <expr><literal type="number">38</literal></expr>:</case> <return>return <expr><literal type="string">"ft6"</literal></expr>;</return>
<case>case <expr><literal type="number">39</literal></expr>:</case> <return>return <expr><literal type="string">"ft7"</literal></expr>;</return>
<case>case <expr><literal type="number">40</literal></expr>:</case> <return>return <expr><literal type="string">"fs0"</literal></expr>;</return>
<case>case <expr><literal type="number">41</literal></expr>:</case> <return>return <expr><literal type="string">"fs1"</literal></expr>;</return>
<case>case <expr><literal type="number">42</literal></expr>:</case> <return>return <expr><literal type="string">"fa0"</literal></expr>;</return>
<case>case <expr><literal type="number">43</literal></expr>:</case> <return>return <expr><literal type="string">"fa1"</literal></expr>;</return>
<case>case <expr><literal type="number">44</literal></expr>:</case> <return>return <expr><literal type="string">"fa2"</literal></expr>;</return>
<case>case <expr><literal type="number">45</literal></expr>:</case> <return>return <expr><literal type="string">"fa3"</literal></expr>;</return>
<case>case <expr><literal type="number">46</literal></expr>:</case> <return>return <expr><literal type="string">"fa4"</literal></expr>;</return>
<case>case <expr><literal type="number">47</literal></expr>:</case> <return>return <expr><literal type="string">"fa5"</literal></expr>;</return>
<case>case <expr><literal type="number">48</literal></expr>:</case> <return>return <expr><literal type="string">"fa6"</literal></expr>;</return>
<case>case <expr><literal type="number">49</literal></expr>:</case> <return>return <expr><literal type="string">"fa7"</literal></expr>;</return>
<case>case <expr><literal type="number">50</literal></expr>:</case> <return>return <expr><literal type="string">"fs2"</literal></expr>;</return>
<case>case <expr><literal type="number">51</literal></expr>:</case> <return>return <expr><literal type="string">"fs3"</literal></expr>;</return>
<case>case <expr><literal type="number">52</literal></expr>:</case> <return>return <expr><literal type="string">"fs4"</literal></expr>;</return>
<case>case <expr><literal type="number">53</literal></expr>:</case> <return>return <expr><literal type="string">"fs5"</literal></expr>;</return>
<case>case <expr><literal type="number">54</literal></expr>:</case> <return>return <expr><literal type="string">"fs6"</literal></expr>;</return>
<case>case <expr><literal type="number">55</literal></expr>:</case> <return>return <expr><literal type="string">"fs7"</literal></expr>;</return>
<case>case <expr><literal type="number">56</literal></expr>:</case> <return>return <expr><literal type="string">"fs8"</literal></expr>;</return>
<case>case <expr><literal type="number">57</literal></expr>:</case> <return>return <expr><literal type="string">"fs9"</literal></expr>;</return>
<case>case <expr><literal type="number">58</literal></expr>:</case> <return>return <expr><literal type="string">"fs10"</literal></expr>;</return>
<case>case <expr><literal type="number">59</literal></expr>:</case> <return>return <expr><literal type="string">"fs11"</literal></expr>;</return>
<case>case <expr><literal type="number">60</literal></expr>:</case> <return>return <expr><literal type="string">"ft8"</literal></expr>;</return>
<case>case <expr><literal type="number">61</literal></expr>:</case> <return>return <expr><literal type="string">"ft9"</literal></expr>;</return>
<case>case <expr><literal type="number">62</literal></expr>:</case> <return>return <expr><literal type="string">"ft10"</literal></expr>;</return>
<case>case <expr><literal type="number">63</literal></expr>:</case> <return>return <expr><literal type="string">"ft11"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<case>case <expr><name>EM_X86_64</name></expr>:</case>
<switch>switch <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="string">"rax"</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"rdx"</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"rcx"</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="string">"rbx"</literal></expr>;</return>
<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"rsi"</literal></expr>;</return>
<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><literal type="string">"rdi"</literal></expr>;</return>
<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><literal type="string">"rbp"</literal></expr>;</return>
<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><literal type="string">"rsp"</literal></expr>;</return>
<case>case <expr><literal type="number">16</literal></expr>:</case> <return>return <expr><literal type="string">"rip"</literal></expr>;</return>
<case>case <expr><literal type="number">17</literal></expr>:</case> <return>return <expr><literal type="string">"xmm0"</literal></expr>;</return>
<case>case <expr><literal type="number">18</literal></expr>:</case> <return>return <expr><literal type="string">"xmm1"</literal></expr>;</return>
<case>case <expr><literal type="number">19</literal></expr>:</case> <return>return <expr><literal type="string">"xmm2"</literal></expr>;</return>
<case>case <expr><literal type="number">20</literal></expr>:</case> <return>return <expr><literal type="string">"xmm3"</literal></expr>;</return>
<case>case <expr><literal type="number">21</literal></expr>:</case> <return>return <expr><literal type="string">"xmm4"</literal></expr>;</return>
<case>case <expr><literal type="number">22</literal></expr>:</case> <return>return <expr><literal type="string">"xmm5"</literal></expr>;</return>
<case>case <expr><literal type="number">23</literal></expr>:</case> <return>return <expr><literal type="string">"xmm6"</literal></expr>;</return>
<case>case <expr><literal type="number">24</literal></expr>:</case> <return>return <expr><literal type="string">"xmm7"</literal></expr>;</return>
<case>case <expr><literal type="number">25</literal></expr>:</case> <return>return <expr><literal type="string">"xmm8"</literal></expr>;</return>
<case>case <expr><literal type="number">26</literal></expr>:</case> <return>return <expr><literal type="string">"xmm9"</literal></expr>;</return>
<case>case <expr><literal type="number">27</literal></expr>:</case> <return>return <expr><literal type="string">"xmm10"</literal></expr>;</return>
<case>case <expr><literal type="number">28</literal></expr>:</case> <return>return <expr><literal type="string">"xmm11"</literal></expr>;</return>
<case>case <expr><literal type="number">29</literal></expr>:</case> <return>return <expr><literal type="string">"xmm12"</literal></expr>;</return>
<case>case <expr><literal type="number">30</literal></expr>:</case> <return>return <expr><literal type="string">"xmm13"</literal></expr>;</return>
<case>case <expr><literal type="number">31</literal></expr>:</case> <return>return <expr><literal type="string">"xmm14"</literal></expr>;</return>
<case>case <expr><literal type="number">32</literal></expr>:</case> <return>return <expr><literal type="string">"xmm15"</literal></expr>;</return>
<case>case <expr><literal type="number">33</literal></expr>:</case> <return>return <expr><literal type="string">"st0"</literal></expr>;</return>
<case>case <expr><literal type="number">34</literal></expr>:</case> <return>return <expr><literal type="string">"st1"</literal></expr>;</return>
<case>case <expr><literal type="number">35</literal></expr>:</case> <return>return <expr><literal type="string">"st2"</literal></expr>;</return>
<case>case <expr><literal type="number">36</literal></expr>:</case> <return>return <expr><literal type="string">"st3"</literal></expr>;</return>
<case>case <expr><literal type="number">37</literal></expr>:</case> <return>return <expr><literal type="string">"st4"</literal></expr>;</return>
<case>case <expr><literal type="number">38</literal></expr>:</case> <return>return <expr><literal type="string">"st5"</literal></expr>;</return>
<case>case <expr><literal type="number">39</literal></expr>:</case> <return>return <expr><literal type="string">"st6"</literal></expr>;</return>
<case>case <expr><literal type="number">40</literal></expr>:</case> <return>return <expr><literal type="string">"st7"</literal></expr>;</return>
<case>case <expr><literal type="number">41</literal></expr>:</case> <return>return <expr><literal type="string">"mm0"</literal></expr>;</return>
<case>case <expr><literal type="number">42</literal></expr>:</case> <return>return <expr><literal type="string">"mm1"</literal></expr>;</return>
<case>case <expr><literal type="number">43</literal></expr>:</case> <return>return <expr><literal type="string">"mm2"</literal></expr>;</return>
<case>case <expr><literal type="number">44</literal></expr>:</case> <return>return <expr><literal type="string">"mm3"</literal></expr>;</return>
<case>case <expr><literal type="number">45</literal></expr>:</case> <return>return <expr><literal type="string">"mm4"</literal></expr>;</return>
<case>case <expr><literal type="number">46</literal></expr>:</case> <return>return <expr><literal type="string">"mm5"</literal></expr>;</return>
<case>case <expr><literal type="number">47</literal></expr>:</case> <return>return <expr><literal type="string">"mm6"</literal></expr>;</return>
<case>case <expr><literal type="number">48</literal></expr>:</case> <return>return <expr><literal type="string">"mm7"</literal></expr>;</return>
<case>case <expr><literal type="number">49</literal></expr>:</case> <return>return <expr><literal type="string">"rflags"</literal></expr>;</return>
<case>case <expr><literal type="number">50</literal></expr>:</case> <return>return <expr><literal type="string">"es"</literal></expr>;</return>
<case>case <expr><literal type="number">51</literal></expr>:</case> <return>return <expr><literal type="string">"cs"</literal></expr>;</return>
<case>case <expr><literal type="number">52</literal></expr>:</case> <return>return <expr><literal type="string">"ss"</literal></expr>;</return>
<case>case <expr><literal type="number">53</literal></expr>:</case> <return>return <expr><literal type="string">"ds"</literal></expr>;</return>
<case>case <expr><literal type="number">54</literal></expr>:</case> <return>return <expr><literal type="string">"fs"</literal></expr>;</return>
<case>case <expr><literal type="number">55</literal></expr>:</case> <return>return <expr><literal type="string">"gs"</literal></expr>;</return>
<case>case <expr><literal type="number">58</literal></expr>:</case> <return>return <expr><literal type="string">"fs.base"</literal></expr>;</return>
<case>case <expr><literal type="number">59</literal></expr>:</case> <return>return <expr><literal type="string">"gs.base"</literal></expr>;</return>
<case>case <expr><literal type="number">62</literal></expr>:</case> <return>return <expr><literal type="string">"tr"</literal></expr>;</return>
<case>case <expr><literal type="number">63</literal></expr>:</case> <return>return <expr><literal type="string">"ldtr"</literal></expr>;</return>
<case>case <expr><literal type="number">64</literal></expr>:</case> <return>return <expr><literal type="string">"mxcsr"</literal></expr>;</return>
<case>case <expr><literal type="number">65</literal></expr>:</case> <return>return <expr><literal type="string">"fcw"</literal></expr>;</return>
<case>case <expr><literal type="number">66</literal></expr>:</case> <return>return <expr><literal type="string">"fsw"</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<default>default:</default>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_ehdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>phnum</name></decl>, <decl><type ref="prev"/><name>shnum</name></decl>, <decl><type ref="prev"/><name>shstrndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ELF Header:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Magic: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>EI_NIDENT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.2x "</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%s\n"</literal></expr></argument>, <argument><expr><literal type="string">" Class:"</literal></expr></argument>, <argument><expr><call><name>elf_class</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%s\n"</literal></expr></argument>, <argument><expr><literal type="string">" Data:"</literal></expr></argument>, <argument><expr><call><name>elf_endian</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%d %s\n"</literal></expr></argument>, <argument><expr><literal type="string">" Version:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_VERSION</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>elf_ver</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_VERSION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%s\n"</literal></expr></argument>, <argument><expr><literal type="string">" OS/ABI:"</literal></expr></argument>, <argument><expr><call><name>elf_osabi</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%d\n"</literal></expr></argument>, <argument><expr><literal type="string">" ABI Version:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_ABIVERSION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%s\n"</literal></expr></argument>, <argument><expr><literal type="string">" Type:"</literal></expr></argument>, <argument><expr><call><name>elf_type</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%s\n"</literal></expr></argument>, <argument><expr><literal type="string">" Machine:"</literal></expr></argument>, <argument><expr><call><name>elf_machine</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%#x\n"</literal></expr></argument>, <argument><expr><literal type="string">" Version:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%#jx\n"</literal></expr></argument>, <argument><expr><literal type="string">" Entry point address:"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%ju (bytes into file)\n"</literal></expr></argument>, <argument><expr><literal type="string">" Start of program headers:"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%ju (bytes into file)\n"</literal></expr></argument>, <argument><expr><literal type="string">" Start of section headers:"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%#x"</literal></expr></argument>, <argument><expr><literal type="string">" Flags:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_eflags</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u (bytes)\n"</literal></expr></argument>, <argument><expr><literal type="string">" Size of this header:"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u (bytes)\n"</literal></expr></argument>, <argument><expr><literal type="string">" Size of program headers:"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u"</literal></expr></argument>, <argument><expr><literal type="string">" Number of program headers:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name> <operator>==</operator> <name>PN_XNUM</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>elf_getphnum</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (%zu)"</literal></expr></argument>, <argument><expr><name>phnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u (bytes)\n"</literal></expr></argument>, <argument><expr><literal type="string">" Size of section headers:"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u"</literal></expr></argument>, <argument><expr><literal type="string">" Number of section headers:"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>elf_getshnum</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>shnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s%u"</literal></expr></argument>, <argument><expr><literal type="string">" Section header string table index:"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name> <operator>==</operator> <name>SHN_XINDEX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>elf_getshstrndx</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shstrndx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (%ju)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>shstrndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_eflags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>e_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>eflags_desc</name></name> <modifier>*</modifier></type><name>edesc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arm_eabi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_ARM</name></expr>:</case>
<expr_stmt><expr><name>arm_eabi</name> <operator>=</operator> <operator>(</operator><name>e_flags</name> <operator>&amp;</operator> <name>EF_ARM_EABIMASK</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arm_eabi</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", GNU EABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>arm_eabi</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", Version%d EABI"</literal></expr></argument>, <argument><expr><name>arm_eabi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>arm_eflags_desc</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>
<switch>switch <condition>(<expr><operator>(</operator><name>e_flags</name> <operator>&amp;</operator> <name>EF_MIPS_ARCH</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">28</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips5"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips32"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips64"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips32r2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", mips64r2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><operator>(</operator><name>e_flags</name> <operator>&amp;</operator> <literal type="number">0x00FF0000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x81</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 3900"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x82</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 4010"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x83</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 4100"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x85</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 4650"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x87</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 4120"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x88</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 4111"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x8a</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", sb1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x8b</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", octeon"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x8c</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", xlr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x91</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 5400"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x98</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 5500"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0x99</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", 9000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0xa0</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", loongson-2e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">0xa1</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", loongson-2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><operator>(</operator><name>e_flags</name> <operator>&amp;</operator> <literal type="number">0x0000F000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", o32"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", o64"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", eabi32"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", eabi64"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>mips_eflags_desc</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EM_PPC64</name></expr>:</case>
<switch>switch <condition>(<expr><name>e_flags</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", Unspecified or Power ELF V1 ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", Power ELF V1 ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", OpenPOWER ELF V2 ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>

<case>case <expr><name>EM_PPC</name></expr>:</case>
<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>powerpc_eflags_desc</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EM_RISCV</name></expr>:</case>
<switch>switch <condition>(<expr><name>e_flags</name> <operator>&amp;</operator> <name>EF_RISCV_FLOAT_ABI_MASK</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EF_RISCV_FLOAT_ABI_SOFT</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", soft-float ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EF_RISCV_FLOAT_ABI_SINGLE</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", single-float ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EF_RISCV_FLOAT_ABI_DOUBLE</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", double-float ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EF_RISCV_FLOAT_ABI_QUAD</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", quad-float ABI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>riscv_eflags_desc</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EM_SPARC</name></expr>:</case>
<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case>
<switch>switch <condition>(<expr><operator>(</operator><name>e_flags</name> <operator>&amp;</operator> <name>EF_SPARCV9_MM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EF_SPARCV9_TSO</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", tso"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>EF_SPARCV9_PSO</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", pso"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>EF_SPARCV9_MM</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", rmo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>edesc</name> <operator>=</operator> <name>sparc_eflags_desc</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>edesc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>edesc</name><operator>-&gt;</operator><name>desc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>e_flags</name> <operator>&amp;</operator> <name><name>edesc</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">", %s"</literal></expr></argument>, <argument><expr><name><name>edesc</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>edesc</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_phdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Phdr</name></type> <name>phdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>phnum</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PH_HDR</name></cpp:macro> <cpp:value>"Type", "Offset", "VirtAddr", "PhysAddr", "FileSiz", "MemSiz", "Flg", "Align"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PH_CT</name></cpp:macro> <cpp:value>phdr_type(re-&gt;ehdr.e_machine, phdr.p_type), (uintmax_t)phdr.p_offset, (uintmax_t)phdr.p_vaddr, (uintmax_t)phdr.p_paddr, (uintmax_t)phdr.p_filesz, (uintmax_t)phdr.p_memsz, phdr.p_flags &amp; PF_R ? 'R' : ' ', phdr.p_flags &amp; PF_W ? 'W' : ' ', phdr.p_flags &amp; PF_X ? 'E' : ' ', (uintmax_t)phdr.p_align</cpp:value></cpp:define>








<if_stmt><if>if <condition>(<expr><call><name>elf_getphnum</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>phnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nThere are no program headers in this file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nElf file type is %s"</literal></expr></argument>, <argument><expr><call><name>elf_type</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nEntry point 0x%jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"There are %ju program headers, starting at offset %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>phnum</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nProgram Headers:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-15s%-9s%-11s%-11s%-8s%-8s%-4s%s\n"</literal></expr></argument>, <argument><expr><name>PH_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-15s%-9s%-19s%-19s%-9s%-9s%-4s%s\n"</literal></expr></argument>, <argument><expr><name>PH_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-15s%-19s%-19s%s\n %-19s%-20s"</literal>
<literal type="string">"%-7s%s\n"</literal></expr></argument>, <argument><expr><name>PH_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name>phnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>phdr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getphdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-14.14s 0x%6.6jx 0x%8.8jx 0x%8.8jx "</literal>
<literal type="string">"0x%5.5jx 0x%5.5jx %c%c%c %#jx\n"</literal></expr></argument>, <argument><expr><name>PH_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-14.14s 0x%6.6jx 0x%16.16jx 0x%16.16jx "</literal>
<literal type="string">"0x%6.6jx 0x%6.6jx %c%c%c %#jx\n"</literal></expr></argument>, <argument><expr><name>PH_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-14.14s 0x%16.16jx 0x%16.16jx 0x%16.16jx\n"</literal>
<literal type="string">" 0x%16.16jx 0x%16.16jx %c%c%c"</literal>
<literal type="string">" %#jx\n"</literal></expr></argument>, <argument><expr><name>PH_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>==</operator> <name>PT_INTERP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rawfile</name> <operator>=</operator> <call><name>elf_rawfile</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawfile failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid program header offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [Requesting program interpreter: %s]\n"</literal></expr></argument>,
<argument><expr><name>rawfile</name> <operator>+</operator> <name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n Section to Segment mapping:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Segment Sections...\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>phnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>phdr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getphdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %2.2d "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>j</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>&lt;</operator> <name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>+</operator> <name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sz</name> <operator>&gt;</operator>
<name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>+</operator> <name><name>phdr</name><operator>.</operator><name>p_filesz</name></name> <operator>&amp;&amp;</operator>
<name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>!=</operator> <name>SHT_NOBITS</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>&lt;</operator> <name><name>phdr</name><operator>.</operator><name>p_vaddr</name></name> <operator>||</operator>
<name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>+</operator> <name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>sz</name> <operator>&gt;</operator>
<name><name>phdr</name><operator>.</operator><name>p_vaddr</name></name> <operator>+</operator> <name><name>phdr</name><operator>.</operator><name>p_memsz</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>==</operator> <name>PT_TLS</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>&amp;</operator> <name>SHF_TLS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PH_HDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PH_CT</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>section_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_SZ</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><name>BUF_SZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>p</name></decl>, <decl><type ref="prev"/><name>nb</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nb</name> <operator>=</operator> <ternary><condition><expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SZ</name></expr></argument>, <argument><expr><literal type="string">"[%*.*jx]: "</literal></expr></argument>, <argument><expr><name>nb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nb</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>section_flag</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name><name>section_flag</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name>BUF_SZ</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>,
<argument><expr><name><name>section_flag</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>section_flag</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>section_flag</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sn</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>nb</name> <operator>+</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_shdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_HDR</name></cpp:macro> <cpp:value>"[Nr] Name", "Type", "Addr", "Off", "Size", "ES", "Flg", "Lk", "Inf", "Al"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_HDRL</name></cpp:macro> <cpp:value>"[Nr] Name", "Type", "Address", "Offset", "Size", "EntSize", "Flags", "Link", "Info", "Align"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_HDR</name></cpp:macro> <cpp:value>"[Nr] Name", "Type", "Addr", "Off", "Size", "ES", "Lk", "Inf", "Al", "Flags"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_HDRL</name></cpp:macro> <cpp:value>"[Nr] Name", "Type", "Address", "Offset", "Link", "Size", "EntSize", "Info", "Align", "Flags"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_CT</name></cpp:macro> <cpp:value>i, s-&gt;name, section_type(re-&gt;ehdr.e_machine, s-&gt;type), (uintmax_t)s-&gt;addr, (uintmax_t)s-&gt;off, (uintmax_t)s-&gt;sz,(uintmax_t)s-&gt;entsize, section_flags(re, s), s-&gt;link, s-&gt;info, (uintmax_t)s-&gt;align</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_CT</name></cpp:macro> <cpp:value>i, s-&gt;name, section_type(re-&gt;ehdr.e_machine, s-&gt;type), (uintmax_t)s-&gt;addr, (uintmax_t)s-&gt;off, (uintmax_t)s-&gt;sz,(uintmax_t)s-&gt;entsize, s-&gt;link, s-&gt;info, (uintmax_t)s-&gt;align, section_flags(re, s)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_CTL</name></cpp:macro> <cpp:value>i, s-&gt;name, section_type(re-&gt;ehdr.e_machine, s-&gt;type), (uintmax_t)s-&gt;addr, (uintmax_t)s-&gt;off, s-&gt;link, (uintmax_t)s-&gt;sz, (uintmax_t)s-&gt;entsize, s-&gt;info, (uintmax_t)s-&gt;align, section_flags(re, s)</cpp:value></cpp:define>




<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nThere are no sections in this file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"There are %ju section headers, starting at offset 0x%jx:\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection Headers:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n %-16s%-9s%-7s%-7s%-5s%-3s%-4s%s\n"</literal>
<literal type="string">"%12s\n"</literal></expr></argument>, <argument><expr><name>ST_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-23s%-16s%-9s%-7s%-7s%-3s%-4s%-3s%-4s%s\n"</literal></expr></argument>,
<argument><expr><name>S_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n %-16s%-17s%-7s%-7s%-5s%-3s%-4s%s\n"</literal>
<literal type="string">"%12s\n"</literal></expr></argument>, <argument><expr><name>ST_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-23s%-16s%-17s%-7s%-7s%-3s%-4s%-3s%-4s%s\n"</literal></expr></argument>,
<argument><expr><name>S_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n %-18s%-17s%-18s%s\n %-18s"</literal>
<literal type="string">"%-17s%-18s%s\n%12s\n"</literal></expr></argument>, <argument><expr><name>ST_HDRL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-23s%-17s%-18s%s\n %-18s%-17s%-7s%"</literal>
<literal type="string">"-6s%-6s%s\n"</literal></expr></argument>, <argument><expr><name>S_HDRL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %s\n %-15.15s %8.8jx"</literal>
<literal type="string">" %6.6jx %6.6jx %2.2jx %2u %3u %2ju\n"</literal>
<literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>ST_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %-17s %-15.15s "</literal>
<literal type="string">"%8.8jx %6.6jx %6.6jx %2.2jx %3s "</literal>
<literal type="string">"%2u %3u %2ju\n"</literal></expr></argument>, <argument><expr><name>S_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %-17.17s %-15.15s "</literal>
<literal type="string">"%8.8jx %6.6jx %6.6jx %2.2jx %3s "</literal>
<literal type="string">"%2u %3u %2ju\n"</literal></expr></argument>, <argument><expr><name>S_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %s\n %-15.15s %16.16jx"</literal>
<literal type="string">" %6.6jx %6.6jx %2.2jx %2u %3u %2ju\n"</literal>
<literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>ST_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %-17s %-15.15s %16.16jx"</literal>
<literal type="string">" %6.6jx %6.6jx %2.2jx %3s %2u %3u %2ju\n"</literal></expr></argument>,
<argument><expr><name>S_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %s\n %-15.15s %16.16jx"</literal>
<literal type="string">" %16.16jx %u\n %16.16jx %16.16jx"</literal>
<literal type="string">" %-16u %ju\n %s\n"</literal></expr></argument>, <argument><expr><name>ST_CTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%2d] %-17.17s %-15.15s %16.16jx"</literal>
<literal type="string">" %8.8jx\n %16.16jx %16.16jx "</literal>
<literal type="string">"%3s %2u %3u %ju\n"</literal></expr></argument>, <argument><expr><name>S_CT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_T</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Key to Flags:\n W (write), A (alloc),"</literal>
<literal type="string">" X (execute), M (merge), S (strings)\n"</literal>
<literal type="string">" I (info), L (link order), G (group), x (unknown)\n"</literal>
<literal type="string">" O (extra OS processing required)"</literal>
<literal type="string">" o (OS specific), p (processor specific)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_HDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_HDRL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ST_HDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ST_HDRL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S_CT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ST_CT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ST_CTL</name></cpp:undef>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ent_count</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ent_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section %s has entry size 0"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section %s has invalid section count"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ent_count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dynamic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Dyn</name></type> <name>dyn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>is_dynamic</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>jmax</name></decl>, <decl><type ref="prev"/><name>nentries</name></decl>;</decl_stmt>

<expr_stmt><expr><name>is_dynamic</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_DYNAMIC</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>is_dynamic</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>nentries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>jmax</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getdyn</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dyn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dyn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getdyn failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nentries</name> <operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nDynamic section at offset 0x%jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" contains %u entries:\n"</literal></expr></argument>, <argument><expr><name>nentries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%5s%12s%28s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Tag"</literal></expr></argument>, <argument><expr><literal type="string">"Type"</literal></expr></argument>, <argument><expr><literal type="string">"Name/Value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%5s%20s%28s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Tag"</literal></expr></argument>, <argument><expr><literal type="string">"Type"</literal></expr></argument>, <argument><expr><literal type="string">"Name/Value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getdyn</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dyn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dyn</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%8.8jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%16.16jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-20s"</literal></expr></argument>, <argument><expr><call><name>dt_type</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>,
<argument><expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_dyn_val</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dyn</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_dynamic</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nThere is no dynamic section in this file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>timestamp</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>ti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ts</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%04d-%02d-%02dT%02d:%02d:%02d"</literal></expr></argument>,
<argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>,
<argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ts</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dyn_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>stab</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>d_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stab</name> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"ERROR"</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>stab</name></expr></argument>, <argument><expr><name>d_val</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"ERROR"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_arch_dyn_val</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>GElf_Dyn</name> <modifier>*</modifier></type><name>dyn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_MIPS_RLD_VERSION</name></expr>:</case>
<case>case <expr><name>DT_MIPS_LOCAL_GOTNO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_CONFLICTNO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_LIBLISTNO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_SYMTABNO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_UNREFEXTNO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_GOTSYM</name></expr>:</case>
<case>case <expr><name>DT_MIPS_HIPAGENO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_CLASS_NO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_INSTANCE_NO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_RELOC_NO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_SYM_NO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_CLASSSYM_NO</name></expr>:</case>
<case>case <expr><name>DT_MIPS_LOCALPAGE_GOTIDX</name></expr>:</case>
<case>case <expr><name>DT_MIPS_LOCAL_GOTIDX</name></expr>:</case>
<case>case <expr><name>DT_MIPS_HIDDEN_GOTIDX</name></expr>:</case>
<case>case <expr><name>DT_MIPS_PROTECTED_GOTIDX</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_MIPS_ICHECKSUM</name></expr>:</case>
<case>case <expr><name>DT_MIPS_FLAGS</name></expr>:</case>
<case>case <expr><name>DT_MIPS_BASE_ADDRESS</name></expr>:</case>
<case>case <expr><name>DT_MIPS_CONFLICT</name></expr>:</case>
<case>case <expr><name>DT_MIPS_LIBLIST</name></expr>:</case>
<case>case <expr><name>DT_MIPS_RLD_MAP</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_CLASS</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_INSTANCE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_RELOC</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_SYM</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DELTA_CLASSSYM</name></expr>:</case>
<case>case <expr><name>DT_MIPS_CXX_FLAGS</name></expr>:</case>
<case>case <expr><name>DT_MIPS_PIXIE_INIT</name></expr>:</case>
<case>case <expr><name>DT_MIPS_SYMBOL_LIB</name></expr>:</case>
<case>case <expr><name>DT_MIPS_OPTIONS</name></expr>:</case>
<case>case <expr><name>DT_MIPS_INTERFACE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_DYNSTR_ALIGN</name></expr>:</case>
<case>case <expr><name>DT_MIPS_INTERFACE_SIZE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_RLD_TEXT_RESOLVE_ADDR</name></expr>:</case>
<case>case <expr><name>DT_MIPS_COMPACT_SIZE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_GP_VALUE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_AUX_DYNAMIC</name></expr>:</case>
<case>case <expr><name>DT_MIPS_PLTGOT</name></expr>:</case>
<case>case <expr><name>DT_MIPS_RLD_OBJ_UPDATE</name></expr>:</case>
<case>case <expr><name>DT_MIPS_RWPLT</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_MIPS_IVERSION</name></expr>:</case>
<case>case <expr><name>DT_MIPS_PERF_SUFFIX</name></expr>:</case>
<case>case <expr><name>DT_MIPS_TIME_STAMP</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><call><name>timestamp</name><argument_list>(<argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>flag_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>flag_desc</name></name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <name>desc</name></expr>;</init> <condition><expr><name><name>fd</name><operator>-&gt;</operator><name>flag</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>fd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;</operator> <name><name>fd</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>&amp;=</operator> <operator>~</operator><name><name>fd</name><operator>-&gt;</operator><name>flag</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>fd</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" unknown (0x%jx)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc</name></name></type> <name><name>dt_flags</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>DF_ORIGIN</name></expr>, <expr><literal type="string">"ORIGIN"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_SYMBOLIC</name></expr>, <expr><literal type="string">"SYMBOLIC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_TEXTREL</name></expr>, <expr><literal type="string">"TEXTREL"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_BIND_NOW</name></expr>, <expr><literal type="string">"BIND_NOW"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_STATIC_TLS</name></expr>, <expr><literal type="string">"STATIC_TLS"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc</name></name></type> <name><name>dt_flags_1</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>DF_1_BIND_NOW</name></expr>, <expr><literal type="string">"NOW"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_GLOBAL</name></expr>, <expr><literal type="string">"GLOBAL"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x4</literal></expr>, <expr><literal type="string">"GROUP"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_NODELETE</name></expr>, <expr><literal type="string">"NODELETE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_LOADFLTR</name></expr>, <expr><literal type="string">"LOADFLTR"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x20</literal></expr>, <expr><literal type="string">"INITFIRST"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_NOOPEN</name></expr>, <expr><literal type="string">"NOOPEN"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_ORIGIN</name></expr>, <expr><literal type="string">"ORIGIN"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x100</literal></expr>, <expr><literal type="string">"DIRECT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_INTERPOSE</name></expr>, <expr><literal type="string">"INTERPOSE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_NODEFLIB</name></expr>, <expr><literal type="string">"NODEFLIB"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x1000</literal></expr>, <expr><literal type="string">"NODUMP"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x2000</literal></expr>, <expr><literal type="string">"CONFALT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x4000</literal></expr>, <expr><literal type="string">"ENDFILTEE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x8000</literal></expr>, <expr><literal type="string">"DISPRELDNE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x10000</literal></expr>, <expr><literal type="string">"DISPRELPND"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x20000</literal></expr>, <expr><literal type="string">"NODIRECT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x40000</literal></expr>, <expr><literal type="string">"IGNMULDEF"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x80000</literal></expr>, <expr><literal type="string">"NOKSYMS"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x100000</literal></expr>, <expr><literal type="string">"NOHDR"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x200000</literal></expr>, <expr><literal type="string">"EDITED"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x400000</literal></expr>, <expr><literal type="string">"NORELOC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x800000</literal></expr>, <expr><literal type="string">"SYMINTPOSE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x1000000</literal></expr>, <expr><literal type="string">"GLOBAUDIT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x02000000</literal></expr>, <expr><literal type="string">"SINGLETON"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0x04000000</literal></expr>, <expr><literal type="string">"STUB"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>DF_1_PIE</name></expr>, <expr><literal type="string">"PIE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dyn_val</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>GElf_Dyn</name> <modifier>*</modifier></type><name>dyn</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>stab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>&gt;=</operator> <name>DT_LOPROC</name> <operator>&amp;&amp;</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>&lt;=</operator> <name>DT_HIPROC</name> <operator>&amp;&amp;</operator>
<name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>!=</operator> <name>DT_AUXILIARY</name> <operator>&amp;&amp;</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>!=</operator> <name>DT_FILTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dump_arch_dyn_val</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>dyn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_AUXILIARY</name> <operator>||</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_FILTER</name> <operator>||</operator>
<name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_NEEDED</name> <operator>||</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_SONAME</name> <operator>||</operator>
<name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_RPATH</name> <operator>||</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_RUNPATH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>dyn_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>stab</name></expr></argument>, <argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch<condition>(<expr><name><name>dyn</name><operator>-&gt;</operator><name>d_tag</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NULL</name></expr>:</case>
<case>case <expr><name>DT_PLTGOT</name></expr>:</case>
<case>case <expr><name>DT_HASH</name></expr>:</case>
<case>case <expr><name>DT_STRTAB</name></expr>:</case>
<case>case <expr><name>DT_SYMTAB</name></expr>:</case>
<case>case <expr><name>DT_RELA</name></expr>:</case>
<case>case <expr><name>DT_INIT</name></expr>:</case>
<case>case <expr><name>DT_SYMBOLIC</name></expr>:</case>
<case>case <expr><name>DT_REL</name></expr>:</case>
<case>case <expr><name>DT_DEBUG</name></expr>:</case>
<case>case <expr><name>DT_TEXTREL</name></expr>:</case>
<case>case <expr><name>DT_JMPREL</name></expr>:</case>
<case>case <expr><name>DT_FINI</name></expr>:</case>
<case>case <expr><name>DT_VERDEF</name></expr>:</case>
<case>case <expr><name>DT_VERNEED</name></expr>:</case>
<case>case <expr><name>DT_VERSYM</name></expr>:</case>
<case>case <expr><name>DT_GNU_HASH</name></expr>:</case>
<case>case <expr><name>DT_GNU_LIBLIST</name></expr>:</case>
<case>case <expr><name>DT_GNU_CONFLICT</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case>
<case>case <expr><name>DT_RELASZ</name></expr>:</case>
<case>case <expr><name>DT_RELAENT</name></expr>:</case>
<case>case <expr><name>DT_STRSZ</name></expr>:</case>
<case>case <expr><name>DT_SYMENT</name></expr>:</case>
<case>case <expr><name>DT_RELSZ</name></expr>:</case>
<case>case <expr><name>DT_RELENT</name></expr>:</case>
<case>case <expr><name>DT_PREINIT_ARRAYSZ</name></expr>:</case>
<case>case <expr><name>DT_INIT_ARRAYSZ</name></expr>:</case>
<case>case <expr><name>DT_FINI_ARRAYSZ</name></expr>:</case>
<case>case <expr><name>DT_GNU_CONFLICTSZ</name></expr>:</case>
<case>case <expr><name>DT_GNU_LIBLISTSZ</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %ju (bytes)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_RELACOUNT</name></expr>:</case>
<case>case <expr><name>DT_RELCOUNT</name></expr>:</case>
<case>case <expr><name>DT_VERDEFNUM</name></expr>:</case>
<case>case <expr><name>DT_VERNEEDNUM</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_AUXILIARY</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Auxiliary library: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_FILTER</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Filter library: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NEEDED</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Shared library: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_SONAME</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Library soname: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_RPATH</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Library rpath: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_RUNPATH</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Library runpath: [%s]\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_PLTREL</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><call><name>dt_type</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>, <argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_GNU_PRELINKED</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><call><name>timestamp</name><argument_list>(<argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_FLAGS</name></expr>:</case>
<expr_stmt><expr><call><name>dump_flags</name><argument_list>(<argument><expr><name>dt_flags</name></expr></argument>, <argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_FLAGS_1</name></expr>:</case>
<expr_stmt><expr><call><name>dump_flags</name><argument_list>(<argument><expr><name>dt_flags_1</name></expr></argument>, <argument><expr><name><name>dyn</name><operator>-&gt;</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_rel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Rel</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>symval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>type2</name></decl>, <decl><type ref="prev"/><name>type3</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_HDR</name></cpp:macro> <cpp:value>"r_offset", "r_info", "r_type", "st_value", "st_name"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CT32</name></cpp:macro> <cpp:value>(uintmax_t)r.r_offset, (uintmax_t)r.r_info, elftc_reloc_type_str(re-&gt;ehdr.e_machine, ELF32_R_TYPE(r.r_info)), (uintmax_t)symval, symname</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_CT64</name></cpp:macro> <cpp:value>(uintmax_t)r.r_offset, (uintmax_t)r.r_info, elftc_reloc_type_str(re-&gt;ehdr.e_machine, type), (uintmax_t)symval, symname</cpp:value></cpp:define>



<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nRelocation section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s %-8s %-19s %-8s %s\n"</literal></expr></argument>, <argument><expr><name>REL_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-16s %-16s %-24s %-16s %s\n"</literal></expr></argument>, <argument><expr><name>REL_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-12s %-12s %-19s %-16s %s\n"</literal></expr></argument>, <argument><expr><name>REL_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrel</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrel failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>symname</name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symval</name> <operator>=</operator> <call><name>get_symbol_value</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><call><name>ELF64_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ELF64_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%8.8jx %8.8jx %-19.19s %8.8jx %s\n"</literal></expr></argument>, <argument><expr><name>REL_CT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ELF64_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type2</name> <operator>=</operator> <operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>type3</name> <operator>=</operator> <operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>type</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type2</name> <operator>=</operator> <name>type3</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%16.16jx %16.16jx %-24.24s"</literal>
<literal type="string">" %16.16jx %s\n"</literal></expr></argument>, <argument><expr><name>REL_CT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%12.12jx %12.12jx %-19.19s"</literal>
<literal type="string">" %16.16jx %s\n"</literal></expr></argument>, <argument><expr><name>REL_CT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%32s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type2"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%32s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type3"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%24s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type2"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%24s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type3"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REL_HDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>REL_CT</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_rela</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Rela</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>symval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>type2</name></decl>, <decl><type ref="prev"/><name>type3</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELA_HDR</name></cpp:macro> <cpp:value>"r_offset", "r_info", "r_type", "st_value", "st_name + r_addend"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELA_CT32</name></cpp:macro> <cpp:value>(uintmax_t)r.r_offset, (uintmax_t)r.r_info, elftc_reloc_type_str(re-&gt;ehdr.e_machine, ELF32_R_TYPE(r.r_info)), (uintmax_t)symval, symname</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELA_CT64</name></cpp:macro> <cpp:value>(uintmax_t)r.r_offset, (uintmax_t)r.r_info, elftc_reloc_type_str(re-&gt;ehdr.e_machine, type), (uintmax_t)symval, symname</cpp:value></cpp:define>



<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nRelocation section with addend (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s %-8s %-19s %-8s %s\n"</literal></expr></argument>, <argument><expr><name>RELA_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-16s %-16s %-24s %-16s %s\n"</literal></expr></argument>, <argument><expr><name>RELA_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-12s %-12s %-19s %-16s %s\n"</literal></expr></argument>, <argument><expr><name>RELA_HDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrela</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrel failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>symname</name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symval</name> <operator>=</operator> <call><name>get_symbol_value</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><call><name>ELF64_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ELF64_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%8.8jx %8.8jx %-19.19s %8.8jx %s"</literal></expr></argument>, <argument><expr><name>RELA_CT32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" + %x\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator> <name><name>r</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ELF64_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type2</name> <operator>=</operator> <operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>type3</name> <operator>=</operator> <operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>type</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type2</name> <operator>=</operator> <name>type3</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%16.16jx %16.16jx %-24.24s"</literal>
<literal type="string">" %16.16jx %s"</literal></expr></argument>, <argument><expr><name>RELA_CT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%12.12jx %12.12jx %-19.19s"</literal>
<literal type="string">" %16.16jx %s"</literal></expr></argument>, <argument><expr><name>RELA_CT64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" + %jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>r</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_WW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%32s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type2"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%32s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type3"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%24s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type2"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%24s: %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Type3"</literal></expr></argument>,
<argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name>EM_MIPS</name></expr></argument>,
<argument><expr><name>type3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RELA_HDR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RELA_CT</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_reloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_REL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_REL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_rel</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_rela</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_symtab</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>stab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>vs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>stab</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Symbol table (%s)"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" contains %d entries:\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%7s%9s%14s%5s%8s%6s%9s%5s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Num:"</literal></expr></argument>, <argument><expr><literal type="string">"Value"</literal></expr></argument>, <argument><expr><literal type="string">"Size"</literal></expr></argument>, <argument><expr><literal type="string">"Type"</literal></expr></argument>,
<argument><expr><literal type="string">"Bind"</literal></expr></argument>, <argument><expr><literal type="string">"Vis"</literal></expr></argument>, <argument><expr><literal type="string">"Ndx"</literal></expr></argument>, <argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>sym</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getsym failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%6d:"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %16.16jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %5ju"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>sym</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-7s"</literal></expr></argument>, <argument><expr><call><name>st_type</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-6s"</literal></expr></argument>, <argument><expr><call><name>st_bind</name><argument_list>(<argument><expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-8s"</literal></expr></argument>, <argument><expr><call><name>st_vis</name><argument_list>(<argument><expr><call><name>GELF_ST_VISIBILITY</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_other</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %3s"</literal></expr></argument>, <argument><expr><call><name>st_shndx</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>stab</name></expr></argument>, <argument><expr><name><name>sym</name><operator>.</operator><name>st_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_DYNSYM</name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>re</name><operator>-&gt;</operator><name>vs</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vs</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>VERSYM_VERSION</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vs</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name>vs</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid versym version index %u"</literal></expr></argument>, <argument><expr><name>vs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>VERSYM_HIDDEN</name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name>vs</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"@%s (%d)"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name>vs</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>vs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"@@%s (%d)"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name>vs</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>vs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_symtabs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Dyn</name></type> <name>dyn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>dyn_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>





<expr_stmt><expr><name>dyn_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_DD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>SHT_DYNAMIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getdyn</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dyn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dyn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getdyn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_SYMTAB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dyn_off</name> <operator>=</operator> <name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SYMTAB</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_DYNSYM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_DD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dyn_off</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dump_symtab</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_symtab</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_svr4_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nbucket</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nchain</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator> <operator>(</operator><name>nbucket</name> <operator>+</operator> <name>nchain</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>nbucket</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nHistogram for bucket list length (total of %u buckets):\n"</literal></expr></argument>,
<argument><expr><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length\tNumber\t\t%% of total\tCoverage\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%7u\t%-10u\t(%5.1f%%)\t%5.1f%%\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <name>nbucket</name></expr></argument>, <argument><expr><name>total</name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <operator>(</operator><name>nchain</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_svr4_hash64</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>






<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name>ELF_T_XWORD</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_xlatetom</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>d</name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_xlatetom failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>.</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>dst</name><operator>.</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nbucket</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nchain</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator> <operator>(</operator><name>nbucket</name> <operator>+</operator> <name>nchain</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>nbucket</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Histogram for bucket list length (total of %ju buckets):\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length\tNumber\t\t%% of total\tCoverage\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%7u\t%-10ju\t(%5.1f%%)\t%5.1f%%\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <name>nbucket</name></expr></argument>, <argument><expr><name>total</name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <operator>(</operator><name>nchain</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_gnu_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>, <decl><type ref="prev"/><name>symndx</name></decl>, <decl><type ref="prev"/><name>maskwords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>dynsymcount</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".gnu.hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symndx</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>maskwords</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dynsymcount</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>symndx</name> <operator>&gt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>dynsymcount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .gnu.hash section (symndx out of range)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name>dynsymcount</name> <operator>-</operator> <name>symndx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator> <literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>maskwords</name> <operator>*</operator>
<operator>(</operator><ternary><condition><expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator> <operator>+</operator>
<operator>(</operator><name>nbucket</name> <operator>+</operator> <name>nchain</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .gnu.hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr> ?</condition><then> <expr><name>maskwords</name></expr> </then><else>: <expr><name>maskwords</name> <operator>*</operator> <literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <name>bucket</name> <operator>+</operator> <name>nbucket</name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>j</name> <operator>-</operator> <name>symndx</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition>
<incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chain</name><index>[<expr><name>j</name> <operator>-</operator> <name>symndx</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Histogram for bucket list length (total of %u buckets):\n"</literal></expr></argument>,
<argument><expr><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length\tNumber\t\t%% of total\tCoverage\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%7u\t%-10u\t(%5.1f%%)\t%5.1f%%\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <name>nbucket</name></expr></argument>, <argument><expr><name>total</name> <operator>*</operator> <literal type="number">100.0</literal> <operator>/</operator> <operator>(</operator><name>nchain</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc</name></name></type> <name><name>gnu_property_aarch64_feature_1_and_bits</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>GNU_PROPERTY_AARCH64_FEATURE_1_BTI</name></expr>, <expr><literal type="string">"BTI"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>GNU_PROPERTY_AARCH64_FEATURE_1_PAC</name></expr>, <expr><literal type="string">"PAC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc_list</name></name></type> <name><name>gnu_property_aarch64</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><name>GNU_PROPERTY_AARCH64_FEATURE_1_AND</name></expr>,
<expr><literal type="string">"AArch64 features"</literal></expr>,
<expr><name>gnu_property_aarch64_feature_1_and_bits</name></expr>
}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc</name></name></type> <name><name>gnu_property_x86_feature_1_and_bits</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>GNU_PROPERTY_X86_FEATURE_1_IBT</name></expr>, <expr><literal type="string">"IBT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>GNU_PROPERTY_X86_FEATURE_1_SHSTK</name></expr>, <expr><literal type="string">"SHSTK"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc_list</name></name></type> <name><name>gnu_property_x86</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><name>GNU_PROPERTY_X86_FEATURE_1_AND</name></expr>,
<expr><literal type="string">"x64 features"</literal></expr>,
<expr><name>gnu_property_x86_feature_1_and_bits</name></expr>
}</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>emachine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>flag_desc_list</name></name> <modifier>*</modifier></type><name>flag_list</name></decl>;</decl_stmt>
}</block> <decl><name><name>gnu_property_archs</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>EM_AARCH64</name></expr>, <expr><name>gnu_property_aarch64</name></expr> }</block></expr>,
<expr><block>{ <expr><name>EM_X86_64</name></expr>, <expr><name>gnu_property_x86</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_gnu_property_type_0</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>flag_desc_list</name></name> <modifier>*</modifier></type><name>desc_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>flag_desc</name></name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>prop_sz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Properties: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prop_sz</name> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prop_sz</name> <operator>&gt;</operator> <name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>GNU_PROPERTY_LOPROC</name> <operator>&amp;&amp;</operator>
<name>type</name> <operator>&lt;=</operator> <name>GNU_PROPERTY_HIPROC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>gnu_property_archs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flag_list</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>gnu_property_archs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>emachine</name> <operator>==</operator>
<name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc_list</name> <operator>=</operator>
<name><name>gnu_property_archs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flag_list</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>desc_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"machine type %x unknown\n"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>unknown</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>desc_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>desc_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>desc_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name><name>desc_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>desc_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prop_sz</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dump_flags</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>+=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>prop_sz</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>-=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>prop_sz</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return;</return>
<label><name>bad</name>:</label>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"corrupt GNU property\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>unknown</name>:</label>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"remaining description data:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_HASH</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_GNU_HASH</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_GNU_HASH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_gnu_hash</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ALPHA</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_svr4_hash64</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_svr4_hash</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_notes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Phdr</name></type> <name>phdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>filesize</name></decl>, <decl><type ref="prev"/><name>phnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_CORE</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>elf_getphnum</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>phnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rawfile</name> <operator>=</operator> <call><name>elf_rawfile</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filesize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawfile failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name>phnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>phdr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getphdr failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>==</operator> <name>PT_NOTE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>&gt;=</operator> <name>filesize</name> <operator>||</operator>
<name><name>phdr</name><operator>.</operator><name>p_filesz</name></name> <operator>&gt;</operator> <name>filesize</name> <operator>-</operator> <name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid PHDR offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dump_notes_content</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>rawfile</name> <operator>+</operator> <name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr></argument>,
<argument><expr><name><name>phdr</name><operator>.</operator><name>p_filesz</name></name></expr></argument>, <argument><expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

</block_content>}</block></if> <else>else <block>{<block_content>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_NOTE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dump_notes_content</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>flag_desc</name></name></type> <name><name>note_feature_ctl_flags</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_ASLR_DISABLE</name></expr>, <expr><literal type="string">"ASLR_DISABLE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_PROTMAX_DISABLE</name></expr>, <expr><literal type="string">"PROTMAX_DISABLE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_STKGAP_DISABLE</name></expr>, <expr><literal type="string">"STKGAP_DISABLE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_WXNEEDED</name></expr>, <expr><literal type="string">"WXNEEDED"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_LA48</name></expr>, <expr><literal type="string">"LA48"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NT_FREEBSD_FCTL_ASG_DISABLE</name></expr>, <expr><literal type="string">"ASG_DISABLE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dump_note_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><index>[<expr><operator>--</operator><name>len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s: %s\n"</literal></expr></argument>, <argument><expr><name>description</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>note_desc</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>fp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>note_desc</name></name></type> <name><name>xen_notes</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="number">5</literal></expr>, <expr><literal type="string">"Xen version"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><literal type="string">"Guest OS"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">7</literal></expr>, <expr><literal type="string">"Guest version"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><literal type="string">"Loader"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">9</literal></expr>, <expr><literal type="string">"PAE mode"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">10</literal></expr>, <expr><literal type="string">"Features"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">11</literal></expr>, <expr><literal type="string">"BSD symtab"</literal></expr>, <expr><name>dump_note_string</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_notes_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>note_desc</name></name> <modifier>*</modifier></type><name>nd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>ubuf</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>buf</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"bad note data alignment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>unknown</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ubuf</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_FREEBSD_ABI_TAG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unknown</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" ABI tag: %u\n"</literal></expr></argument>, <argument><expr><name><name>ubuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>

<case>case <expr><name>NT_FREEBSD_ARCH_TAG</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Arch tag: %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>NT_FREEBSD_FEATURE_CTL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unknown</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Features:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_flags</name><argument_list>(<argument><expr><name>note_feature_ctl_flags</name></expr></argument>, <argument><expr><name><name>ubuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"Go"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Build ID: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"%c"</literal></expr> </then><else>: <expr><literal type="string">"&lt;%02x&gt;"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"GNU"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_GNU_PROPERTY_TYPE_0</name></expr>:</case>
<expr_stmt><expr><call><name>dump_gnu_property_type_0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>NT_GNU_BUILD_ID</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Build ID: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"Xen"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>nd</name> <operator>=</operator> <name>xen_notes</name></expr>;</init> <condition><expr><name><name>nd</name><operator>-&gt;</operator><name>description</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>nd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nd</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>nd</name><operator>-&gt;</operator><name>fp</name></name><argument_list>(<argument><expr><name><name>nd</name><operator>-&gt;</operator><name>description</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<label><name>unknown</name>:</label>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" description data:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_notes_content</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Note</name> <modifier>*</modifier></type><name>note</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>namesz</name></decl>, <decl><type ref="prev"/><name>descsz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nNotes at offset %#010jx with length %#010jx:\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-13s %-15s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Owner"</literal></expr></argument>, <argument><expr><literal type="string">"Data size"</literal></expr></argument>, <argument><expr><literal type="string">"Description"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>note</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid note header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>note</name> <operator>=</operator> <operator>(</operator><name>Elf_Note</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namesz</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>descsz</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>&lt;</operator> <name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name> <operator>||</operator> <name><name>descsz</name> <argument_list type="generic">&lt; <argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_descsz</name></name> <operator>||</operator>
<name>buf</name> <operator>+</operator> <name>namesz</name> <operator>+</operator> <name>descsz</name></expr></argument> &gt;</argument_list></name> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid note header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Note</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>namesz</name></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"CORE"</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strnlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>note</name><operator>-&gt;</operator><name>n_namesz</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"&lt;invalid&gt;"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-13s %#010jx"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>note</name><operator>-&gt;</operator><name>n_descsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><call><name>note_type</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></argument>,
<argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_notes_data</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>note</name><operator>-&gt;</operator><name>n_descsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>descsz</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Elf_Verdef</name></cpp:macro> <cpp:value>Elf32_Verdef</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Elf_Verdaux</name></cpp:macro> <cpp:value>Elf32_Verdaux</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Elf_Verneed</name></cpp:macro> <cpp:value>Elf32_Verneed</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Elf_Vernaux</name></cpp:macro> <cpp:value>Elf32_Vernaux</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAVE_VERSION_NAME</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>n</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { while (x &gt;= re-&gt;ver_sz) { nv = realloc(re-&gt;ver, sizeof(*re-&gt;ver) * re-&gt;ver_sz * 2); if (nv == NULL) { warn("realloc failed"); free(re-&gt;ver); return; } re-&gt;ver = nv; for (i = re-&gt;ver_sz; i &lt; re-&gt;ver_sz * 2; i++) { re-&gt;ver[i].name = NULL; re-&gt;ver[i].type = 0; } re-&gt;ver_sz *= 2; } if (x &gt; 1) { re-&gt;ver[x].name = n; re-&gt;ver[x].type = t; } } while (0)</cpp:value></cpp:define>























<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_verdef</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>symver</name></name> <modifier>*</modifier></type><name>nv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Verdef</name> <modifier>*</modifier></type><name>vd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Verdaux</name> <modifier>*</modifier></type><name>vda</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>vd_s</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>re</name><operator>-&gt;</operator><name>ver</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator>
<name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"*local*"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"*global*"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nVersion definition section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Verdef</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vd</name> <operator>=</operator> <operator>(</operator><name>Elf_Verdef</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%4.4lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator>
<operator>(</operator><name>buf</name> <operator>-</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" vd_version: %u vd_flags: %d"</literal>
<literal type="string">" vd_ndx: %u vd_cnt: %u"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_version</name></name></expr></argument>,
<argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_flags</name></name></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_ndx</name></name></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_aux</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf2</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Verdaux</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vda</name> <operator>=</operator> <operator>(</operator><name>Elf_Verdaux</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_string</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vda</name><operator>-&gt;</operator><name>vda_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" vda_name: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SAVE_VERSION_NAME</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>vd</name><operator>-&gt;</operator><name>vd_ndx</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%4.4lx parent: %s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><name>buf2</name> <operator>-</operator>
<operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vda</name><operator>-&gt;</operator><name>vda_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>vda</name><operator>-&gt;</operator><name>vda_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_verneed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dump</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>symver</name></name> <modifier>*</modifier></type><name>nv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Verneed</name> <modifier>*</modifier></type><name>vn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Vernaux</name> <modifier>*</modifier></type><name>vna</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>vn_s</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>re</name><operator>-&gt;</operator><name>ver</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator>
<name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"*local*"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"*global*"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nVersion needed section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Verneed</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vn</name> <operator>=</operator> <operator>(</operator><name>Elf_Verneed</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%4.4lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator>
<operator>(</operator><name>buf</name> <operator>-</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" vn_version: %u vn_file: %s vn_cnt: %u\n"</literal></expr></argument>,
<argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_version</name></name></expr></argument>,
<argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_file</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_aux</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf2</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Vernaux</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vna</name> <operator>=</operator> <operator>(</operator><name>Elf32_Vernaux</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf2</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%4.4lx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator>
<operator>(</operator><name>buf2</name> <operator>-</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_string</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dump</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" vna_name: %s vna_flags: %u"</literal>
<literal type="string">" vna_other: %u\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_flags</name></name></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_other</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SAVE_VERSION_NAME</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>vna</name><operator>-&gt;</operator><name>vna_other</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vna</name><operator>-&gt;</operator><name>vna_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>vna</name><operator>-&gt;</operator><name>vna_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>vn</name><operator>-&gt;</operator><name>vn_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_versym</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>vs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>vs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nVersion symbol section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>vs_sz</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %03x:"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vs</name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>VERSYM_VERSION</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vs</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name>vs</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid versym version index %u"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>VERSYM_HIDDEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %3xh %-12s "</literal></expr></argument>, <argument><expr><name>vs</name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>VERSYM_VERSION</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %3x %-12s "</literal></expr></argument>, <argument><expr><name>vs</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name><index>[<expr><name><name>re</name><operator>-&gt;</operator><name>vs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_ver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name></name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>vs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_versym</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vd_s</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_verdef</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vn_s</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_verneed</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>search_ver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_versym</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_verneed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vn_s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_verdef</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vd_s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vd_s</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_verdef</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vn_s</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_verneed</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name></name> <operator>&amp;&amp;</operator> <name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs_sz</name></name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Half</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Elf_Verdef</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Elf_Verdaux</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Elf_Verneed</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Elf_Vernaux</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SAVE_VERSION_NAME</name></cpp:undef>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Elf_Lib</name></cpp:macro> <cpp:value>Elf32_Lib</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_liblist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>ti</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tbuf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Lib</name> <modifier>*</modifier></type><name>lib</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>first</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_GNU_LIBLIST</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lib</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nLibrary list section '%s' "</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"contains %d entries:\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%12s%24s%18s%10s%6s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Library"</literal></expr></argument>, <argument><expr><literal type="string">"Time Stamp"</literal></expr></argument>,
<argument><expr><literal type="string">"Checksum"</literal></expr></argument>, <argument><expr><literal type="string">"Version"</literal></expr></argument>, <argument><expr><literal type="string">"Flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%3d: "</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-20.20s "</literal></expr></argument>,
<argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>lib</name><operator>-&gt;</operator><name>l_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ti</name> <operator>=</operator> <name><name>lib</name><operator>-&gt;</operator><name>l_time_stamp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%04d-%02d-%02dT%02d:%02d"</literal>
<literal type="string">":%2d"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1900</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-19.19s "</literal></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%08x "</literal></expr></argument>, <argument><expr><name><name>lib</name><operator>-&gt;</operator><name>l_checksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-7d %#x"</literal></expr></argument>, <argument><expr><name><name>lib</name><operator>-&gt;</operator><name>l_version</name></name></expr></argument>, <argument><expr><name><name>lib</name><operator>-&gt;</operator><name>l_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lib</name><operator>-&gt;</operator><name>l_flags</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>l_flag</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>l_flag</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>&amp;</operator> <name><name>lib</name><operator>-&gt;</operator><name>l_flags</name></name><operator>)</operator> <operator>==</operator>
<literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>l_flag</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lib</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Elf_Lib</name></cpp:undef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_section_groups</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_GROUP</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GRP_COMDAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRP_COMDAT</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>w</name><operator>++</operator> <operator>&amp;</operator> <name>GRP_COMDAT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>symname</name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name><operator>--</operator> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nCOMDAT group section [%5d] `%s' [%s] contains %ju"</literal>
<literal type="string">" sections:\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>symname</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"[Index]"</literal></expr></argument>, <argument><expr><literal type="string">"Name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>w</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>w</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid section index: %u"</literal></expr></argument>, <argument><expr><operator>*</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%5u] %s\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>w</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><operator>*</operator><name>w</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type>
<name>dump_unknown_tag</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>val</name></decl>;</decl_stmt>








<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tag_unknown_%ju: "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name> <modifier>*</modifier></type>
<name>dump_compatibility_tag</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"flag = %ju, vendor = %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>val</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_arm_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name></decl>, <decl><type ref="prev"/><name>desc</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>re</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>desc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>aeabi_tags</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>aeabi_tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name><name>aeabi_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s: "</literal></expr></argument>, <argument><expr><name><name>aeabi_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>s_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aeabi_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>get_desc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>,
<argument><expr><name><name>aeabi_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get_desc</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>&lt;</operator> <name><name>aeabi_tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_unknown_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>desc</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<case>case <expr><literal type="number">5</literal></expr>:</case>
<case>case <expr><literal type="number">67</literal></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_compatibility_tag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">64</literal></expr>:</case>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"True\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">65</literal></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unknown\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>aeabi_cpu_arch</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>Tag_GNU_MIPS_ABI_FP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tag_GNU_MIPS_ABI_FP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>re</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Tag_GNU_MIPS_ABI_FP</name></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tag_GNU_MIPS_ABI_FP: %s\n"</literal></expr></argument>, <argument><expr><call><name>mips_abi_fp</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_compatibility_tag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_unknown_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>Tag_GNU_Power_ABI_FP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tag_GNU_Power_ABI_FP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>Tag_GNU_Power_ABI_Vector</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Tag_GNU_Power_ABI_Vector</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_ppc_attributes</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Tag_GNU_Power_ABI_FP</name></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tag_GNU_Power_ABI_FP: %s\n"</literal></expr></argument>, <argument><expr><call><name>ppc_abi_fp</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Tag_GNU_Power_ABI_Vector</name></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tag_GNU_Power_ABI_Vector: %s\n"</literal></expr></argument>,
<argument><expr><call><name>ppc_abi_vector</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">32</literal></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_compatibility_tag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>dump_unknown_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_attributes</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pe</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>seclen</name></decl>, <decl><type ref="prev"/><name>nlen</name></decl>, <decl><type ref="prev"/><name>sublen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_GNU_ATTRIBUTES</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>!=</operator> <name>EM_ARM</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_LOPROC</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pe</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'A'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unknown Attribute Section Format: %c\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"truncated attribute section length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>seclen</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>seclen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid attribute section length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>seclen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlen</name> <operator>+</operator> <literal type="number">4</literal> <operator>&gt;</operator> <name>seclen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid attribute section name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Attribute Section: %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>seclen</name> <operator>-=</operator> <name>nlen</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>seclen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sublen</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sublen</name> <operator>&gt;</operator> <name>seclen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid attribute sub-section"</literal>
<literal type="string">" length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>seclen</name> <operator>-=</operator> <name>sublen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>top_tag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>tag</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %ju"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ARM</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_LOPROC</name> <operator>+</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_arm_attributes</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <name>sublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name> <operator>||</operator>
<name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS_RS3_LE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_mips_attributes</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>sp</name> <operator>+</operator> <name>sublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_PPC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_ppc_attributes</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sp</name> <operator>+</operator> <name>sublen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>sp</name> <operator>+</operator> <name>sublen</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></while>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_specific_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".MIPS.options"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_MIPS_OPTIONS</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dump_mips_options</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".MIPS.abiflags"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_MIPS_ABIFLAGS</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_mips_abiflags</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".reginfo"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_MIPS_REGINFO</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_mips_reginfo</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_abiflags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>isa_ext</name></decl>, <decl><type ref="prev"/><name>ases</name></decl>, <decl><type ref="prev"/><name>flags1</name></decl>, <decl><type ref="prev"/><name>flags2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>isa_level</name></decl>, <decl><type ref="prev"/><name>isa_rev</name></decl>, <decl><type ref="prev"/><name>gpr_size</name></decl>, <decl><type ref="prev"/><name>cpr1_size</name></decl>, <decl><type ref="prev"/><name>cpr2_size</name></decl>, <decl><type ref="prev"/><name>fp_abi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator> <literal type="number">24</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid MIPS abiflags section size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"MIPS ABI Flags Version: %u"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>version</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (unknown)\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isa_level</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>isa_rev</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>gpr_size</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cpr1_size</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cpr2_size</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fp_abi</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>isa_ext</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ases</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags1</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags2</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ISA: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isa_rev</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"MIPS%u\n"</literal></expr></argument>, <argument><expr><name>isa_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"MIPS%ur%u\n"</literal></expr></argument>, <argument><expr><name>isa_level</name></expr></argument>, <argument><expr><name>isa_rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"GPR size: %d\n"</literal></expr></argument>, <argument><expr><call><name>get_mips_register_size</name><argument_list>(<argument><expr><name>gpr_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"CPR1 size: %d\n"</literal></expr></argument>, <argument><expr><call><name>get_mips_register_size</name><argument_list>(<argument><expr><name>cpr1_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"CPR2 size: %d\n"</literal></expr></argument>, <argument><expr><call><name>get_mips_register_size</name><argument_list>(<argument><expr><name>cpr2_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FP ABI: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>fp_abi</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Soft float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>fp_abi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nISA Extension: %u\n"</literal></expr></argument>, <argument><expr><name>isa_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ASEs: %u\n"</literal></expr></argument>, <argument><expr><name>ases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FLAGS 1: %08x\n"</literal></expr></argument>, <argument><expr><name>flags1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FLAGS 2: %08x\n"</literal></expr></argument>, <argument><expr><name>flags2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_mips_register_size</name><parameter_list>(<parameter><decl><type><name>uint8_t</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="number">32</literal></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="number">64</literal></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="number">128</literal></expr>;</return>
<default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_reginfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection '%s' contains %d entries:\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_mips_odk_reginfo</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>sndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>kind</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection %s contains:\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pe</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pe</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Truncated MIPS option header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sndx</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal> <operator>||</operator> <name>size</name> <operator>-</operator> <literal type="number">8</literal></expr></argument> &gt;</argument_list></name> <name>pe</name> <operator>-</operator> <name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed MIPS option header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ODK_REGINFO</name></expr>:</case>
<expr_stmt><expr><call><name>dump_mips_odk_reginfo</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_EXCEPTIONS</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" EXCEPTIONS FPU_MIN: %#x\n"</literal></expr></argument>,
<argument><expr><name>info</name> <operator>&amp;</operator> <name>OEX_FPU_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%11.11s FPU_MAX: %#x\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><name>info</name> <operator>&amp;</operator> <name>OEX_FPU_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_mips_option_flags</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>mips_exceptions_option</name></expr></argument>,
<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_PAD</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s section: %ju\n"</literal></expr></argument>, <argument><expr><literal type="string">"OPAD"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>sndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_mips_option_flags</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>mips_pad_option</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_HWPATCH</name></expr>:</case>
<expr_stmt><expr><call><name>dump_mips_option_flags</name><argument_list>(<argument><expr><literal type="string">"HWPATCH"</literal></expr></argument>, <argument><expr><name>mips_hwpatch_option</name></expr></argument>,
<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_HWAND</name></expr>:</case>
<expr_stmt><expr><call><name>dump_mips_option_flags</name><argument_list>(<argument><expr><literal type="string">"HWAND"</literal></expr></argument>, <argument><expr><name>mips_hwa_option</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_HWOR</name></expr>:</case>
<expr_stmt><expr><call><name>dump_mips_option_flags</name><argument_list>(<argument><expr><literal type="string">"HWOR"</literal></expr></argument>, <argument><expr><name>mips_hwo_option</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_FILL</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s %#jx\n"</literal></expr></argument>, <argument><expr><literal type="string">"FILL"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_TAGS</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s\n"</literal></expr></argument>, <argument><expr><literal type="string">"TAGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ODK_GP_GROUP</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s GP group number: %#x\n"</literal></expr></argument>, <argument><expr><literal type="string">"GP_GROUP"</literal></expr></argument>,
<argument><expr><name>info</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>info</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s GP group is "</literal>
<literal type="string">"self-contained\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ODK_IDENT</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s default GP group number: %#x\n"</literal></expr></argument>,
<argument><expr><literal type="string">"IDENT"</literal></expr></argument>, <argument><expr><name>info</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>info</name> <operator>&amp;</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s default GP group is "</literal>
<literal type="string">"self-contained\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ODK_PAGESIZE</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s\n"</literal></expr></argument>, <argument><expr><literal type="string">"PAGESIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_option_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>mips_option</name></name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>;</decl_stmt>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>opt</name><operator>-&gt;</operator><name>desc</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>opt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>info</name> <operator>&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>flag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-10.10s %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><name>name</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_mips_odk_reginfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ri_gprmask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>ri_cprmask</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ri_gp_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pe</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ri_gprmask</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS64</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ri_cprmask</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ri_gp_value</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ri_gp_value</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><call><name>option_kind</name><argument_list>(<argument><expr><name>ODK_REGINFO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ri_gprmask: 0x%08jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ri_gprmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%11.11s ri_cprmask[%d]: 0x%08jx\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>ri_cprmask</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%12.12s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ri_gp_value: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>ri_gp_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_arch_specific_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>dump_liblist</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_attributes</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>
<expr_stmt><expr><call><name>dump_mips_specific_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dwarf_regname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>rx</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rn</name> <operator>=</operator> <call><name>dwarf_reg</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rn</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"r%u"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>rx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_line</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>version</name></decl>, <decl><type ref="prev"/><name>pointer_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>endoff</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>hdrlen</name></decl>, <decl><type ref="prev"/><name>dirndx</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>, <decl><type ref="prev"/><name>fsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Small</name></type> <name>minlen</name></decl>, <decl><type ref="prev"/><name>defstmt</name></decl>, <decl><type ref="prev"/><name>lrange</name></decl>, <decl><type ref="prev"/><name>opbase</name></decl>, <decl><type ref="prev"/><name>oplen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>address</name></decl>, <decl><type ref="prev"/><name>file</name></decl>, <decl><type ref="prev"/><name>line</name></decl>, <decl><type ref="prev"/><name>column</name></decl>, <decl><type ref="prev"/><name>isa</name></decl>, <decl><type ref="prev"/><name>opsize</name></decl>, <decl><type ref="prev"/><name>udelta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>sdelta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int8_t</name></type> <name>lbase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>is_stmt</name></decl>, <decl><type ref="prev"/><name>dwarf_size</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nDump of debug contents of section .debug_line:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_line"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_compile_unit</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>die</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"could not find DW_TAG_compile_unit die"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_stmt_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>-</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid .dwarf_line section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>endoff</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pe</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name>endoff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdrlen</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>dwarf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>minlen</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>defstmt</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lbase</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lrange</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opbase</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length:\t\t\t%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" DWARF version:\t\t%u\n"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Prologue Length:\t\t%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>hdrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Minimum Instruction Length:\t%u\n"</literal></expr></argument>, <argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Initial value of 'is_stmt':\t%u\n"</literal></expr></argument>, <argument><expr><name>defstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Line Base:\t\t\t%d\n"</literal></expr></argument>, <argument><expr><name>lbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Line Range:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>lrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Opcode Base:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>opbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dwarf_get_address_size</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pointer_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (Pointer size:\t\t%u)\n"</literal></expr></argument>, <argument><expr><name>pointer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Opcodes:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>opbase</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>oplen</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Opcode %d has %u args\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" The Directory Table:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" The File Name Table:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Entry\tDir\tTime\tSize\tName\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>pn</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dirndx</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mtime</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fsize</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d\t%ju\t%ju\t%ju\t%s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>dirndx</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>mtime</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fsize</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET_REGISTERS</name></cpp:macro> <cpp:value>do { address = 0; file = 1; line = 1; column = 0; is_stmt = defstmt; } while(0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(lbase + (((x) - opbase) % lrange))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRESS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((x) - opbase) / lrange) * minlen)</cpp:value></cpp:define>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Line Number Statements:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>RESET_REGISTERS</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pe</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>opsize</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Extended opcode %u: "</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_LNE_end_sequence</name></expr>:</case>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>RESET_REGISTERS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"End of Sequence\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNE_set_address</name></expr>:</case>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>address</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,
<argument><expr><name>pointer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"set Address to %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNE_define_file</name></expr>:</case>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>pn</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dirndx</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mtime</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fsize</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"define new file: %s\n"</literal></expr></argument>, <argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>opsize</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unknown opcode\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;</operator> <name>opbase</name></expr>)</condition> <block>{<block_content>



<switch>switch<condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_LNS_copy</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Copy\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_advance_pc</name></expr>:</case>
<expr_stmt><expr><name>udelta</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call> <operator>*</operator>
<name>minlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <name>udelta</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Advance PC by %ju to %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>udelta</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_advance_line</name></expr>:</case>
<expr_stmt><expr><name>sdelta</name> <operator>=</operator> <call><name>_decode_sleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>+=</operator> <name>sdelta</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Advance Line by %jd to %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>sdelta</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_file</name></expr>:</case>
<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set File to %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_column</name></expr>:</case>
<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set Column to %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_negate_stmt</name></expr>:</case>
<expr_stmt><expr><name>is_stmt</name> <operator>=</operator> <operator>!</operator><name>is_stmt</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set is_stmt to %d\n"</literal></expr></argument>, <argument><expr><name>is_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_basic_block</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set basic block flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_const_add_pc</name></expr>:</case>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <call><name>ADDRESS</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Advance PC by constant %ju"</literal>
<literal type="string">" to %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <call><name>ADDRESS</name><argument_list>(<argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_fixed_advance_pc</name></expr>:</case>
<expr_stmt><expr><name>udelta</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <name>udelta</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Advance PC by fixed value "</literal>
<literal type="string">"%ju to %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>udelta</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_prologue_end</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set prologue end flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_epilogue_begin</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set epilogue begin flag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_LNS_set_isa</name></expr>:</case>
<expr_stmt><expr><name>isa</name> <operator>=</operator> <call><name>_decode_uleb128</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Set isa to %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>isa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Unknown extended opcode %u\n"</literal></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>line</name> <operator>+=</operator> <call><name>LINE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>address</name> <operator>+=</operator> <call><name>ADDRESS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Special opcode %u: advance Address "</literal>
<literal type="string">"by %ju to %#jx and Line by %jd to %ju\n"</literal></expr></argument>,
<argument><expr><operator>*</operator><name>p</name> <operator>-</operator> <name>opbase</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <call><name>ADDRESS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>address</name></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <call><name>LINE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


</block_content>}</block></while>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_next_cu_header: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RESET_REGISTERS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LINE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ADDRESS</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_line_decoded</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Line</name> <modifier>*</modifier></type><name>linebuf</name></decl>, <decl><type ref="prev"/><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>lineaddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>linecount</name></decl>, <decl><type ref="prev"/><name>srccount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>lineno</name></decl>, <decl><type ref="prev"/><name>fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcfiles</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Decoded dump of debug contents of section .debug_line:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_string</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_string</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_comp_dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"CU: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>&amp;&amp;</operator> <name>file</name> <operator>&amp;&amp;</operator> <name><name>file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s %11s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Filename"</literal></expr></argument>, <argument><expr><literal type="string">"Line Number"</literal></expr></argument>,
<argument><expr><literal type="string">"Starting Address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_srclines</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>linebuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>linecount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_srcfiles</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcfiles</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srccount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>linecount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>linebuf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_line_srcfileno</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_lineno</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_lineaddr</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-37s %11ju %#18jx\n"</literal></expr></argument>,
<argument><expr><call><name>basename</name><argument_list>(<argument><expr><name><name>srcfiles</name><index>[<expr><name>fn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>lineno</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>lineaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_die</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Attribute</name> <modifier>*</modifier></type><name>attr_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>ret_die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>dieoff</name></decl>, <decl><type ref="prev"/><name>cuoff</name></decl>, <decl><type ref="prev"/><name>culen</name></decl>, <decl><type ref="prev"/><name>attroff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>ate</name></decl>, <decl><type ref="prev"/><name>lang</name></decl>, <decl><type ref="prev"/><name>v_udata</name></decl>, <decl><type ref="prev"/><name>v_sig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>attr_count</name></decl>, <decl><type ref="prev"/><name>v_sdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>v_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>v_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>attr</name></decl>, <decl><type ref="prev"/><name>form</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Block</name> <modifier>*</modifier></type><name>v_block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Bool</name></type> <name>v_bool</name></decl>, <decl><type ref="prev"/><name>is_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Sig8</name></type> <name>v_sig8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Ptr</name></type> <name>v_expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>attr_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ate_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lang_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>unk_tag</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>unk_attr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>abc</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_dieoffset</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dieoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_dieoffset failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" &lt;%d&gt;&lt;%jx&gt;: "</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>dieoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_die_CU_offset_range</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cuoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>culen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_die_CU_offset_range failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cuoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>abc</name> <operator>=</operator> <call><name>dwarf_die_abbrev_code</name><argument_list>(<argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_TAG_name</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_tag</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[Unknown Tag: %#x]"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tag_str</name> <operator>=</operator> <name>unk_tag</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Abbrev Number: %d (%s)\n"</literal></expr></argument>, <argument><expr><name>abc</name></expr></argument>, <argument><expr><name>tag_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_attrlist</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_attrlist failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_whatform</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_whatform failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_whatattr</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_whatattr failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_AT_name</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_attr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_attr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown AT: %#x]"</literal></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr_str</name> <operator>=</operator> <name>unk_attr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attroffset</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attroff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_attroffset failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attroff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" &lt;%jx&gt; %-18s: "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>attroff</name></expr></argument>, <argument><expr><name>attr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>form</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_FORM_ref_addr</name></expr>:</case>
<case>case <expr><name>DW_FORM_sec_offset</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_global_formref</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_global_formref failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>form</name> <operator>==</operator> <name>DW_FORM_ref_addr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"&lt;0x%jx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_ref1</name></expr>:</case>
<case>case <expr><name>DW_FORM_ref2</name></expr>:</case>
<case>case <expr><name>DW_FORM_ref4</name></expr>:</case>
<case>case <expr><name>DW_FORM_ref8</name></expr>:</case>
<case>case <expr><name>DW_FORM_ref_udata</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formref</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formref failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>v_off</name> <operator>+=</operator> <name>cuoff</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"&lt;0x%jx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_addr</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formaddr</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formaddr failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%#jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_data1</name></expr>:</case>
<case>case <expr><name>DW_FORM_data2</name></expr>:</case>
<case>case <expr><name>DW_FORM_data4</name></expr>:</case>
<case>case <expr><name>DW_FORM_data8</name></expr>:</case>
<case>case <expr><name>DW_FORM_udata</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formudata</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formudata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name>DW_AT_high_pc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"0x%jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%ju"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_sdata</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formsdata</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_sdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formudata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>v_sdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_flag</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formflag</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_bool</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formflag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>v_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_flag_present</name></expr>:</case>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_string</name></expr>:</case>
<case>case <expr><name>DW_FORM_strp</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formstring</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formstring failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>form</name> <operator>==</operator> <name>DW_FORM_string</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>v_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(indirect string) %s"</literal></expr></argument>, <argument><expr><name>v_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_block</name></expr>:</case>
<case>case <expr><name>DW_FORM_block1</name></expr>:</case>
<case>case <expr><name>DW_FORM_block2</name></expr>:</case>
<case>case <expr><name>DW_FORM_block4</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formblock</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formblock failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%ju byte block:"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>v_block</name><operator>-&gt;</operator><name>bl_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>v_block</name><operator>-&gt;</operator><name>bl_data</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Unsigned</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name><name>v_block</name><operator>-&gt;</operator><name>bl_len</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %x"</literal></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_block</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>v_block</name><operator>-&gt;</operator><name>bl_data</name></name></expr></argument>, <argument><expr><name><name>v_block</name><operator>-&gt;</operator><name>bl_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_exprloc</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formexprloc</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_expr</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formexprloc failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%ju byte block:"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>v_expr</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Unsigned</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name>v_udata</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %x"</literal></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_block</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>v_expr</name></expr></argument>, <argument><expr><name>v_udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_FORM_ref_sig8</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formsig8</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v_sig8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formsig8 failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <operator>&amp;</operator><name><name>v_sig8</name><operator>.</operator><name>signature</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v_sig</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"signature: 0x%jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>v_sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><name>attr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_AT_encoding</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_ATE_name</name><argument_list>(<argument><expr><name>ate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ate_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ate_str</name> <operator>=</operator> <literal type="string">"DW_ATE_UNKNOWN"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(%s)"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ate_str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"DW_ATE_"</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_AT_language</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lang</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_LANG_name</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lang_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(%s)"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lang_str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"DW_LANG_"</literal></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_AT_location</name></expr>:</case>
<case>case <expr><name>DW_AT_string_length</name></expr>:</case>
<case>case <expr><name>DW_AT_return_addr</name></expr>:</case>
<case>case <expr><name>DW_AT_data_member_location</name></expr>:</case>
<case>case <expr><name>DW_AT_frame_base</name></expr>:</case>
<case>case <expr><name>DW_AT_segment</name></expr>:</case>
<case>case <expr><name>DW_AT_static_link</name></expr>:</case>
<case>case <expr><name>DW_AT_use_location</name></expr>:</case>
<case>case <expr><name>DW_AT_vtable_elem_location</name></expr>:</case>
<switch>switch <condition>(<expr><name>form</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_FORM_data4</name></expr>:</case>
<case>case <expr><name>DW_FORM_data8</name></expr>:</case>
<case>case <expr><name>DW_FORM_sec_offset</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(location list)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<label><name>cont_search</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_child</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_child: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_die</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>is_info</name> <operator>=</operator> <call><name>dwarf_get_die_infotypes_flag</name><argument_list>(<argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_siblingof_b</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><name>is_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_siblingof: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_die</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_DLA_DIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_cu_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>psize</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>osize</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Half</name></type> <name>ver</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>cu_psize</name></name> <operator>=</operator> <name>psize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>cu_osize</name></name> <operator>=</operator> <name>osize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>cu_ver</name></name> <operator>=</operator> <name>ver</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_info</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Bool</name></type> <name>is_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>version</name></decl>, <decl><type ref="prev"/><name>pointer_size</name></decl>, <decl><type ref="prev"/><name>off_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>cu_offset</name></decl>, <decl><type ref="prev"/><name>cu_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>aboff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>typeoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Sig8</name></type> <name>sig8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>sig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sn</name> <operator>=</operator> <ternary><condition><expr><name>is_info</name></expr> ?</condition><then> <expr><literal type="string">".debug_info"</literal></expr> </then><else>: <expr><literal type="string">".debug_types"</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nDump of debug contents of section %s:\n"</literal></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header_c</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>is_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aboff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pointer_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig8</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>typeoff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_cu_context</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>pointer_size</name></expr></argument>, <argument><expr><name>off_size</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dwarf_siblingof_b</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><name>is_info</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_info</name> <operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <name>DW_TAG_compile_unit</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>is_info</name> <operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <name>DW_TAG_type_unit</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>die</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>is_info</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"could not find DW_TAG_compile_unit "</literal>
<literal type="string">"die"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>die</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_info</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"could not find DW_TAG_type_unit die"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_die_CU_offset_range</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cu_offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cu_length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_die_CU_offset failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cu_length</name> <operator>-=</operator> <ternary><condition><expr><name>off_size</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">12</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>sig</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_info</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <operator>&amp;</operator><name><name>sig8</name><operator>.</operator><name>signature</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n Type Unit @ offset 0x%jx:\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cu_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length:\t\t%#jx (%d-bit)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cu_length</name></expr></argument>, <argument><expr><ternary><condition><expr><name>off_size</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">32</literal></expr> </then><else>: <expr><literal type="number">64</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Version:\t\t%u\n"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Abbrev Offset:\t0x%jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>aboff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Pointer Size:\t%u\n"</literal></expr></argument>, <argument><expr><name>pointer_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_info</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Signature:\t\t0x%016jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Type Offset:\t0x%jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>typeoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dump_dwarf_die</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_next_cu_header: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_info</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>dwarf_next_types_section</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_abbrev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Abbrev</name></type> <name>ab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>aboff</name></decl>, <decl><type ref="prev"/><name>atoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>attr_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>flag</name></decl>, <decl><type ref="prev"/><name>form</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>attr_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>form_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>unk_tag</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>unk_attr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>unk_form</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of section .debug_abbrev:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aboff</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Number TAG\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_get_abbrev</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>aboff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>attr_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>ab</name></expr></argument>, <argument><expr><name>DW_DLA_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>aboff</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%4d"</literal></expr></argument>, <argument><expr><operator>++</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_abbrev_tag</name><argument_list>(<argument><expr><name>ab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_abbrev_tag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_abbrev</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_TAG_name</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_tag</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_tag</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown Tag: %#x]"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tag_str</name> <operator>=</operator> <name>unk_tag</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_abbrev_children_flag</name><argument_list>(<argument><expr><name>ab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_abbrev_children_flag failed:"</literal>
<literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_abbrev</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s %s\n"</literal></expr></argument>, <argument><expr><name>tag_str</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>flag</name></expr> ?</condition><then> <expr><literal type="string">"[has children]"</literal></expr> </then><else>: <expr><literal type="string">"[no children]"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Unsigned</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_abbrev_entry</name><argument_list>(<argument><expr><name>ab</name></expr></argument>, <argument><expr><operator>(</operator><name>Dwarf_Signed</name><operator>)</operator> <name>j</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atoff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_abbrev_entry failed:"</literal>
<literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_AT_name</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_str</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_attr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_attr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown AT: %#x]"</literal></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr_str</name> <operator>=</operator> <name>unk_attr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_FORM_name</name><argument_list>(<argument><expr><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form_str</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_form</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_form</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown Form: %#x]"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>Dwarf_Half</name><operator>)</operator> <name>form</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>form_str</name> <operator>=</operator> <name>unk_form</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-18s %s\n"</literal></expr></argument>, <argument><expr><name>attr_str</name></expr></argument>, <argument><expr><name>form_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<label><name>next_abbrev</name>:</label>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>ab</name></expr></argument>, <argument><expr><name>DW_DLA_ABBREV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_abbrev: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_next_cu_header: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_pubnames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>die_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>nt_cu_offset</name></decl>, <decl><type ref="prev"/><name>nt_cu_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Global</name> <modifier>*</modifier></type><name>globs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>nt_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>glob_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>dwarf_size</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of the .debug_pubnames section:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_pubnames"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>-</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid .dwarf_pubnames section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nt_version</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nt_cu_offset</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>dwarf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nt_cu_length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>dwarf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length:\t\t\t\t%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Version:\t\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>nt_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Offset into .debug_info section:\t%ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>nt_cu_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Size of area in .debug_info section:\t%ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>nt_cu_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_globals</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>globs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_globals failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n Offset Name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_globname</name><argument_list>(<argument><expr><name><name>globs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>glob_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_globname failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_global_die_offset</name><argument_list>(<argument><expr><name><name>globs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die_off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_global_die_offset failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-11ju %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>die_off</name></expr></argument>, <argument><expr><name>glob_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_aranges</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Arange</name> <modifier>*</modifier></type><name>aranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>length</name></decl>, <decl><type ref="prev"/><name>as_cu_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>die_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>as_version</name></decl>, <decl><type ref="prev"/><name>as_addrsz</name></decl>, <decl><type ref="prev"/><name>as_segsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>dwarf_size</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of section .debug_aranges:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_aranges"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dwarf_size</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>-</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid .dwarf_aranges section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>as_version</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>as_cu_offset</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>dwarf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>as_addrsz</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>as_segsz</name> <operator>=</operator> <call><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Length:\t\t\t%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Version:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>as_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Offset into .debug_info:\t%ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>as_cu_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Pointer Size:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>as_addrsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Segment Size:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>as_segsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_aranges</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aranges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_aranges failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n Address Length\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_arange_info</name><argument_list>(<argument><expr><name><name>aranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>die_off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_arange_info failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %08jx %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>start</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_ranges_foreach</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Addr</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Attribute</name> <modifier>*</modifier></type><name>attr_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Ranges</name> <modifier>*</modifier></type><name>ranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>ret_die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>base0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>attr_count</name></decl>, <decl><type ref="prev"/><name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>bytecnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_attrlist</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_attrlist failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_whatattr</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_whatattr failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>DW_AT_ranges</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formudata</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formudata failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_ranges</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Dwarf_Off</name><operator>)</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ranges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>bytecnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>base0</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %08jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_type</name> <operator>==</operator> <name>DW_RANGES_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><literal type="string">"&lt;End of list&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_type</name> <operator>==</operator>
<name>DW_RANGES_ADDRESS_SELECTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base0</name> <operator>=</operator> <name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_addr2</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08jx %08jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_addr1</name> <operator>+</operator> <name>base0</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_addr2</name> <operator>+</operator> <name>base0</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016jx %016jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_addr1</name> <operator>+</operator> <name>base0</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>ranges</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dwr_addr2</name> <operator>+</operator> <name>base0</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<label><name>cont_search</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_child</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_child: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_ranges_foreach</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_siblingof: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_ranges_foreach</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_ranges</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Ranges</name> <modifier>*</modifier></type><name>ranges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>bytecnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>lowpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_ranges</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ranges</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytecnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Contents of the .debug_ranges section:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-8s %-8s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Offset"</literal></expr></argument>, <argument><expr><literal type="string">"Begin"</literal></expr></argument>, <argument><expr><literal type="string">"End"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-8s %-16s %s\n"</literal></expr></argument>, <argument><expr><literal type="string">"Offset"</literal></expr></argument>, <argument><expr><literal type="string">"Begin"</literal></expr></argument>, <argument><expr><literal type="string">"End"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_compile_unit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_low_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lowpc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dump_dwarf_ranges_foreach</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>(</operator><name>Dwarf_Addr</name><operator>)</operator> <name>lowpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_macinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Macro_Details</name> <modifier>*</modifier></type><name>md</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mi_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>unk_mi</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_MAX_MACINFO_ENTRY</name></cpp:macro> <cpp:value>65535</cpp:value></cpp:define>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of section .debug_macinfo:\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dwarf_get_macro_details</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>_MAX_MACINFO_ENTRY</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>md</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_MACINFO_name</name><argument_list>(<argument><expr><name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mi_str</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_mi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_mi</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown MACINFO: %#x]"</literal></expr></argument>, <argument><expr><name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mi_str</name> <operator>=</operator> <name>unk_mi</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>mi_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_MACINFO_define</name></expr>:</case>
<case>case <expr><name>DW_MACINFO_undef</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - lineno : %jd macro : %s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_lineno</name></expr></argument>,
<argument><expr><name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_macro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_MACINFO_start_file</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" - lineno : %jd filenum : %jd\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_lineno</name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>md</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dmd_fileindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></while>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_MAX_MACINFO_ENTRY</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_frame_inst</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Cie</name></type> <name>cie</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>insts</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>caf</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Signed</name></type> <name>daf</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Addr</name></type> <name>pc</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Frame_Op</name> <modifier>*</modifier></type><name>oplist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>opcnt</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Small</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>unk_op</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_expand_frame_instructions</name><argument_list>(<argument><expr><name>cie</name></expr></argument>, <argument><expr><name>insts</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oplist</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>opcnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_expand_frame_instructions failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>opcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_base_op</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_base_op</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_extended_op</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_CFA_name</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_op</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_op</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[Unknown CFA: %#x]"</literal></expr></argument>,
<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>op_str</name> <operator>=</operator> <name>unk_op</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>op_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_CFA_advance_loc</name></expr>:</case>
<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name> <operator>*</operator> <name>caf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pc</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju to %08jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>delta</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_offset</name></expr>:</case>
<case>case <expr><name>DW_CFA_offset_extended</name></expr>:</case>
<case>case <expr><name>DW_CFA_offset_extended_sf</name></expr>:</case>
<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name> <operator>*</operator> <name>daf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": r%u (%s) at cfa%+jd"</literal></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_restore</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": r%u (%s)"</literal></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_set_loc</name></expr>:</case>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": to %08jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_advance_loc1</name></expr>:</case>
<case>case <expr><name>DW_CFA_advance_loc2</name></expr>:</case>
<case>case <expr><name>DW_CFA_advance_loc4</name></expr>:</case>
<expr_stmt><expr><name>pc</name> <operator>+=</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %jd to %08jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_def_cfa</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": r%u (%s) ofs %ju"</literal></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_def_cfa_sf</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": r%u (%s) ofs %jd"</literal></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <operator>(</operator><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name> <operator>*</operator> <name>daf</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_def_cfa_register</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": r%u (%s)"</literal></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_register</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_def_cfa_offset</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DW_CFA_def_cfa_offset_sf</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <operator>(</operator><name><name>oplist</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fp_offset</name> <operator>*</operator> <name>daf</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>oplist</name></expr></argument>, <argument><expr><name>DW_DLA_FRAME_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_regoff_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Addr</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>rs</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name>DW_FRAME_UNDEFINED_VAL</name> <operator>||</operator> <name>reg</name> <operator>==</operator> <name>DW_FRAME_REG_INITIAL_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>reg</name> <operator>==</operator> <name>DW_FRAME_CFA_COL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"c%+jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%+jd"</literal></expr></argument>, <argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><operator>(</operator><name>rs</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>dump_dwarf_frame_regtable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Fde</name></type> <name>fde</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Addr</name></type> <name>pc</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>func_len</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Half</name></type> <name>cie_ra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Regtable</name></type> <name>rt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>row_pc</name></decl>, <decl><type ref="prev"/><name>end_pc</name></decl>, <decl><type ref="prev"/><name>pre_pc</name></decl>, <decl><type ref="prev"/><name>cur_pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_SET</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v[(n)&gt;&gt;3] |= 1U &lt;&lt; ((n) &amp; 7))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_CLR</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v[(n)&gt;&gt;3] &amp;= ~(1U &lt;&lt; ((n) &amp; 7)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_ISSET</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v[(n)&gt;&gt;3] &amp; (1U &lt;&lt; ((n) &amp; 7)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rt.rules[(x)]</cpp:value></cpp:define>

<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><operator>(</operator><name>DW_REG_TABLE_SIZE</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pre_pc</name> <operator>=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>Dwarf_Addr</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cur_pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_pc</name> <operator>=</operator> <name>pc</name> <operator>+</operator> <name>func_len</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>cur_pc</name> <operator>&lt;</operator> <name>end_pc</name></expr>;</condition> <incr><expr><name>cur_pc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_info_for_all_regs</name><argument_list>(<argument><expr><name>fde</name></expr></argument>, <argument><expr><name>cur_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row_pc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_info_for_all_regs failed: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>row_pc</name> <operator>==</operator> <name>pre_pc</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pre_pc</name> <operator>=</operator> <name>row_pc</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DW_REG_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rt</name><operator>.</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dw_regnum</name> <operator>!=</operator> <name>DW_FRAME_REG_INITIAL_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>BIT_SET</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" LOC CFA "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DW_REG_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_ISSET</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Dwarf_Half</name><operator>)</operator> <name>i</name> <operator>==</operator> <name>cie_ra</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ra "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-5s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pre_pc</name> <operator>=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>Dwarf_Addr</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cur_pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_pc</name> <operator>=</operator> <name>pc</name> <operator>+</operator> <name>func_len</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>cur_pc</name> <operator>&lt;</operator> <name>end_pc</name></expr>;</condition> <incr><expr><name>cur_pc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_info_for_all_regs</name><argument_list>(<argument><expr><name>fde</name></expr></argument>, <argument><expr><name>cur_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>row_pc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_info_for_all_regs failed: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>row_pc</name> <operator>==</operator> <name>pre_pc</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pre_pc</name> <operator>=</operator> <name>row_pc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>row_pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s "</literal></expr></argument>, <argument><expr><call><name>get_regoff_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><call><name>RT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><name>dw_regnum</name></expr></argument>,
<argument><expr><call><name>RT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><name>dw_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DW_REG_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BIT_ISSET</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-5s"</literal></expr></argument>, <argument><expr><call><name>get_regoff_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>,
<argument><expr><call><name>RT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>dw_regnum</name></expr></argument>, <argument><expr><call><name>RT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>dw_offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIT_SET</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIT_CLR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BIT_ISSET</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RT</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_frame_section</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>alt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Cie</name> <modifier>*</modifier></type><name>cie_list</name></decl>, <decl><type ref="prev"/><name>cie</name></decl>, <decl><type ref="prev"/><name>pre_cie</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Fde</name> <modifier>*</modifier></type><name>fde_list</name></decl>, <decl><type ref="prev"/><name>fde</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>cie_offset</name></decl>, <decl><type ref="prev"/><name>fde_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>cie_length</name></decl>, <decl><type ref="prev"/><name>fde_instlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>cie_caf</name></decl>, <decl><type ref="prev"/><name>cie_daf</name></decl>, <decl><type ref="prev"/><name>cie_instlen</name></decl>, <decl><type ref="prev"/><name>func_len</name></decl>, <decl><type ref="prev"/><name>fde_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>cie_count</name></decl>, <decl><type ref="prev"/><name>fde_count</name></decl>, <decl><type ref="prev"/><name>cie_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>low_pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>cie_ra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Small</name></type> <name>cie_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Ptr</name></type> <name>fde_addr</name></decl>, <decl><type ref="prev"/><name>fde_inst</name></decl>, <decl><type ref="prev"/><name>cie_inst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cie_aug</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>eh_frame</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nThe section %s contains:\n\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_frame"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eh_frame</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_list</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_count</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>fde_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_list failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".eh_frame"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eh_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_list_eh</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_count</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>fde_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_list_eh failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return;</return></block_content></block></else></if_stmt>

<expr_stmt><expr><name>pre_cie</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>fde_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_n</name><argument_list>(<argument><expr><name>fde_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_n failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_cie_of_fde</name><argument_list>(<argument><expr><name>fde</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_n failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_range</name><argument_list>(<argument><expr><name>fde</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>low_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>func_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_addr</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>fde_length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_offset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_range failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_fde_instr_bytes</name><argument_list>(<argument><expr><name>fde</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_inst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fde_instlen</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_fde_instr_bytes failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pre_cie</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cie</name> <operator>!=</operator> <name>pre_cie</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pre_cie</name> <operator>=</operator> <name>cie</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_cie_info</name><argument_list>(<argument><expr><name>cie</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_version</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cie_aug</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_caf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_daf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_ra</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cie_inst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cie_instlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_cie_info failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08jx %08jx %8.8jx CIE"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_offset</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_length</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>eh_frame</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>~</operator><literal type="number">0U</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Version:\t\t\t%u\n"</literal></expr></argument>, <argument><expr><name>cie_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Augmentation:\t\t\t\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>cie_aug</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Code alignment factor:\t%ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_caf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Data alignment factor:\t%jd\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name>cie_daf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Return address column:\t%ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_frame_inst</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cie</name></expr></argument>, <argument><expr><name>cie_inst</name></expr></argument>,
<argument><expr><name>cie_instlen</name></expr></argument>, <argument><expr><name>cie_caf</name></expr></argument>, <argument><expr><name>cie_daf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" \""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>cie_aug</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cf=%ju df=%jd ra=%ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_caf</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_daf</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_frame_regtable</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>fde</name></expr></argument>, <argument><expr><name>low_pc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><name>cie_ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08jx %08jx %08jx FDE cie=%08jx pc=%08jx..%08jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fde_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>fde_length</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>cie_offset</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>eh_frame</name></expr> ?</condition><then> <expr><name>fde_offset</name> <operator>+</operator> <literal type="number">4</literal> <operator>-</operator> <name>cie_offset</name></expr> </then><else>:
<expr><name>cie_offset</name></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>low_pc</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name>low_pc</name> <operator>+</operator> <name>func_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_frame_inst</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>cie</name></expr></argument>, <argument><expr><name>fde_inst</name></expr></argument>, <argument><expr><name>fde_instlen</name></expr></argument>,
<argument><expr><name>cie_caf</name></expr></argument>, <argument><expr><name>cie_daf</name></expr></argument>, <argument><expr><name>low_pc</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_frame_regtable</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>fde</name></expr></argument>, <argument><expr><name>low_pc</name></expr></argument>, <argument><expr><name>func_len</name></expr></argument>,
<argument><expr><name>cie_ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_frame</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>alt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dwarf_set_frame_cfa_value</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>DW_FRAME_CFA_COL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_frame"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".eh_frame"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_frame_section</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>alt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of section .debug_str:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".debug_str"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%08x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>+</operator> <literal type="number">16</literal> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>+</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>%</operator> <literal type="number">4</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>loc_at_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>la1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>la2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>loc_at</name></name> <modifier>*</modifier></type><name>left</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>loc_at</name> <operator>*</operator><operator>)</operator><name>la1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> struct <name>loc_at</name> <operator>*</operator><operator>)</operator><name>la2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>la_off</name></name> <operator>&gt;</operator> <name><name>right</name><operator>-&gt;</operator><name>la_off</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>la_off</name></name> <operator>&lt;</operator> <name><name>right</name><operator>-&gt;</operator><name>la_off</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>search_loclist_at</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>lowpc</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>loc_at</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>la_list</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>la_list_len</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>la_list_cap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>loc_at</name></name> <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Attribute</name> <modifier>*</modifier></type><name>attr_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>ret_die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>attr_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>attr</name></decl>, <decl><type ref="prev"/><name>form</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Bool</name></type> <name>is_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>is_info</name> <operator>=</operator> <call><name>dwarf_get_die_infotypes_flag</name><argument_list>(<argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_attrlist</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_attrlist failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attr_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_whatattr</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_whatattr failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>DW_AT_location</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_string_length</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_return_addr</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_data_member_location</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_frame_base</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_segment</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_static_link</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_use_location</name> <operator>&amp;&amp;</operator>
<name>attr</name> <operator>!=</operator> <name>DW_AT_vtable_elem_location</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_whatform</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>form</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_whatform failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>form</name> <operator>==</operator> <name>DW_FORM_data4</name> <operator>||</operator> <name>form</name> <operator>==</operator> <name>DW_FORM_data8</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_formudata</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_formudata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>form</name> <operator>==</operator> <name>DW_FORM_sec_offset</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_global_formref</name><argument_list>(<argument><expr><name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_global_formref failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>la_list_cap</name> <operator>==</operator> <operator>*</operator><name>la_list_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>la_list</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><operator>*</operator><name>la_list</name></expr></argument>,
<argument><expr><operator>*</operator><name>la_list_cap</name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>la_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>la_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"realloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>la_list_cap</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>la</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>la_list</name><operator>)</operator><index>[<expr><operator>*</operator><name>la_list_len</name></expr>]</index><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_at</name></name> <operator>=</operator> <name><name>attr_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_off</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_lowpc</name></name> <operator>=</operator> <name>lowpc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_psize</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>cu_psize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_osize</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>cu_osize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_ver</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>cu_ver</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>la_list_len</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>cont_search</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_child</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_child: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>search_loclist_at</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>lowpc</name></expr></argument>, <argument><expr><name>la_list</name></expr></argument>,
<argument><expr><name>la_list_len</name></expr></argument>, <argument><expr><name>la_list_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_siblingof_b</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><name>is_info</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_siblingof: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>search_loclist_at</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>lowpc</name></expr></argument>, <argument><expr><name>la_list</name></expr></argument>,
<argument><expr><name>la_list_len</name></expr></argument>, <argument><expr><name>la_list_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_loc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Loc</name> <modifier>*</modifier></type><name>lr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>unk_op</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_OP_name</name><argument_list>(<argument><expr><name><name>lr</name><operator>-&gt;</operator><name>lr_atom</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op_str</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unk_op</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unk_op</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"[Unknown OP: %#x]"</literal></expr></argument>, <argument><expr><name><name>lr</name><operator>-&gt;</operator><name>lr_atom</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>op_str</name> <operator>=</operator> <name>unk_op</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>op_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>lr</name><operator>-&gt;</operator><name>lr_atom</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DW_OP_reg0</name></expr>:</case>
<case>case <expr><name>DW_OP_reg1</name></expr>:</case>
<case>case <expr><name>DW_OP_reg2</name></expr>:</case>
<case>case <expr><name>DW_OP_reg3</name></expr>:</case>
<case>case <expr><name>DW_OP_reg4</name></expr>:</case>
<case>case <expr><name>DW_OP_reg5</name></expr>:</case>
<case>case <expr><name>DW_OP_reg6</name></expr>:</case>
<case>case <expr><name>DW_OP_reg7</name></expr>:</case>
<case>case <expr><name>DW_OP_reg8</name></expr>:</case>
<case>case <expr><name>DW_OP_reg9</name></expr>:</case>
<case>case <expr><name>DW_OP_reg10</name></expr>:</case>
<case>case <expr><name>DW_OP_reg11</name></expr>:</case>
<case>case <expr><name>DW_OP_reg12</name></expr>:</case>
<case>case <expr><name>DW_OP_reg13</name></expr>:</case>
<case>case <expr><name>DW_OP_reg14</name></expr>:</case>
<case>case <expr><name>DW_OP_reg15</name></expr>:</case>
<case>case <expr><name>DW_OP_reg16</name></expr>:</case>
<case>case <expr><name>DW_OP_reg17</name></expr>:</case>
<case>case <expr><name>DW_OP_reg18</name></expr>:</case>
<case>case <expr><name>DW_OP_reg19</name></expr>:</case>
<case>case <expr><name>DW_OP_reg20</name></expr>:</case>
<case>case <expr><name>DW_OP_reg21</name></expr>:</case>
<case>case <expr><name>DW_OP_reg22</name></expr>:</case>
<case>case <expr><name>DW_OP_reg23</name></expr>:</case>
<case>case <expr><name>DW_OP_reg24</name></expr>:</case>
<case>case <expr><name>DW_OP_reg25</name></expr>:</case>
<case>case <expr><name>DW_OP_reg26</name></expr>:</case>
<case>case <expr><name>DW_OP_reg27</name></expr>:</case>
<case>case <expr><name>DW_OP_reg28</name></expr>:</case>
<case>case <expr><name>DW_OP_reg29</name></expr>:</case>
<case>case <expr><name>DW_OP_reg30</name></expr>:</case>
<case>case <expr><name>DW_OP_reg31</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>lr</name><operator>-&gt;</operator><name>lr_atom</name></name> <operator>-</operator> <name>DW_OP_reg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_deref</name></expr>:</case>
<case>case <expr><name>DW_OP_lit0</name></expr>:</case>
<case>case <expr><name>DW_OP_lit1</name></expr>:</case>
<case>case <expr><name>DW_OP_lit2</name></expr>:</case>
<case>case <expr><name>DW_OP_lit3</name></expr>:</case>
<case>case <expr><name>DW_OP_lit4</name></expr>:</case>
<case>case <expr><name>DW_OP_lit5</name></expr>:</case>
<case>case <expr><name>DW_OP_lit6</name></expr>:</case>
<case>case <expr><name>DW_OP_lit7</name></expr>:</case>
<case>case <expr><name>DW_OP_lit8</name></expr>:</case>
<case>case <expr><name>DW_OP_lit9</name></expr>:</case>
<case>case <expr><name>DW_OP_lit10</name></expr>:</case>
<case>case <expr><name>DW_OP_lit11</name></expr>:</case>
<case>case <expr><name>DW_OP_lit12</name></expr>:</case>
<case>case <expr><name>DW_OP_lit13</name></expr>:</case>
<case>case <expr><name>DW_OP_lit14</name></expr>:</case>
<case>case <expr><name>DW_OP_lit15</name></expr>:</case>
<case>case <expr><name>DW_OP_lit16</name></expr>:</case>
<case>case <expr><name>DW_OP_lit17</name></expr>:</case>
<case>case <expr><name>DW_OP_lit18</name></expr>:</case>
<case>case <expr><name>DW_OP_lit19</name></expr>:</case>
<case>case <expr><name>DW_OP_lit20</name></expr>:</case>
<case>case <expr><name>DW_OP_lit21</name></expr>:</case>
<case>case <expr><name>DW_OP_lit22</name></expr>:</case>
<case>case <expr><name>DW_OP_lit23</name></expr>:</case>
<case>case <expr><name>DW_OP_lit24</name></expr>:</case>
<case>case <expr><name>DW_OP_lit25</name></expr>:</case>
<case>case <expr><name>DW_OP_lit26</name></expr>:</case>
<case>case <expr><name>DW_OP_lit27</name></expr>:</case>
<case>case <expr><name>DW_OP_lit28</name></expr>:</case>
<case>case <expr><name>DW_OP_lit29</name></expr>:</case>
<case>case <expr><name>DW_OP_lit30</name></expr>:</case>
<case>case <expr><name>DW_OP_lit31</name></expr>:</case>
<case>case <expr><name>DW_OP_dup</name></expr>:</case>
<case>case <expr><name>DW_OP_drop</name></expr>:</case>
<case>case <expr><name>DW_OP_over</name></expr>:</case>
<case>case <expr><name>DW_OP_swap</name></expr>:</case>
<case>case <expr><name>DW_OP_rot</name></expr>:</case>
<case>case <expr><name>DW_OP_xderef</name></expr>:</case>
<case>case <expr><name>DW_OP_abs</name></expr>:</case>
<case>case <expr><name>DW_OP_and</name></expr>:</case>
<case>case <expr><name>DW_OP_div</name></expr>:</case>
<case>case <expr><name>DW_OP_minus</name></expr>:</case>
<case>case <expr><name>DW_OP_mod</name></expr>:</case>
<case>case <expr><name>DW_OP_mul</name></expr>:</case>
<case>case <expr><name>DW_OP_neg</name></expr>:</case>
<case>case <expr><name>DW_OP_not</name></expr>:</case>
<case>case <expr><name>DW_OP_or</name></expr>:</case>
<case>case <expr><name>DW_OP_plus</name></expr>:</case>
<case>case <expr><name>DW_OP_shl</name></expr>:</case>
<case>case <expr><name>DW_OP_shr</name></expr>:</case>
<case>case <expr><name>DW_OP_shra</name></expr>:</case>
<case>case <expr><name>DW_OP_xor</name></expr>:</case>
<case>case <expr><name>DW_OP_eq</name></expr>:</case>
<case>case <expr><name>DW_OP_ge</name></expr>:</case>
<case>case <expr><name>DW_OP_gt</name></expr>:</case>
<case>case <expr><name>DW_OP_le</name></expr>:</case>
<case>case <expr><name>DW_OP_lt</name></expr>:</case>
<case>case <expr><name>DW_OP_ne</name></expr>:</case>
<case>case <expr><name>DW_OP_nop</name></expr>:</case>
<case>case <expr><name>DW_OP_push_object_address</name></expr>:</case>
<case>case <expr><name>DW_OP_form_tls_address</name></expr>:</case>
<case>case <expr><name>DW_OP_call_frame_cfa</name></expr>:</case>
<case>case <expr><name>DW_OP_stack_value</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_push_tls_address</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_uninit</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>DW_OP_const1u</name></expr>:</case>
<case>case <expr><name>DW_OP_pick</name></expr>:</case>
<case>case <expr><name>DW_OP_deref_size</name></expr>:</case>
<case>case <expr><name>DW_OP_xderef_size</name></expr>:</case>
<case>case <expr><name>DW_OP_const2u</name></expr>:</case>
<case>case <expr><name>DW_OP_bra</name></expr>:</case>
<case>case <expr><name>DW_OP_skip</name></expr>:</case>
<case>case <expr><name>DW_OP_const4u</name></expr>:</case>
<case>case <expr><name>DW_OP_const8u</name></expr>:</case>
<case>case <expr><name>DW_OP_constu</name></expr>:</case>
<case>case <expr><name>DW_OP_plus_uconst</name></expr>:</case>
<case>case <expr><name>DW_OP_regx</name></expr>:</case>
<case>case <expr><name>DW_OP_piece</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator>
<name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_const1s</name></expr>:</case>
<case>case <expr><name>DW_OP_const2s</name></expr>:</case>
<case>case <expr><name>DW_OP_const4s</name></expr>:</case>
<case>case <expr><name>DW_OP_const8s</name></expr>:</case>
<case>case <expr><name>DW_OP_consts</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator>
<name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_breg0</name></expr>:</case>
<case>case <expr><name>DW_OP_breg1</name></expr>:</case>
<case>case <expr><name>DW_OP_breg2</name></expr>:</case>
<case>case <expr><name>DW_OP_breg3</name></expr>:</case>
<case>case <expr><name>DW_OP_breg4</name></expr>:</case>
<case>case <expr><name>DW_OP_breg5</name></expr>:</case>
<case>case <expr><name>DW_OP_breg6</name></expr>:</case>
<case>case <expr><name>DW_OP_breg7</name></expr>:</case>
<case>case <expr><name>DW_OP_breg8</name></expr>:</case>
<case>case <expr><name>DW_OP_breg9</name></expr>:</case>
<case>case <expr><name>DW_OP_breg10</name></expr>:</case>
<case>case <expr><name>DW_OP_breg11</name></expr>:</case>
<case>case <expr><name>DW_OP_breg12</name></expr>:</case>
<case>case <expr><name>DW_OP_breg13</name></expr>:</case>
<case>case <expr><name>DW_OP_breg14</name></expr>:</case>
<case>case <expr><name>DW_OP_breg15</name></expr>:</case>
<case>case <expr><name>DW_OP_breg16</name></expr>:</case>
<case>case <expr><name>DW_OP_breg17</name></expr>:</case>
<case>case <expr><name>DW_OP_breg18</name></expr>:</case>
<case>case <expr><name>DW_OP_breg19</name></expr>:</case>
<case>case <expr><name>DW_OP_breg20</name></expr>:</case>
<case>case <expr><name>DW_OP_breg21</name></expr>:</case>
<case>case <expr><name>DW_OP_breg22</name></expr>:</case>
<case>case <expr><name>DW_OP_breg23</name></expr>:</case>
<case>case <expr><name>DW_OP_breg24</name></expr>:</case>
<case>case <expr><name>DW_OP_breg25</name></expr>:</case>
<case>case <expr><name>DW_OP_breg26</name></expr>:</case>
<case>case <expr><name>DW_OP_breg27</name></expr>:</case>
<case>case <expr><name>DW_OP_breg28</name></expr>:</case>
<case>case <expr><name>DW_OP_breg29</name></expr>:</case>
<case>case <expr><name>DW_OP_breg30</name></expr>:</case>
<case>case <expr><name>DW_OP_breg31</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (%s): %jd"</literal></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>lr</name><operator>-&gt;</operator><name>lr_atom</name></name> <operator>-</operator> <name>DW_OP_breg0</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_fbreg</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator>
<name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_bregx</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju (%s) %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_addr</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_encoded_addr</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %#jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator>
<name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_GNU_implicit_pointer</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": &lt;0x%jx&gt; %jd"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_implicit_value</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju byte block:"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Unsigned</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %x"</literal></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>

<case>case <expr><name>DW_OP_GNU_entry_value</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_block</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr></argument>,
<argument><expr><name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_GNU_const_type</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": &lt;0x%jx&gt; "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint8_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %x"</literal></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>

<case>case <expr><name>DW_OP_GNU_regval_type</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": %ju (%s) &lt;0x%jx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>,
<argument><expr><call><name>dwarf_regname</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DW_OP_GNU_convert</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_deref_type</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_parameter_ref</name></expr>:</case>
<case>case <expr><name>DW_OP_GNU_reinterpret</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": &lt;0x%jx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>lr</name><operator>-&gt;</operator><name>lr_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_block</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Unsigned</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Locdesc</name> <modifier>*</modifier></type><name>llbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>lcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_loclist_from_expr_b</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>cu_psize</name></name></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>cu_osize</name></name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>cu_ver</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>llbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_loclist_form_expr_b: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Half</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>llbuf</name><operator>-&gt;</operator><name>ld_cents</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dump_dwarf_loc</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>llbuf</name><operator>-&gt;</operator><name>ld_s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>llbuf</name><operator>-&gt;</operator><name>ld_cents</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>llbuf</name><operator>-&gt;</operator><name>ld_s</name></name></expr></argument>, <argument><expr><name>DW_DLA_LOC_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>llbuf</name></expr></argument>, <argument><expr><name>DW_DLA_LOCDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf_loclist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Locdesc</name> <modifier>*</modifier><modifier>*</modifier></type><name>llbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>lowpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>lcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>, <decl><type ref="prev"/><name>version</name></decl>, <decl><type ref="prev"/><name>pointer_size</name></decl>, <decl><type ref="prev"/><name>off_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>loc_at</name></name> <modifier>*</modifier></type><name>la_list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>left</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>la_list_len</name></decl>, <decl><type ref="prev"/><name>la_list_cap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>duplicates</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>has_content</name></decl>;</decl_stmt>

<expr_stmt><expr><name>la_list_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>la_list_cap</name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>la_list</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>la_list_cap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>loc_at</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header_b</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>pointer_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_cu_context</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>pointer_size</name></expr></argument>, <argument><expr><name>off_size</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_compile_unit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_low_pc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>lowpc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>search_loclist_at</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><name>lowpc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>la_list</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>la_list_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>la_list_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_next_cu_header: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<do>do <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header_c</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>version</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pointer_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_cu_context</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>pointer_size</name></expr></argument>, <argument><expr><name>off_size</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_type_unit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_low_pc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>lowpc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lowpc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>search_loclist_at</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><name>lowpc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>la_list</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>la_list_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>la_list_cap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_next_cu_header: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>dwarf_next_types_section</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>la_list_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>la_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>la_list</name></expr></argument>, <argument><expr><name>la_list_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>loc_at</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>loc_at_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>duplicates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>la_list_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>&amp;</operator><name><name>la_list</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>duplicates</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>&amp;</operator><name><name>la_list</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>la_off</name></name> <operator>==</operator> <name><name>right</name><operator>-&gt;</operator><name>la_off</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>duplicates</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>la_list</name><index>[<expr><name>k</name> <operator>-</operator> <name>duplicates</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>right</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>la_list_len</name> <operator>-=</operator> <name>duplicates</name></expr>;</expr_stmt>

<expr_stmt><expr><name>has_content</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>la_list_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>la</name> <operator>=</operator> <operator>&amp;</operator><name><name>la_list</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_loclist_n</name><argument_list>(<argument><expr><name><name>la</name><operator>-&gt;</operator><name>la_at</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>llbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DW_DLV_NO_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_loclist_n failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_content</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>has_content</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nContents of section .debug_loc:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Offset Begin End Expression\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_cu_context</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_psize</name></name></expr></argument>, <argument><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_osize</name></name></expr></argument>,
<argument><expr><name><name>la</name><operator>-&gt;</operator><name>la_cu_ver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %8.8jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>la</name><operator>-&gt;</operator><name>la_off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_lopc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_hipc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"&lt;End of list&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%8.8jx %8.8jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>la</name><operator>-&gt;</operator><name>la_lowpc</name></name> <operator>+</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_lopc</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>la</name><operator>-&gt;</operator><name>la_lowpc</name></name> <operator>+</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_hipc</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Half</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_cents</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dump_dwarf_loc</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>ld_s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_cents</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_lopc</name> <operator>==</operator> <name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_hipc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (start == end)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ld_s</name></expr></argument>,
<argument><expr><name>DW_DLA_LOC_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name><name>llbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>DW_DLA_LOCDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>llbuf</name></expr></argument>, <argument><expr><name>DW_DLA_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_content</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection '.debug_loc' has no debugging data.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>la_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>get_string</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strtab</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_symbol_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>symtab</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_SYMTAB</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_DYNSYM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>sym</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STT_SECTION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name> <operator>&amp;&amp;</operator>
<name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr>]</index></name><operator>.</operator><name>name</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name> <operator>||</operator>
<operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>sym</name><operator>.</operator><name>st_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>get_symbol_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>symtab</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_SYMTAB</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_DYNSYM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>sym</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>sym</name><operator>.</operator><name>st_value</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type> <name>decompress_section</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>compressed_data_buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>compressed_size</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret_buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ret_sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>sh</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_getshdr() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>.</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_COMPRESSED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Chdr</name></type> <name>chdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Xword</name></type> <name>inflated_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>uncompressed_data_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Xword</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_stream</name></type> <name>strm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getchdr</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>chdr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_getchdr() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chdr</name><operator>.</operator><name>ch_type</name></name> <operator>!=</operator> <name>ELFCOMPRESS_ZLIB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"unknown compression type: %d"</literal></expr></argument>, <argument><expr><name><name>chdr</name><operator>.</operator><name>ch_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>inflated_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uncompressed_size</name> <operator>=</operator> <name><name>chdr</name><operator>.</operator><name>ch_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>uncompressed_data_buffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>uncompressed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed_data_buffer</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed_size</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>zalloc</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>zfree</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>compressed_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>uncompressed_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>




<while>while <condition>(<expr><name>inflated_size</name> <operator>&lt;</operator> <name>compressed_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>compressed_data_buffer</name> <operator>+</operator> <name>inflated_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strm</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>uncompressed_data_buffer</name> <operator>+</operator> <name>inflated_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strm</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>inflated_size</name> <operator>=</operator> <name>uncompressed_size</name> <operator>-</operator> <name><name>strm</name><operator>.</operator><name>avail_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflateReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>.</operator><name>avail_out</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Warning: wrong info in compression header."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_buf</name> <operator>=</operator> <name>uncompressed_data_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ret_sz</name> <operator>=</operator> <name>uncompressed_size</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>strm</name><operator>.</operator><name>msg</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>strm</name><operator>.</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"ZLIB error: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>uncompressed_data_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hex_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>new_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>find_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>HEX_DUMP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection '%s' has no data to dump.\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_Z</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>decompress_section</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>new_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>new_buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nHex dump of section '%s':\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>sz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" 0x%8.8jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <ternary><condition><expr><name>sz</name> <operator>&gt;</operator> <literal type="number">16</literal></expr>?</condition><then> <expr><literal type="number">16</literal></expr> </then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>j</name> <operator>&lt;</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%2.2x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>j</name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>j</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>nbytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>-=</operator> <name>nbytes</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>str_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>new_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>find_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>STR_DUMP</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>d</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nSection '%s' has no data to dump.\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_Z</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>decompress_section</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>new_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>new_buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf_end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nString dump of section '%s':\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<while>while <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>buf_end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><operator>*</operator><name>start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <name>buf_end</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>end</name> <operator>&lt;</operator> <name>buf_end</name> <operator>&amp;&amp;</operator> <call><name>isprint</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%6lx] "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>start</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><name><name>start</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>buf_end</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" No strings found in this section."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>sh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shstrndx</name></decl>, <decl><type ref="prev"/><name>ndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshnum</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getshnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>sl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshstrndx</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shstrndx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getshstrndx failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getshdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>shstrndx</name></expr></argument>, <argument><expr><name><name>sh</name><operator>.</operator><name>sh_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"&lt;no-name&gt;"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ndx</name> <operator>=</operator> <call><name>elf_ndxscn</name><argument_list>(<argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_ndxscn failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section index of '%s' out of range"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sh</name><operator>.</operator><name>sh_link</name></name> <operator>&gt;=</operator> <name><name>re</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section link %llu of '%s' out of range"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name><name>sh</name><operator>.</operator><name>sh_link</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name> <operator>=</operator> <name>scn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_addralign</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_info</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_nextscn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unload_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>sl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>sl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>sl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>shnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vd_s</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vn_s</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs_s</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>vs_sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ver_sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dump_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>ehdr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getehdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>ec</name></name> <operator>=</operator> <call><name>gelf_getclass</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>ELFCLASSNONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getclass failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2MSB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name> <operator>=</operator> <name>_read_msb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name> <operator>=</operator> <name>_decode_msb</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dw_read</name></name> <operator>=</operator> <name>_read_lsb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dw_decode</name></name> <operator>=</operator> <name>_decode_lsb</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>RE_H</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_sections</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_VV</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_S</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>search_ver</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_H</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_ehdr</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_L</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_phdr</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_SS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_shdr</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_G</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_section_groups</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_D</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dynamic</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_R</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_reloc</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_S</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_symtabs</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_N</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_notes</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_II</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_hash</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_X</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hex_dump</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_P</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>str_dump</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_VV</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_ver</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_AA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_arch_specific_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_W</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>RE_H</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unload_sections</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_dwarf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_elf_init</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>DW_DLC_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>error</name> <operator>=</operator> <call><name>dwarf_errno</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>DW_DLE_DEBUG_INFO_NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"dwarf_elf_init failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_A</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_abbrev</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_L</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_line</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_LL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_line_decoded</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_I</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dump_dwarf_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_dwarf_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_P</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_pubnames</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_R</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_aranges</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_RR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_ranges</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_M</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_macinfo</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_F</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_frame</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_FF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_frame</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_S</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>&amp;</operator> <name>DW_O</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dump_dwarf_loclist</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dwarf_finish</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dump_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Arsym</name> <modifier>*</modifier></type><name>arsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Cmd</name></type> <name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>RE_C</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arsym</name> <operator>=</operator> <call><name>elf_getarsym</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarsym() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>process_members</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Index of archive %s: (%ju entries)\n"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>sz</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name> <operator>!=</operator> <name>off</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>elf_rand</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>off</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rand() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator>
<name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arhdr</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarhdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Binary %s(%s) contains:\n"</literal></expr></argument>,
<argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t%s\n"</literal></expr></argument>, <argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>elf_rand</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><name>SARMAG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SARMAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rand() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>process_members</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>~</operator><name>RE_C</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>ELF_C_READ</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arhdr</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarhdr() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_member</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>, <argument><expr><literal type="string">"//"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>, <argument><expr><literal type="string">"__.SYMDEF"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next_member</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nFile: %s(%s)\n"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dump_elf</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>next_member</name>:</label>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>elf_next</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <name><name>re</name><operator>-&gt;</operator><name>ar</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dump_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>rv</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DISPLAY_FILENAME</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nFile: %s\n"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELF_K_NONE</name></expr>:</case>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Not an ELF file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
<case>case <expr><name>ELF_K_ELF</name></expr>:</case>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dump_elf</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ELF_K_AR</name></expr>:</case>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dump_ar</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Internal: libelf returned unknown elf kind."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rv</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_dumpop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>si</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dumpop</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>find_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>si</name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>DUMP_BY_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>si</name></name> <operator>=</operator> <name>si</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sn</name></name> <operator>=</operator> <name>sn</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>v_dumpop</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>dumpop_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>op</name></name> <operator>|=</operator> <name>op</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dumpop</name></name> <modifier>*</modifier></type>
<name>find_dumpop</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>si</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>dumpop</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<macro><name>STAILQ_FOREACH</name><argument_list>(<argument>d</argument>, <argument>&amp;re-&gt;v_dumpop</argument>, <argument>dumpop_list</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>op</name> <operator>&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>op</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>t</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>unsigned</name><operator>)</operator> <name>t</name> <operator>==</operator> <name><name>d</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DUMP_BY_INDEX</name> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>si</name></name> <operator>==</operator> <name>si</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>DUMP_BY_NAME</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>sn</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>d</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
}</block> <decl><name><name>dwarf_op</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"rawline"</literal></expr>, <expr><literal type="char">'l'</literal></expr>, <expr><name>DW_L</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"decodedline"</literal></expr>, <expr><literal type="char">'L'</literal></expr>, <expr><name>DW_LL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><name>DW_I</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"abbrev"</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><name>DW_A</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"pubnames"</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><name>DW_P</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"aranges"</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><name>DW_R</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"ranges"</literal></expr>, <expr><literal type="char">'r'</literal></expr>, <expr><name>DW_R</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"Ranges"</literal></expr>, <expr><literal type="char">'R'</literal></expr>, <expr><name>DW_RR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"macro"</literal></expr>, <expr><literal type="char">'m'</literal></expr>, <expr><name>DW_M</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"frames"</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><name>DW_F</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"frames-interp"</literal></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><name>DW_FF</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"str"</literal></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><name>DW_S</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"loc"</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><name>DW_O</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_dwarf_op_short</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>|=</operator> <name>DW_DEFAULT_OPTIONS</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sn</name> <operator>==</operator> <operator>*</operator><name>op</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>|=</operator> <name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_dwarf_op_long</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>token</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>|=</operator> <name>DW_DEFAULT_OPTIONS</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"strdup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>token</name> <operator>=</operator> <call><name>strsep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ln</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>dop</name></name> <operator>|=</operator> <name><name>dwarf_op</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>_read_lsb</name><parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsetp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <operator>*</operator><name>offsetp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>bytes_to_read</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>offsetp</name> <operator>+=</operator> <name>bytes_to_read</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>_read_msb</name><parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>offsetp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>d</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <operator>*</operator><name>offsetp</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>bytes_to_read</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>offsetp</name> <operator>+=</operator> <name>bytes_to_read</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>_decode_lsb</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>*</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>bytes_to_read</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>data</name> <operator>+=</operator> <name>bytes_to_read</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>_decode_msb</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bytes_to_read</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>*</operator><name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>bytes_to_read</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">48</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>data</name> <operator>+=</operator> <name>bytes_to_read</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64_t</name></type>
<name>_decode_sleb128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dpe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>b</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>*</operator><name>dp</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>dpe</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&lt;</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x40</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>-</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>_decode_uleb128</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dpe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>*</operator><name>dp</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>dpe</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>b</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>dp</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readelf_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>elftc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] file...\nDisplay information about ELF objects and ar(1) archives.\n\nOptions:\n-a | --all Equivalent to specifying options '-dhIlrsASV'.\n-c | --archive-index Print the archive symbol table for archives.\n-d | --dynamic Print the contents of SHT_DYNAMIC sections.\n-e | --headers Print all headers in the object.\n-g | --section-groups Print the contents of the section groups.\n-h | --file-header Print the file header for the object.\n-l | --program-headers Print the PHDR table for the object.\n-n | --notes Print the contents of SHT_NOTE sections.\n-p INDEX | --string-dump=INDEX\nPrint the contents of section at index INDEX.\n-r | --relocs Print relocation information.\n-s | --syms | --symbols Print symbol tables.\n-t | --section-details Print additional information about sections.\n-v | --version Print a version identifier and exit.\n-w[afilmoprsFLR] | --debug-dump={abbrev,aranges,decodedline,frames,\nframes-interp,info,loc,macro,pubnames,\nranges,Ranges,rawline,str}\nDisplay DWARF information.\n-x INDEX | --hex-dump=INDEX\nDisplay contents of a section as hexadecimal.\n-z | --decompress Decompress the contents of a section before displaying it.\n-A | --arch-specific (accepted, but ignored)\n-D | --use-dynamic Print the symbol table specified by the DT_SYMTAB\nentry in the \".dynamic\" section.\n-H | --help Print a help message.\n-I | --histogram Print information on bucket list lengths for \nhash sections.\n-N | --full-section-name (accepted, but ignored)\n-S | --sections | --section-headers\nPrint information about section headers.\n-V | --version-info Print symbol versoning information.\n-W | --wide Print information without wrapping long lines.\n"</cpp:value></cpp:define>





































<function><type><specifier>static</specifier> <name>void</name></type>
<name>readelf_usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>cap_rights_t</name></type> <name>rights</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fileargs_t</name> <modifier>*</modifier></type><name>fa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>readelf</name></name> <modifier>*</modifier></type><name>re</name></decl>, <decl><type ref="prev"/><name>re_storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>si</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>exit_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<expr_stmt><expr><name>re</name> <operator>=</operator> <operator>&amp;</operator><name>re_storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>re</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>v_dumpop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"AacDdegHhIi:lNnp:rSstuVvWw::x:z"</literal></expr></argument>,
<argument><expr><name>longopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>readelf_usage</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_AA</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_AA</name> <operator>|</operator> <name>RE_D</name> <operator>|</operator> <name>RE_G</name> <operator>|</operator> <name>RE_H</name> <operator>|</operator> <name>RE_II</name> <operator>|</operator>
<name>RE_L</name> <operator>|</operator> <name>RE_N</name> <operator>|</operator> <name>RE_R</name> <operator>|</operator> <name>RE_SS</name> <operator>|</operator> <name>RE_S</name> <operator>|</operator> <name>RE_U</name> <operator>|</operator> <name>RE_VV</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_C</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_DD</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_D</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_H</name> <operator>|</operator> <name>RE_L</name> <operator>|</operator> <name>RE_SS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_G</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<expr_stmt><expr><call><name>readelf_usage</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_H</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_II</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_L</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_NN</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_N</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_P</name></expr>;</expr_stmt>
<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ep</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>si</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>STR_DUMP</name></expr></argument>,
<argument><expr><name>DUMP_BY_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>STR_DUMP</name></expr></argument>,
<argument><expr><name>DUMP_BY_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_R</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_SS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_S</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_SS</name> <operator>|</operator> <name>RE_T</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_U</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_VV</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><call><name>readelf_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_WW</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_W</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_dwarf_op_short</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_X</name></expr>;</expr_stmt>
<expr_stmt><expr><name>si</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ep</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ep</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>si</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>HEX_DUMP</name></expr></argument>,
<argument><expr><name>DUMP_BY_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_dumpop</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>HEX_DUMP</name></expr></argument>,
<argument><expr><name>DUMP_BY_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'z'</literal></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_Z</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>OPTION_DEBUG_DUMP</name></expr>:</case>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>RE_W</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_dwarf_op_long</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>re</name><operator>-&gt;</operator><name>options</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>readelf_usage</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DISPLAY_FILENAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"ELF library initialization failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cap_rights_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>CAP_FCNTL</name></expr></argument>, <argument><expr><name>CAP_FSTAT</name></expr></argument>, <argument><expr><name>CAP_MMAP_R</name></expr></argument>, <argument><expr><name>CAP_SEEK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fa</name> <operator>=</operator> <call><name>fileargs_init</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>FA_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Unable to initialize casper fileargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>caph_cache_catpages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_limit_stdio</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fileargs_free</name><argument_list>(<argument><expr><name>fa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Unable to limit stdio rights"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_enter_casper</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fileargs_free</name><argument_list>(<argument><expr><name>fa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Unable to enter capability mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>fileargs_open</name><argument_list>(<argument><expr><name>fa</name></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"open %s failed"</literal></expr></argument>, <argument><expr><name><name>re</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dump_object</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
