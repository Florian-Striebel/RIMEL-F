<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/elfdump/elfdump.c">



























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelftc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;archive.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;archive_entry.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"_elftc.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>ELFTC_VCSID</name><argument_list>(<argument><expr><literal type="string">"$Id: elfdump.c 3762 2019-06-28 21:06:24Z emaste $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFTC_NEED_ELF_NOTE_DEFINITION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"native-elf-format.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ELFTC_CLASS</name> <operator>==</operator> <name>ELFCLASS32</name></expr></cpp:if>
<typedef>typedef <type><name>Elf32_Nhdr</name></type> <name>Elf_Note</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>Elf64_Nhdr</name></type> <name>Elf_Note</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_DYN</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_EHDR</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_GOT</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_HASH</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_INTERP</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_NOTE</name></cpp:macro> <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_PHDR</name></cpp:macro> <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_REL</name></cpp:macro> <cpp:value>(1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_SHDR</name></cpp:macro> <cpp:value>(1&lt;&lt;8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_SYMTAB</name></cpp:macro> <cpp:value>(1&lt;&lt;9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_SYMVER</name></cpp:macro> <cpp:value>(1&lt;&lt;10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_CHECKSUM</name></cpp:macro> <cpp:value>(1&lt;&lt;11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ED_ALL</name></cpp:macro> <cpp:value>((1&lt;&lt;12)-1)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOLARIS_FMT</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_FILENAME</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_ARSYM</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONLY_ARSYM</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRT</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fprintf(ed-&gt;out, __VA_ARGS__)</cpp:value></cpp:define>


<struct>struct <name>section</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>entsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>align</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>link</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>info</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>spec_name</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<macro><name>STAILQ_ENTRY</name><argument_list>(<argument>spec_name</argument>)</argument_list></macro> <expr_stmt><expr><name>sn_list</name></expr>;</expr_stmt>
}</block>;</struct>


<struct>struct <name>elfdump</name> <block>{
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>archive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>ar</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
<macro><name>STAILQ_HEAD</name><argument_list>(<argument/>, <argument>spec_name</argument>)</argument_list></macro> <expr_stmt><expr><name>snl</name></expr>;</expr_stmt>
}</block>;</struct>


<struct>struct <name>rel_entry</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>GElf_Rel</name></type> <name>rel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Rela</name></type> <name>rela</name></decl>;</decl_stmt>
}</block> <decl><name>u_r</name></decl>;</union>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFTC_NEED_BYTEORDER_EXTENSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>__inline</name> <name>uint32_t</name></type>
<name>be32dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>uint32_t</name></type>
<name>le32dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>d_tags</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>unknown_buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"DT_NULL"</literal></expr>;</return>
<case>case <expr><name>DT_NEEDED</name></expr>:</case> <return>return <expr><literal type="string">"DT_NEEDED"</literal></expr>;</return>
<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_PLTRELSZ"</literal></expr>;</return>
<case>case <expr><name>DT_PLTGOT</name></expr>:</case> <return>return <expr><literal type="string">"DT_PLTGOT"</literal></expr>;</return>
<case>case <expr><name>DT_HASH</name></expr>:</case> <return>return <expr><literal type="string">"DT_HASH"</literal></expr>;</return>
<case>case <expr><name>DT_STRTAB</name></expr>:</case> <return>return <expr><literal type="string">"DT_STRTAB"</literal></expr>;</return>
<case>case <expr><name>DT_SYMTAB</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMTAB"</literal></expr>;</return>
<case>case <expr><name>DT_RELA</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELA"</literal></expr>;</return>
<case>case <expr><name>DT_RELASZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELASZ"</literal></expr>;</return>
<case>case <expr><name>DT_RELAENT</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELAENT"</literal></expr>;</return>
<case>case <expr><name>DT_STRSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_STRSZ"</literal></expr>;</return>
<case>case <expr><name>DT_SYMENT</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMENT"</literal></expr>;</return>
<case>case <expr><name>DT_INIT</name></expr>:</case> <return>return <expr><literal type="string">"DT_INIT"</literal></expr>;</return>
<case>case <expr><name>DT_FINI</name></expr>:</case> <return>return <expr><literal type="string">"DT_FINI"</literal></expr>;</return>
<case>case <expr><name>DT_SONAME</name></expr>:</case> <return>return <expr><literal type="string">"DT_SONAME"</literal></expr>;</return>
<case>case <expr><name>DT_RPATH</name></expr>:</case> <return>return <expr><literal type="string">"DT_RPATH"</literal></expr>;</return>
<case>case <expr><name>DT_SYMBOLIC</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMBOLIC"</literal></expr>;</return>
<case>case <expr><name>DT_REL</name></expr>:</case> <return>return <expr><literal type="string">"DT_REL"</literal></expr>;</return>
<case>case <expr><name>DT_RELSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELSZ"</literal></expr>;</return>
<case>case <expr><name>DT_RELENT</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELENT"</literal></expr>;</return>
<case>case <expr><name>DT_PLTREL</name></expr>:</case> <return>return <expr><literal type="string">"DT_PLTREL"</literal></expr>;</return>
<case>case <expr><name>DT_DEBUG</name></expr>:</case> <return>return <expr><literal type="string">"DT_DEBUG"</literal></expr>;</return>
<case>case <expr><name>DT_TEXTREL</name></expr>:</case> <return>return <expr><literal type="string">"DT_TEXTREL"</literal></expr>;</return>
<case>case <expr><name>DT_JMPREL</name></expr>:</case> <return>return <expr><literal type="string">"DT_JMPREL"</literal></expr>;</return>
<case>case <expr><name>DT_BIND_NOW</name></expr>:</case> <return>return <expr><literal type="string">"DT_BIND_NOW"</literal></expr>;</return>
<case>case <expr><name>DT_INIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"DT_INIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_FINI_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"DT_FINI_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_INIT_ARRAYSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_INIT_ARRAYSZ"</literal></expr>;</return>
<case>case <expr><name>DT_FINI_ARRAYSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_FINI_ARRAYSZ"</literal></expr>;</return>
<case>case <expr><name>DT_RUNPATH</name></expr>:</case> <return>return <expr><literal type="string">"DT_RUNPATH"</literal></expr>;</return>
<case>case <expr><name>DT_FLAGS</name></expr>:</case> <return>return <expr><literal type="string">"DT_FLAGS"</literal></expr>;</return>
<case>case <expr><name>DT_PREINIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"DT_PREINIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>DT_PREINIT_ARRAYSZ</name></expr>:</case><return>return <expr><literal type="string">"DT_PREINIT_ARRAYSZ"</literal></expr>;</return>

<case>case <expr><literal type="number">0x6ffffdf5</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_PRELINKED"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffdf6</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_CONFLICTSZ"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffdf7</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_LIBLISTSZ"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffdf8</literal></expr>:</case> <return>return <expr><literal type="string">"DT_SUNW_CHECKSUM"</literal></expr>;</return>
<case>case <expr><name>DT_PLTPADSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_PLTPADSZ"</literal></expr>;</return>
<case>case <expr><name>DT_MOVEENT</name></expr>:</case> <return>return <expr><literal type="string">"DT_MOVEENT"</literal></expr>;</return>
<case>case <expr><name>DT_MOVESZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_MOVESZ"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffdfc</literal></expr>:</case> <return>return <expr><literal type="string">"DT_FEATURE"</literal></expr>;</return>
<case>case <expr><name>DT_POSFLAG_1</name></expr>:</case> <return>return <expr><literal type="string">"DT_POSFLAG_1"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINSZ</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMINSZ"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINENT</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMINENT (DT_VALRNGHI)"</literal></expr>;</return>
<case>case <expr><name>DT_ADDRRNGLO</name></expr>:</case> <return>return <expr><literal type="string">"DT_ADDRRNGLO"</literal></expr>;</return>
<case>case <expr><name>DT_GNU_HASH</name></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_HASH"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffef8</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_CONFLICT"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffef9</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_LIBLIST"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffefa</literal></expr>:</case> <return>return <expr><literal type="string">"DT_CONFIG"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffefb</literal></expr>:</case> <return>return <expr><literal type="string">"DT_DEPAUDIT"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffefc</literal></expr>:</case> <return>return <expr><literal type="string">"DT_AUDIT"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffefd</literal></expr>:</case> <return>return <expr><literal type="string">"DT_PLTPAD"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffefe</literal></expr>:</case> <return>return <expr><literal type="string">"DT_MOVETAB"</literal></expr>;</return>
<case>case <expr><name>DT_SYMINFO</name></expr>:</case> <return>return <expr><literal type="string">"DT_SYMINFO (DT_ADDRRNGHI)"</literal></expr>;</return>
<case>case <expr><name>DT_RELACOUNT</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELACOUNT"</literal></expr>;</return>
<case>case <expr><name>DT_RELCOUNT</name></expr>:</case> <return>return <expr><literal type="string">"DT_RELCOUNT"</literal></expr>;</return>
<case>case <expr><name>DT_FLAGS_1</name></expr>:</case> <return>return <expr><literal type="string">"DT_FLAGS_1"</literal></expr>;</return>
<case>case <expr><name>DT_VERDEF</name></expr>:</case> <return>return <expr><literal type="string">"DT_VERDEF"</literal></expr>;</return>
<case>case <expr><name>DT_VERDEFNUM</name></expr>:</case> <return>return <expr><literal type="string">"DT_VERDEFNUM"</literal></expr>;</return>
<case>case <expr><name>DT_VERNEED</name></expr>:</case> <return>return <expr><literal type="string">"DT_VERNEED"</literal></expr>;</return>
<case>case <expr><name>DT_VERNEEDNUM</name></expr>:</case> <return>return <expr><literal type="string">"DT_VERNEEDNUM"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffff0</literal></expr>:</case> <return>return <expr><literal type="string">"DT_GNU_VERSYM"</literal></expr>;</return>

<case>case <expr><literal type="number">0x70000000</literal></expr>:</case> <return>return <expr><literal type="string">"DT_IA_64_PLT_RESERVE"</literal></expr>;</return>
<case>case <expr><name>DT_AUXILIARY</name></expr>:</case> <return>return <expr><literal type="string">"DT_AUXILIARY"</literal></expr>;</return>
<case>case <expr><name>DT_USED</name></expr>:</case> <return>return <expr><literal type="string">"DT_USED"</literal></expr>;</return>
<case>case <expr><name>DT_FILTER</name></expr>:</case> <return>return <expr><literal type="string">"DT_FILTER"</literal></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unknown_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unknown_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"&lt;unknown: %#llx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>unknown_buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>e_machines</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>machdesc</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_NONE</name></expr>:</case> <return>return <expr><literal type="string">"EM_NONE"</literal></expr>;</return>
<case>case <expr><name>EM_M32</name></expr>:</case> <return>return <expr><literal type="string">"EM_M32"</literal></expr>;</return>
<case>case <expr><name>EM_SPARC</name></expr>:</case> <return>return <expr><literal type="string">"EM_SPARC"</literal></expr>;</return>
<case>case <expr><name>EM_386</name></expr>:</case> <return>return <expr><literal type="string">"EM_386"</literal></expr>;</return>
<case>case <expr><name>EM_68K</name></expr>:</case> <return>return <expr><literal type="string">"EM_68K"</literal></expr>;</return>
<case>case <expr><name>EM_88K</name></expr>:</case> <return>return <expr><literal type="string">"EM_88K"</literal></expr>;</return>
<case>case <expr><name>EM_IAMCU</name></expr>:</case> <return>return <expr><literal type="string">"EM_IAMCU"</literal></expr>;</return>
<case>case <expr><name>EM_860</name></expr>:</case> <return>return <expr><literal type="string">"EM_860"</literal></expr>;</return>
<case>case <expr><name>EM_MIPS</name></expr>:</case> <return>return <expr><literal type="string">"EM_MIPS"</literal></expr>;</return>
<case>case <expr><name>EM_PPC</name></expr>:</case> <return>return <expr><literal type="string">"EM_PPC"</literal></expr>;</return>
<case>case <expr><name>EM_PPC64</name></expr>:</case> <return>return <expr><literal type="string">"EM_PPC64"</literal></expr>;</return>
<case>case <expr><name>EM_ARM</name></expr>:</case> <return>return <expr><literal type="string">"EM_ARM"</literal></expr>;</return>
<case>case <expr><name>EM_ALPHA</name></expr>:</case> <return>return <expr><literal type="string">"EM_ALPHA (legacy)"</literal></expr>;</return>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case><return>return <expr><literal type="string">"EM_SPARCV9"</literal></expr>;</return>
<case>case <expr><name>EM_IA_64</name></expr>:</case> <return>return <expr><literal type="string">"EM_IA_64"</literal></expr>;</return>
<case>case <expr><name>EM_X86_64</name></expr>:</case> <return>return <expr><literal type="string">"EM_X86_64"</literal></expr>;</return>
<case>case <expr><name>EM_AARCH64</name></expr>:</case><return>return <expr><literal type="string">"EM_AARCH64"</literal></expr>;</return>
<case>case <expr><name>EM_RISCV</name></expr>:</case> <return>return <expr><literal type="string">"EM_RISCV"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>machdesc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>machdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"(unknown machine) -- type 0x%x"</literal></expr></argument>, <argument><expr><name>mach</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>machdesc</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_type_str</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_type</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>ET_NONE</name></expr>:</case> <return>return <expr><literal type="string">"ET_NONE"</literal></expr>;</return>
<case>case <expr><name>ET_REL</name></expr>:</case> <return>return <expr><literal type="string">"ET_REL"</literal></expr>;</return>
<case>case <expr><name>ET_EXEC</name></expr>:</case> <return>return <expr><literal type="string">"ET_EXEC"</literal></expr>;</return>
<case>case <expr><name>ET_DYN</name></expr>:</case> <return>return <expr><literal type="string">"ET_DYN"</literal></expr>;</return>
<case>case <expr><name>ET_CORE</name></expr>:</case> <return>return <expr><literal type="string">"ET_CORE"</literal></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>ET_LOPROC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;proc: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>ET_LOOS</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>&lt;=</operator> <name>ET_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;os: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_version_str</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ver</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_ver</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ver</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EV_NONE</name></expr>:</case> <return>return <expr><literal type="string">"EV_NONE"</literal></expr>;</return>
<case>case <expr><name>EV_CURRENT</name></expr>:</case> <return>return <expr><literal type="string">"EV_CURRENT"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_ver</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_ver</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>ver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_ver</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_class_str</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_class</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>class</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFCLASSNONE</name></expr>:</case> <return>return <expr><literal type="string">"ELFCLASSNONE"</literal></expr>;</return>
<case>case <expr><name>ELFCLASS32</name></expr>:</case> <return>return <expr><literal type="string">"ELFCLASS32"</literal></expr>;</return>
<case>case <expr><name>ELFCLASS64</name></expr>:</case> <return>return <expr><literal type="string">"ELFCLASS64"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_class</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_class</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_class</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_data_str</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_data</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFDATANONE</name></expr>:</case> <return>return <expr><literal type="string">"ELFDATANONE"</literal></expr>;</return>
<case>case <expr><name>ELFDATA2LSB</name></expr>:</case> <return>return <expr><literal type="string">"ELFDATA2LSB"</literal></expr>;</return>
<case>case <expr><name>ELFDATA2MSB</name></expr>:</case> <return>return <expr><literal type="string">"ELFDATA2MSB"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_data</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_data</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>ei_abis</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="string">"ELFOSABI_NONE"</literal></expr>, <expr><literal type="string">"ELFOSABI_HPUX"</literal></expr>, <expr><literal type="string">"ELFOSABI_NETBSD"</literal></expr>, <expr><literal type="string">"ELFOSABI_LINUX"</literal></expr>,
<expr><literal type="string">"ELFOSABI_HURD"</literal></expr>, <expr><literal type="string">"ELFOSABI_86OPEN"</literal></expr>, <expr><literal type="string">"ELFOSABI_SOLARIS"</literal></expr>, <expr><literal type="string">"ELFOSABI_AIX"</literal></expr>,
<expr><literal type="string">"ELFOSABI_IRIX"</literal></expr>, <expr><literal type="string">"ELFOSABI_FREEBSD"</literal></expr>, <expr><literal type="string">"ELFOSABI_TRU64"</literal></expr>,
<expr><literal type="string">"ELFOSABI_MODESTO"</literal></expr>, <expr><literal type="string">"ELFOSABI_OPENBSD"</literal></expr>,
<expr><index>[<expr><literal type="number">17</literal></expr>]</index> <operator>=</operator> <literal type="string">"ELFOSABI_CLOUDABI"</literal></expr>,
<expr><index>[<expr><literal type="number">64</literal></expr>]</index> <operator>=</operator> <literal type="string">"ELFOSABI_ARM_AEABI"</literal></expr>,
<expr><index>[<expr><literal type="number">97</literal></expr>]</index> <operator>=</operator> <literal type="string">"ELFOSABI_ARM"</literal></expr>,
<expr><index>[<expr><literal type="number">255</literal></expr>]</index> <operator>=</operator> <literal type="string">"ELFOSABI_STANDALONE"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>elf_phdr_type_str</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_type</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"PT_NULL"</literal></expr>;</return>
<case>case <expr><name>PT_LOAD</name></expr>:</case> <return>return <expr><literal type="string">"PT_LOAD"</literal></expr>;</return>
<case>case <expr><name>PT_DYNAMIC</name></expr>:</case> <return>return <expr><literal type="string">"PT_DYNAMIC"</literal></expr>;</return>
<case>case <expr><name>PT_INTERP</name></expr>:</case> <return>return <expr><literal type="string">"PT_INTERP"</literal></expr>;</return>
<case>case <expr><name>PT_NOTE</name></expr>:</case> <return>return <expr><literal type="string">"PT_NOTE"</literal></expr>;</return>
<case>case <expr><name>PT_SHLIB</name></expr>:</case> <return>return <expr><literal type="string">"PT_SHLIB"</literal></expr>;</return>
<case>case <expr><name>PT_PHDR</name></expr>:</case> <return>return <expr><literal type="string">"PT_PHDR"</literal></expr>;</return>
<case>case <expr><name>PT_TLS</name></expr>:</case> <return>return <expr><literal type="string">"PT_TLS"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_EH_FRAME</name></expr>:</case> <return>return <expr><literal type="string">"PT_GNU_EH_FRAME"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_STACK</name></expr>:</case> <return>return <expr><literal type="string">"PT_GNU_STACK"</literal></expr>;</return>
<case>case <expr><name>PT_GNU_RELRO</name></expr>:</case> <return>return <expr><literal type="string">"PT_GNU_RELRO"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_RANDOMIZE</name></expr>:</case> <return>return <expr><literal type="string">"PT_OPENBSD_RANDOMIZE"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_WXNEEDED</name></expr>:</case> <return>return <expr><literal type="string">"PT_OPENBSD_WXNEEDED"</literal></expr>;</return>
<case>case <expr><name>PT_OPENBSD_BOOTDATA</name></expr>:</case> <return>return <expr><literal type="string">"PT_OPENBSD_BOOTDATA"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>p_flags</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"PF_X"</literal></expr>, <expr><literal type="string">"PF_W"</literal></expr>, <expr><literal type="string">"PF_X|PF_W"</literal></expr>, <expr><literal type="string">"PF_R"</literal></expr>, <expr><literal type="string">"PF_X|PF_R"</literal></expr>, <expr><literal type="string">"PF_W|PF_R"</literal></expr>,
<expr><literal type="string">"PF_X|PF_W|PF_R"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>sh_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ndx</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHN_UNDEF</name></expr>:</case> <return>return <expr><literal type="string">"UNDEF"</literal></expr>;</return>
<case>case <expr><name>SHN_ABS</name></expr>:</case> <return>return <expr><literal type="string">"ABS"</literal></expr>;</return>
<case>case <expr><name>SHN_COMMON</name></expr>:</case> <return>return <expr><literal type="string">"COMMON"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>ndx</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>ndx</name></expr>]</index></name><operator>.</operator><name>name</name><operator>)</operator></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>num</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>sh_types</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>sht</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>unknown_buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sht</name> <operator>&lt;</operator> <literal type="number">0x60000000</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_NULL</name></expr>:</case> <return>return <expr><literal type="string">"SHT_NULL"</literal></expr>;</return>
<case>case <expr><name>SHT_PROGBITS</name></expr>:</case> <return>return <expr><literal type="string">"SHT_PROGBITS"</literal></expr>;</return>
<case>case <expr><name>SHT_SYMTAB</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SYMTAB"</literal></expr>;</return>
<case>case <expr><name>SHT_STRTAB</name></expr>:</case> <return>return <expr><literal type="string">"SHT_STRTAB"</literal></expr>;</return>
<case>case <expr><name>SHT_RELA</name></expr>:</case> <return>return <expr><literal type="string">"SHT_RELA"</literal></expr>;</return>
<case>case <expr><name>SHT_HASH</name></expr>:</case> <return>return <expr><literal type="string">"SHT_HASH"</literal></expr>;</return>
<case>case <expr><name>SHT_DYNAMIC</name></expr>:</case> <return>return <expr><literal type="string">"SHT_DYNAMIC"</literal></expr>;</return>
<case>case <expr><name>SHT_NOTE</name></expr>:</case> <return>return <expr><literal type="string">"SHT_NOTE"</literal></expr>;</return>
<case>case <expr><name>SHT_NOBITS</name></expr>:</case> <return>return <expr><literal type="string">"SHT_NOBITS"</literal></expr>;</return>
<case>case <expr><name>SHT_REL</name></expr>:</case> <return>return <expr><literal type="string">"SHT_REL"</literal></expr>;</return>
<case>case <expr><name>SHT_SHLIB</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SHLIB"</literal></expr>;</return>
<case>case <expr><name>SHT_DYNSYM</name></expr>:</case> <return>return <expr><literal type="string">"SHT_DYNSYM"</literal></expr>;</return>
<case>case <expr><name>SHT_INIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"SHT_INIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_FINI_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"SHT_FINI_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_PREINIT_ARRAY</name></expr>:</case> <return>return <expr><literal type="string">"SHT_PREINIT_ARRAY"</literal></expr>;</return>
<case>case <expr><name>SHT_GROUP</name></expr>:</case> <return>return <expr><literal type="string">"SHT_GROUP"</literal></expr>;</return>
<case>case <expr><name>SHT_SYMTAB_SHNDX</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SYMTAB_SHNDX"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sht</name> <operator>&lt;</operator> <literal type="number">0x70000000</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x6ffffff0</literal></expr>:</case> <return>return <expr><literal type="string">"XXX:VERSYM"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_dof</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SUNW_dof"</literal></expr>;</return>
<case>case <expr><name>SHT_GNU_HASH</name></expr>:</case> <return>return <expr><literal type="string">"SHT_GNU_HASH"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffff7</literal></expr>:</case> <return>return <expr><literal type="string">"SHT_GNU_LIBLIST"</literal></expr>;</return>
<case>case <expr><literal type="number">0x6ffffffc</literal></expr>:</case> <return>return <expr><literal type="string">"XXX:VERDEF"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_verdef</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SUNW(GNU)_verdef"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_verneed</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SUNW(GNU)_verneed"</literal></expr>;</return>
<case>case <expr><name>SHT_SUNW_versym</name></expr>:</case> <return>return <expr><literal type="string">"SHT_SUNW(GNU)_versym"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>sht</name> <operator>&lt;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_ARM</name></expr>:</case>
<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_ARM_EXIDX</name></expr>:</case> <return>return <expr><literal type="string">"SHT_ARM_EXIDX"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_PREEMPTMAP</name></expr>:</case> <return>return <expr><literal type="string">"SHT_ARM_PREEMPTMAP"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_ATTRIBUTES</name></expr>:</case> <return>return <expr><literal type="string">"SHT_ARM_ATTRIBUTES"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_DEBUGOVERLAY</name></expr>:</case>
<return>return <expr><literal type="string">"SHT_ARM_DEBUGOVERLAY"</literal></expr>;</return>
<case>case <expr><name>SHT_ARM_OVERLAYSECTION</name></expr>:</case>
<return>return <expr><literal type="string">"SHT_ARM_OVERLAYSECTION"</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_IA_64</name></expr>:</case>
<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x70000000</literal></expr>:</case> <return>return <expr><literal type="string">"SHT_IA_64_EXT"</literal></expr>;</return>
<case>case <expr><literal type="number">0x70000001</literal></expr>:</case> <return>return <expr><literal type="string">"SHT_IA_64_UNWIND"</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>EM_MIPS</name></expr>:</case>
<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_MIPS_REGINFO</name></expr>:</case> <return>return <expr><literal type="string">"SHT_MIPS_REGINFO"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_OPTIONS</name></expr>:</case> <return>return <expr><literal type="string">"SHT_MIPS_OPTIONS"</literal></expr>;</return>
<case>case <expr><name>SHT_MIPS_ABIFLAGS</name></expr>:</case> <return>return <expr><literal type="string">"SHT_MIPS_ABIFLAGS"</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><name>sht</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x7ffffffd</literal></expr>:</case> <return>return <expr><literal type="string">"XXX:AUXILIARY"</literal></expr>;</return>
<case>case <expr><literal type="number">0x7fffffff</literal></expr>:</case> <return>return <expr><literal type="string">"XXX:FILTER"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>unknown_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unknown_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"&lt;unknown: %#llx&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>sht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>unknown_buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_SHFLAGS</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>DEFINE_SHF(WRITE) DEFINE_SHF(ALLOC) DEFINE_SHF(EXECINSTR) DEFINE_SHF(MERGE) DEFINE_SHF(STRINGS) DEFINE_SHF(INFO_LINK) DEFINE_SHF(LINK_ORDER) DEFINE_SHF(OS_NONCONFORMING) DEFINE_SHF(GROUP) DEFINE_SHF(TLS) DEFINE_SHF(COMPRESSED)</cpp:value></cpp:define>












<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFINE_SHF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_SHF</name><parameter_list>(<parameter><type><name>F</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>"SHF_" #F "|"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLSHFLAGS</name></cpp:macro> <cpp:value>DEFINE_SHFLAGS()</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>sh_flags</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>shf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>flg</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ALLSHFLAGS</name></expr></argument>)</argument_list></sizeof><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>flg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFINE_SHF</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_SHF</name><parameter_list>(<parameter><type><name>N</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (shf &amp; SHF_##N) strcat(flg, "SHF_" #N "|");</cpp:value></cpp:define>



<macro><name>DEFINE_SHFLAGS</name><argument_list>()</argument_list></macro>

<expr_stmt><expr><name><name>flg</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>flg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>flg</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_type</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_type</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STT_NOTYPE</name></expr>:</case> <return>return <expr><literal type="string">"STT_NOTYPE"</literal></expr>;</return>
<case>case <expr><name>STT_OBJECT</name></expr>:</case> <return>return <expr><literal type="string">"STT_OBJECT"</literal></expr>;</return>
<case>case <expr><name>STT_FUNC</name></expr>:</case> <return>return <expr><literal type="string">"STT_FUNC"</literal></expr>;</return>
<case>case <expr><name>STT_SECTION</name></expr>:</case> <return>return <expr><literal type="string">"STT_SECTION"</literal></expr>;</return>
<case>case <expr><name>STT_FILE</name></expr>:</case> <return>return <expr><literal type="string">"STT_FILE"</literal></expr>;</return>
<case>case <expr><name>STT_COMMON</name></expr>:</case> <return>return <expr><literal type="string">"STT_COMMON"</literal></expr>;</return>
<case>case <expr><name>STT_TLS</name></expr>:</case> <return>return <expr><literal type="string">"STT_TLS"</literal></expr>;</return>
<case>case <expr><literal type="number">13</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>mach</name> <operator>==</operator> <name>EM_SPARCV9</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"STT_SPARC_REGISTER"</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_type_S</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_type</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STT_NOTYPE</name></expr>:</case> <return>return <expr><literal type="string">"NOTY"</literal></expr>;</return>
<case>case <expr><name>STT_OBJECT</name></expr>:</case> <return>return <expr><literal type="string">"OBJT"</literal></expr>;</return>
<case>case <expr><name>STT_FUNC</name></expr>:</case> <return>return <expr><literal type="string">"FUNC"</literal></expr>;</return>
<case>case <expr><name>STT_SECTION</name></expr>:</case> <return>return <expr><literal type="string">"SECT"</literal></expr>;</return>
<case>case <expr><name>STT_FILE</name></expr>:</case> <return>return <expr><literal type="string">"FILE"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_type</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_type</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>s_type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_bindings</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_sbind</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sbind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STB_LOCAL</name></expr>:</case> <return>return <expr><literal type="string">"STB_LOCAL"</literal></expr>;</return>
<case>case <expr><name>STB_GLOBAL</name></expr>:</case> <return>return <expr><literal type="string">"STB_GLOBAL"</literal></expr>;</return>
<case>case <expr><name>STB_WEAK</name></expr>:</case> <return>return <expr><literal type="string">"STB_WEAK"</literal></expr>;</return>
<case>case <expr><name>STB_GNU_UNIQUE</name></expr>:</case> <return>return <expr><literal type="string">"STB_GNU_UNIQUE"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOOS</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"OS"</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOPROC</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIPROC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"PROC"</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_sbind</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_sbind</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;unknown: %#x&gt;"</literal></expr></argument>,
<argument><expr><name>sbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_sbind</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>st_bindings_S</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>sbind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>s_sbind</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sbind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STB_LOCAL</name></expr>:</case> <return>return <expr><literal type="string">"LOCL"</literal></expr>;</return>
<case>case <expr><name>STB_GLOBAL</name></expr>:</case> <return>return <expr><literal type="string">"GLOB"</literal></expr>;</return>
<case>case <expr><name>STB_WEAK</name></expr>:</case> <return>return <expr><literal type="string">"WEAK"</literal></expr>;</return>
<case>case <expr><name>STB_GNU_UNIQUE</name></expr>:</case> <return>return <expr><literal type="string">"UNIQ"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOOS</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIOS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"OS"</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>sbind</name> <operator>&gt;=</operator> <name>STB_LOPROC</name> <operator>&amp;&amp;</operator> <name>sbind</name> <operator>&lt;=</operator> <name>STB_HIPROC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"PROC"</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>s_sbind</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s_sbind</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt;%#x&gt;"</literal></expr></argument>,
<argument><expr><name>sbind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>s_sbind</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>st_others</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="char">'D'</literal></expr>, <expr><literal type="char">'I'</literal></expr>, <expr><literal type="char">'H'</literal></expr>, <expr><literal type="char">'P'</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_ehdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_phdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_shdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_symtab</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_symtabs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_symver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_verdef</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_verneed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_interp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_dynamic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_rel_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rel_entry</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_rela</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_rel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_reloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_got</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_got_section</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_svr4_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_svr4_hash64</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_gnu_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_checksum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_gotrel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rel_entry</name></name> <modifier>*</modifier></type><name>got</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>spec_name</name></name> <modifier>*</modifier></type><name>find_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_ent_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ent_count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_symbol_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_string</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strtab</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_versym</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>vs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nvs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unload_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ac_detect_ar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ac_print_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elf_print_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>elfdump_longopts</name><index>[]</index></name> <init>=
<expr><block>{
<expr><block>{ <expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'H'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ac</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl>, <decl><type ref="prev"/><name>ed_storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>spec_name</name></name> <modifier>*</modifier></type><name>sn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ed</name> <operator>=</operator> <operator>&amp;</operator><name>ed_storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><literal type="string">"acdeiGHhknN:prsSvVw:"</literal></expr></argument>,
<argument><expr><name>elfdump_longopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>ED_ALL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_SHDR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_DYN</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_EHDR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_INTERP</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_GOT</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_HASH</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_CHECKSUM</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_NOTE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_PHDR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_REL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_SYMTAB</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SOLARIS_FMT</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>|=</operator> <name>ED_SYMVER</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>elftc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>out</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch></block_content></block></while>

<expr_stmt><expr><name>ac</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>av</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>ED_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_SYMTAB</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>sn</name> <operator>=</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><literal type="string">"ARSYM"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PRINT_ARSYM</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><name>spec_name</name></expr></argument>, <argument><expr><name>sn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ONLY_ARSYM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PRINT_FILENAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"ELF library initialization failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ac</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name><name>av</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>archive</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_object</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>


<struct>struct <name>arsym_entry</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sym_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>off</name></decl>;</decl_stmt>
}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AC</name><parameter_list>(<parameter><type><name>CALL</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((CALL)) { warnx("%s", archive_error_string(a)); return; } } while (0)</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <name>int</name></type>
<name>ac_detect_ar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <call><name>archive_read_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>archive_read_support_format_ar</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_read_open_fd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">10240</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>archive_read_close</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>r</name> <operator>==</operator> <name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>ac_print_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>arsym_entry</name></name> <modifier>*</modifier></type><name>arsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"lseek failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>a</name> <operator>=</operator> <call><name>archive_read_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>archive_error_string</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>archive_read_support_format_ar</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AC</name><argument_list>(<argument><expr><call><name>archive_read_open_fd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">10240</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>ARCHIVE_FATAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>archive_error_string</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>ARCHIVE_EOF</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>ARCHIVE_WARN</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>ARCHIVE_RETRY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>archive_error_string</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>ARCHIVE_RETRY</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>archive_entry_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buff</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_read_data</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>archive_error_string</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PRINT_ARSYM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>be32dec</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arsym</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>arsym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arsym</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name> <operator>=</operator> <call><name>be32dec</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sym_name</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nSymbol Table: (archive)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index offset symbol\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nsymbol table (archive):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"0x%8.8jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sym_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\toffset: %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsymbol: %s\n"</literal></expr></argument>,
<argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sym_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>arsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ONLY_ARSYM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>AC</name><argument_list>(<argument><expr><call><name>archive_read_close</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AC</name><argument_list>(<argument><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <call><name>elf_memory</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_memroy() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ELF_K_ELF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s(%s):\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_elf</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>AC</name><argument_list>(<argument><expr><call><name>archive_read_close</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AC</name><argument_list>(<argument><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_ar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arsym</name> <modifier>*</modifier></type><name>arsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Cmd</name></type> <name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">21</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name> <operator>=</operator> <name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PRINT_ARSYM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arsym</name> <operator>=</operator> <call><name>elf_getarsym</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarsym failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>print_members</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>print_members</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nSymbol Table: (archive)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index offset member name and symbol\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nsymbol table (archive):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>elf_rand</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rand failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arh</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarhdr failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%zu]"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"0x%8.8jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"(%s):%s\n"</literal></expr></argument>, <argument><expr><name><name>arh</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>,
<argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %zu\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\toffset: %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tmember: %s\n"</literal></expr></argument>, <argument><expr><name><name>arh</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsymbol: %s\n"</literal></expr></argument>, <argument><expr><name><name>arsym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>as_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ONLY_ARSYM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<label><name>print_members</name>:</label>


<if_stmt><if>if <condition>(<expr><call><name>elf_rand</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>, <argument><expr><name>SARMAG</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SARMAG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rand failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>ELF_C_READ</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ar</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ELF_K_ELF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arh</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getarhdr failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s(%s):\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name><name>arh</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_elf</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>elf_next</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_object</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"open %s failed"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>ac_detect_ar</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>archive</name></name> <operator>=</operator> <name><name>ed</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ac_print_ar</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELF_K_NONE</name></expr>:</case>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Not an ELF file."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>ELF_K_ELF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PRINT_FILENAME</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s:\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>elf_print_elf</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ELF_K_AR</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBARCHIVE_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>archive</name></name> <operator>=</operator> <name><name>ed</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_ar</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Internal: libelf returned unknown elf kind."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getehdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>=</operator> <call><name>gelf_getclass</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>ELFCLASSNONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getclass failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <operator>(</operator><name>ED_SHDR</name> <operator>|</operator> <name>ED_DYN</name> <operator>|</operator> <name>ED_REL</name> <operator>|</operator> <name>ED_GOT</name> <operator>|</operator> <name>ED_SYMTAB</name> <operator>|</operator>
<name>ED_SYMVER</name> <operator>|</operator> <name>ED_NOTE</name> <operator>|</operator> <name>ED_HASH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>load_sections</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_EHDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_ehdr</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_PHDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_phdr</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_INTERP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_interp</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_SHDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_shdr</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_DYN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_dynamic</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_REL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_reloc</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_GOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_got</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_SYMTAB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_symtabs</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_SYMVER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_symver</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_NOTE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_note</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_HASH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_hash</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>ED_CHECKSUM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_checksum</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>unload_sections</name><argument_list>(<argument><expr><name>ed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>sh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>shstrndx</name></decl>, <decl><type ref="prev"/><name>ndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshnum</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getshnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshstrndx</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shstrndx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getshstrndx failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getscn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getshdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>shstrndx</name></expr></argument>, <argument><expr><name><name>sh</name><operator>.</operator><name>sh_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"ERROR"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ndx</name> <operator>=</operator> <call><name>elf_ndxscn</name><argument_list>(<argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_ndxscn failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section index of '%s' out of range"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>ndx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name> <operator>=</operator> <name>scn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>off</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_addralign</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name> <operator>=</operator> <name><name>sh</name><operator>.</operator><name>sh_info</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_nextscn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>unload_sections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>spec_name</name></name> <modifier>*</modifier></type><name>sn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sn</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>sn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>, <argument><expr><name>sn</name></expr></argument>, <argument><expr><name>sn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>spec_name</name></name> <modifier>*</modifier></type>
<name>find_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>spec_name</name></name> <modifier>*</modifier></type><name>sn</name></decl>;</decl_stmt>

<macro><name>STAILQ_FOREACH</name><argument_list>(<argument>sn</argument>, <argument>&amp;ed-&gt;snl</argument>, <argument>sn_list</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>sn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>sn</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_symbol_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>symtab</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>sname</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>symtab</name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>symtab</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_SYMTAB</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_DYNSYM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>sym</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STT_SECTION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s (section)"</literal></expr></argument>,
<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>sname</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>sym</name><operator>.</operator><name>st_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>get_string</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strtab</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">""</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_ehdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nELF Header\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" ei_magic: { %#x, %c, %c, %c }\n"</literal></expr></argument>,
<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" ei_class: %-18s"</literal></expr></argument>,
<argument><expr><call><name>elf_class_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" ei_data: %s\n"</literal></expr></argument>,
<argument><expr><call><name>elf_data_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_machine: %-18s"</literal></expr></argument>, <argument><expr><call><name>e_machines</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_version: %s\n"</literal></expr></argument>,
<argument><expr><call><name>elf_version_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_type: %s\n"</literal></expr></argument>, <argument><expr><call><name>elf_type_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_flags: %18d\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_entry: %#18jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_ehsize: %6d"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_shstrndx:%5d\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_shoff: %#18jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_shentsize: %3d"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_shnum: %5d\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_phoff: %#18jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_phentsize: %3d"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" e_phnum: %5d\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nelf header:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_ident: %s %s %s\n"</literal></expr></argument>,
<argument><expr><call><name>elf_class_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_data_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ei_abis</name><index>[<expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_type: %s\n"</literal></expr></argument>, <argument><expr><call><name>elf_type_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_machine: %s\n"</literal></expr></argument>, <argument><expr><call><name>e_machines</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_version: %s\n"</literal></expr></argument>, <argument><expr><call><name>elf_version_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_entry: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_phoff: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_shoff: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_flags: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_ehsize: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_phentsize: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_phnum: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_shentsize: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_shnum: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\te_shstrndx: %u\n"</literal></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_phdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Phdr</name></type> <name>ph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>phnum</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elf_getphnum</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>header</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>phnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ph</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>ph</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><call><name>elf_phdr_type_str</name><argument_list>(<argument><expr><name><name>ph</name><operator>.</operator><name>p_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nProgram Header[%zu]:\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_vaddr: %#-14jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_flags: [ %s ]\n"</literal></expr></argument>,
<argument><expr><name><name>p_flags</name><index>[<expr><name><name>ph</name><operator>.</operator><name>p_flags</name></name> <operator>&amp;</operator> <literal type="number">0x7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_paddr: %#-14jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_paddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_type: [ %s ]\n"</literal></expr></argument>,
<argument><expr><call><name>elf_phdr_type_str</name><argument_list>(<argument><expr><name><name>ph</name><operator>.</operator><name>p_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_filesz: %#-14jx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_filesz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_memsz: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_memsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_offset: %#-14jx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" p_align: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>header</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nprogram header:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"entry: %zu\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_type: %s\n"</literal></expr></argument>, <argument><expr><call><name>elf_phdr_type_str</name><argument_list>(<argument><expr><name><name>ph</name><operator>.</operator><name>p_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_offset: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_vaddr: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_paddr: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_paddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_filesz: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_filesz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_memsz: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_memsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_flags: %s\n"</literal></expr></argument>, <argument><expr><name><name>p_flags</name><index>[<expr><name><name>ph</name><operator>.</operator><name>p_flags</name></name> <operator>&amp;</operator> <literal type="number">0x7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tp_align: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>ph</name><operator>.</operator><name>p_align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_shdr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nsection header:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nSection Header[%zu]:"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_name: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_addr: %#-14jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_flags: [ %s ]\n"</literal></expr></argument>, <argument><expr><call><name>sh_flags</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_flags: 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_size: %#-14jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_type: [ %s ]\n"</literal></expr></argument>,
<argument><expr><call><name>sh_types</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_offset: %#-14jx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_entsize: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_link: %-14u"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_info: %u\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" sh_addralign: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"entry: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_name: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_type: %s\n"</literal></expr></argument>,
<argument><expr><call><name>sh_types</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_flags: %s\n"</literal></expr></argument>, <argument><expr><call><name>sh_flags</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_addr: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_offset: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_size: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_link: %u\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_info: %u\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_addralign: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>align</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tsh_entsize: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ent_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ent_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section %s has entry size 0"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"section %s has invalid section count"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ent_count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sz</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_versym</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>vs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nvs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_versym</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>vs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>vs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>vs</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nvs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nvs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_symtab</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>vs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>nvs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nSymbol Table Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nsymbol table (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nvs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index value "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index value "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"size type bind oth ver shndx name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_versym</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vs</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nvs</name> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"#symbol not equal to #versym"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>sym</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getsym failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>sym</name><operator>.</operator><name>st_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"0x%8.8jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"0x%8.8jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"0x%12.12jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>st_type_S</name><argument_list>(<argument><expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>st_bindings_S</name><argument_list>(<argument><expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%c "</literal></expr></argument>, <argument><expr><name><name>st_others</name><index>[<expr><name><name>sym</name><operator>.</operator><name>st_other</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%3u "</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>vs</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>vs</name><index>[<expr><name>j</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-11.11s "</literal></expr></argument>, <argument><expr><call><name>sh_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %d\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tst_name: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tst_value: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tst_size: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tst_info: %s %s\n"</literal></expr></argument>,
<argument><expr><call><name>st_type</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>,
<argument><expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>st_bindings</name><argument_list>(<argument><expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tst_shndx: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>sym</name><operator>.</operator><name>st_shndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_symtabs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>SHT_SYMTAB</name> <operator>||</operator>
<name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>SHT_DYNSYM</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_symtab</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_dynamic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Dyn</name></type> <name>dyn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_DYNAMIC</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"Dynamic Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index tag value\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\ndynamic:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getdyn</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dyn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dyn</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getdyn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s %-16s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>d_tags</name><argument_list>(<argument><expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"entry: %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\td_tag: %s\n"</literal></expr></argument>, <argument><expr><call><name>d_tags</name><argument_list>(<argument><expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<switch>switch<condition>(<expr><name><name>dyn</name><operator>.</operator><name>d_tag</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NEEDED</name></expr>:</case>
<case>case <expr><name>DT_SONAME</name></expr>:</case>
<case>case <expr><name>DT_RPATH</name></expr>:</case>
<case>case <expr><name>DT_RUNPATH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
<argument><expr><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%#-16jx %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\td_val: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case>
<case>case <expr><name>DT_RELA</name></expr>:</case>
<case>case <expr><name>DT_RELASZ</name></expr>:</case>
<case>case <expr><name>DT_RELAENT</name></expr>:</case>
<case>case <expr><name>DT_RELACOUNT</name></expr>:</case>
<case>case <expr><name>DT_STRSZ</name></expr>:</case>
<case>case <expr><name>DT_SYMENT</name></expr>:</case>
<case>case <expr><name>DT_RELSZ</name></expr>:</case>
<case>case <expr><name>DT_RELENT</name></expr>:</case>
<case>case <expr><name>DT_PLTREL</name></expr>:</case>
<case>case <expr><name>DT_VERDEF</name></expr>:</case>
<case>case <expr><name>DT_VERDEFNUM</name></expr>:</case>
<case>case <expr><name>DT_VERNEED</name></expr>:</case>
<case>case <expr><name>DT_VERNEEDNUM</name></expr>:</case>
<case>case <expr><name>DT_VERSYM</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\td_val: %ju\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_PLTGOT</name></expr>:</case>
<case>case <expr><name>DT_HASH</name></expr>:</case>
<case>case <expr><name>DT_GNU_HASH</name></expr>:</case>
<case>case <expr><name>DT_STRTAB</name></expr>:</case>
<case>case <expr><name>DT_SYMTAB</name></expr>:</case>
<case>case <expr><name>DT_INIT</name></expr>:</case>
<case>case <expr><name>DT_FINI</name></expr>:</case>
<case>case <expr><name>DT_REL</name></expr>:</case>
<case>case <expr><name>DT_JMPREL</name></expr>:</case>
<case>case <expr><name>DT_DEBUG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\td_ptr: %#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>dyn</name><operator>.</operator><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NULL</name></expr>:</case>
<case>case <expr><name>DT_SYMBOLIC</name></expr>:</case>
<case>case <expr><name>DT_TEXTREL</name></expr>:</case>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_rel_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>j</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>rel_entry</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" %-23s "</literal></expr></argument>, <argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>,
<argument><expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%#12jx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10jd "</literal></expr></argument>, <argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rela</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-14s "</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>symn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"entry: %d\n"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tr_offset: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tr_info: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator>
<call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><call><name>ELF64_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ELF64_R_TYPE</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tr_info: %#jx\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tr_addend: %jd\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>r</name><operator>-&gt;</operator><name>u_r</name><operator>.</operator><name>rela</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_rela</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rel_entry</name></name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nRelocation Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" type offset "</literal>
<literal type="string">"addend section with respect to\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nrelocation with addend (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>SHT_RELA</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrela</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rela</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rela</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrela failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>symn</name></name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
<argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_rel_entry</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_rel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rel_entry</name></name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nRelocation Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" type offset "</literal>
<literal type="string">"section with respect to\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nrelocation (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>SHT_REL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrel</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrel failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>symn</name></name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
<argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_print_rel_entry</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_reloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_REL</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_RELA</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_REL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_rel</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_rela</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_interp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Phdr</name></type> <name>phdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>filesize</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>phnum</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><literal type="string">"PT_INTERP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>elf_rawfile</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filesize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawfile failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getphnum</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phnum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphnum failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>phnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>phdr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getphdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>==</operator> <name>PT_INTERP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>&gt;=</operator> <name>filesize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid phdr offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\ninterp:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t%s\n"</literal></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>phdr</name><operator>.</operator><name>p_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_gotrel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>gs</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rel_entry</name></name> <modifier>*</modifier></type><name>got</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rel_entry</name></name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_REL</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>SHT_RELA</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rel_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_REL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrel</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
<operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrel failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrela</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rela</name></name></expr></argument>)</argument_list></call> <operator>!=</operator>
<operator>&amp;</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rela</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getrel failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>&gt;=</operator> <name><name>gs</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator>
<name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>&lt;</operator> <name><name>gs</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>gs</name><operator>-&gt;</operator><name>sz</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>symn</name></name> <operator>=</operator> <call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
<argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name><name>r</name><operator>.</operator><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>-</operator> <name><name>gs</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator> <operator>/</operator>
<name><name>gs</name><operator>-&gt;</operator><name>entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>got</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rel_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_got_section</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rel_entry</name></name> <modifier>*</modifier></type><name>got</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>align</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>align</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nGlobal Offset Table Section: %s (%d entries)\n"</literal></expr></argument>,
<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nglobal offset table: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name>ELF_T_WORD</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name>ELF_T_XWORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_xlatetom</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator>
<operator>&amp;</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_xlatetom failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dst</name><operator>.</operator><name>d_size</name></name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name>got</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rel_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>find_gotrel</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" ndx addr value reloc "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"addend symbol\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" ndx addr value "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"reloc addend symbol\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"[%5.5d] "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-8.8jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-8.8x "</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>dst</name><operator>.</operator><name>d_buf</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-16.16jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <name><name>s</name><operator>-&gt;</operator><name>entsize</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-16.16jx "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>dst</name><operator>.</operator><name>d_buf</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-18s "</literal></expr></argument>, <argument><expr><call><name>elftc_reloc_type_str</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>,
<argument><expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u_r</name><operator>.</operator><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-8.8jd "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u_r</name><operator>.</operator><name>rela</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-12.12jd "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u_r</name><operator>.</operator><name>rela</name><operator>.</operator><name>r_addend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symn</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>got</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>symn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t%#x\n"</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>dst</name><operator>.</operator><name>d_buf</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t%#jx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name><name>dst</name><operator>.</operator><name>d_buf</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_got</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".got"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_got_section</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Note</name> <modifier>*</modifier></type><name>en</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>namesz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>descsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_NOTE</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">".note.ABI-tag"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nNote Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nnote (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Note</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>en</name> <operator>=</operator> <operator>(</operator><name>Elf_Note</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namesz</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>n_namesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>descsz</name> <operator>=</operator> <name><name>en</name><operator>-&gt;</operator><name>n_descsz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Note</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Note</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>roundup2</name><argument_list>(<argument><expr><name>namesz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>descsz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"truncated note section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n type %#x\n"</literal></expr></argument>, <argument><expr><name><name>en</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" namesz %#x:\n"</literal></expr></argument>, <argument><expr><name><name>en</name><operator>-&gt;</operator><name>n_namesz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t%s "</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>namesz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>namesz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" descsz %#x:"</literal></expr></argument>, <argument><expr><name><name>en</name><operator>-&gt;</operator><name>n_descsz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>descsz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0xF</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"desc[%d]"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n %-9s"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">0x3</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" %2.2x"</literal></expr></argument>, <argument><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2MSB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>be32dec</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>le32dec</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>src</name> <operator>+=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>descsz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name>descsz</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_svr4_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nHash Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nhash table (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nbucket</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nchain</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator>
<operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>nbucket</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>nchain</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>nbucket</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" bucket symndx name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10d "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10u buckets contain %8d symbols\n"</literal></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10u buckets %8u symbols (globals)\n"</literal></expr></argument>, <argument><expr><name>nbucket</name></expr></argument>,
<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nnbucket: %u\n"</literal></expr></argument>, <argument><expr><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"nchain: %u\n\n"</literal></expr></argument>, <argument><expr><name>nchain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"bucket[%d]:\n\t%u\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"chain[%d]:\n\t%u\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>chain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_svr4_hash64</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>elferr</name></decl>, <decl><type ref="prev"/><name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nHash Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nhash table (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>






<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_rawdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name>ELF_T_XWORD</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_xlatetom</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>dst</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_xlatetom failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>.</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>dst</name><operator>.</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nbucket</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>nchain</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dst</name><operator>.</operator><name>d_size</name></name> <operator>!=</operator> <operator>(</operator><name>nbucket</name> <operator>+</operator> <name>nchain</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <name>nbucket</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" bucket symndx name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name><name>chain</name><index>[<expr><name>j</name></expr>]</index></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10zu "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%zu]"</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10ju buckets contain %8zu symbols\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10ju buckets %8ju symbols (globals)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>nbucket</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nnbucket: %ju\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"nchain: %ju\n\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name>nchain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"bucket[%zu]:\n\t%ju\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"chain[%zu]:\n\t%ju\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator><name><name>chain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>

</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_gnu_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bucket</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nbucket</name></decl>, <decl><type ref="prev"/><name>nchain</name></decl>, <decl><type ref="prev"/><name>symndx</name></decl>, <decl><type ref="prev"/><name>maskwords</name></decl>, <decl><type ref="prev"/><name>shift2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"/><name>maxl</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>dynsymcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nGNU Hash Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\ngnu hash table (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">".gnu.hash section too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbucket</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symndx</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>maskwords</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shift2</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name> <operator>&gt;=</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .gnu.hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ent_count</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dynsymcount</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>symndx</name> <operator>&gt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>dynsymcount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .gnu.hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nchain</name> <operator>=</operator> <name>dynsymcount</name> <operator>-</operator> <name>symndx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>!=</operator> <literal type="number">4</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>maskwords</name> <operator>*</operator>
<operator>(</operator><ternary><condition><expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator> <operator>+</operator>
<operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>nbucket</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>nchain</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"Malformed .gnu.hash section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bucket</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>ed</name><operator>-&gt;</operator><name>ec</name></name> <operator>==</operator> <name>ELFCLASS32</name></expr> ?</condition><then> <expr><name>maskwords</name></expr> </then><else>: <expr><name>maskwords</name> <operator>*</operator> <literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>chain</name> <operator>=</operator> <name>bucket</name> <operator>+</operator> <name>nbucket</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>nbucket</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>-</operator> <name>symndx</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxl</name> <operator>=</operator> <name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chain</name><index>[<expr><name>j</name> <operator>-</operator> <name>symndx</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>maxl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>bl</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" bucket symndx name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>-</operator> <name>symndx</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10d "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>get_symbol_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>chain</name><index>[<expr><name>j</name> <operator>-</operator> <name>symndx</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>maxl</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10u buckets contain %8d symbols\n"</literal></expr></argument>, <argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10u buckets %8u symbols (globals)\n"</literal></expr></argument>, <argument><expr><name>nbucket</name></expr></argument>,
<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nnbucket: %u\n"</literal></expr></argument>, <argument><expr><name>nbucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"symndx: %u\n"</literal></expr></argument>, <argument><expr><name>symndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"maskwords: %u\n"</literal></expr></argument>, <argument><expr><name>maskwords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"shift2: %u\n"</literal></expr></argument>, <argument><expr><name>shift2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"nchain: %u\n\n"</literal></expr></argument>, <argument><expr><name>nchain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbucket</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"bucket[%d]:\n\t%u\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bucket</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchain</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"chain[%d]:\n\t%u\n\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>chain</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_HASH</name> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_GNU_HASH</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_GNU_HASH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_gnu_hash</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ALPHA</name> <operator>&amp;&amp;</operator>
<name><name>s</name><operator>-&gt;</operator><name>entsize</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_svr4_hash64</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_svr4_hash</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_verdef</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Verdef</name> <modifier>*</modifier></type><name>vd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Verdaux</name> <modifier>*</modifier></type><name>vda</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"Version Definition Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nversion definition section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>data</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" index version dependency\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Verdef</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vd</name> <operator>=</operator> <operator>(</operator><name>Elf32_Verdef</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"[%d]"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_ndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%10s "</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_version: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_flags: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_ndx: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_ndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_cnt: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_hash: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_aux: %u\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_aux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvd_next: %u\n\n"</literal></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_aux</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf2</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Verdaux</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vda</name> <operator>=</operator> <operator>(</operator><name>Elf32_Verdaux</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vda</name><operator>-&gt;</operator><name>vda_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-26.26s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" %-20.20s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n%40.40s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\tvda: %d\n"</literal></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvda_name: %s\n"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvda_next: %u\n"</literal></expr></argument>, <argument><expr><name><name>vda</name><operator>-&gt;</operator><name>vda_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vda</name><operator>-&gt;</operator><name>vda_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd_flags</name></name> <operator>&amp;</operator> <name>VER_FLG_BASE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%-20.20s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"[ BASE ]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>vda</name><operator>-&gt;</operator><name>vda_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>vd</name><operator>-&gt;</operator><name>vd_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_verneed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Verneed</name> <modifier>*</modifier></type><name>vn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Vernaux</name> <modifier>*</modifier></type><name>vna</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buf2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>elferr</name></decl>, <decl><type ref="prev"/><name>first</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nVersion Needed Section: %s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nversion need section (%s):\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>scn</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elferr</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elferr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getdata failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>elferr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>data</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" file version\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Verneed</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vn</name> <operator>=</operator> <operator>(</operator><name>Elf32_Verneed</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">" %-26.26s "</literal></expr></argument>,
<argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nentry: %d\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvn_version: %u\n"</literal></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvn_cnt: %u\n"</literal></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvn_file: %s\n"</literal></expr></argument>,
<argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_file</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvn_aux: %u\n"</literal></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_aux</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\tvn_next: %u\n\n"</literal></expr></argument>, <argument><expr><name><name>vn</name><operator>-&gt;</operator><name>vn_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_aux</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>buf2</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Vernaux</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vna</name> <operator>=</operator> <operator>(</operator><name>Elf32_Vernaux</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>buf2</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ed</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SOLARIS_FMT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%40.40s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>,
<argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\tvna: %d\n"</literal></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvna_hash: %u\n"</literal></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvna_flags: %u\n"</literal></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvna_other: %u\n"</literal></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_other</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvna_name: %s\n"</literal></expr></argument>,
<argument><expr><call><name>get_string</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\t\t\tvna_next: %u\n"</literal></expr></argument>, <argument><expr><name><name>vna</name><operator>-&gt;</operator><name>vna_next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>vna</name><operator>-&gt;</operator><name>vna_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf2</name> <operator>+=</operator> <name><name>vna</name><operator>-&gt;</operator><name>vna_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>vn</name><operator>-&gt;</operator><name>vn_next</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>buf</name> <operator>+=</operator> <name><name>vn</name><operator>-&gt;</operator><name>vn_next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_symver</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ed</name><operator>-&gt;</operator><name>shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>sl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>find_name</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_verdef</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_verdef</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SHT_SUNW_verneed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elf_print_verneed</name><argument_list>(<argument><expr><name>ed</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>elf_print_checksum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfdump</name></name> <modifier>*</modifier></type><name>ed</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ed</name><operator>-&gt;</operator><name>snl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PRT</name><argument_list>(<argument><expr><literal type="string">"\nelf checksum: %#lx\n"</literal></expr></argument>, <argument><expr><call><name>gelf_checksum</name><argument_list>(<argument><expr><name><name>ed</name><operator>-&gt;</operator><name>elf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] file...\nDisplay information about ELF objects and ar(1) archives.\n\nOptions:\n-a Show all information.\n-c Show shared headers.\n-d Show dynamic symbols.\n-e Show the ELF header.\n-G Show the GOT.\n-H | --help Show a usage message and exit.\n-h Show hash values.\n-i Show the dynamic interpreter.\n-k Show the ELF checksum.\n-n Show the contents of note sections.\n-N NAME Show the section named \"NAME\".\n-p Show the program header.\n-r Show relocations.\n-s Show the symbol table.\n-S Use the Solaris elfdump format.\n-v Show symbol-versioning information.\n-V | --version Print a version identifier and exit.\n-w FILE Write output to \"FILE\".\n"</cpp:value></cpp:define>






















<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
