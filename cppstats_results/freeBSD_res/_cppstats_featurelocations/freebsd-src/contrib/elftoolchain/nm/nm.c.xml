<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/nm/nm.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;capsicum_helpers.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dwarf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libdwarf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelftc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libcasper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;casper/cap_fileargs.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"_elftc.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>ELFTC_VCSID</name><argument_list>(<argument><expr><literal type="string">"$Id: nm.c 3722 2019-03-23 17:01:58Z jkoshy $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>STAILQ_HEAD</name><argument_list>(<argument><expr><name>sym_head</name></expr></argument>, <argument><expr><name>sym_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct>struct <name>sym_entry</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>
<macro><name>STAILQ_ENTRY</name><argument_list>(<argument>sym_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>sym_entries</name></expr>;</expr_stmt>
}</block>;</struct>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>fn_sort</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>fn_elem_print</name>)<parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>fn_sym_print</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>fn_filter</name>)<parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>


<expr_stmt><expr><specifier>static</specifier> <macro><name>SLIST_HEAD</name><argument_list>(<argument>filter_head</argument>, <argument>filter_entry</argument>)</argument_list></macro> <name>nm_out_filter</name> <operator>=</operator>
<call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>nm_out_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct>struct <name>filter_entry</name> <block>{
<decl_stmt><decl><type><name>fn_filter</name></type> <name>fn</name></decl>;</decl_stmt>
<macro><name>SLIST_ENTRY</name><argument_list>(<argument>filter_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>filter_entries</name></expr>;</expr_stmt>
}</block>;</struct>

<struct>struct <name>sym_print_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type><name>headp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sh_num</name></decl>, <decl><type ref="prev"/><name>list_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t_table</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>s_table</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>filename</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>objname</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>nm_prog_info</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>def_filename</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>line_info_entry</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<macro><name>SLIST_ENTRY</name><argument_list>(<argument>line_info_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>entries</name></expr>;</expr_stmt>
}</block>;</struct>
<expr_stmt><expr><call><name>SLIST_HEAD</name><argument_list>(<argument><expr><name>line_info_head</name></expr></argument>, <argument><expr><name>line_info_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<struct>struct <name>func_info_entry</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>lowpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>highpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>line</name></decl>;</decl_stmt>
<macro><name>SLIST_ENTRY</name><argument_list>(<argument>func_info_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>entries</name></expr>;</expr_stmt>
}</block>;</struct>
<expr_stmt><expr><call><name>SLIST_HEAD</name><argument_list>(<argument><expr><name>func_info_head</name></expr></argument>, <argument><expr><name>func_info_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<struct>struct <name>var_info_entry</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>line</name></decl>;</decl_stmt>
<macro><name>SLIST_ENTRY</name><argument_list>(<argument>var_info_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>entries</name></expr>;</expr_stmt>
}</block>;</struct>
<expr_stmt><expr><call><name>SLIST_HEAD</name><argument_list>(<argument><expr><name>var_info_head</name></expr></argument>, <argument><expr><name>var_info_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<enum>enum <name>radix</name> <block>{
<decl><name>RADIX_OCT</name></decl>,
<decl><name>RADIX_HEX</name></decl>,
<decl><name>RADIX_DEC</name></decl>
}</block>;</enum>


<enum>enum <name>print_symbol</name> <block>{
<decl><name>PRINT_SYM_SYM</name></decl>,
<decl><name>PRINT_SYM_DYN</name></decl>
}</block>;</enum>


<enum>enum <name>print_name</name> <block>{
<decl><name>PRINT_NAME_NONE</name></decl>,
<decl><name>PRINT_NAME_FULL</name></decl>,
<decl><name>PRINT_NAME_MULTI</name></decl>
}</block>;</enum>

<struct>struct <name>nm_prog_options</name> <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>print_symbol</name></name></type> <name>print_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>print_name</name></name></type> <name>print_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>radix</name></name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>demangle_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>print_debug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>print_armap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>print_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>debug_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>def_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>undef_only</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sort_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>sort_reverse</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>no_demangle</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>fn_sort</name></type> <name>sort_fn</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>fn_elem_print</name></type> <name>elem_print_fn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>fn_sym_print</name></type> <name>value_print_fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fn_sym_print</name></type> <name>size_print_fn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>fileargs_t</name> <modifier>*</modifier></type><name>fileargs</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SYM_PRINT_DATA</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(p-&gt;headp == NULL || p-&gt;sh_num == 0 || p-&gt;t_table == NULL || p-&gt;s_table == NULL || p-&gt;filename == NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SYM_TYPE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t) == '?' || isalpha((t)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_UNDEF_SYM_TYPE</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t) == 'U' || (t) == 'v' || (t) == 'w')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)p)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_none</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmp_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>enter_cap_mode</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>filter_dest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>filter_insert</name><parameter_list>(<parameter><decl><type><name>fn_filter</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_opt</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_sym</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>get_sym_name</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>get_sym_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>global_dest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>global_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sec_data</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sec_debug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sec_nobits</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sec_readonly</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_sec_text</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_ar_index</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_elf</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Elf_Kind</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_files</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_opt_value_print_fn</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>radix</name></name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_def</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_global</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_global_static</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_nondebug</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_nonzero_size</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_elem_print_all</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_elem_print_all_portable</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_elem_print_all_sysv</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_elem_undef</name><parameter_list>(<parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_list_dest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sym_list_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_list_print</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_list_print_each</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>sym_list_sort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_size_oct_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_size_hex_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_size_dec_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_value_oct_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_value_hex_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sym_value_dec_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>nm_prog_info</name></name></type> <name>nm_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>nm_prog_options</name></name></type> <name>nm_opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nm_elfclass</name></decl>;</decl_stmt>







<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type><name>nm_print_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>nm_longopts</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"debug-syms"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'a'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"defined-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>nm_opts</name><operator>.</operator><name>def_only</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"demangle"</literal></expr>, <expr><name>optional_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'C'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"dynamic"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'D'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"extern-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'g'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'F'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"line-numbers"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'l'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"no-demangle"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>nm_opts</name><operator>.</operator><name>no_demangle</name></name></expr>,
<expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"no-sort"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"numeric-sort"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'v'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"print-armap"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"print-file-name"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'A'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"print-size"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"radix"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"reverse-sort"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'r'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"size-sort"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><operator>&amp;</operator><name><name>nm_opts</name><operator>.</operator><name>sort_size</name></name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{ <expr><literal type="string">"undefined-only"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'u'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFTC_NEED_BYTEORDER_EXTENSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>__inline</name> <name>uint32_t</name></type>
<name>be32dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>uint32_t</name></type>
<name>le32dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>uint64_t</name></type>
<name>be64dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>be32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>be32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>uint64_t</name></type>
<name>le64dec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <call><name>le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>sym_entry</name> <operator>*</operator><operator>)</operator><name>l</name><operator>)</operator><operator>-&gt;</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>sym_entry</name> <operator>*</operator><operator>)</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>sym_entry</name> <operator>*</operator><operator>)</operator><name>l</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>sym_entry</name> <operator>*</operator><operator>)</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_none</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>l</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>-</operator> <name><name>r</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_size</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ttable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l_is_undef</name></decl>, <decl><type ref="prev"/><name>r_is_undef</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nm_print_data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ttable</name> <operator>=</operator> <name><name>nm_print_data</name><operator>-&gt;</operator><name>t_table</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ttable</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l_is_undef</name> <operator>=</operator> <ternary><condition><expr><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><call><name>get_sym_type</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><name>ttable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>r_is_undef</name> <operator>=</operator> <ternary><condition><expr><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><call><name>get_sym_type</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><name>ttable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l_is_undef</name> <operator>+</operator> <name>r_is_undef</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>l_is_undef</name> <operator>+</operator> <name>r_is_undef</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>l_is_undef</name> <operator>+</operator> <name>r_is_undef</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>l</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>&gt;</operator> <name><name>r</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>l_is_undef</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>

<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>


<return>return <expr><operator>(</operator><name><name>l</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>-</operator> <name><name>r</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enter_cap_mode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>cap_rights_t</name></type> <name>rights</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fileargs_t</name> <modifier>*</modifier></type><name>fa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>defaultfn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cap_rights_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>CAP_FSTAT</name></expr></argument>, <argument><expr><name>CAP_MMAP_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>defaultfn</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>nm_info</name><operator>.</operator><name>def_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>defaultfn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name>defaultfn</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fa</name> <operator>=</operator> <call><name>fileargs_init</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>FA_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize fileargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>caph_cache_catpages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_limit_stdio</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to limit stdio rights"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_enter_casper</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to enter capability mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>fileargs</name></name> <operator>=</operator> <name>fa</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>filter_dest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>filter_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nm_out_filter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nm_out_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_REMOVE_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nm_out_filter</name></expr></argument>, <argument><expr><name>filter_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>filter_insert</name><parameter_list>(<parameter><decl><type><name>fn_filter</name></type> <name>filter_fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>filter_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>filter_fn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>filter_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>fn</name></name> <operator>=</operator> <name>filter_fn</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nm_out_filter</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>filter_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_demangle_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ELFTC_DEM_UNKNOWN</name><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"gnu-v2"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ELFTC_DEM_GNU2</name><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"gnu-v3"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ELFTC_DEM_GNU3</name><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ELFTC_DEM_ARM</name><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unknown demangling style '%s'"</literal></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_opt</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_posix</name></decl>, <decl><type ref="prev"/><name>oflag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argc</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oflag</name> <operator>=</operator> <name>is_posix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_HEX</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><operator>*</operator><name>argc</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>, <argument><expr><literal type="string">"ABCDF:PSVaefghlnoprst:uvx"</literal></expr></argument>,
<argument><expr><name>nm_longopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>=</operator> <name>PRINT_NAME_FULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_elem_print_all</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>demangle_type</name></name> <operator>=</operator> <call><name>parse_demangle_option</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>=</operator> <name>PRINT_SYM_DYN</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_elem_print_all</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>is_posix</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator>
<operator>&amp;</operator><name>sym_elem_print_all_portable</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator>
<operator>&amp;</operator><name>sym_elem_print_all_sysv</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: Invalid format"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<break>break;</break>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<expr_stmt><expr><name>is_posix</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_elem_print_all_portable</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_size</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_debug</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_global_static</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<break>break;</break>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>debug_line</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>cmp_value</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<expr_stmt><expr><name>oflag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>cmp_none</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_reverse</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_armap</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>optarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_DEC</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_OCT</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_HEX</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: Invalid radix"</literal></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_undef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>undef_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_HEX</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>sort_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>cmp_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_nonzero_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>def_only</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>no_demangle</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>demangle_type</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default :</default>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>oflag</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>is_posix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>RADIX_OCT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>=</operator> <name>PRINT_NAME_FULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"nm_opts.sort_fn is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<literal type="string">"nm_opts.elem_print_fn is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<literal type="string">"nm_opts.value_print_fn is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_opt_value_print_fn</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>undef_only</name></name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>==</operator> <operator>&amp;</operator><name>cmp_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"--size-sort with -u is meaningless"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>def_only</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"-u with --defined-only is meaningless"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_debug</name></name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>filter_insert</name><argument_list>(<argument><expr><name>sym_elem_nondebug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>sort_reverse</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>==</operator> <name>cmp_none</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_reverse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_sym</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type><name>headp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shnum</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dynndx</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>strndx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sec_table</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>sec_table_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>filter_entry</name></name> <modifier>*</modifier></type><name>fep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rtn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>filter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>elf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>headp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_getscn failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>shdr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getshdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_SYMTAB</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>!=</operator> <name>PRINT_SYM_SYM</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>shdr</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_DYNSYM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>!=</operator> <name>PRINT_SYM_DYN</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></else></if_stmt>

<expr_stmt><expr><name>ndx</name> <operator>=</operator> <ternary><condition><expr><name><name>shdr</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_DYNSYM</name></expr> ?</condition><then> <expr><name>dynndx</name></expr> </then><else>: <expr><name>strndx</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name><operator>++</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <call><name>get_sym_name</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>,
<argument><expr><name>sec_table</name></expr></argument>, <argument><expr><name>sec_table_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filter</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_sym_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>type_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>SLIST_FOREACH</name><argument_list>(<argument>fep</argument>, <argument>&amp;nm_out_filter</argument>,
<argument>filter_entries</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>fep</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>filter</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>filter</name> <operator>==</operator> <name>false</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>sym_list_insert</name><argument_list>(<argument><expr><name>headp</name></expr></argument>, <argument><expr><name>sym_name</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rtn</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></while>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>rtn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_sym_name</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ndx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sec_table</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>sec_table_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STT_SECTION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sec_table</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>&lt;</operator> <name>sec_table_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <name><name>sec_table</name><index>[<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sym_name</name> <operator>=</operator> <literal type="string">"(null)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>sym_name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name></type>
<name>get_sym_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>is_local</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>type_table</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="char">'?'</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>is_local</name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>==</operator> <name>STB_LOCAL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_ABS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><literal type="char">'a'</literal></expr> </then><else>: <expr><literal type="char">'A'</literal></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_COMMON</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="char">'C'</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>==</operator> <name>STB_WEAK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>==</operator> <name>STT_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_UNDEF</name></expr> ?</condition><then> <expr><literal type="char">'v'</literal></expr> </then><else>: <expr><literal type="char">'V'</literal></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_UNDEF</name></expr> ?</condition><then> <expr><literal type="char">'w'</literal></expr> </then><else>: <expr><literal type="char">'W'</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="char">'U'</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>is_local</name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <name><name>type_table</name><index>[<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name> <operator>!=</operator> <literal type="char">'N'</literal></expr> ?</condition><then>
<expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>type_table</name><index>[<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><name><name>type_table</name><index>[<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>global_dest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>filter_dest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>global_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_version error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>nm_info</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_info</name><operator>.</operator><name>def_filename</name></name> <operator>=</operator> <literal type="string">"a.out"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>=</operator> <name>PRINT_SYM_SYM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>=</operator> <name>PRINT_NAME_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>demangle_type</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_debug</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_armap</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>debug_line</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>def_only</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>undef_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_reverse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>no_demangle</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>cmp_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_elem_print_all</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_value_dec_print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_size_dec_print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>fileargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nm_out_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_sec_data</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"shdr is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_ALLOC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>!=</operator> <name>SHT_NOBITS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_sec_debug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>dbg_sec</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">".debug"</literal></expr>,
<expr><literal type="string">".gnu.linkonce.wi."</literal></expr>,
<expr><literal type="string">".line"</literal></expr>,
<expr><literal type="string">".rel.debug"</literal></expr>,
<expr><literal type="string">".rela.debug"</literal></expr>,
<expr><literal type="string">".stab"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>dbg_sec</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>shname</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>true</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_sec_nobits</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"shdr is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_NOBITS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_sec_readonly</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"shdr is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_WRITE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_sec_text</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"shdr is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_EXECINSTR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_ar_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>arf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arsym</name> <modifier>*</modifier></type><name>arsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Cmd</name></type> <name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arsym_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arsym</name> <operator>=</operator> <call><name>elf_getarsym</name><argument_list>(<argument><expr><name>arf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arsym_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nArchive index:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>arsym</name><operator>-&gt;</operator><name>as_off</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>ELF_C_READ</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>arsym_size</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>elf_rand</name><argument_list>(<argument><expr><name>arf</name></expr></argument>, <argument><expr><name><name>arsym</name><operator>-&gt;</operator><name>as_off</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>arsym</name><operator>-&gt;</operator><name>as_off</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>elf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arhdr</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s in %s\n"</literal></expr></argument>, <argument><expr><name><name>arsym</name><operator>-&gt;</operator><name>as_name</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
<expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr> </then><else>: <expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_rawname</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>arsym</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>arsym_size</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>elf_rand</name><argument_list>(<argument><expr><name>arf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEMANGLED_BUFFER_SIZE</name></cpp:macro> <cpp:value>(8 * 1024)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_DEMANGLED_NAME</name><parameter_list>(<parameter><type><name>FORMAT</name></type></parameter>, <parameter><type><name>NAME</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char _demangled[DEMANGLED_BUFFER_SIZE]; if (nm_opts.demangle_type &lt; 0 || elftc_demangle((NAME), _demangled, sizeof(_demangled), nm_opts.demangle_type) &lt; 0) printf((FORMAT), (NAME)); else printf((FORMAT), _demangled); } while (0)</cpp:value></cpp:define>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator> <operator>&amp;</operator><name>sym_elem_print_all_sysv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\n%s from %s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>nm_opts</name><operator>.</operator><name>undef_only</name></name> <operator>==</operator> <name>false</name></expr> ?</condition><then> <expr><literal type="string">"Symbols"</literal></expr> </then><else>:
<expr><literal type="string">"Undefined symbols"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%s]"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">":\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
Name Value Class Type Size Line Section\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>!=</operator> <name>PRINT_NAME_FULL</name> <operator>&amp;&amp;</operator> <name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator>
<name>sym_elem_print_all_portable</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s[%s]:\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator> <name>sym_elem_print_all</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s:\n"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>==</operator> <name>PRINT_NAME_MULTI</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator> <name>sym_elem_print_all</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><name><name>nm_info</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>elftc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>get_block_value</name><parameter_list>(<parameter><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Block</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>eh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_get_elf</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_get_elf failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eh</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>&amp;</operator><name>eh</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"gelf_getehdr failed: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>bl_len</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>eh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2LSB</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>le32dec</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>block</name><operator>-&gt;</operator><name>bl_data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>be32dec</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>block</name><operator>-&gt;</operator><name>bl_data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>block</name><operator>-&gt;</operator><name>bl_len</name></name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>eh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2LSB</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>le64dec</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>block</name><operator>-&gt;</operator><name>bl_data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>be64dec</name><argument_list>(<argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name><name>block</name><operator>-&gt;</operator><name>bl_data</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>find_object_name</name><parameter_list>(<parameter><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>ret_die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Attribute</name></type> <name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Off</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_string</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attr</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_specification</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_global_formref</name><argument_list>(<argument><expr><name>at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_offdie</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>find_object_name</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>search_line_attr</name><parameter_list>(<parameter><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type><name>func_info</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type><name>var_info</name></decl></parameter>, <parameter><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src_files</name></decl></parameter>,
<parameter><decl><type><name>Dwarf_Signed</name></type> <name>filecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Attribute</name></type> <name>at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>udata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Block</name> <modifier>*</modifier></type><name>block</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Bool</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>ret_die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>func_info_entry</name></name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>var_info_entry</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>!=</operator> <name>DW_TAG_subprogram</name> <operator>&amp;&amp;</operator> <name>tag</name> <operator>!=</operator> <name>DW_TAG_entry_point</name> <operator>&amp;&amp;</operator>
<name>tag</name> <operator>!=</operator> <name>DW_TAG_inlined_subroutine</name> <operator>&amp;&amp;</operator> <name>tag</name> <operator>!=</operator> <name>DW_TAG_variable</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cont_search</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_variable</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_flag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_artificial</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name> <operator>&amp;&amp;</operator> <name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cont_search</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_flag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_declaration</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name> <operator>&amp;&amp;</operator> <name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cont_search</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_flag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_external</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name> <operator>||</operator> <operator>!</operator><name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cont_search</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>var</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_decl_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name> <operator>&amp;&amp;</operator> <name>udata</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>Dwarf_Signed</name><operator>)</operator> <operator>(</operator><name>udata</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>filecount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>src_files</name><index>[<expr><name>udata</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_decl_line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>find_object_name</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attr</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_location</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name> <operator>&amp;&amp;</operator>
<call><name>dwarf_formblock</name><argument_list>(<argument><expr><name>at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name><name>block</name><operator>-&gt;</operator><name>bl_data</name></name><operator>)</operator> <operator>==</operator> <name>DW_OP_addr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <call><name>get_block_value</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>func</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>func</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_decl_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name> <operator>&amp;&amp;</operator> <name>udata</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>Dwarf_Signed</name><operator>)</operator> <operator>(</operator><name>udata</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>filecount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>src_files</name><index>[<expr><name>udata</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_decl_line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>find_object_name</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cont_search</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_low_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>lowpc</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_attrval_unsigned</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_AT_high_pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>func</name><operator>-&gt;</operator><name>highpc</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>cont_search</name>:</label>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_child</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_child: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>search_line_attr</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>src_files</name></expr></argument>,
<argument><expr><name>filecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret_die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_siblingof: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>search_line_attr</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>ret_die</name></expr></argument>, <argument><expr><name>src_files</name></expr></argument>,
<argument><expr><name>filecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dwarf_dealloc</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><name>DW_DLA_DIE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_elf</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>Elf_Kind</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Dwarf_Debug</name></type> <name>dbg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Die</name></type> <name>die</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Error</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Half</name></type> <name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Line</name> <modifier>*</modifier></type><name>lbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Unsigned</name></type> <name>lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Signed</name></type> <name>lcount</name></decl>, <decl><type ref="prev"/><name>filecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Dwarf_Addr</name></type> <name>lineaddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_print_data</name></name></type> <name>p_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_head</name></name></type> <name>list_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type><name>line_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type><name>func_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type><name>var_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>line_info_entry</name></name> <modifier>*</modifier></type><name>lie</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>func_info_entry</name></name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>var_info_entry</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>objname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_table</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>sec_table</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sfile</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>src_files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>shstrndx</name></decl>, <decl><type ref="prev"/><name>shnum</name></decl>, <decl><type ref="prev"/><name>dynndx</name></decl>, <decl><type ref="prev"/><name>strndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>rtn</name></decl>, <decl><type ref="prev"/><name>e_err</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OBJNAME</name></cpp:macro> <cpp:value>(objname == NULL ? filename : objname)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>filename</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"filename is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type_table</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sec_table</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>line_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>func_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>var_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>objname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dynndx</name> <operator>=</operator> <name>SHN_UNDEF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>strndx</name> <operator>=</operator> <name>SHN_UNDEF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>nm_elfclass</name> <operator>=</operator> <call><name>gelf_getclass</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>ELF_K_AR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arhdr</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next_cmd</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>objname</name> <operator>=</operator> <ternary><condition><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr> </then><else>:
<expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_rawname</name></name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshnum</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shnum</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_err</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>, <argument><expr><literal type="string">"File format not recognized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: cannot get section number"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>shnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: has no section"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshstrndx</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shstrndx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: cannot get str index"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type_table</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>shnum</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"%s: malloc"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sec_table</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>shnum</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"%s: calloc"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>type_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'U'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sec_table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"*UND*"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shnum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'U'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_err</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>e_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: cannot get section"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next_cmd</name>;</goto></block_content></block></if></if_stmt>




<expr_stmt><expr><name>shname</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>shstrndx</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>shdr</name><operator>.</operator><name>sh_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>shname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sec_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>shname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>shname</name></expr></argument>, <argument><expr><literal type="string">".dynstr"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dynndx</name> <operator>=</operator> <call><name>elf_ndxscn</name><argument_list>(<argument><expr><name>scn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dynndx</name> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: elf_ndxscn failed: %s"</literal></expr></argument>,
<argument><expr><name>OBJNAME</name></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>shname</name></expr></argument>, <argument><expr><literal type="string">".strtab"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>strndx</name> <operator>=</operator> <call><name>elf_ndxscn</name><argument_list>(<argument><expr><name>scn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>strndx</name> <operator>==</operator> <name>SHN_UNDEF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: elf_ndxscn failed: %s"</literal></expr></argument>,
<argument><expr><name>OBJNAME</name></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>sec_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"*UND*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sec_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>is_sec_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_sec_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_sec_readonly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'R'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_sec_nobits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_sec_debug</name><argument_list>(<argument><expr><name>shname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_sec_readonly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_sec_nobits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>print_header</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dynndx</name> <operator>==</operator> <name>SHN_UNDEF</name> <operator>&amp;&amp;</operator> <name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>==</operator> <name>PRINT_SYM_DYN</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>strndx</name> <operator>==</operator> <name>SHN_UNDEF</name> <operator>&amp;&amp;</operator> <name><name>nm_opts</name><operator>.</operator><name>print_symbol</name></name> <operator>==</operator> <name>PRINT_SYM_SYM</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: no symbols"</literal></expr></argument>, <argument><expr><name>OBJNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>next_cmd</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nm_opts</name><operator>.</operator><name>debug_line</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>process_sym</name>;</goto></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>dwarf_elf_init</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>DW_DLC_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_elf_init failed: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>process_sym</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line_info</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>line_info_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func_info</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>func_info_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>var_info</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>var_info_head</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INIT</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>func_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INIT</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>var_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INIT</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>line_info</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>func_info</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>var_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dwarf_finish</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>process_sym</name>;</goto>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>dwarf_next_cu_header</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>die</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dwarf_siblingof</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_tag</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_tag failed: %s"</literal></expr></argument>,
<argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>DW_TAG_compile_unit</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>die</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"could not find DW_TAG_compile_unit die"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_srcfiles</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src_files</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filecount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_srclines: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>





<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dwarf_srclines</name><argument_list>(<argument><expr><name>die</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lcount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>DW_DLV_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_srclines: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DW_DLV_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>line_attr</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>Dwarf_Signed</name><operator>)</operator> <name>i</name> <operator>&lt;</operator> <name>lcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_lineaddr</name><argument_list>(<argument><expr><name><name>lbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_lineaddr: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_lineno</name><argument_list>(<argument><expr><name><name>lbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lineno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_lineno: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dwarf_linesrc</name><argument_list>(<argument><expr><name><name>lbuf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"dwarf_linesrc: %s"</literal></expr></argument>, <argument><expr><call><name>dwarf_errmsg</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lie</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lie</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lie</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>lineaddr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lie</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lie</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>sfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lie</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>, <argument><expr><name>lie</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>line_attr</name>:</label>

<expr_stmt><expr><call><name>search_line_attr</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>die</name></expr></argument>, <argument><expr><name>src_files</name></expr></argument>, <argument><expr><name>filecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dwarf_finish</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>process_sym</name>:</label>

<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>list_num</name></name> <operator>=</operator> <call><name>get_sym</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list_head</name></expr></argument>, <argument><expr><name>shnum</name></expr></argument>, <argument><expr><name>dynndx</name></expr></argument>, <argument><expr><name>strndx</name></expr></argument>,
<argument><expr><name>type_table</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sec_table</name></expr></argument>, <argument><expr><name>shnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p_data</name><operator>.</operator><name>list_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>next_cmd</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>headp</name></name> <operator>=</operator> <operator>&amp;</operator><name>list_head</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>sh_num</name></name> <operator>=</operator> <name>shnum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>t_table</name></name> <operator>=</operator> <name>type_table</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>s_table</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sec_table</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p_data</name><operator>.</operator><name>objname</name></name> <operator>=</operator> <name>objname</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sym_list_print</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p_data</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>next_cmd</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>debug_line</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>func_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_REMOVE_HEAD</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>func_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>var_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_REMOVE_HEAD</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>var_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>line_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lie</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_REMOVE_HEAD</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lie</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sec_table</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>shnum</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sec_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sec_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>type_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sym_list_dest</name><argument_list>(<argument><expr><operator>&amp;</operator><name>list_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>rtn</name><operator>)</operator></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OBJNAME</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Cmd</name></type> <name>elf_cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Kind</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>rtn</name></decl>, <decl><type ref="prev"/><name>e_err</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>filename</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"filename is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>fileargs_open</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>fileargs</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"'%s'"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>elf_cmd</name> <operator>=</operator> <name>ELF_C_READ</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>elf_cmd</name></expr></argument>, <argument><expr><operator>(</operator><name>Elf</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_err</name> <operator>=</operator> <call><name>elf_errno</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin error: %s"</literal></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><name>e_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"elf_begin error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>arf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"arf is null."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rtn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>kind</name> <operator>=</operator> <call><name>elf_kind</name><argument_list>(<argument><expr><name>arf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>ELF_K_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: File format not recognized"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>arf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>ELF_K_AR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>==</operator> <name>PRINT_NAME_MULTI</name> <operator>&amp;&amp;</operator>
<name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator> <name>sym_elem_print_all</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s:\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_armap</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_ar_index</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>arf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>elf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>elf_cmd</name></expr></argument>, <argument><expr><name>arf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rtn</name> <operator>|=</operator> <call><name>read_elf</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>elf_cmd</name> <operator>=</operator> <call><name>elf_next</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name>arf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>rtn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_files</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rtn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rtn</name> <operator>|=</operator> <call><name>read_object</name><argument_list>(<argument><expr><name><name>nm_info</name><operator>.</operator><name>def_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>==</operator> <name>PRINT_NAME_NONE</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>=</operator> <name>PRINT_NAME_MULTI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rtn</name> <operator>|=</operator> <call><name>read_object</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>rtn</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_lineno</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type><name>func_info</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type><name>var_info</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type><name>line_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>func_info_entry</name></name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>var_info_entry</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>line_info_entry</name></name> <modifier>*</modifier></type><name>lie</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>==</operator> <name>STT_FUNC</name> <operator>&amp;&amp;</operator> <name>func_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<macro><name>SLIST_FOREACH</name><argument_list>(<argument>func</argument>, <argument>func_info</argument>, <argument>entries</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>&gt;=</operator> <name><name>func</name><operator>-&gt;</operator><name>lowpc</name></name> <operator>&amp;&amp;</operator>
<name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>&lt;</operator> <name><name>func</name><operator>-&gt;</operator><name>highpc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t%s:%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>==</operator> <name>STT_OBJECT</name> <operator>&amp;&amp;</operator> <name>var_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<macro><name>SLIST_FOREACH</name><argument_list>(<argument>var</argument>, <argument>var_info</argument>, <argument>entries</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t%s:%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>line_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<macro><name>SLIST_FOREACH</name><argument_list>(<argument>lie</argument>, <argument>line_info</argument>, <argument>entries</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>==</operator> <name><name>lie</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t%s:%"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>lie</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>lie</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_opt_value_print_fn</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>radix</name></name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>RADIX_OCT</name></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_value_oct_print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_size_oct_print</name></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>RADIX_DEC</name></expr>:</case>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_value_dec_print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_size_dec_print</name></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><name>RADIX_HEX</name></expr>:</case>
<default>default :</default>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_value_hex_print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name> <operator>=</operator> <operator>&amp;</operator><name>sym_size_hex_print</name></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<literal type="string">"nm_opts.value_print_fn is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_elem_print_all</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sym</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>RADIX_HEX</name> <operator>&amp;&amp;</operator> <name>nm_elfclass</name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-8s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-16s"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><operator>(</operator><ternary><condition><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>==</operator> <operator>&amp;</operator> <name>cmp_size</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
<name><name>nm_opts</name><operator>.</operator><name>print_size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %c "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINT_DEMANGLED_NAME</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_elem_print_all_portable</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sym</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PRINT_DEMANGLED_NAME</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %c "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_elem_print_all_sysv</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sym</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>PRINT_DEMANGLED_NAME</name><argument_list>(<argument><expr><literal type="string">"%-20s|"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>value_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"| %c |"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><name>STT_OBJECT</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"OBJECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_FUNC</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"FUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_SECTION</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"SECTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_FILE</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"FILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_LOPROC</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"LOPROC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_HIPROC</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"HIPROC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STT_NOTYPE</name></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%18s|"</literal></expr></argument>, <argument><expr><literal type="string">"NOTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>size_print_fn</name></name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"| |%s"</literal></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_def</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_SYM_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>!</operator><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_global</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_SYM_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><operator>(</operator><call><name>isupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>type</name> <operator>==</operator> <literal type="char">'w'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_global_static</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>info</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>info</name> <operator>==</operator> <name>STB_LOCAL</name> <operator>||</operator>
<name>info</name> <operator>==</operator> <name>STB_GLOBAL</name> <operator>||</operator>
<name>info</name> <operator>==</operator> <name>STB_WEAK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_nondebug</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>==</operator> <name>STT_FILE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_nonzero_size</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_elem_undef</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>IS_SYM_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_list_dest</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type><name>headp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>ep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ep_n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>headp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>STAILQ_FIRST</name><argument_list>(<argument><expr><name>headp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ep_n</name> <operator>=</operator> <call><name>STAILQ_NEXT</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>sym_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> <operator>=</operator> <name>ep_n</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sym_list_insert</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_head</name></name> <modifier>*</modifier></type><name>headp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>headp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sym</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sym_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>sym</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GElf_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><name>sym</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GElf_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>==</operator> <name>SHN_COMMON</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><name>headp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>sym_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_list_print</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type><name>func_info</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type><name>var_info</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type><name>line_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>e_v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>si</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>CHECK_SYM_PRINT_DATA</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_v</name> <operator>=</operator> <call><name>sym_list_sort</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>sort_reverse</name></name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>si</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>si</name> <operator>!=</operator> <name><name>p</name><operator>-&gt;</operator><name>list_num</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>si</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sym_list_print_each</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e_v</name><index>[<expr><name>si</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>,
<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>list_num</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sym_list_print_each</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e_v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>,
<argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>e_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_list_print_each</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>func_info_head</name></name> <modifier>*</modifier></type><name>func_info</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>var_info_head</name></name> <modifier>*</modifier></type><name>var_info</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>line_info_head</name></name> <modifier>*</modifier></type><name>line_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ep</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>CHECK_SYM_PRINT_DATA</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_sym_type</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>t_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>print_name</name></name> <operator>==</operator> <name>PRINT_NAME_FULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name> <operator>==</operator> <operator>&amp;</operator><name>sym_elem_print_all_portable</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>objname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%s]"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>objname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">":%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>objname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHN_LOPROC</name></expr>:</case>

<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*LOPROC*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_HIPROC</name></expr>:</case>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*HIPROC*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_LOOS</name></expr>:</case>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*LOOS*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_HIOS</name></expr>:</case>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*HIOS*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_ABS</name></expr>:</case>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*ABS*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_COMMON</name></expr>:</case>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*COM*"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHN_HIRESERVE</name></expr>:</case>

<expr_stmt><expr><name>sec</name> <operator>=</operator> <literal type="string">"*HIRESERVE*"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>sh_num</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sec</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>s_table</name><index>[<expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><call><name><name>nm_opts</name><operator>.</operator><name>elem_print_fn</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name><name>ep</name><operator>-&gt;</operator><name>sym</name></name></expr></argument>, <argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>debug_line</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_UNDEF_SYM_TYPE</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_lineno</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>func_info</name></expr></argument>, <argument><expr><name>var_info</name></expr></argument>, <argument><expr><name>line_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type>
<name>sym_list_sort</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sym_print_data</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sym_entry</name></name> <modifier>*</modifier></type><name>ep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e_v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>CHECK_SYM_PRINT_DATA</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_v</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sym_entry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>list_num</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<macro><name>STAILQ_FOREACH</name><argument_list>(<argument>ep</argument>, <argument>p-&gt;headp</argument>, <argument>sym_entries</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ep</name><operator>-&gt;</operator><name>sym</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e_v</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e_v</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>sym</name> <operator>=</operator> <name><name>ep</name><operator>-&gt;</operator><name>sym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>idx</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>idx</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>list_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name> <operator>!=</operator> <operator>&amp;</operator><name>cmp_none</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nm_print_data</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nm_print_data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>e_v</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>list_num</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sym_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>nm_opts</name><operator>.</operator><name>sort_fn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>e_v</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_size_oct_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRIo64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_size_hex_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nm_elfclass</name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08"</literal> <name>PRIx64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRIx64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_size_dec_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRId64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_value_oct_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRIo64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_value_hex_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nm_elfclass</name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%08"</literal> <name>PRIx64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRIx64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sym_value_dec_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sym</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <literal type="string">"sym is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%016"</literal> <name>PRId64</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage: %s [options] file ...\
\n Display symbolic information in file.\n\
\n Options: \
\n -A, --print-file-name Write the full pathname or library name of an\
\n object on each line.\
\n -a, --debug-syms Display all symbols include debugger-only\
\n symbols."</literal></expr></argument>, <argument><expr><name><name>nm_info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
\n -B Equivalent to specifying \"--format=bsd\".\
\n -C, --demangle[=style] Decode low-level symbol names.\
\n --no-demangle Do not demangle low-level symbol names.\
\n -D, --dynamic Display only dynamic symbols.\
\n -e Display only global and static symbols."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
\n -f Produce full output (default).\
\n --format=format Display output in specific format. Allowed\
\n formats are: \"bsd\", \"posix\" and \"sysv\".\
\n -g, --extern-only Display only global symbol information.\
\n -h, --help Show this help message.\
\n -l, --line-numbers Display filename and linenumber using\
\n debugging information.\
\n -n, --numeric-sort Sort symbols numerically by value."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
\n -o Write numeric values in octal. Equivalent to\
\n specifying \"-t o\".\
\n -p, --no-sort Do not sort symbols.\
\n -P Write information in a portable output format.\
\n Equivalent to specifying \"--format=posix\".\
\n -r, --reverse-sort Reverse the order of the sort.\
\n -S, --print-size Print symbol sizes instead values.\
\n -s, --print-armap Include an index of archive members.\
\n --size-sort Sort symbols by size."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
\n -t, --radix=format Write each numeric value in the specified\
\n format:\
\n d In decimal,\
\n o In octal,\
\n x In hexadecimal."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\
\n -u, --undefined-only Display only undefined symbols.\
\n --defined-only Display only defined symbols.\
\n -V, --version Show the version identifier for %s.\
\n -v Sort output by value.\
\n -x Write numeric values in hexadecimal.\
\n Equivalent to specifying \"-t x\"."</literal></expr></argument>,
<argument><expr><name><name>nm_info</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n\
\n The default options are: output in bsd format, use a hexadecimal radix,\
\n sort by symbol name, do not demangle names.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rtn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>global_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_opt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enter_cap_mode</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtn</name> <operator>=</operator> <call><name>read_files</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>global_dest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rtn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
