<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/size/size.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;capsicum_helpers.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelftc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libcasper.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;casper/cap_fileargs.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"_elftc.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>ELFTC_VCSID</name><argument_list>(<argument><expr><literal type="string">"$Id: size.c 3458 2016-05-09 15:01:25Z emaste $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_ALIGN</name><parameter_list>(<parameter><type><name>val</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((val)+(x)-1) &amp; ~((x)-1))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_VERSION_STRING</name></cpp:macro> <cpp:value>"size 1.0"</cpp:value></cpp:define>

<enum>enum <name>return_code</name> <block>{
<decl><name>RETURN_OK</name></decl>,
<decl><name>RETURN_DATAERR</name></decl>,
<decl><name>RETURN_USAGE</name></decl>
}</block>;</enum>

<enum>enum <name>output_style</name> <block>{
<decl><name>STYLE_BERKELEY</name></decl>,
<decl><name>STYLE_SYSV</name></decl>
}</block>;</enum>

<enum>enum <name>radix_style</name> <block>{
<decl><name>RADIX_OCTAL</name></decl>,
<decl><name>RADIX_DECIMAL</name></decl>,
<decl><name>RADIX_HEX</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>bss_size</name></decl>, <decl><type ref="prev"/><name>data_size</name></decl>, <decl><type ref="prev"/><name>text_size</name></decl>, <decl><type ref="prev"/><name>total_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>bss_size_total</name></decl>, <decl><type ref="prev"/><name>data_size_total</name></decl>, <decl><type ref="prev"/><name>text_size_total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>show_totals</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>size_option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>radix_style</name></name></type> <name>radix</name> <init>= <expr><name>RADIX_DECIMAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>output_style</name></name></type> <name>style</name> <init>= <expr><name>STYLE_BERKELEY</name></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>row</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier><name>tb</name></decl>;</struct>

<enum>enum <block>{
<decl><name>OPT_FORMAT</name></decl>,
<decl><name>OPT_RADIX</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>size_longopts</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"format"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><operator>&amp;</operator><name>size_option</name></expr>, <expr><name>OPT_FORMAT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"radix"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><operator>&amp;</operator><name>size_option</name></expr>, <expr><name>OPT_RADIX</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"totals"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'t'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>berkeley_calc</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>berkeley_footer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>berkeley_header</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>berkeley_totals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>handle_core</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handle_core_note</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Phdr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>handle_elf</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handle_phdr</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Phdr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>show_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sysv_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sysv_footer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sysv_calc</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbl_new</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbl_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbl_print_num</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>radix_style</name></name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbl_append</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbl_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>






<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>cap_rights_t</name></type> <name>rights</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fileargs_t</name> <modifier>*</modifier></type><name>fa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>, <decl><type ref="prev"/><name>fd</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>defaultfn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>RETURN_OK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"ELF library initialization failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"ABVdhotx"</literal></expr></argument>, <argument><expr><name>size_longopts</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<switch>switch<condition>(<expr><operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<expr_stmt><expr><name>style</name> <operator>=</operator> <name>STYLE_SYSV</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<expr_stmt><expr><name>style</name> <operator>=</operator> <name>STYLE_BERKELEY</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><call><name>show_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_DECIMAL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_OCTAL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name>show_totals</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_HEX</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<switch>switch <condition>(<expr><name>size_option</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OPT_FORMAT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>optarg</name> <operator>==</operator> <literal type="char">'s'</literal> <operator>||</operator> <operator>*</operator><name>optarg</name> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>style</name> <operator>=</operator> <name>STYLE_SYSV</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>optarg</name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <operator>*</operator><name>optarg</name> <operator>==</operator> <literal type="char">'B'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>style</name> <operator>=</operator> <name>STYLE_BERKELEY</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"unrecognized format \"%s\"."</literal></expr></argument>,
<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>OPT_RADIX</name></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_OCTAL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_DECIMAL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>RADIX_HEX</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"unsupported radix \"%s\"."</literal></expr></argument>,
<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"Error in option handling."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch></block_content></block></while>
<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>defaultfn</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"a.out"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>defaultfn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name>defaultfn</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>defaultfn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>cap_rights_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>CAP_FSTAT</name></expr></argument>, <argument><expr><name>CAP_MMAP_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fa</name> <operator>=</operator> <call><name>fileargs_init</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rights</name></expr></argument>, <argument><expr><name>FA_OPEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize fileargs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>caph_cache_catpages</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_limit_stdio</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to limit stdio rights"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>caph_enter_casper</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"failed to enter capability mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>argc</name><operator>--</operator></expr><operator>,</operator> <expr><name>argv</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>fn</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>fileargs_open</name><argument_list>(<argument><expr><name>fa</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"%s: Failed to open"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>handle_elf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>RETURN_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: File format not recognized"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>show_totals</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>berkeley_totals</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tbl_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fileargs_free</name><argument_list>(<argument><expr><name>fa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>defaultfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rc</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xlatetom</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>elfhdr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_src</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>_dst</name></decl></parameter>,
<parameter><decl><type><name>Elf_Type</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Data</name></type> <name>src</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>src</name><operator>.</operator><name>d_buf</name></name> <operator>=</operator> <name>_src</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>d_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>d_version</name></name> <operator>=</operator> <name><name>elfhdr</name><operator>-&gt;</operator><name>e_version</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>d_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>.</operator><name>d_buf</name></name> <operator>=</operator> <name>_dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>.</operator><name>d_version</name></name> <operator>=</operator> <name><name>elfhdr</name><operator>-&gt;</operator><name>e_version</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>.</operator><name>d_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>gelf_xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><name><name>elfhdr</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator>
<name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTE_OFFSET_32</name><parameter_list>(<parameter><type><name>nhdr</name></type></parameter>, <parameter><type><name>namesz</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)nhdr + sizeof(Elf32_Nhdr) + ELF_ALIGN((int32_t)namesz, 4) + offset)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTE_OFFSET_64</name><parameter_list>(<parameter><type><name>nhdr</name></type></parameter>, <parameter><type><name>namesz</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)nhdr + sizeof(Elf32_Nhdr) + ELF_ALIGN((int32_t)namesz, 8) + offset)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PID32</name><parameter_list>(<parameter><type><name>nhdr</name></type></parameter>, <parameter><type><name>namesz</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pid_t)*((int *)((uintptr_t)NOTE_OFFSET_32(nhdr, namesz, offset)));</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PID64</name><parameter_list>(<parameter><type><name>nhdr</name></type></parameter>, <parameter><type><name>namesz</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(pid_t)*((int *)((uintptr_t)NOTE_OFFSET_64(nhdr, namesz, offset)));</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_NOTE</name><parameter_list>(<parameter><type><name>elfhdr</name></type></parameter>, <parameter><type><name>descsz</name></type></parameter>, <parameter><type><name>namesz</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (elfhdr-&gt;e_ident[EI_CLASS] == ELFCLASS32) { offset += ELF_ALIGN((int32_t)descsz, 4) + sizeof(Elf32_Nhdr) + ELF_ALIGN((int32_t)namesz, 4); } else { offset += ELF_ALIGN((int32_t)descsz, 8) + sizeof(Elf32_Nhdr) + ELF_ALIGN((int32_t)namesz, 8); } } while (0)</cpp:value></cpp:define>














<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_core_note</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>elfhdr</name></decl></parameter>, <parameter><decl><type><name>GElf_Phdr</name> <modifier>*</modifier></type><name>phdr</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cmd_line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>max_size</name></decl>, <decl><type ref="prev"/><name>segment_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>raw_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Off</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>ver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Nhdr</name> <modifier>*</modifier></type><name>nhdr</name></decl>, <decl><type ref="prev"/><name>nhdr_l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reg_pseudo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>reg2_pseudo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>BUF_SIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>elfhdr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>phdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>elf_rawfile</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name>max_size</name> <operator>||</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name> <operator>&gt;</operator> <name>max_size</name> <operator>-</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid PHDR offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>segment_end</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>segment_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nhdr</name> <operator>=</operator> <operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>data</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nhdr_l</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr_l</name><operator>.</operator><name>n_type</name></name></expr></argument>,
<argument><expr><name>ELF_T_WORD</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Word</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr</name><operator>-&gt;</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr></argument>,
<argument><expr><name>ELF_T_WORD</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Word</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr</name><operator>-&gt;</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>,
<argument><expr><name>ELF_T_WORD</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Word</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
<call><name>ELF_ALIGN</name><argument_list>(<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator>
<call><name>ELF_ALIGN</name><argument_list>(<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>segment_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"invalid note header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>nhdr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>nhdr_l</name><operator>.</operator><name>n_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_PRSTATUS</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>raw_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>elfhdr</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>==</operator> <name>ELFOSABI_FREEBSD</name> <operator>&amp;&amp;</operator>
<name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name> <operator>==</operator> <literal type="number">0x8</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>elfhdr</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>raw_size</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator>
<operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>name</name> <operator>+</operator>
<call><name>ELF_ALIGN</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator>
<name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ver</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>NOTE_OFFSET_32</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>ver</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>PID32</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>raw_size</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator>
<operator>(</operator><name>name</name> <operator>+</operator> <call><name>ELF_ALIGN</name><argument_list>(<argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator>
<name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ver</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><call><name>NOTE_OFFSET_64</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>ver</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>PID64</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>raw_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>raw_size</name></expr></argument>, <argument><expr><name>ELF_T_WORD</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>xlatetom</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>,
<argument><expr><name>ELF_T_WORD</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>raw_size</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>style</name> <operator>==</operator> <name>STYLE_SYSV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s/%d"</literal></expr></argument>,
<argument><expr><literal type="string">".reg"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>raw_size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reg_pseudo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">".reg"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>raw_size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reg_pseudo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name>raw_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name>raw_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>
<case>case <expr><name>NT_FPREGSET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_SYSV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"%s/%d"</literal></expr></argument>, <argument><expr><literal type="string">".reg2"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reg2_pseudo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">".reg2"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reg2_pseudo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
case NT_AUXV:
if (style == STYLE_SYSV) {
tbl_append();
tbl_print(".auxv", 0);
tbl_print_num(nhdr_l.n_descsz, radix, 1);
tbl_print_num(0, radix, 2);
text_size_total += nhdr_l.n_descsz;
}
break;
case NT_PRXFPREG:
if (style == STYLE_SYSV) {
(void) snprintf(buf, BUF_SIZE, "%s/%d",
".reg-xfp", pid);
tbl_append();
tbl_print(buf, 0);
tbl_print_num(nhdr_l.n_descsz, radix, 1);
tbl_print_num(0, radix, 2);
if (!regxfp_pseudo) {
tbl_append();
tbl_print(".reg-xfp", 0);
tbl_print_num(nhdr_l.n_descsz, radix,
1);
tbl_print_num(0, radix, 2);
regxfp_pseudo = 1;
text_size_total += nhdr_l.n_descsz;
}
text_size_total += nhdr_l.n_descsz;
}
break;
case NT_PSINFO:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>NT_PRPSINFO</name></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name> <operator>==</operator> <literal type="number">0x78</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cmd_line</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>NOTE_OFFSET_64</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name> <operator>==</operator> <literal type="number">0x6c</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cmd_line</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>NOTE_OFFSET_32</name><argument_list>(<argument><expr><name>nhdr</name></expr></argument>,
<argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd_line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><name>cmd_line</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>cmd_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> <operator>&gt;</operator> <operator>*</operator><name>cmd_line</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>s</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x20</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
case NT_PSTATUS:
case NT_LWPSTATUS:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>NEXT_NOTE</name><argument_list>(<argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_descsz</name></name></expr></argument>, <argument><expr><name><name>nhdr_l</name><operator>.</operator><name>n_namesz</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_phdr</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>elfhdr</name></decl></parameter>, <parameter><decl><type><name>GElf_Phdr</name> <modifier>*</modifier></type><name>phdr</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>split</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>elfhdr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>phdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>split</name> <operator>=</operator> <operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>&gt;</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_SYSV</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"%s%d%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>split</name></expr> ?</condition><then> <expr><literal type="string">"a"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>phdr</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>+</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s%d%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>-&gt;</operator><name>p_type</name></name> <operator>!=</operator> <name>PT_LOAD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>p_flags</name></name> <operator>&amp;</operator> <name>PF_W</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>phdr</name><operator>-&gt;</operator><name>p_flags</name></name> <operator>&amp;</operator> <name>PF_X</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data_size</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data_size</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>text_size</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>text_size</name> <operator>+=</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_memsz</name></name> <operator>-</operator> <name><name>phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_core</name><parameter_list>(<parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>elfhdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Phdr</name></type> <name>phdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>core_cmdline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>seg_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>elf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>elfhdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>RETURN_DATAERR</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>elfhdr</name><operator>-&gt;</operator><name>e_shnum</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>elfhdr</name><operator>-&gt;</operator><name>e_type</name></name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>RETURN_DATAERR</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <name>core_cmdline</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_SYSV</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sysv_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>berkeley_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>elfhdr</name><operator>-&gt;</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getphdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>==</operator> <name>PT_NOTE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>handle_phdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="string">"note"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>handle_core_note</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>core_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch<condition>(<expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_NULL</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_LOAD</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"load"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_DYNAMIC</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"dynamic"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_INTERP</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"interp"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_SHLIB</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"shlib"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_PHDR</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"phdr"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_GNU_EH_FRAME</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"eh_frame_hdr"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_GNU_STACK</name></expr>:</case>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"stack"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>seg_name</name> <operator>=</operator> <literal type="string">"segment"</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>handle_phdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>seg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>core_cmdline</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>berkeley_footer</name><argument_list>(<argument><expr><name>core_cmdline</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><literal type="string">"core file invoked as"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>berkeley_footer</name><argument_list>(<argument><expr><name>core_cmdline</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"core file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sysv_footer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>core_cmdline</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (core file invoked as %s)\n\n"</literal></expr></argument>,
<argument><expr><name>core_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (core file)\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>core_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>RETURN_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_elf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>elfhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elf1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Cmd</name></type> <name>elf_cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>

<expr_stmt><expr><name>elf_cmd</name> <operator>=</operator> <name>ELF_C_READ</name></expr>;</expr_stmt>
<expr_stmt><expr><name>elf1</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>elf_cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>elf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>elf_cmd</name></expr></argument>, <argument><expr><name>elf1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arhdr</name> <operator>=</operator> <call><name>elf_getarhdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ELF_K_NONE</name> <operator>&amp;&amp;</operator> <name>arhdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>RETURN_DATAERR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ELF_K_ELF</name> <operator>||</operator>
<operator>(</operator><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elfhdr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elf_cmd</name> <operator>=</operator> <call><name>elf_next</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"%s: File format not recognized"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>arhdr</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr> </then><else>: <expr><name>name</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elfhdr</name><operator>.</operator><name>e_shnum</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>elfhdr</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_CORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <call><name>handle_core</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elfhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>exit_code</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>scn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>berkeley_header</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>berkeley_calc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sysv_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>arhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sysv_calc</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elfhdr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>arhdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>berkeley_footer</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>,
<argument><expr><literal type="string">"ex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>berkeley_footer</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"ex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>sysv_footer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>elf_cmd</name> <operator>=</operator> <call><name>elf_next</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>RETURN_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>sysv_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Elf_Arhdr</name> <modifier>*</modifier></type><name>arhdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>text_size_total</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arhdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (ex %s):\n"</literal></expr></argument>, <argument><expr><name><name>arhdr</name><operator>-&gt;</operator><name>ar_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s :\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>tbl_new</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"section"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sysv_calc</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>elfhdr</name></decl></parameter>, <parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>shdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>section_name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>elfhdr</name><operator>-&gt;</operator><name>e_shstrndx</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_SYMTAB</name> <operator>||</operator>
<name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_STRTAB</name> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_RELA</name> <operator>||</operator>
<name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_addr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_addr</name></name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sysv_footer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"Total"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>text_size_total</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>berkeley_header</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>printed</name></decl>;</decl_stmt>

<expr_stmt><expr><name>text_size</name> <operator>=</operator> <name>data_size</name> <operator>=</operator> <name>bss_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>printed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tbl_new</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"text"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"data"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"bss"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>radix</name> <operator>==</operator> <name>RADIX_OCTAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"oct"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"dec"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"hex"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><literal type="string">"filename"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>printed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>berkeley_calc</name><parameter_list>(<parameter><decl><type><name>GElf_Shdr</name> <modifier>*</modifier></type><name>shdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>shdr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_ALLOC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_ALLOC</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_EXECINSTR</name><operator>)</operator> <operator>||</operator>
<operator>!</operator><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_WRITE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>text_size</name> <operator>+=</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_ALLOC</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>&amp;</operator> <name>SHF_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>!=</operator> <name>SHT_NOBITS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data_size</name> <operator>+=</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bss_size</name> <operator>+=</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>berkeley_totals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>grand_total</name></decl>;</decl_stmt>

<expr_stmt><expr><name>grand_total</name> <operator>=</operator> <name>text_size_total</name> <operator>+</operator> <name>data_size_total</name> <operator>+</operator> <name>bss_size_total</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>text_size_total</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>data_size_total</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>bss_size_total</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>radix</name> <operator>==</operator> <name>RADIX_OCTAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>grand_total</name></expr></argument>, <argument><expr><name>RADIX_OCTAL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>grand_total</name></expr></argument>, <argument><expr><name>RADIX_DECIMAL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>grand_total</name></expr></argument>, <argument><expr><name>RADIX_HEX</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>berkeley_footer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ar_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>total_size</name> <operator>=</operator> <name>text_size</name> <operator>+</operator> <name>data_size</name> <operator>+</operator> <name>bss_size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>show_totals</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>text_size_total</name> <operator>+=</operator> <name>text_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bss_size_total</name> <operator>+=</operator> <name>bss_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data_size_total</name> <operator>+=</operator> <name>data_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tbl_append</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>text_size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>data_size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>bss_size</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>radix</name> <operator>==</operator> <name>RADIX_OCTAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>RADIX_OCTAL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>RADIX_DECIMAL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>tbl_print_num</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>RADIX_HEX</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ar_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s (%s %s)"</literal></expr></argument>, <argument><expr><name>ar_name</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ar_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s (%s)"</literal></expr></argument>, <argument><expr><name>ar_name</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbl_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tb</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>col</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tb</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tb</name><operator>-&gt;</operator><name>tbl</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>tb</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tb</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>tb</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbl_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tb</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tb</name><operator>-&gt;</operator><name>row</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>col</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>col</name></expr>]</index><index>[<expr><name><name>tb</name><operator>-&gt;</operator><name>row</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>col</name></expr>]</index><index>[<expr><name><name>tb</name><operator>-&gt;</operator><name>row</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"strdup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>width</name><index>[<expr><name>col</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>width</name><index>[<expr><name>col</name></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbl_print_num</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>radix_style</name></name></type> <name>rad</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUF_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>rad</name> <operator>==</operator> <name>RADIX_DECIMAL</name></expr> ?</condition><then> <expr><literal type="string">"%ju"</literal></expr> </then><else>:
<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>rad</name> <operator>==</operator> <name>RADIX_OCTAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"0%jo"</literal></expr> </then><else>: <expr><literal type="string">"0x%jx"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>uintmax_t</name><operator>)</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tbl_print</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbl_append</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tb</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>row</name></name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tb</name><operator>-&gt;</operator><name>row</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"realloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name><name>tb</name><operator>-&gt;</operator><name>row</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbl_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>row</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_SYSV</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%-*s"</literal></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>width</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>style</name> <operator>==</operator> <name>STYLE_BERKELEY</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>==</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name><name>tb</name><operator>-&gt;</operator><name>width</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>col</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>tb</name><operator>-&gt;</operator><name>row</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>tbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tb</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tb</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] file ...\nDisplay sizes of ELF sections.\n\nOptions:\n--format=format Display output in specified format. Supported\nvalues are `berkeley' and `sysv'.\n--help Display this help message and exit.\n--radix=radix Display numeric values in the specified radix.\nSupported values are: 8, 10 and 16.\n--totals Show cumulative totals of section sizes.\n--version Display a version identifier and exit.\n-A Equivalent to `--format=sysv'.\n-B Equivalent to `--format=berkeley'.\n-V Equivalent to `--version'.\n-d Equivalent to `--radix=10'.\n-h Same as option --help.\n-o Equivalent to `--radix=8'.\n-t Equivalent to option --totals.\n-x Equivalent to `--radix=16'.\n"</cpp:value></cpp:define>



















<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>show_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>elftc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
