<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googlemock/include/gmock/gmock-generated-matchers.h">






































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sstream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/gmock-matchers.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_FIELD_TYPE_</name><parameter_list>(<parameter><type><name>Tuple</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typename ::testing::tuple_element&lt;i, Tuple&gt;::type</cpp:value></cpp:define>













<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k3</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k4</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k5</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k6</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k7</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k8</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k9</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TupleFields</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>,
<argument><expr><name>int</name> <name>k7</name></expr></argument>, <argument><expr><name>int</name> <name>k8</name></expr></argument>, <argument><expr><name>int</name> <name>k9</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TupleFields</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k5</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k6</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k7</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k8</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k9</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k7</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k9</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type></decl></parameter> )</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k5</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k5</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k6</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>,
<argument><expr><name>int</name> <name>k7</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k5</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k6</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k7</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k7</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name></expr></argument>, <argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>,
<argument><expr><name>int</name> <name>k7</name></expr></argument>, <argument><expr><name>int</name> <name>k8</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k0</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k1</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k2</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k3</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k4</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k5</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k6</name><operator>)</operator></expr></argument>,
<argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k7</name><operator>)</operator></expr></argument>, <argument><expr><name>GMOCK_FIELD_TYPE_</name><operator>(</operator><name>Tuple</name>, <name>k8</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<function><type><specifier>static</specifier> <name>type</name></type> <name>GetSelectedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k0</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k7</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>k8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GMOCK_FIELD_TYPE_</name></cpp:undef>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ArgsTuple</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k3</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k4</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k5</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k6</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k7</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k8</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k9</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ArgsMatcherImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>ArgsTuple</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>

<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>ArgsTuple</argument>)</argument_list></macro> <expr_stmt><expr><name>RawArgsTuple</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>RawArgsTuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>,
<argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>, <argument><expr><name>k9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>SelectedArgs</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SelectedArgs</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>MonomorphicInnerMatcher</name>;</typedef>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>InnerMatcher</name><operator>&gt;</operator>
<name>explicit</name> <call><name>ArgsMatcherImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InnerMatcher</name><operator>&amp;</operator> <name>inner_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>inner_matcher_</name><argument_list>(<argument>SafeMatcherCast&lt;const SelectedArgs&amp;&gt;(inner_matcher)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>ArgsTuple args</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>SelectedArgs</name><operator>&amp;</operator> <name>selected_args</name> <operator>=</operator> <call><name>GetSelectedArgs</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>inner_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>selected_args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<call><name>PrintIndices</name><argument_list>(<argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"are "</literal> <operator>&lt;&lt;</operator> <call><name>PrintToString</name><argument_list>(<argument><expr><name>selected_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>inner_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>inner_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>selected_args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"are a tuple "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIndices</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"are a tuple "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIndices</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>inner_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<function><type><specifier>static</specifier> <name>SelectedArgs</name></type> <name>GetSelectedArgs</name><parameter_list>(<parameter><decl><type><name>ArgsTuple</name></type> <name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>TupleFields</name><argument_list type="generic">&lt;<argument><expr><name>RawArgsTuple</name></expr></argument>, <argument><expr><name>k0</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>,
<argument><expr><name>k9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>GetSelectedFields</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>PrintIndices</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"whose fields ("</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>indices</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>k0</name></expr>, <expr><name>k1</name></expr>, <expr><name>k2</name></expr>, <expr><name>k3</name></expr>, <expr><name>k4</name></expr>, <expr><name>k5</name></expr>, <expr><name>k6</name></expr>, <expr><name>k7</name></expr>, <expr><name>k8</name></expr>, <expr><name>k9</name></expr> }</block></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"#"</literal> <operator>&lt;&lt;</operator> <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">") "</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>MonomorphicInnerMatcher</name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ArgsMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>InnerMatcher</name></expr></argument>, <argument><expr><name>int</name> <name>k0</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k2</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k3</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k4</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k5</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k6</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k7</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><name>int</name> <name>k8</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>int</name> <name>k9</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ArgsMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ArgsMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InnerMatcher</name><operator>&amp;</operator> <name>inner_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>inner_matcher_</name><argument_list>(<argument>inner_matcher</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ArgsTuple</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>ArgsTuple</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new ArgsMatcherImpl&lt;ArgsTuple</argument>, <argument>k0</argument>, <argument>k1</argument>, <argument>k2</argument>, <argument>k3</argument>, <argument>k4</argument>, <argument>k5</argument>,
<argument>k6</argument>, <argument>k7</argument>, <argument>k8</argument>, <argument>k9&gt;(inner_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>InnerMatcher</name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ArgsMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name><operator>&gt;</operator>
struct <name>AllOfResult1</name> <block>{
<typedef>typedef <type><name>M1</name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name><operator>&gt;</operator>
struct <name>AllOfResult2</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name><operator>&gt;</operator>
struct <name>AllOfResult3</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name><operator>&gt;</operator>
struct <name>AllOfResult4</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name><operator>&gt;</operator>
struct <name>AllOfResult5</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name><operator>&gt;</operator>
struct <name>AllOfResult6</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name><operator>&gt;</operator>
struct <name>AllOfResult7</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name><operator>&gt;</operator>
struct <name>AllOfResult8</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name></expr><operator>,</operator> <expr><name>typename</name> <name>M9</name><operator>&gt;</operator>
struct <name>AllOfResult9</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name></expr><operator>,</operator> <expr><name>typename</name> <name>M9</name></expr><operator>,</operator> <expr><name>typename</name> <name>M10</name><operator>&gt;</operator>
struct <name>AllOfResult10</name> <block>{
<typedef>typedef <type><name><name>BothOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AllOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AllOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>, <argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>







<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name><operator>&gt;</operator>
struct <name>AnyOfResult1</name> <block>{
<typedef>typedef <type><name>M1</name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name><operator>&gt;</operator>
struct <name>AnyOfResult2</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name><operator>&gt;</operator>
struct <name>AnyOfResult3</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult1</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name><operator>&gt;</operator>
struct <name>AnyOfResult4</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name><operator>&gt;</operator>
struct <name>AnyOfResult5</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name><operator>&gt;</operator>
struct <name>AnyOfResult6</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name><operator>&gt;</operator>
struct <name>AnyOfResult7</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name><operator>&gt;</operator>
struct <name>AnyOfResult8</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name></expr><operator>,</operator> <expr><name>typename</name> <name>M9</name><operator>&gt;</operator>
struct <name>AnyOfResult9</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name></expr><operator>,</operator> <expr><name>typename</name> <name>M3</name></expr><operator>,</operator> <expr><name>typename</name> <name>M4</name></expr><operator>,</operator> <expr><name>typename</name> <name>M5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>M6</name></expr><operator>,</operator> <expr><name>typename</name> <name>M7</name></expr><operator>,</operator> <expr><name>typename</name> <name>M8</name></expr><operator>,</operator> <expr><name>typename</name> <name>M9</name></expr><operator>,</operator> <expr><name>typename</name> <name>M10</name><operator>&gt;</operator>
struct <name>AnyOfResult10</name> <block>{
<typedef>typedef <type><name><name>EitherOfMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name><name>AnyOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>AnyOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>, <argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>
&gt;</argument_list></name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

}




template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>InnerMatcher</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>, <argument><expr><name>int</name> <name>k7</name></expr></argument>,
<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>,
<argument><expr><name>k7</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>, <argument><expr><name>int</name> <name>k7</name></expr></argument>, <argument><expr><name>int</name> <name>k8</name></expr></argument>,
<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>,
<argument><expr><name>k8</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>, <argument><expr><name>int</name> <name>k7</name></expr></argument>, <argument><expr><name>int</name> <name>k8</name></expr></argument>,
<argument><expr><name>int</name> <name>k9</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>, <argument><expr><name>k9</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>,
<argument><expr><name>k9</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>int</name> <name>k1</name></expr></argument>, <argument><expr><name>int</name> <name>k2</name></expr></argument>, <argument><expr><name>int</name> <name>k3</name></expr></argument>, <argument><expr><name>int</name> <name>k4</name></expr></argument>, <argument><expr><name>int</name> <name>k5</name></expr></argument>, <argument><expr><name>int</name> <name>k6</name></expr></argument>, <argument><expr><name>int</name> <name>k7</name></expr></argument>, <argument><expr><name>int</name> <name>k8</name></expr></argument>,
<argument><expr><name>int</name> <name>k9</name></expr></argument>, <argument><expr><name>int</name> <name>k10</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>, <argument><expr><name>k9</name></expr></argument>,
<argument><expr><name>k10</name></expr></argument>&gt;</argument_list></name>
<macro><name>Args</name><argument_list>(<argument>const InnerMatcher&amp; matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ArgsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name>k1</name></expr></argument>, <argument><expr><name>k2</name></expr></argument>, <argument><expr><name>k3</name></expr></argument>, <argument><expr><name>k4</name></expr></argument>, <argument><expr><name>k5</name></expr></argument>, <argument><expr><name>k6</name></expr></argument>, <argument><expr><name>k7</name></expr></argument>, <argument><expr><name>k8</name></expr></argument>,
<argument><expr><name>k9</name></expr></argument>, <argument><expr><name>k10</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>















<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>()</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>, <argument><expr><name>e6</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>, <argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>, <argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>,
<argument><expr><name>e8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name></expr><operator>,</operator> <expr><name>typename</name> <name>T9</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>, <argument>const T9&amp; e9</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>, <argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>,
<argument><expr><name>e8</name></expr></argument>, <argument><expr><name>e9</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name></expr><operator>,</operator> <expr><name>typename</name> <name>T9</name></expr><operator>,</operator> <expr><name>typename</name> <name>T10</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>, <argument>const T9&amp; e9</argument>,
<argument>const T10&amp; e10</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>, <argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>,
<argument><expr><name>e8</name></expr></argument>, <argument><expr><name>e9</name></expr></argument>, <argument><expr><name>e10</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}







inline <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>()</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>,
<argument><expr><name>e6</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>,
<argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>,
<argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>, <argument><expr><name>e8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name></expr><operator>,</operator> <expr><name>typename</name> <name>T9</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>, <argument>const T9&amp; e9</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>,
<argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>, <argument><expr><name>e8</name></expr></argument>, <argument><expr><name>e9</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name></expr><operator>,</operator> <expr><name>typename</name> <name>T3</name></expr><operator>,</operator> <expr><name>typename</name> <name>T4</name></expr><operator>,</operator> <expr><name>typename</name> <name>T5</name></expr><operator>,</operator>
<expr><name>typename</name> <name>T6</name></expr><operator>,</operator> <expr><name>typename</name> <name>T7</name></expr><operator>,</operator> <expr><name>typename</name> <name>T8</name></expr><operator>,</operator> <expr><name>typename</name> <name>T9</name></expr><operator>,</operator> <expr><name>typename</name> <name>T10</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const T1&amp; e1</argument>, <argument>const T2&amp; e2</argument>, <argument>const T3&amp; e3</argument>, <argument>const T4&amp; e4</argument>,
<argument>const T5&amp; e5</argument>, <argument>const T6&amp; e6</argument>, <argument>const T7&amp; e7</argument>, <argument>const T8&amp; e8</argument>, <argument>const T9&amp; e9</argument>,
<argument>const T10&amp; e10</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name>T10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Args</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>e3</name></expr></argument>, <argument><expr><name>e4</name></expr></argument>, <argument><expr><name>e5</name></expr></argument>,
<argument><expr><name>e6</name></expr></argument>, <argument><expr><name>e7</name></expr></argument>, <argument><expr><name>e8</name></expr></argument>, <argument><expr><name>e9</name></expr></argument>, <argument><expr><name>e10</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}




template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>M1</name></expr><operator>,</operator> <expr><name>typename</name> <name>M2</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><name>m1</name></expr></argument>,
<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><name>m1</name></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult6</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult6</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult7</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult7</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult8</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult8</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>, <argument><expr><name>typename</name> <name>M9</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult9</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>, <argument>M9 m9</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult9</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>,
<argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>, <argument><expr><name>m9</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>, <argument><expr><name>typename</name> <name>M9</name></expr></argument>, <argument><expr><name>typename</name> <name>M10</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult10</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>,
<argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AllOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>, <argument>M9 m9</argument>, <argument>M10 m10</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AllOfResult10</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>,
<argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AllOf</name><argument_list>(<argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>, <argument><expr><name>m9</name></expr></argument>, <argument><expr><name>m10</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult2</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><name>m1</name></expr></argument>,
<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult3</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><name>m1</name></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult4</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult5</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult6</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult6</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult7</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult7</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult8</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult8</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>, <argument><expr><name>typename</name> <name>M9</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult9</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>, <argument>M9 m9</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult9</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>,
<argument><expr><name>M9</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m5</name></expr></argument>, <argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>, <argument><expr><name>m9</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M1</name></expr></argument>, <argument><expr><name>typename</name> <name>M2</name></expr></argument>, <argument><expr><name>typename</name> <name>M3</name></expr></argument>, <argument><expr><name>typename</name> <name>M4</name></expr></argument>, <argument><expr><name>typename</name> <name>M5</name></expr></argument>,
<argument><expr><name>typename</name> <name>M6</name></expr></argument>, <argument><expr><name>typename</name> <name>M7</name></expr></argument>, <argument><expr><name>typename</name> <name>M8</name></expr></argument>, <argument><expr><name>typename</name> <name>M9</name></expr></argument>, <argument><expr><name>typename</name> <name>M10</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult10</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>,
<argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>AnyOf</name><argument_list>(<argument>M1 m1</argument>, <argument>M2 m2</argument>, <argument>M3 m3</argument>, <argument>M4 m4</argument>, <argument>M5 m5</argument>, <argument>M6 m6</argument>, <argument>M7 m7</argument>, <argument>M8 m8</argument>, <argument>M9 m9</argument>, <argument>M10 m10</argument>)</argument_list></macro> <block>{
<return>return <expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>AnyOfResult10</name><argument_list type="generic">&lt;<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>M3</name></expr></argument>, <argument><expr><name>M4</name></expr></argument>, <argument><expr><name>M5</name></expr></argument>, <argument><expr><name>M6</name></expr></argument>, <argument><expr><name>M7</name></expr></argument>, <argument><expr><name>M8</name></expr></argument>, <argument><expr><name>M9</name></expr></argument>,
<argument><expr><name>M10</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>, <argument><expr><name>m3</name></expr></argument>, <argument><expr><name>m4</name></expr></argument>, <argument><expr><name>m5</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name>AnyOf</name><argument_list>(<argument><expr><name>m6</name></expr></argument>, <argument><expr><name>m7</name></expr></argument>, <argument><expr><name>m8</name></expr></argument>, <argument><expr><name>m9</name></expr></argument>, <argument><expr><name>m10</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

}


























































































































































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>class name##Matcher {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(){}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;&gt;()));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;());}name##Matcher() {}private:};inline name##Matcher name() {return name##Matcher();}template &lt;typename arg_type&gt;bool name##Matcher::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>














































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type&gt;class name##MatcherP {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:explicit gmock_Impl(p0##_type gmock_p0): p0(::testing::internal::move(gmock_p0)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type&gt;(p0)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0));}explicit name##MatcherP(p0##_type gmock_p0) : p0(::testing::internal::move(gmock_p0)) {}p0##_type const p0;private:};template &lt;typename p0##_type&gt;inline name##MatcherP&lt;p0##_type&gt; name(p0##_type p0) {return name##MatcherP&lt;p0##_type&gt;(p0);}template &lt;typename p0##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP&lt;p0##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>




















































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P2</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type&gt;class name##MatcherP2 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type&gt;(p0, p1)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1));}name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)) {}p0##_type const p0;p1##_type const p1;private:};template &lt;typename p0##_type, typename p1##_type&gt;inline name##MatcherP2&lt;p0##_type, p1##_type&gt; name(p0##_type p0, p1##_type p1) {return name##MatcherP2&lt;p0##_type, p1##_type&gt;(p0, p1);}template &lt;typename p0##_type, typename p1##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP2&lt;p0##_type, p1##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>


























































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P3</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;class name##MatcherP3 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, p2)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2));}name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;inline name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2) {return name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, p2);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P4</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type&gt;class name##MatcherP4 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt;(p0, p1, p2, p3)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3));}name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type&gt;inline name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3) {return name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt;(p0, p1, p2, p3);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>










































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P5</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type&gt;class name##MatcherP5 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type&gt;(p0, p1, p2, p3, p4)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4));}name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type&gt;inline name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4) {return name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type&gt;(p0, p1, p2, p3, p4);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>














































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P6</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>p5</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type&gt;class name##MatcherP6 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5));}name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type&gt;inline name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5) {return name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>


















































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P7</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>p5</name></type></parameter>, <parameter><type><name>p6</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type&gt;class name##MatcherP7 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, p6)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6));}name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type&gt;inline name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, p6##_type p6) {return name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, p6);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>





























































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P8</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>p5</name></type></parameter>, <parameter><type><name>p6</name></type></parameter>, <parameter><type><name>p7</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type&gt;class name##MatcherP8 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7));}name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type&gt;inline name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7) {return name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>



































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P9</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>p5</name></type></parameter>, <parameter><type><name>p6</name></type></parameter>, <parameter><type><name>p7</name></type></parameter>, <parameter><type><name>p8</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type&gt;class name##MatcherP9 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)), p8(::testing::internal::move(gmock_p8)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;p8##_type const p8;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8));}name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)), p8(::testing::internal::move(gmock_p8)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;p8##_type const p8;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type&gt;inline name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8) {return name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>








































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHER_P10</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>p0</name></type></parameter>, <parameter><type><name>p1</name></type></parameter>, <parameter><type><name>p2</name></type></parameter>, <parameter><type><name>p3</name></type></parameter>, <parameter><type><name>p4</name></type></parameter>, <parameter><type><name>p5</name></type></parameter>, <parameter><type><name>p6</name></type></parameter>, <parameter><type><name>p7</name></type></parameter>, <parameter><type><name>p8</name></type></parameter>, <parameter><type><name>p9</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type, typename p9##_type&gt;class name##MatcherP10 {public:template &lt;typename arg_type&gt;class gmock_Impl : public ::testing::MatcherInterface&lt;GTEST_REFERENCE_TO_CONST_(arg_type)&gt; {public:gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, p9##_type gmock_p9): p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)), p8(::testing::internal::move(gmock_p8)), p9(::testing::internal::move(gmock_p9)) {}virtual bool MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener) const;virtual void DescribeTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(false);}virtual void DescribeNegationTo(::std::ostream* gmock_os) const {*gmock_os &lt;&lt; FormatDescription(true);}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;p8##_type const p8;p9##_type const p9;private:::std::string FormatDescription(bool negation) const {::std::string gmock_description = (description);if (!gmock_description.empty())return gmock_description;return ::testing::internal::FormatMatcherDescription(negation, #name, ::testing::internal::UniversalTersePrintTupleFieldsToStrings(::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));}};template &lt;typename arg_type&gt;operator ::testing::Matcher&lt;arg_type&gt;() const {return ::testing::Matcher&lt;arg_type&gt;(new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));}name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, p9##_type gmock_p9) : p0(::testing::internal::move(gmock_p0)), p1(::testing::internal::move(gmock_p1)), p2(::testing::internal::move(gmock_p2)), p3(::testing::internal::move(gmock_p3)), p4(::testing::internal::move(gmock_p4)), p5(::testing::internal::move(gmock_p5)), p6(::testing::internal::move(gmock_p6)), p7(::testing::internal::move(gmock_p7)), p8(::testing::internal::move(gmock_p8)), p9(::testing::internal::move(gmock_p9)) {}p0##_type const p0;p1##_type const p1;p2##_type const p2;p3##_type const p3;p4##_type const p4;p5##_type const p5;p6##_type const p6;p7##_type const p7;p8##_type const p8;p9##_type const p9;private:};template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type, typename p9##_type&gt;inline name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, p9##_type p9) {return name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);}template &lt;typename p0##_type, typename p1##_type, typename p2##_type, typename p3##_type, typename p4##_type, typename p5##_type, typename p6##_type, typename p7##_type, typename p8##_type, typename p9##_type&gt;template &lt;typename arg_type&gt;bool name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(GTEST_REFERENCE_TO_CONST_(arg_type) arg,::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)const</cpp:value></cpp:define>

















































































































<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
