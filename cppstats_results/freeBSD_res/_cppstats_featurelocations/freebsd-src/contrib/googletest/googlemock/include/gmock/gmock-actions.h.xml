<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googlemock/include/gmock/gmock-actions.h">



































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-internal-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-port.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;functional&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>










<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F1</name></expr></argument>, <argument><expr><name>typename</name> <name>F2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ActionAdaptor</name></decl>;</decl_stmt>






<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>bool</name> <name>kDefaultConstructible</name><operator>&gt;</operator>
struct <name>BuiltInDefaultValueGetter</name> <block>{
<expr><specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>T</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>BuiltInDefaultValueGetter</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>,
<argument><expr><literal type="string">"Default action undefined for the function return type."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>Invalid</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>


}</block>
}</expr>;








<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>BuiltInDefaultValue</name> <block>{
<expr><name>public</name><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>

<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>::</operator><name>std</name><operator>::</operator><name><name>is_default_constructible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name><name>BuiltInDefaultValueGetter</name><argument_list type="generic">&lt;
<argument><expr><name>T</name></expr></argument>, <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>is_default_constructible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name><name>BuiltInDefaultValueGetter</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Exists</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<specifier>static</specifier> <name>T</name><operator>*</operator> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NULL</name></expr>;</return> }</block>
}</expr>;



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;&gt; class BuiltInDefaultValue&lt;type&gt; { public: static bool Exists() { return true; } static type Get() { return value; } }</cpp:value></cpp:define>







<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>void</name></expr></argument>, )</argument_list></call></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><operator>::</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>unsigned char</argument>, <argument><literal type="char">'\0'</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>signed char</argument>, <argument><literal type="char">'\0'</literal></argument>)</argument_list></macro>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GMOCK_WCHAR_T_IS_NATIVE_</name></expr></cpp:if>
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>wchar_t</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>unsigned short</argument>, <argument><literal type="number">0U</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>signed short</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>unsigned int</argument>, <argument><literal type="number">0U</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>signed int</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>unsigned long</argument>, <argument><literal type="number">0UL</literal></argument>)</argument_list></macro>;
<macro><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument>signed long</argument>, <argument><literal type="number">0L</literal></argument>)</argument_list></macro>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>UInt64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>Int64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name><argument_list>(<argument><expr><name>double</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</name></cpp:undef>

}</block>














<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>DefaultValue</name> <block>{
<expr><name>public</name><operator>:</operator>


<specifier>static</specifier> <name>void</name> <macro><name>Set</name><argument_list>(<argument>T x</argument>)</argument_list></macro> <block>{
<expr><name>delete</name> <name>producer_</name></expr>;
<expr><name>producer_</name> <operator>=</operator> <name>new</name> <call><name>FixedValueProducer</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>




<typedef>typedef <function_decl><type><name>T</name></type> (<modifier>*</modifier><name>FactoryFunction</name>)<parameter_list>()</parameter_list>;</function_decl></typedef>
<specifier>static</specifier> <name>void</name> <macro><name>SetFactory</name><argument_list>(<argument>FactoryFunction factory</argument>)</argument_list></macro> <block>{
<expr><name>delete</name> <name>producer_</name></expr>;
<expr><name>producer_</name> <operator>=</operator> <name>new</name> <call><name>FactoryValueProducer</name><argument_list>(<argument><expr><name>factory</name></expr></argument>)</argument_list></call></expr>;
}</block></block>


<specifier>static</specifier> <name>void</name> <macro><name>Clear</name><argument_list>()</argument_list></macro> <block>{
<expr><name>delete</name> <name>producer_</name></expr>;
<expr><name>producer_</name> <operator>=</operator> <name>NULL</name></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>IsSet</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>producer_</name> <operator>!=</operator> <name>NULL</name></expr>;</return> }</block>



<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>IsSet</name><argument_list>()</argument_list></call> <operator>||</operator> <name>internal</name><operator>::</operator><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Exists</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<specifier>static</specifier> <name>T</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>producer_</name> <operator>==</operator> <name>NULL</name> <operator>?</operator>
<name>internal</name><operator>::</operator><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name><name>producer_</name><operator>-&gt;</operator><name>Produce</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>class</name> <name>ValueProducer</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><macro><name>ValueProducer</name><argument_list>()</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>T</name> <call><name>Produce</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>FixedValueProducer</name> <operator>:</operator> <name>public</name> <name>ValueProducer</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>FixedValueProducer</name><argument_list>(<argument>T value</argument>)</argument_list></macro> <operator>:</operator> <macro><name>value_</name><argument_list>(<argument>value</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>T</name> <macro><name>Produce</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>value_</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>T</name> <name>value_</name></expr>;
<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>FixedValueProducer</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name>class</name> <name>FactoryValueProducer</name> <operator>:</operator> <name>public</name> <name>ValueProducer</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>FactoryValueProducer</name><argument_list>(<argument>FactoryFunction factory</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>factory_</name><argument_list>(<argument>factory</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>T</name> <macro><name>Produce</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>factory_</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>FactoryFunction</name> <name>factory_</name></expr>;
<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>FactoryValueProducer</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><specifier>static</specifier> <name>ValueProducer</name><operator>*</operator> <name>producer_</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>void</name> <macro><name>Set</name><argument_list>(<argument>T&amp; x</argument>)</argument_list></macro> <block>{
<expr><name>address_</name> <operator>=</operator> <operator>&amp;</operator><name>x</name></expr>;
}</block>


<specifier>static</specifier> <name>void</name> <macro><name>Clear</name><argument_list>()</argument_list></macro> <block>{
<expr><name>address_</name> <operator>=</operator> <name>NULL</name></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>IsSet</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>address_</name> <operator>!=</operator> <name>NULL</name></expr>;</return> }</block>



<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>IsSet</name><argument_list>()</argument_list></call> <operator>||</operator> <name>internal</name><operator>::</operator><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Exists</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<specifier>static</specifier> <name>T</name><operator>&amp;</operator> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><name>address_</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then>
<expr><name>internal</name><operator>::</operator><name><name>BuiltInDefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><operator>*</operator><name>address_</name></expr></else></ternary></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <name>T</name><operator>*</operator> <name>address_</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>Exists</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<specifier>static</specifier> <name>void</name> <macro><name>Get</name><argument_list>()</argument_list></macro> <block>{}</block>
}</expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ValueProducer</name><operator>*</operator> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>producer_</name> <operator>=</operator> <name>NULL</name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name><operator>*</operator> <name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>address_</name> <operator>=</operator> <name>NULL</name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ActionInterface</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>ActionInterface</name><argument_list>()</argument_list></macro> <block>{}</block></block>
<name>virtual</name> <operator>~</operator><macro><name>ActionInterface</name><argument_list>()</argument_list></macro> <block>{}</block>





<name>virtual</name> <name>Result</name> <call><name>Perform</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>private</name><operator>:</operator>
<call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ActionInterface</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;










<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Action</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>



<macro><name>Action</name><argument_list>()</argument_list></macro> <block>{}</block></block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>G</name></expr></argument>,
<argument><expr><name>typename</name> <operator>=</operator> <name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>is_constructible</name><argument_list type="generic">&lt;<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>G</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name>
<call><name>Action</name><argument_list>(<argument><expr><name>G</name><operator>&amp;&amp;</operator> <name>fun</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>fun_</name><argument_list>(<argument>::std::forward&lt;G&gt;(fun)</argument>)</argument_list></macro> <block>{}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<name>explicit</name> <call><name>Action</name><argument_list>(<argument><expr><name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Func</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name> <call><name>Action</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>Func</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>action</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <macro><name>IsDoDefault</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<return>return <expr><name>impl_</name> <operator>==</operator> <name>nullptr</name> <operator>&amp;&amp;</operator> <name>fun_</name> <operator>==</operator> <name>nullptr</name></expr>;</return></block></expr>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>impl_</name> <operator>==</operator> <name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>Result</name></type> <name>Perform</name><argument_list>(<argument><expr><name>ArgumentTuple</name> <name>args</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IsDoDefault</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>internal</name><operator>::</operator><call><name>IllegalDoDefault</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>fun_</name> <operator>!=</operator> <name>nullptr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name>Apply</name><argument_list>(<argument><expr><name>fun_</name></expr></argument>, <argument><expr><operator>::</operator><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Perform</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F1</name></expr></argument>, <argument><expr><name>typename</name> <name>F2</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>ActionAdaptor</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>G</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>Action</name></decl>;</decl_stmt>







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <name>fun_</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>impl_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






















<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Impl</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PolymorphicAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>PolymorphicAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Impl</name><operator>&amp;</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>MonomorphicImpl</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MonomorphicImpl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>MonomorphicImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Impl</name><operator>&amp;</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>impl_</name><operator>.</operator><name>template</name></name> <call><name><name>Perform</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Impl</name></type> <name>impl_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>MonomorphicImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>Impl</name></type> <name>impl_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PolymorphicAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></type> <name>MakeAction</name><parameter_list>(<parameter><decl><type><name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>impl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Impl</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>Impl</name></expr></argument>&gt;</argument_list></name></type> <name>MakePolymorphicAction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Impl</name><modifier>&amp;</modifier></type> <name>impl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>Impl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F1</name></expr></argument>, <argument><expr><name>typename</name> <name>F2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ActionAdaptor</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F1</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ActionAdaptor</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>from</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>from.impl_</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Perform</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F2</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>impl_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ActionAdaptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>ByMoveWrapper</name> <block>{
<expr><name>explicit</name> <macro><name>ByMoveWrapper</name><argument_list>(<argument>T value</argument>)</argument_list></macro> <operator>:</operator> <macro><name>payload</name><argument_list>(<argument>internal::move(value)</argument>)</argument_list></macro> <block>{}</block>
<name>T</name> <name>payload</name></expr>;
}</block></expr>;</expr_stmt>




























<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ReturnAction</name> <block>{<block_content>
<label><name>public</name>:</label>



<macro><name>explicit</name></macro> <macro><name>ReturnAction</name><argument_list>(<argument>R value</argument>)</argument_list></macro> : <macro><name>value_</name><argument_list>(<argument>new R(internal::move(value))</argument>)</argument_list></macro> <block>{<block_content/>}</block>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{








<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef>
<call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_ReturnRef_instead_of_Return_to_return_a_reference</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>, <argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R_</name></expr></argument>, <argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>








<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>value_before_cast_</name><argument_list>(<argument><expr><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>value_</name><argument_list>(<argument>ImplicitCast_&lt;Result&gt;(value_before_cast_)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <block>{ <return>return <expr><name>value_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>Result_cannot_be_a_reference_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>R</name></type> <name>value_before_cast_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Result</name></type> <name>value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R_</name></expr></argument>, <argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name><name>ByMoveWrapper</name><argument_list type="generic">&lt;<argument><expr><name>R_</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>wrapper</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>performed_</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>wrapper_</name><argument_list>(<argument>wrapper</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <block>{
<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><operator>!</operator><name>performed_</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"A ByMove() action should only be performed once."</literal></expr>;
<expr><name>performed_</name> <operator>=</operator> <name>true</name></expr>;
<return>return <expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name><name>wrapper_</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>performed_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name></type> <name>wrapper_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<decl_stmt><decl><type><specifier>const</specifier> <name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name></type> <name>value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ReturnAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>ReturnNullAction</name> <block>{<block_content>
<label><name>public</name>:</label>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>Result</name></type> <name>Perform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<return>return <expr><name>nullptr</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>ReturnNull_can_be_used_to_return_a_pointer_only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ReturnVoidAction</name> <block>{<block_content>
<label><name>public</name>:</label>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>Perform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>CompileAssertTypesEqual</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ReturnRefAction</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ReturnRefAction</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>ref</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>ref_</name><argument_list>(<argument>ref</argument>)</argument_list></macro> <block>{}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef>



<call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_Return_instead_of_ReturnRef_to_return_a_value</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ref_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>ref</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>ref_</name><argument_list>(<argument>ref</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>ref_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>ref_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<decl_stmt><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>ref_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ReturnRefAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ReturnRefOfCopyAction</name> <block>{<block_content>
<label><name>public</name>:</label>


<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ReturnRefOfCopyAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>value_</name><argument_list>(<argument>value</argument>)</argument_list></macro> <block>{}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef>



<call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_Return_instead_of_ReturnRefOfCopy_to_return_a_value</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>value_</name><argument_list>(<argument>value</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>value_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name></type> <name>value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ReturnRefOfCopyAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name>class</name></type> <name>DoDefaultAction</name> <block>{<block_content>
<label><name>public</name>:</label>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>AssignAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>AssignAction</name><argument_list>(<argument>T1* ptr</argument>, <argument>T2 value</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>ptr_</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>value_</name><argument_list>(<argument>value</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>ptr_</name> <operator>=</operator> <name>value_</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>T1</name><operator>*</operator> <specifier>const</specifier> <name>ptr_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T2</name></type> <name>value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>AssignAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_OS_WINDOWS_MOBILE</name></expr></cpp:if>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>SetErrnoAndReturnAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>SetErrnoAndReturnAction</name><argument_list>(<argument>int errno_value</argument>, <argument>T result</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>errno_</name><argument_list>(<argument><expr><name>errno_value</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>result_</name><argument_list>(<argument>result</argument>)</argument_list></macro> <expr><block>{}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>errno</name> <operator>=</operator> <name>errno_</name></expr>;
<return>return <expr><name>result_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>errno_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>result_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>SetErrnoAndReturnAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>bool</name> <name>kIsProto</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>SetArgumentPointeeAction</name> <block>{<block_content>
<label><name>public</name>:</label>


<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>SetArgumentPointeeAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>value_</name><argument_list>(<argument>value</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>CompileAssertTypesEqual</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<expr><operator>*</operator><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>value_</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>A</name> <name>value_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>SetArgumentPointeeAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>typename</name> <name>Proto</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;<argument><expr><name>N</name></expr></argument>, <argument><expr><name>Proto</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>




<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>SetArgumentPointeeAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Proto</name><operator>&amp;</operator> <name>proto</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>proto_</name><argument_list>(<argument>new Proto</argument>)</argument_list></macro> <block>{
<expr><call><name><name>proto_</name><operator>-&gt;</operator><name>CopyFrom</name></name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>CompileAssertTypesEqual</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>CopyFrom</name><argument_list>(<argument><expr><operator>*</operator><name>proto_</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Proto</name></expr></argument>&gt;</argument_list></name> <name>proto_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>SetArgumentPointeeAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FunctionImpl</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>InvokeWithoutArgsAction</name> <block>{<block_content>
<label><name>public</name>:</label>


<macro><name>explicit</name></macro> <macro><name>InvokeWithoutArgsAction</name><argument_list>(<argument>FunctionImpl function_impl</argument>)</argument_list></macro>
: <macro><name>function_impl_</name><argument_list>(<argument>function_impl</argument>)</argument_list></macro> <block>{<block_content/>}</block>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>Result</name></type> <name>Perform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>function_impl_</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>FunctionImpl</name></type> <name>function_impl_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>InvokeWithoutArgsAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>MethodPtr</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>InvokeMethodWithoutArgsAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>InvokeMethodWithoutArgsAction</name><argument_list>(<argument>Class* obj_ptr</argument>, <argument>MethodPtr method_ptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>obj_ptr_</name><argument_list>(<argument><expr><name>obj_ptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>method_ptr_</name><argument_list>(<argument>method_ptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>obj_ptr_</name><operator>-&gt;*</operator><name>method_ptr_</name><operator>)</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Class</name><modifier>*</modifier> <specifier>const</specifier></type> <name>obj_ptr_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>MethodPtr</name></type> <name>method_ptr_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>InvokeMethodWithoutArgsAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CallbackType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>InvokeCallbackWithoutArgsAction</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>InvokeCallbackWithoutArgsAction</name><argument_list>(<argument><expr><name>CallbackType</name><operator>*</operator> <name>callback</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>callback_</name><argument_list>(<argument>callback</argument>)</argument_list></macro> <block>{
<expr><call><name><name>callback</name><operator>-&gt;</operator><name>CheckIsRepeatable</name></name><argument_list>()</argument_list></call></expr>;
}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Result</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name>
<name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>callback_</name><operator>-&gt;</operator><name>Run</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CallbackType</name></expr></argument>&gt;</argument_list></name> <name>callback_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>InvokeCallbackWithoutArgsAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>IgnoreResultAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>IgnoreResultAction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>action</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>action_</name><argument_list>(<argument>action</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{








<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef>


<call><name><name>CompileAssertTypesEqual</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>

<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>action_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>action</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>action_</name><argument_list>(<argument>action</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <block>{

<expr><call><name><name>action_</name><operator>.</operator><name>Perform</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator></expr></expr_stmt>


<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>MakeResultIgnoredValue</name>
<name>OriginalFunction</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>OriginalFunction</name></expr></argument>&gt;</argument_list></name></type> <name>action_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<decl_stmt><decl><type><specifier>const</specifier> <name>A</name></type> <name>action_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>IgnoreResultAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};








<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ReferenceWrapper</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ReferenceWrapper</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>l_value</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>pointer_</name><argument_list>(<argument>&amp;l_value</argument>)</argument_list></macro> <block>{}</block>



<name>operator</name> <name>T</name><operator>&amp;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>pointer_</name></expr>;</return> }</block></expr></expr_stmt>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name><modifier>*</modifier></type> <name>pointer_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>PrintTo</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>ReferenceWrapper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>ref</name></expr></argument>, <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>value</name> <init>= <expr><name>ref</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Action1</name></expr></argument>, <argument><expr><name>typename</name> <name>Action2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>DoBothAction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>DoBothAction</name><argument_list>(<argument>Action1 action1</argument>, <argument>Action2 action2</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>action1_</name><argument_list>(<argument><expr><name>action1</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>action2_</name><argument_list>(<argument>action2</argument>)</argument_list></macro> <expr><block>{}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Action</name></macro><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Action</name></macro><expr><operator>&lt;</operator><name>F</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>action1_</name></expr></argument>, <argument><expr><name>action2_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>ActionInterface</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>MakeResultVoid</name> <name>VoidResult</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>VoidResult</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>action1</name></expr></argument>, <argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>action2</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>action1_</name><argument_list>(<argument><expr><name>action1</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>action2_</name><argument_list>(<argument>action2</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>Result</name> <macro><name>Perform</name><argument_list>(<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <block>{
<expr><call><name><name>action1_</name><operator>.</operator><name>Perform</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>action2_</name><operator>.</operator><name>Perform</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>VoidResult</name></expr></argument>&gt;</argument_list></name></type> <name>action1_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></type> <name>action2_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>Action1</name></type> <name>action1_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Action2</name></type> <name>action2_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>DoBothAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

}































typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name>IgnoredValue</name> <name>Unused</name></expr>;</expr_stmt>





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
<name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Action</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>from</name></expr></argument>)</argument_list></call>
<operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<call><name>fun_</name><argument_list>(<argument><expr><name><name>from</name><operator>.</operator><name>fun_</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>impl_</name><argument_list>(<argument>from.impl_ == NULL ? NULL
: new internal::ActionAdaptor&lt;To</argument>, <argument>From&gt;(from)</argument>)</argument_list></macro> <expr><block>{
}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>ReturnAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name> <macro><name>Return</name><argument_list>(<argument>R value</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ReturnAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>inline</specifier> <name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ReturnNullAction</name></expr></argument>&gt;</argument_list></name></type> <name>ReturnNull</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>ReturnNullAction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>inline</specifier> <name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ReturnVoidAction</name></expr></argument>&gt;</argument_list></name></type> <name>Return</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>ReturnVoidAction</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ReturnRefAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name> <macro><name>ReturnRef</name><argument_list>(<argument>R&amp; x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ReturnRefAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ReturnRefOfCopyAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name> <macro><name>ReturnRefOfCopy</name><argument_list>(<argument>const R&amp; x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ReturnRefOfCopyAction</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>ByMoveWrapper</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name> <macro><name>ByMove</name><argument_list>(<argument>R x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ByMoveWrapper</name><argument_list type="generic">&lt;<argument><expr><name>R</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>DoDefaultAction</name> <macro><name>DoDefault</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name>DoDefaultAction</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>IsAProtocolMessage</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>SetArgPointee</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>IsAProtocolMessage</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><operator>(</operator><name>GTEST_GCC_VER_</name> <operator>&amp;&amp;</operator> <name>GTEST_GCC_VER_</name> <operator>&lt;</operator> <literal type="number">40000</literal><operator>)</operator> <operator>||</operator> <name>GTEST_OS_SYMBIAN</name><operator>)</operator></expr></cpp:if>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;<argument><expr><name>N</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><modifier>*</modifier></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>SetArgPointee</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;<argument><expr><name>N</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>SetArgPointee</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>wchar_t</name><operator>*</operator></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>IsAProtocolMessage</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>SetArgumentPointee</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>SetArgumentPointeeAction</name><argument_list type="generic">&lt;
<argument><expr><name>N</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><name><name>IsAProtocolMessage</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>AssignAction</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>Assign</name><parameter_list>(<parameter><decl><type><name>T1</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>T2</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>AssignAction</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_OS_WINDOWS_MOBILE</name></expr></cpp:if>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>SetErrnoAndReturnAction</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>SetErrnoAndReturn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errval</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>SetErrnoAndReturnAction</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>errval</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FunctionImpl</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>InvokeWithoutArgsAction</name><argument_list type="generic">&lt;<argument><expr><name>FunctionImpl</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>InvokeWithoutArgs</name><parameter_list>(<parameter><decl><type><name>FunctionImpl</name></type> <name>function_impl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>InvokeWithoutArgsAction</name><argument_list type="generic">&lt;<argument><expr><name>FunctionImpl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>function_impl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>MethodPtr</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicAction</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>InvokeMethodWithoutArgsAction</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>MethodPtr</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>InvokeWithoutArgs</name><parameter_list>(<parameter><decl><type><name>Class</name><modifier>*</modifier></type> <name>obj_ptr</name></decl></parameter>, <parameter><decl><type><name>MethodPtr</name></type> <name>method_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicAction</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>InvokeMethodWithoutArgsAction</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>MethodPtr</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>obj_ptr</name></expr></argument>, <argument><expr><name>method_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>IgnoreResultAction</name><argument_list type="generic">&lt;<argument><expr><name>A</name></expr></argument>&gt;</argument_list></name> <macro><name>IgnoreResult</name><argument_list>(<argument>const A&amp; an_action</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>IgnoreResultAction</name><argument_list type="generic">&lt;<argument><expr><name>A</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>an_action</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ReferenceWrapper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>ByRef</name><argument_list>(<argument>T&amp; l_value</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ReferenceWrapper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>l_value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
