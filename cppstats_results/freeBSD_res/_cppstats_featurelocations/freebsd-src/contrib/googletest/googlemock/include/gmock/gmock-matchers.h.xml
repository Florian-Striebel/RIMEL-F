<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googlemock/include/gmock/gmock-matchers.h">





































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sstream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-internal-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-port.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;initializer_list&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(
<argument><literal type="number">4251</literal> <literal type="number">5046</literal></argument>

)</argument_list></macro>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>




















<decl_stmt><decl><type><name>class</name></type> <name>MatchResultListener</name> <block>{<block_content>
<label><name>public</name>:</label>



<decl_stmt><decl><type><name>explicit</name></type> <name>MatchResultListener</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <range>: <macro><name>stream_</name><argument_list>(<argument>os</argument>)</argument_list></macro> <expr><block>{}</block>
<name>virtual</name> <operator>~</operator><call><name>MatchResultListener</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr></range></decl>;</decl_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>MatchResultListener</name><operator>&amp;</operator> <name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>x</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><name>stream_</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>stream_</name> <operator>&lt;&lt;</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <macro><name>stream</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>stream_</name></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>IsInterested</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>stream_</name> <operator>!=</operator> <name>NULL</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <specifier>const</specifier> <name>stream_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>MatchResultListener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>MatchResultListener</name><operator>::</operator><operator>~</operator><macro><name>MatchResultListener</name><argument_list>()</argument_list></macro> <block>{
}</block>



<name>class</name> <name>MatcherDescriberInterface</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><macro><name>MatcherDescriberInterface</name><argument_list>()</argument_list></macro> <block>{}</block>






<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;







<expr><name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"not ("</literal></expr>;
<expr><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;
}</block></expr>
}</block></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MatcherInterface</name> <range>: <expr><name>public</name> <name>MatcherDescriberInterface</name> <block>{
<expr><name>public</name><operator>:</operator>































<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T x</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;




}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MatcherInterfaceAdapter</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>MatcherInterfaceAdapter</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>MatcherInterfaceAdapter</name><argument_list>()</argument_list></macro> <block>{ <expr><name>delete</name> <name>impl_</name></expr>; }</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>impl_</name><operator>-&gt;</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const T&amp; x</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <specifier>const</specifier> <name>impl_</name></expr>;

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>MatcherInterfaceAdapter</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>StringMatchResultListener</name> <range>: <expr><name>public</name> <name>MatchResultListener</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>StringMatchResultListener</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>MatchResultListener</name><argument_list>(<argument>&amp;ss_</argument>)</argument_list></macro> <block>{}</block>


<name>std</name><operator>::</operator><name>string</name> <macro><name>str</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ss_</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>Clear</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>ss_</name><operator>.</operator><name>str</name></name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>; }</block>

<name>private</name><operator>:</operator>
<operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>ss_</name></expr>;

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>StringMatchResultListener</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>

<struct>struct <name>AnyEq</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>==</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>AnyNe</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>!=</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>AnyLt</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>AnyGt</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>AnyLe</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>&lt;=</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>AnyGe</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>A</name></expr></argument>, <argument><expr><name>typename</name> <name>B</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>A</name><operator>&amp;</operator> <name>a</name><operator>,</operator> <specifier>const</specifier> <name>B</name><operator>&amp;</operator> <name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>&gt;=</operator> <name>b</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>DummyMatchResultListener</name> <range>: <expr><name>public</name> <name>MatchResultListener</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>DummyMatchResultListener</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>MatchResultListener</name><argument_list>(<argument>NULL</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>DummyMatchResultListener</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>StreamMatchResultListener</name> <range>: <expr><name>public</name> <name>MatchResultListener</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>StreamMatchResultListener</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MatchResultListener</name><argument_list>(<argument>os</argument>)</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>
<call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>StreamMatchResultListener</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MatcherBase</name> <block>{<block_content>
<label><name>public</name>:</label>


<decl_stmt><decl><type><name>bool</name></type> <name>MatchAndExplain</name><argument_list>(<argument><expr><macro><name>GTEST_REFERENCE_TO_CONST_</name><argument_list>(<argument>T</argument>)</argument_list></macro> <name>x</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Matches</name><argument_list>(<argument><expr><macro><name>GTEST_REFERENCE_TO_CONST_</name><argument_list>(<argument>T</argument>)</argument_list></macro> <name>x</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>DummyMatchResultListener</name></type> <name>dummy</name></decl>;</decl_stmt>
<return>return <expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content> <expr_stmt><expr><call><name><name>impl_</name><operator>-&gt;</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>impl_</name><operator>-&gt;</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>ExplainMatchResultTo</name><argument_list>(<argument><expr><macro><name>GTEST_REFERENCE_TO_CONST_</name><argument_list>(<argument>T</argument>)</argument_list></macro> <name>x</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<function_decl><type><name>StreamMatchResultListener</name></type> <name>listener</name><parameter_list>(<parameter><decl><type><name>os</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><specifier>const</specifier> <name>MatcherDescriberInterface</name><operator>*</operator> <macro><name>GetDescriber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>impl_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>protected</name>:</label>
<macro><name>MatcherBase</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>


<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>MatcherBase</name><argument_list>(
<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name> <macro><name>MatcherBase</name><argument_list>(
<argument>const MatcherInterface&lt;U&gt;* impl</argument>,
<argument>typename internal::EnableIf&lt;
!internal::IsSame&lt;U</argument>, <argument>GTEST_REFERENCE_TO_CONST_(U)&gt;::value&gt;::type* =
NULL</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>new internal::MatcherInterfaceAdapter&lt;U&gt;(impl)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <operator>~</operator><macro><name>MatcherBase</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>private</name><operator>:</operator>











<operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;
<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>impl_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>






<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Matcher</name> <range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>explicit</name> <macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name> <macro><name>Matcher</name><argument_list>(<argument>const MatcherInterface&lt;U&gt;* impl</argument>,
<argument>typename internal::EnableIf&lt;!internal::IsSame&lt;
U</argument>, <argument>GTEST_REFERENCE_TO_CONST_(U)&gt;::value&gt;::type* = NULL</argument>)</argument_list></macro>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<macro><name>Matcher</name><argument_list>(<argument>T value</argument>)</argument_list></macro></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>std</name><operator>::</operator><name>string</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>
<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>std</name><operator>::</operator><name>string</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;



<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator> <operator>::</operator><name>string</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>
<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator> <operator>::</operator><name>string</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;



<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>absl</name><operator>::</operator><name>string_view</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>absl</name><operator>::</operator><name>string_view</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>absl</name><operator>::</operator><name>string_view</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><specifier>const</specifier> <name>absl</name><operator>::</operator><name>string_view</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;


<macro><name>Matcher</name><argument_list>(<argument>absl::string_view s</argument>)</argument_list></macro>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name> <name>GTEST_API_</name></type> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>absl</name><operator>::</operator><name>string_view</name></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name><name>MatcherBase</name><argument_list type="generic">&lt;<argument><expr><name>absl</name><operator>::</operator><name>string_view</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Matcher</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>absl</name><operator>::</operator><name>string_view</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>absl</name><operator>::</operator><name>string_view</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>
<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>absl</name><operator>::</operator><name>string_view</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <name>internal</name><operator>::</operator><macro><name>MatcherBase</name></macro><operator>&lt;</operator><name>absl</name><operator>::</operator><name>string_view</name><operator>&gt;</operator><operator>(</operator><name>impl</name><operator>)</operator> <block>{}</block>



<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;


<macro><name>Matcher</name><argument_list>(<argument>absl::string_view s</argument>)</argument_list></macro>;
}</block></expr></range></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>os</name><operator>,</operator> <specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name><operator>)</operator> <block>{
<expr><call><name><name>matcher</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>os</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>os</name></expr>;</return>
}</block></expr></expr_stmt>













<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Impl</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PolymorphicMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>PolymorphicMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Impl</name><operator>&amp;</operator> <name>an_impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>an_impl</argument>)</argument_list></macro> <block>{}</block>



<name>Impl</name><operator>&amp;</operator> <macro><name>mutable_impl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>impl_</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>Impl</name><operator>&amp;</operator> <macro><name>impl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>impl_</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>MonomorphicImpl</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MonomorphicImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>MonomorphicImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Impl</name><operator>&amp;</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>impl_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>impl_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T x</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>impl_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>Impl</name> <name>impl_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>MonomorphicImpl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Impl</name></type> <name>impl_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PolymorphicMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>








<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>MakeMatcher</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>impl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Impl</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Impl</name></expr></argument>&gt;</argument_list></name></type> <name>MakePolymorphicMatcher</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Impl</name><modifier>&amp;</modifier></type> <name>impl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Impl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>impl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>











<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MatcherCastImpl</name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>polymorphic_matcher_or_value</name></decl></parameter>)</parameter_list> <block>{<block_content>













<return>return <expr><call><name>CastImpl</name><argument_list>(
<argument><expr><name>polymorphic_matcher_or_value</name></expr></argument>,
<argument><expr><call><name><name>BooleanConstant</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>BooleanConstant</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>Ignore</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>CastImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>polymorphic_matcher_or_value</name></decl></parameter>,
<parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></type></decl></parameter> ,
<parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>Ignore</name></expr></argument>&gt;</argument_list></name></type></decl></parameter>)</parameter_list> <block>{<block_content>








<return>return <expr><name>polymorphic_matcher_or_value</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>CastImpl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></type></decl></parameter> ,
<parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name></type></decl></parameter> )</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ImplicitCast_</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function_decl><type><specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>CastImpl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></type></decl></parameter> ,
<parameter><decl><type><name><name>BooleanConstant</name><argument_list type="generic">&lt;<argument><expr><name>false</name></expr></argument>&gt;</argument_list></name></type></decl></parameter> )</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>MatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>source_matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name>Impl</name><argument_list>(<argument><expr><name>source_matcher</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>source_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>source_matcher_</name><argument_list>(<argument>source_matcher</argument>)</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T x</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<expr><name>using</name> <name>FromType</name> <operator>=</operator> <name>typename</name> <name>std</name><operator>::</operator><name><name>remove_cv</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_pointer</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr>;
<expr><name>using</name> <name>ToType</name> <operator>=</operator> <name>typename</name> <name>std</name><operator>::</operator><name><name>remove_cv</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_pointer</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_reference</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr>;

<expr><call><name>static_assert</name><argument_list>(


<argument><expr><operator>(</operator><name>std</name><operator>::</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>!=</operator>
<name>std</name><operator>::</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>remove_reference</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>FromType</name></expr></argument>, <argument><expr><name>ToType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<operator>!</operator><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>FromType</name></expr></argument>, <argument><expr><name>ToType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"Can't implicitly convert from &lt;base&gt; to &lt;derived&gt;"</literal></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name><name>source_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>source_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>source_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name> <name>source_matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>MatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>matcher</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>MatcherCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><name><name>MatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Cast</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>SafeMatcherCastImpl</name> <block>{<block_content>
<label><name>public</name>:</label>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>polymorphic_matcher_or_value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><name><name>MatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Cast</name><argument_list>(<argument><expr><name>polymorphic_matcher_or_value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Cast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(<argument><expr><operator>(</operator><name>internal</name><operator>::</operator><name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator></expr></argument>,
<argument><expr><name>T_must_be_implicitly_convertible_to_U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator> <operator>!</operator><name>internal</name><operator>::</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>U</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>cannot_convert_non_reference_arg_to_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>T</argument>)</argument_list></macro> <expr_stmt><expr><name>RawT</name></expr>;</expr_stmt></typedef>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>U</argument>)</argument_list></macro> <expr_stmt><expr><name>RawU</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>kTIsOther</name> <init>= <expr><call><name>GMOCK_KIND_OF_</name><argument_list>(<argument><expr><name>RawT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>internal</name><operator>::</operator><name>kOther</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>kUIsOther</name> <init>= <expr><call><name>GMOCK_KIND_OF_</name><argument_list>(<argument><expr><name>RawU</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>internal</name><operator>::</operator><name>kOther</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><name>kTIsOther</name> <operator>||</operator> <name>kUIsOther</name> <operator>||</operator>
<operator>(</operator><name>internal</name><operator>::</operator><name><name>LosslessArithmeticConvertible</name><argument_list type="generic">&lt;<argument><expr><name>RawT</name></expr></argument>, <argument><expr><name>RawU</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator></expr></argument>,
<argument><expr><name>conversion_of_arithmetic_types_must_be_lossless</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>SafeMatcherCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>M</name><modifier>&amp;</modifier></type> <name>polymorphic_matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>SafeMatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Cast</name><argument_list>(<argument><expr><name>polymorphic_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>A</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>


<decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>PrintIfNotEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>explanation</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>explanation</name> <operator>!=</operator> <literal type="string">""</literal> <operator>&amp;&amp;</operator> <name>os</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal> <operator>&lt;&lt;</operator> <name>explanation</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><specifier>inline</specifier> <name>bool</name></type> <name>IsReadableTypeName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>type_name</name></expr></argument>)</argument_list> <block>{<block_content>


<return>return <expr><operator>(</operator><call><name><name>type_name</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <literal type="number">20</literal> <operator>||</operator>
<call><name><name>type_name</name><operator>.</operator><name>find_first_of</name></name><argument_list>(<argument><expr><literal type="string">"&lt;("</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>npos</name><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Value</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>MatchPrintAndExplain</name><parameter_list>(<parameter><decl><type><name>Value</name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>,
<parameter><decl><type><name>MatchResultListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<return>return <expr><call><name><name>matcher</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>inner_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>matcher</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_RTTI</name></expr></cpp:if>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>type_name</name> <operator>=</operator> <call><name><name>GetTypeName</name><argument_list type="generic">&lt;<argument><expr><name>Value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IsReadableTypeName</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" (of type "</literal> <operator>&lt;&lt;</operator> <name>type_name</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TuplePrefix</name> <block>{<block_content>
<label><name>public</name>:</label>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>bool</name></type> <name>Matches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MatcherTuple</name><modifier>&amp;</modifier></type> <name>matcher_tuple</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ValueTuple</name><modifier>&amp;</modifier></type> <name>value_tuple</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>TuplePrefix</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Matches</name><argument_list>(<argument><expr><name>matcher_tuple</name></expr></argument>, <argument><expr><name>value_tuple</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher_tuple</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Matches</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value_tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>ExplainMatchFailuresTo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatcherTuple</name><operator>&amp;</operator> <name>matchers</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ValueTuple</name><operator>&amp;</operator> <name>values</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>

<expr_stmt><expr><name><name>TuplePrefix</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>ExplainMatchFailuresTo</name><argument_list>(<argument><expr><name>matchers</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>typename</name> <name><name>tuple_element</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>matcher</name> <operator>=</operator>
<call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>tuple_element</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ValueTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>Value</name></expr>;</expr_stmt></typedef>
<macro><name>GTEST_REFERENCE_TO_CONST_</name><argument_list>(<argument>Value</argument>)</argument_list></macro> <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>listener</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>matcher</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>listener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Expected arg #"</literal> <operator>&lt;&lt;</operator> <name>N</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>N</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n Actual: "</literal></expr>;</expr_stmt>





<expr_stmt><expr><name>internal</name><operator>::</operator><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name></type> <name><name>TuplePrefix</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>bool</name></type> <name>Matches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MatcherTuple</name><modifier>&amp;</modifier></type></decl></parameter> ,
<parameter><decl><type><specifier>const</specifier> <name>ValueTuple</name><modifier>&amp;</modifier></type></decl></parameter> )</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>ExplainMatchFailuresTo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatcherTuple</name><operator>&amp;</operator></expr></argument> ,
<argument><expr><specifier>const</specifier> <name>ValueTuple</name><operator>&amp;</operator></expr></argument> ,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator></expr></argument> )</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>TupleMatches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MatcherTuple</name><modifier>&amp;</modifier></type> <name>matcher_tuple</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ValueTuple</name><modifier>&amp;</modifier></type> <name>value_tuple</name></decl></parameter>)</parameter_list> <block>{<block_content>


<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(<argument><expr><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>==</operator>
<name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>ValueTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>matcher_and_value_have_different_numbers_of_fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>TuplePrefix</name><argument_list type="generic">&lt;<argument><expr><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>ValueTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<call><name>Matches</name><argument_list>(<argument><expr><name>matcher_tuple</name></expr></argument>, <argument><expr><name>value_tuple</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueTuple</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>ExplainMatchFailureTupleTo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatcherTuple</name><operator>&amp;</operator> <name>matchers</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ValueTuple</name><operator>&amp;</operator> <name>values</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>TuplePrefix</name><argument_list type="generic">&lt;<argument><expr><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>ExplainMatchFailuresTo</name><argument_list>(
<argument><expr><name>matchers</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple</name></expr></argument>, <argument><expr><name>typename</name> <name>Func</name></expr></argument>, <argument><expr><name>typename</name> <name>OutIter</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TransformTupleValuesHelper</name> <block>{<block_content>
<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name> <name>TupleSize</name></expr>;</expr_stmt></typedef>

<label><name>public</name>:</label>


<function><type><specifier>static</specifier> <name>OutIter</name></type> <name>Run</name><parameter_list>(<parameter><decl><type><name>Func</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Tuple</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>OutIter</name></type> <name>out</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><call><name><name>IterateOverTuple</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>TupleSize</name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Tup</name></expr><operator>,</operator> <expr><name>size_t</name> <name>kRemainingSize</name><operator>&gt;</operator>
struct <name>IterateOverTuple</name> <block>{
<expr><name>OutIter</name> <macro><name>operator</name><argument_list>()</argument_list></macro> <operator>(</operator><name>Func</name> <name>f</name><operator>,</operator> <specifier>const</specifier> <name>Tup</name><operator>&amp;</operator> <name>t</name><operator>,</operator> <name>OutIter</name> <name>out</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>out</name><operator>++</operator> <operator>=</operator> <call><name>f</name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>TupleSize</name><operator>::</operator><name>value</name> <operator>-</operator> <name>kRemainingSize</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><call><name><name>IterateOverTuple</name><argument_list type="generic">&lt;<argument><expr><name>Tup</name></expr></argument>, <argument><expr><name>kRemainingSize</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tup</name></expr></argument>&gt;</argument_list></name>
struct <name><name>IterateOverTuple</name><argument_list type="generic">&lt;<argument><expr><name>Tup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>OutIter</name> <macro><name>operator</name><argument_list>()</argument_list></macro> <operator>(</operator><name>Func</name> <operator>,</operator> <specifier>const</specifier> <name>Tup</name><operator>&amp;</operator> <operator>,</operator> <name>OutIter</name> <name>out</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>out</name></expr>;</return>
}</block>
}</expr>;
}</block></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple</name></expr></argument>, <argument><expr><name>typename</name> <name>Func</name></expr></argument>, <argument><expr><name>typename</name> <name>OutIter</name></expr></argument>&gt;</argument_list></name>
<name>OutIter</name> <macro><name>TransformTupleValues</name><argument_list>(<argument>Func f</argument>, <argument>const Tuple&amp; t</argument>, <argument>OutIter out</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>TransformTupleValuesHelper</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>, <argument><expr><name>Func</name></expr></argument>, <argument><expr><name>OutIter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Run</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>AnyMatcherImpl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>GTEST_REFERENCE_TO_CONST_(T)</argument> ,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>true</name></expr>;</return>
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is anything"</literal></expr>; }</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{



<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"never matches"</literal></expr>;
}</block>
}</expr>;





<expr><name>class</name> <name>AnythingMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>A</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;











<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>D</name></expr></argument>, <argument><expr><name>typename</name> <name>Rhs</name></expr></argument>, <argument><expr><name>typename</name> <name>Op</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ComparisonBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>ComparisonBase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>rhs_</name><argument_list>(<argument>rhs</argument>)</argument_list></macro> <block>{}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Lhs</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Lhs</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;Lhs&gt;(rhs_)</argument>)</argument_list></macro>;</return>
}</block>

<name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Lhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Lhs</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>rhs_</name><argument_list>(<argument>rhs</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(
<argument>Lhs lhs</argument>, <argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><call><name>Op</name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <name>D</name><operator>::</operator><call><name>Desc</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>rhs_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <name>D</name><operator>::</operator><call><name>NegatedDesc</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>rhs_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>private</name><operator>:</operator>
<name>Rhs</name> <name>rhs_</name></expr>;
<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;
<expr><name>Rhs</name> <name>rhs_</name></expr>;
<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ComparisonBase</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>EqMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>EqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyEq</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>EqMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>EqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyEq</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is equal to"</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't equal to"</literal></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>NeMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>NeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyNe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>NeMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>NeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyNe</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't equal to"</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is equal to"</literal></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>LtMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>LtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyLt</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>LtMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>LtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyLt</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is &lt;"</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't &lt;"</literal></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>GtMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>GtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyGt</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>GtMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>GtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyGt</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is &gt;"</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't &gt;"</literal></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>LeMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>LeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyLe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>LeMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>LeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyLe</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is &lt;="</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't &lt;="</literal></expr>;</return> }</block>
}</expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>GeMatcher</name> <operator>:</operator> <name>public</name> <name><name>ComparisonBase</name><argument_list type="generic">&lt;<argument><expr><name><name>GeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Rhs</name></expr></argument>, <argument><expr><name>AnyGe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>GeMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Rhs</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ComparisonBase</name></macro><operator>&lt;</operator><name><name>GeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>Rhs</name></expr>, <expr><name>AnyGe</name><operator>&gt;</operator><operator>(</operator><name>rhs</name><operator>)</operator> <block>{ }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"is &gt;="</literal></expr>;</return> }</block>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>NegatedDesc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"isn't &gt;="</literal></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>IsNullMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Pointer</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const Pointer&amp; p</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<return>return <expr><name>p</name> <operator>==</operator> <name>nullptr</name></expr>;</return></block></expr>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>GetRawPointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is NULL"</literal></expr>; }</block>
<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"isn't NULL"</literal></expr>;
}</block>
}</expr>;



<expr><name>class</name> <name>NotNullMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Pointer</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const Pointer&amp; p</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<return>return <expr><name>p</name> <operator>!=</operator> <name>nullptr</name></expr>;</return></block></expr>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>GetRawPointer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"isn't NULL"</literal></expr>; }</block>
<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is NULL"</literal></expr>;
}</block>
}</expr>;














<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>RefMatcher</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name><name>RefMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{





<expr><name>public</name><operator>:</operator>



<name>explicit</name> <call><name>RefMatcher</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>x</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>object_</name><argument_list>(<argument>x</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Super</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Super</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{





<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;Super&gt;(object_)</argument>)</argument_list></macro>;</return>
}</block>

<name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Super</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Super</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>Impl</name><argument_list>(<argument><expr><name>Super</name><operator>&amp;</operator> <name>x</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>object_</name><argument_list>(<argument>x</argument>)</argument_list></macro> <block>{}</block>



<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(
<argument>Super&amp; x</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which is located @"</literal> <operator>&lt;&lt;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>&amp;</operator><name>x</name> <operator>==</operator> <operator>&amp;</operator><name>object_</name></expr>;</return>
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"references the variable "</literal></expr>;
<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>Super</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><name>object_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"does not reference the variable "</literal></expr>;
<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>Super</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><name>object_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>Super</name><operator>&amp;</operator> <name>object_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name>T</name><operator>&amp;</operator> <name>object_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>RefMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;


<expr><specifier>inline</specifier> <name>bool</name> <macro><name>CaseInsensitiveCStringEquals</name><argument_list>(<argument>const char* lhs</argument>, <argument>const char* rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>String</name><operator>::</operator><call><name>CaseInsensitiveCStringEquals</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name>bool</name> <macro><name>CaseInsensitiveCStringEquals</name><argument_list>(<argument>const wchar_t* lhs</argument>,
<argument>const wchar_t* rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>String</name><operator>::</operator><call><name>CaseInsensitiveWideCStringEquals</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>StringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>CaseInsensitiveStringEquals</name><argument_list>(<argument>const StringType&amp; s1</argument>,
<argument>const StringType&amp; s2</argument>)</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CaseInsensitiveCStringEquals</name><argument_list>(<argument><expr><call><name><name>s1</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>s2</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>


const typename StringType::value_type nul = 0</block><empty_stmt>;</empty_stmt></if></if_stmt>
<specifier>const</specifier> <name>size_t</name> <name>i1</name> <operator>=</operator> <call><name><name>s1</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>nul</name></expr></argument>)</argument_list></call><operator>,</operator> <name>i2</name> <operator>=</operator> <call><name><name>s2</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>nul</name></expr></argument>)</argument_list></call></block></expr>;


<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>==</operator> <name>StringType</name><operator>::</operator><name>npos</name> <operator>||</operator> <name>i2</name> <operator>==</operator> <name>StringType</name><operator>::</operator><name>npos</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>i1</name> <operator>==</operator> <name>i2</name></expr>;</return>
<expr_stmt/>}</block_content>


return CaseInsensitiveStringEquals(s1.substr(i1 + 1</block></if></if_stmt>)<operator>,</operator> <call><name><name>s2</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><name>i2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>)</block></expr>;
}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>StringType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>StrEqualityMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>StrEqualityMatcher</name><argument_list>(<argument>const StringType&amp; str</argument>, <argument>bool expect_eq</argument>,
<argument>bool case_sensitive</argument>)</argument_list></macro>
<operator>:</operator> <call><name>string_</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>expect_eq_</name><argument_list>(<argument><expr><name>expect_eq</name></expr></argument>)</argument_list></call></expr>, <macro><name>case_sensitive_</name><argument_list>(<argument>case_sensitive</argument>)</argument_list></macro> <expr><block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const absl::string_view&amp; s</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>!</operator><name>expect_eq_</name></expr>;</return>
<expr_stmt/>}</block_content>


const StringType&amp; str = string(s</block></if></if_stmt>)</block></expr>;
<return>return <expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CharType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>CharType* s</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>!</operator><name>expect_eq_</name></expr>;</return>
<expr_stmt/>}</block_content>
return MatchAndExplain(StringType(s</block></if></if_stmt>)<operator>,</operator> <name>listener</name>)</block></expr>;
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcheeStringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const MatcheeStringType&amp; s</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <call><name>s2</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>eq</name> <operator>=</operator> <ternary><condition><expr><name>case_sensitive_</name></expr> ?</condition><then> <expr><name>s2</name> <operator>==</operator> <name>string_</name></expr> </then><else>:
<expr><call><name>CaseInsensitiveStringEquals</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>string_</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;
<return>return <expr><name>expect_eq_</name> <operator>==</operator> <name>eq</name></expr>;</return>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>DescribeToHelper</name><argument_list>(<argument><expr><name>expect_eq_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>DescribeToHelper</name><argument_list>(<argument><expr><operator>!</operator><name>expect_eq_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>DescribeToHelper</name><argument_list>(<argument>bool expect_eq</argument>, <argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>expect_eq</name></expr> ?</condition><then> <expr><literal type="string">"is "</literal></expr> </then><else>: <expr><literal type="string">"isn't "</literal></expr></else></ternary><operator>)</operator></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"equal to "</literal></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>case_sensitive_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"(ignoring case) "</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
UniversalPrint(string_</block><operator>,</operator> <expr_stmt><expr><name>os</name></expr></expr_stmt></if></if_stmt>)</block></expr>;
}</block>

<specifier>const</specifier> <name>StringType</name> <name>string_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>expect_eq_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>case_sensitive_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>StrEqualityMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>StringType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasSubstrMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasSubstrMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <name>substring</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>substring_</name><argument_list>(<argument>substring</argument>)</argument_list></macro> <block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const absl::string_view&amp; s</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>


const StringType&amp; str = string(s</block></if></if_stmt>)</block></expr>;
<return>return <expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CharType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>CharType* s</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>MatchAndExplain</name><argument_list>(<argument><expr><call><name>StringType</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcheeStringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const MatcheeStringType&amp; s</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <call><name>s2</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>s2</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>substring_</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>StringType</name><operator>::</operator><name>npos</name></expr>;</return>
}</block>


<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has substring "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>substring_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has no substring "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>substring_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>StringType</name> <name>substring_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>HasSubstrMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>StringType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>StartsWithMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>StartsWithMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <name>prefix</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>prefix_</name><argument_list>(<argument>prefix</argument>)</argument_list></macro> <block>{
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const absl::string_view&amp; s</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>


const StringType&amp; str = string(s</block></if></if_stmt>)</block></expr>;
<return>return <expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CharType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>CharType* s</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>MatchAndExplain</name><argument_list>(<argument><expr><call><name>StringType</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcheeStringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const MatcheeStringType&amp; s</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <call><name>s2</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>s2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>prefix_</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>s2</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>prefix_</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>prefix_</name></expr>;</return>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"starts with "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>prefix_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't start with "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>prefix_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>StringType</name> <name>prefix_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>StartsWithMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>StringType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>EndsWithMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>EndsWithMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <name>suffix</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>suffix_</name><argument_list>(<argument>suffix</argument>)</argument_list></macro> <block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const absl::string_view&amp; s</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>


const StringType&amp; str = string(s</block></if></if_stmt>)</block></expr>;
<return>return <expr><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CharType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>CharType* s</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>MatchAndExplain</name><argument_list>(<argument><expr><call><name>StringType</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcheeStringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const MatcheeStringType&amp; s</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>StringType</name><operator>&amp;</operator> <call><name>s2</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>s2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <call><name><name>suffix_</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>s2</name><operator>.</operator><name>substr</name></name><argument_list>(<argument><expr><call><name><name>s2</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>suffix_</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>suffix_</name></expr>;</return>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"ends with "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>suffix_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't end with "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>suffix_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>StringType</name> <name>suffix_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>EndsWithMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;




<expr><name>class</name> <name>MatchesRegexMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>MatchesRegexMatcher</name><argument_list>(<argument>const RE* regex</argument>, <argument>bool full_match</argument>)</argument_list></macro>
<operator>:</operator> <call><name>regex_</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>, <macro><name>full_match_</name><argument_list>(<argument>full_match</argument>)</argument_list></macro> <expr><block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const absl::string_view&amp; s</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>s</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MatchAndExplain</name><argument_list>(<argument><expr><call><name>string</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CharType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>CharType* s</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>s</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>MatcheeStringType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const MatcheeStringType&amp; s</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <call><name>s2</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><name>full_match_</name></expr> ?</condition><then> <expr><name>RE</name><operator>::</operator><call><name>FullMatch</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><operator>*</operator><name>regex_</name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><name>RE</name><operator>::</operator><call><name>PartialMatch</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><operator>*</operator><name>regex_</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>full_match_</name></expr> ?</condition><then> <expr><literal type="string">"matches"</literal></expr> </then><else>: <expr><literal type="string">"contains"</literal></expr></else></ternary><operator>)</operator>
<operator>&lt;&lt;</operator> <literal type="string">" regular expression "</literal></expr>;
<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><call><name><name>regex_</name><operator>-&gt;</operator><name>pattern</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't "</literal> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>full_match_</name></expr> ?</condition><then> <expr><literal type="string">"match"</literal></expr> </then><else>: <expr><literal type="string">"contain"</literal></expr></else></ternary><operator>)</operator>
<operator>&lt;&lt;</operator> <literal type="string">" regular expression "</literal></expr>;
<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><call><name><name>regex_</name><operator>-&gt;</operator><name>pattern</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RE</name></expr></argument>&gt;</argument_list></name> <name>regex_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>full_match_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>MatchesRegexMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;









<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>D</name></expr></argument>, <argument><expr><name>typename</name> <name>Op</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PairMatchBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name> <operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt; ::testing::tuple&lt;T1</argument>, <argument>T2&gt; &gt;</argument>)</argument_list></macro>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;const ::testing::tuple&lt;T1</argument>, <argument>T2&gt;&amp;&gt;</argument>)</argument_list></macro>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <macro><name>GetDesc</name><argument_list>(<argument>::std::ostream&amp; os</argument>)</argument_list></macro> <block>{
<return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <name>D</name><operator>::</operator><call><name>Desc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(
<argument>Tuple args</argument>,
<argument>MatchResultListener*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><call><name>Op</name><argument_list>()</argument_list></call><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"are "</literal> <operator>&lt;&lt;</operator> <name>GetDesc</name></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"aren't "</literal> <operator>&lt;&lt;</operator> <name>GetDesc</name></expr>;
}</block>
}</expr>;
}</block></expr>;

<expr><name>class</name> <name>Eq2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Eq2Matcher</name></expr></argument>, <argument><expr><name>AnyEq</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"an equal pair"</literal></expr>;</return> }</block>
}</expr>;
<expr><name>class</name> <name>Ne2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Ne2Matcher</name></expr></argument>, <argument><expr><name>AnyNe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"an unequal pair"</literal></expr>;</return> }</block>
}</expr>;
<expr><name>class</name> <name>Lt2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Lt2Matcher</name></expr></argument>, <argument><expr><name>AnyLt</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"a pair where the first &lt; the second"</literal></expr>;</return> }</block>
}</expr>;
<expr><name>class</name> <name>Gt2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Gt2Matcher</name></expr></argument>, <argument><expr><name>AnyGt</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"a pair where the first &gt; the second"</literal></expr>;</return> }</block>
}</expr>;
<expr><name>class</name> <name>Le2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Le2Matcher</name></expr></argument>, <argument><expr><name>AnyLe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"a pair where the first &lt;= the second"</literal></expr>;</return> }</block>
}</expr>;
<expr><name>class</name> <name>Ge2Matcher</name> <operator>:</operator> <name>public</name> <name><name>PairMatchBase</name><argument_list type="generic">&lt;<argument><expr><name>Ge2Matcher</name></expr></argument>, <argument><expr><name>AnyGe</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Desc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="string">"a pair where the first &gt;= the second"</literal></expr>;</return> }</block>
}</expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>NotMatcherImpl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>NotMatcherImpl</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>GTEST_REFERENCE_TO_CONST_(T) x</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>NotMatcherImpl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>NotMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>NotMatcher</name><argument_list>(<argument>InnerMatcher matcher</argument>)</argument_list></macro> <operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <block>{}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>NotMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>InnerMatcher</name> <name>matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>NotMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>AllOfMatcherImpl</name>
<operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>AllOfMatcherImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>matchers</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>internal::move(matchers)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">") and ("</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
*os &lt;&lt; ")"</block><empty_stmt>;</empty_stmt></for>
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">") or ("</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeNegationTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
*os &lt;&lt; ")"</block><empty_stmt>;</empty_stmt></for>
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>GTEST_REFERENCE_TO_CONST_(T) x</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<expr><name>std</name><operator>::</operator><name>string</name> <name>all_match_result</name></expr>;

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>slistener</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slistener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>all_match_result</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>all_match_result</name> <operator>=</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>result</name> <operator>=</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>result</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>all_match_result</name> <operator>+=</operator> <literal type="string">", and "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>all_match_result</name> <operator>+=</operator> <name>result</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
} else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
}


*listener &lt;&lt; all_match_result</block></block><empty_stmt>;</empty_stmt></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>

private:
const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_</block></block><empty_stmt>;</empty_stmt></if></if_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>AllOfMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>CombiningMatcher</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>VariadicMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>VariadicMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator><operator>...</operator> <name>matchers</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>matchers...</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Must have at least one matcher."</literal></expr></argument>)</argument_list></call></expr>;
}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>values</name></expr>;
<expr><call><name><name>CreateVariadicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>values</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>integral_constant</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>CombiningMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>I</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>CreateVariadicMatcher</name><argument_list>(<argument>std::vector&lt;Matcher&lt;T&gt; &gt;* values</argument>,
<argument>std::integral_constant&lt;size_t</argument>, <argument>I&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name><name>values</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>I</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matchers_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>CreateVariadicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>integral_constant</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>I</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>CreateVariadicMatcher</name><argument_list>(
<argument>std::vector&lt;Matcher&lt;T&gt; &gt;*</argument>,
<argument>std::integral_constant&lt;size_t</argument>, <argument>sizeof...(Args)&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{}</block>

<name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>Args</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>matchers_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>VariadicMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>using</name></type> <name>AllOfMatcher</name> <init>= <expr><name><name>VariadicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>AllOfMatcherImpl</name></expr></argument>, <argument><expr><name>Args</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Matcher1</name></expr></argument>, <argument><expr><name>typename</name> <name>Matcher2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>BothOfMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>BothOfMatcher</name><argument_list>(<argument>Matcher1 matcher1</argument>, <argument>Matcher2 matcher2</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>matcher1_</name><argument_list>(<argument><expr><name>matcher1</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matcher2_</name><argument_list>(<argument>matcher2</argument>)</argument_list></macro> <expr><block>{}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>values</name></expr>;
<expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher1_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher2_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>AllOfMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>Matcher1</name> <name>matcher1_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Matcher2</name></type> <name>matcher2_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>BothOfMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>AnyOfMatcherImpl</name>
<range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>AnyOfMatcherImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>matchers</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>internal::move(matchers)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">") or ("</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
*os &lt;&lt; ")"</block><empty_stmt>;</empty_stmt></for>
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">") and ("</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeNegationTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
*os &lt;&lt; ")"</block><empty_stmt>;</empty_stmt></for>
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>GTEST_REFERENCE_TO_CONST_(T) x</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>std</name><operator>::</operator><name>string</name> <name>no_match_result</name></expr>;



<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>slistener</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slistener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content> else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>no_match_result</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>no_match_result</name> <operator>=</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>result</name> <operator>=</operator> <call><name><name>slistener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>result</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>no_match_result</name> <operator>+=</operator> <literal type="string">", and "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>no_match_result</name> <operator>+=</operator> <name>result</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}
}


*listener &lt;&lt; no_match_result</block><empty_stmt>;</empty_stmt></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>

private:
const std::vector&lt;Matcher&lt;T&gt; &gt; matchers_</block></block><empty_stmt>;</empty_stmt></if></if_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>AnyOfMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block></block><empty_stmt>;</empty_stmt></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>using</name></type> <name>AnyOfMatcher</name> <init>= <expr><name><name>VariadicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>AnyOfMatcherImpl</name></expr></argument>, <argument><expr><name>Args</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Matcher1</name></expr></argument>, <argument><expr><name>typename</name> <name>Matcher2</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>EitherOfMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>EitherOfMatcher</name><argument_list>(<argument>Matcher1 matcher1</argument>, <argument>Matcher2 matcher2</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>matcher1_</name><argument_list>(<argument><expr><name>matcher1</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matcher2_</name><argument_list>(<argument>matcher2</argument>)</argument_list></macro> <expr><block>{}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>values</name></expr>;
<expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher1_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>values</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher2_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>AnyOfMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>Matcher1</name> <name>matcher1_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Matcher2</name></type> <name>matcher2_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>EitherOfMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Predicate</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TrulyMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>TrulyMatcher</name><argument_list>(<argument>Predicate pred</argument>)</argument_list></macro> : <macro><name>predicate_</name><argument_list>(<argument>pred</argument>)</argument_list></macro> <block>{<block_content><expr_stmt/>}</block_content>





template &lt;typename T&gt;
bool MatchAndExplain(T&amp; x</block><operator>,</operator>
<expr_stmt><expr><name>MatchResultListener</name><operator>*</operator></expr></expr_stmt> )</block_content> const <block>{<block_content>






<if_stmt><if>if <condition>(<expr><call><name>predicate_</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>

void DescribeTo(::std::ostream* os</block></block></decl>) const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"satisfies the given predicate"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

void DescribeNegationTo(::std::ostream* os</block></decl_stmt>)</block_content> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't satisfy the given predicate"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

private:
Predicate predicate_</block></block><empty_stmt>;</empty_stmt></for>

<call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>TrulyMatcher</name></expr></argument>)</argument_list></call></block></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MatcherAsPredicate</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>MatcherAsPredicate</name><argument_list>(<argument>M matcher</argument>)</argument_list></macro> : <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <block>{<block_content><expr_stmt/>}</block_content>







template &lt;typename T&gt;
bool operator(</block>)</block_content>(const T&amp; x</block></decl>) const <block>{<block_content>














<return>return <expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher_</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>Matches</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

private:
M matcher_</block>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>MatcherAsPredicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block><empty_stmt>;</empty_stmt></for>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PredicateFormatterFromMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>PredicateFormatterFromMatcher</name><argument_list>(<argument>M m</argument>)</argument_list></macro> <operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>internal::move(m)</argument>)</argument_list></macro> <block>{}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>AssertionResult</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator> <name>value_text</name><operator>,</operator> <specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>x</name><operator>)</operator> <specifier>const</specifier> <block>{











<expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher</name> <operator>=</operator> <call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher_</name></expr></argument>)</argument_list></call></expr>;
<expr><name>StringMatchResultListener</name> <name>listener</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>matcher</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>listener</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AssertionSuccess</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>ss</name></block></expr>;
<expr><name>ss</name> <operator>&lt;&lt;</operator> <literal type="string">"Value of: "</literal> <operator>&lt;&lt;</operator> <name>value_text</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal>
<operator>&lt;&lt;</operator> <literal type="string">"Expected: "</literal></expr>;
<expr><call><name><name>matcher</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ss</name> <operator>&lt;&lt;</operator> <literal type="string">"\n Actual: "</literal> <operator>&lt;&lt;</operator> <call><name><name>listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>AssertionFailure</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>ss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>M</name> <name>matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PredicateFormatterFromMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PredicateFormatterFromMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name>
<macro><name>MakePredicateFormatterFromMatcher</name><argument_list>(<argument>M matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>PredicateFormatterFromMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FloatType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>FloatingEqMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>






<macro><name>FloatingEqMatcher</name><argument_list>(<argument>FloatType expected</argument>, <argument>bool nan_eq_nan</argument>)</argument_list></macro> <operator>:</operator>
<call><name>expected_</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>nan_eq_nan_</name><argument_list>(<argument><expr><name>nan_eq_nan</name></expr></argument>)</argument_list></call></expr>, <macro><name>max_abs_error_</name><argument_list>(<argument>-<literal type="number">1</literal></argument>)</argument_list></macro> <expr><block>{
}</block>




<macro><name>FloatingEqMatcher</name><argument_list>(<argument>FloatType expected</argument>, <argument>bool nan_eq_nan</argument>,
<argument>FloatType max_abs_error</argument>)</argument_list></macro>
<operator>:</operator> <call><name>expected_</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>nan_eq_nan_</name><argument_list>(<argument><expr><name>nan_eq_nan</name></expr></argument>)</argument_list></call></expr>,
<macro><name>max_abs_error_</name><argument_list>(<argument>max_abs_error</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>max_abs_error</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">", where max_abs_error is"</literal> <operator>&lt;&lt;</operator> <name>max_abs_error</name></expr>;
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Impl</name><argument_list>(<argument>FloatType expected</argument>, <argument>bool nan_eq_nan</argument>, <argument>FloatType max_abs_error</argument>)</argument_list></macro>
<operator>:</operator> <call><name>expected_</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>nan_eq_nan_</name><argument_list>(<argument><expr><name>nan_eq_nan</name></expr></argument>)</argument_list></call></expr>,
<macro><name>max_abs_error_</name><argument_list>(<argument>max_abs_error</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T value</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name> <call><name>actual</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>expected</name><argument_list>(<argument><expr><name>expected_</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><call><name><name>actual</name><operator>.</operator><name>is_nan</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>expected</name><operator>.</operator><name>is_nan</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>actual</name><operator>.</operator><name>is_nan</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>expected</name><operator>.</operator><name>is_nan</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>nan_eq_nan_</name></expr>;</return>
<expr_stmt/>}</block_content>

return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>
if (HasMaxAbsError(</block></if></if_stmt>))</block> <block>{




<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>expected_</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>

const FloatType diff = value - expected_</block><empty_stmt>;</empty_stmt></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>max_abs_error_</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>

if (listener-&gt;IsInterested(</block></if></if_stmt>))</block> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which is "</literal> <operator>&lt;&lt;</operator> <name>diff</name> <operator>&lt;&lt;</operator> <literal type="string">" from "</literal> <operator>&lt;&lt;</operator> <name>expected_</name></expr>;
}</block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block></expr> <if_stmt><else>else <block>{<block_content>
<return>return <expr><call><name><name>actual</name><operator>.</operator><name>AlmostEquals</name></name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
}

virtual void DescribeTo(::std::ostream* os</block></else></if_stmt>) <specifier>const</specifier> <block>{



<expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>streamsize</name> <name>old_precision</name> <operator>=</operator> <call><name><name>os</name><operator>-&gt;</operator><name>precision</name></name><argument_list>(
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>digits10</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>expected_</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>is_nan</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nan_eq_nan_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is NaN"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"never matches"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
} else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is approximately "</literal> <operator>&lt;&lt;</operator> <name>expected_</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HasMaxAbsError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" (absolute error &lt;= "</literal> <operator>&lt;&lt;</operator> <name>max_abs_error_</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
os-&gt;precision(old_precision</block></if></if_stmt>)</block_content></block></block></block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>

virtual void DescribeNegationTo(::std::ostream* os</block></if></if_stmt>) <specifier>const</specifier> <block>{

<expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>streamsize</name> <name>old_precision</name> <operator>=</operator> <call><name><name>os</name><operator>-&gt;</operator><name>precision</name></name><argument_list>(
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>digits10</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>expected_</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>is_nan</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nan_eq_nan_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"isn't NaN"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is anything"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
} else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"isn't approximately "</literal> <operator>&lt;&lt;</operator> <name>expected_</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HasMaxAbsError</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" (absolute error &gt; "</literal> <operator>&lt;&lt;</operator> <name>max_abs_error_</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

os-&gt;precision(old_precision</block></if></if_stmt>)</block_content></block></block></block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>

private:
bool HasMaxAbsError(</block></if></if_stmt>) <specifier>const</specifier> <block>{
<return>return <expr><name>max_abs_error_</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</return>
}</block></block></block></block>

<specifier>const</specifier> <name>FloatType</name> <name>expected_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>nan_eq_nan_</name></expr>;

<expr><specifier>const</specifier> <name>FloatType</name> <name>max_abs_error_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;







<expr><name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>FloatType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new Impl&lt;FloatType&gt;(expected_, nan_eq_nan_, max_abs_error_)</argument>)</argument_list></macro>;</return>
}</block>

<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><specifier>const</specifier> <name>FloatType</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new Impl&lt;const FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_)</argument>)</argument_list></macro>;</return>
}</block>

<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>FloatType</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new Impl&lt;FloatType&amp;&gt;(expected_, nan_eq_nan_, max_abs_error_)</argument>)</argument_list></macro>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>FloatType</name> <name>expected_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>nan_eq_nan_</name></expr>;

<expr><specifier>const</specifier> <name>FloatType</name> <name>max_abs_error_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>FloatingEqMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FloatType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>FloatingEq2Matcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>FloatingEq2Matcher</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>Init</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>explicit</name> <macro><name>FloatingEq2Matcher</name><argument_list>(<argument>bool nan_eq_nan</argument>)</argument_list></macro> <block>{ <expr><call><name>Init</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>nan_eq_nan</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>explicit</name> <macro><name>FloatingEq2Matcher</name><argument_list>(<argument>FloatType max_abs_error</argument>)</argument_list></macro> <block>{
<expr><call><name>Init</name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>FloatingEq2Matcher</name><argument_list>(<argument>FloatType max_abs_error</argument>, <argument>bool nan_eq_nan</argument>)</argument_list></macro> <block>{
<expr><call><name>Init</name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>, <argument><expr><name>nan_eq_nan</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name> <operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new Impl&lt; ::testing::tuple&lt;T1</argument>, <argument>T2&gt; &gt;(max_abs_error_, nan_eq_nan_)</argument>)</argument_list></macro>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new Impl&lt;const ::testing::tuple&lt;T1</argument>, <argument>T2&gt;&amp;&gt;(max_abs_error_, nan_eq_nan_)</argument>)</argument_list></macro>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <macro><name>GetDesc</name><argument_list>(<argument>::std::ostream&amp; os</argument>)</argument_list></macro> <block>{
<return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"an almost-equal pair"</literal></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Impl</name><argument_list>(<argument>FloatType max_abs_error</argument>, <argument>bool nan_eq_nan</argument>)</argument_list></macro> <operator>:</operator>
<call><name>max_abs_error_</name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>,
<macro><name>nan_eq_nan_</name><argument_list>(<argument>nan_eq_nan</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Tuple args</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>max_abs_error_</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name></type> <name>fm</name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nan_eq_nan_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content> else <block>{<block_content>
<decl_stmt><decl><type><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name></type> <name>fm</name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nan_eq_nan_</name></expr></argument>,
<argument><expr><name>max_abs_error_</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatType</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><argument_list>(<argument><expr><name>fm</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(
<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
}
virtual void DescribeTo(::std::ostream* os</block></block></if></if_stmt>) <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"are "</literal> <operator>&lt;&lt;</operator> <name>GetDesc</name></expr>;
}</block></block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"aren't "</literal> <operator>&lt;&lt;</operator> <name>GetDesc</name></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>FloatType</name> <name>max_abs_error_</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>nan_eq_nan_</name></expr>;
}</block></expr>;

<expr><name>void</name> <macro><name>Init</name><argument_list>(<argument>FloatType max_abs_error_val</argument>, <argument>bool nan_eq_nan_val</argument>)</argument_list></macro> <block>{
<expr><name>max_abs_error_</name> <operator>=</operator> <name>max_abs_error_val</name></expr>;
<expr><name>nan_eq_nan_</name> <operator>=</operator> <name>nan_eq_nan_val</name></expr>;
}</block>
<name>FloatType</name> <name>max_abs_error_</name></expr>;
<expr><name>bool</name> <name>nan_eq_nan_</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PointeeMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>PointeeMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InnerMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <block>{}</block>









<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Pointer</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>Pointer</name><operator>&gt;</operator><operator>(</operator>
<name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>Pointer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<name>private</name><operator>:</operator>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Pointer</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Pointer</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>PointeeOf</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator>
<name>GTEST_REMOVE_REFERENCE_</name><operator>(</operator><name>Pointer</name><operator>)</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>Pointee</name></expr>;</expr_stmt></typedef>

<name>explicit</name> <call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InnerMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>MatcherCast&lt;const Pointee&amp;&gt;(matcher)</argument>)</argument_list></macro> <block>{}</block></block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"points to a value that "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"does not point to a value that "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Pointer pointer</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>GetRawPointer</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which points to "</literal></block></expr>;
<return>return <expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><operator>*</operator><name>pointer</name></expr></argument>, <argument><expr><name>matcher_</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Pointee</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><specifier>const</specifier> <name>InnerMatcher</name> <name>matcher_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PointeeMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_RTTI</name></expr></cpp:if>






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>WhenDynamicCastToMatcherBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>WhenDynamicCastToMatcherBase</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>GetCastTypeDescription</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>GetCastTypeDescription</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>protected</name><operator>:</operator>
<specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;

<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetToName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>GetTypeName</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <name>void</name> <macro><name>GetCastTypeDescription</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"when dynamic_cast to "</literal> <operator>&lt;&lt;</operator> <call><name>GetToName</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;
}</block>

<call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>WhenDynamicCastToMatcherBase</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>WhenDynamicCastToMatcher</name> <operator>:</operator> <name>public</name> <name><name>WhenDynamicCastToMatcherBase</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>WhenDynamicCastToMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>WhenDynamicCastToMatcherBase</name></macro><operator>&lt;</operator><name>To</name><operator>&gt;</operator><operator>(</operator><name>matcher</name><operator>)</operator> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>From from</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<expr><name>To</name> <name>to</name> <operator>=</operator> <call><name><name>dynamic_cast</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>matcher_</name></name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name><name>WhenDynamicCastToMatcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>WhenDynamicCastToMatcherBase</name><argument_list type="generic">&lt;<argument><expr><name>To</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>WhenDynamicCastToMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>WhenDynamicCastToMatcherBase</name></macro><operator>&lt;</operator><name>To</name><operator>&amp;</operator><operator>&gt;</operator><operator>(</operator><name>matcher</name><operator>)</operator> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>From&amp; from</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<expr><name>To</name><operator>*</operator> <name>to</name> <operator>=</operator> <call><name><name>dynamic_cast</name><argument_list type="generic">&lt;<argument><expr><name>To</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>from</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which cannot be dynamic_cast to "</literal> <operator>&lt;&lt;</operator> <call><name><name>this</name><operator>-&gt;</operator><name>GetToName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
return MatchPrintAndExplain(*to</block><operator>,</operator> <expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>matcher_</name></name></expr><operator>,</operator> <expr><name>listener</name></expr></expr_stmt></if></if_stmt>)</block></expr>;
}</block></expr>
}</block></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>FieldType</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>FieldMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>FieldMatcher</name><argument_list>(<argument>FieldType Class::*field</argument>,
<argument>const Matcher&lt;const FieldType&amp;&gt;&amp; matcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>field_</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>matcher_</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>, <macro><name>whose_field_</name><argument_list>(<argument><literal type="string">"whose given field "</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>FieldMatcher</name><argument_list>(<argument>const std::string&amp; field_name</argument>, <argument>FieldType Class::*field</argument>,
<argument>const Matcher&lt;const FieldType&amp;&gt;&amp; matcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>field_</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>matcher_</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>,
<macro><name>whose_field_</name><argument_list>(<argument><literal type="string">"whose field `"</literal> + field_name + <literal type="string">"` "</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an object "</literal> <operator>&lt;&lt;</operator> <name>whose_field_</name></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an object "</literal> <operator>&lt;&lt;</operator> <name>whose_field_</name></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const T&amp; value</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>MatchAndExplainImpl</name><argument_list>(
<argument><expr><name>typename</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator>
<name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>value</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>



<name>bool</name> <macro><name>MatchAndExplainImpl</name><argument_list>(<argument>false_type</argument> , <argument>const Class&amp; obj</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <name>whose_field_</name> <operator>&lt;&lt;</operator> <literal type="string">"is "</literal></expr>;
<return>return <expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><name>obj</name><operator>.*</operator><name>field_</name></expr></argument>, <argument><expr><name>matcher_</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>MatchAndExplainImpl</name><argument_list>(<argument>true_type</argument> , <argument>const Class* p</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which points to an object "</literal></block></expr>;



<return>return <expr><call><name>MatchAndExplainImpl</name><argument_list>(<argument><expr><call><name>false_type</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>FieldType</name> <name>Class</name><operator>::</operator><operator>*</operator><name>field_</name></expr>;
<expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FieldType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;



<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>whose_field_</name></expr>;

<expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>FieldMatcher</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyType</name></expr></argument>, <argument><expr><name>typename</name> <name>Property</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PropertyMatcher</name> <block>{
<expr><name>public</name><operator>:</operator></expr>




<typedef>typedef <macro><name>GTEST_REFERENCE_TO_CONST_</name><argument_list>(<argument>PropertyType</argument>)</argument_list></macro> <expr_stmt><expr><name>RefToConstProperty</name></expr>;</expr_stmt></typedef>

<macro><name>PropertyMatcher</name><argument_list>(<argument>Property property</argument>, <argument>const Matcher&lt;RefToConstProperty&gt;&amp; matcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>property_</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call><operator>,</operator>
<call><name>matcher_</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call><operator>,</operator>
<macro><name>whose_property_</name><argument_list>(<argument><literal type="string">"whose given property "</literal></argument>)</argument_list></macro> <block>{}</block></block>

<macro><name>PropertyMatcher</name><argument_list>(<argument>const std::string&amp; property_name</argument>, <argument>Property property</argument>,
<argument>const Matcher&lt;RefToConstProperty&gt;&amp; matcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>property_</name><argument_list>(<argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>matcher_</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>,
<macro><name>whose_property_</name><argument_list>(<argument><literal type="string">"whose property `"</literal> + property_name + <literal type="string">"` "</literal></argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an object "</literal> <operator>&lt;&lt;</operator> <name>whose_property_</name></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an object "</literal> <operator>&lt;&lt;</operator> <name>whose_property_</name></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const T&amp;value</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>MatchAndExplainImpl</name><argument_list>(
<argument><expr><name>typename</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator>
<name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>type</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>value</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>



<name>bool</name> <macro><name>MatchAndExplainImpl</name><argument_list>(<argument>false_type</argument> , <argument>const Class&amp; obj</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <name>whose_property_</name> <operator>&lt;&lt;</operator> <literal type="string">"is "</literal></expr>;


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_PREFAST_</name></expr></argument> )</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>==</operator> <literal type="number">1800</literal></expr></cpp:if>


<expr><name>posix</name><operator>::</operator><call><name>Abort</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>RefToConstProperty</name> <name>result</name> <operator>=</operator> <operator>(</operator><name>obj</name><operator>.*</operator><name>property_</name><operator>)</operator><operator>(</operator><operator>)</operator></block></expr>;
<return>return <expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>matcher_</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<name>bool</name> <macro><name>MatchAndExplainImpl</name><argument_list>(<argument>true_type</argument> , <argument>const Class* p</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which points to an object "</literal></block></expr>;



<return>return <expr><call><name>MatchAndExplainImpl</name><argument_list>(<argument><expr><call><name>false_type</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>Property</name></type> <name>property_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>RefToConstProperty</name></expr></argument>&gt;</argument_list></name></type> <name>matcher_</name></decl>;</decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>whose_property_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PropertyMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Functor</name><operator>&gt;</operator>
struct <name>CallableTraits</name> <block>{
<typedef>typedef <type><name>Functor</name></type> <name>StorageType</name>;</typedef>

<specifier>static</specifier> <name>void</name> <macro><name>CheckIsValid</name><argument_list>(<argument>Functor</argument> )</argument_list></macro> <block>{}</block></block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>auto</name> <macro><name>Invoke</name><argument_list>(<argument>Functor f</argument>, <argument>T arg</argument>)</argument_list></macro> <operator>-&gt;</operator> <macro><name>decltype</name><argument_list>(<argument>f(arg)</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>Functor</name><operator>::</operator><name>result_type</name> <name>ResultType</name></expr>;</expr_stmt></typedef>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ResultType</name></type> <name>Invoke</name><parameter_list>(<parameter><decl><type><name>Functor</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>f</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>ArgType</name></expr><operator>,</operator> <expr><name>typename</name> <name>ResType</name><operator>&gt;</operator>
struct <name><name>CallableTraits</name><argument_list type="generic">&lt;<argument><expr><name>ResType</name><operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><name>ArgType</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><name>ResType</name></type> <name>ResultType</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <function_decl><type><name>ResType</name></type>(<modifier>*</modifier><name>StorageType</name>)<parameter_list>(<parameter><decl><type><name>ArgType</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>CheckIsValid</name><parameter_list>(<parameter><function_decl><type><name>ResType</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>ArgType</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"NULL function pointer is passed into ResultOf()."</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ResType</name></type> <name>Invoke</name><parameter_list>(<parameter><function_decl><type><name>ResType</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>ArgType</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>T</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
};



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ResultOfMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>ResultOfMatcher</name><argument_list>(<argument>Callable callable</argument>, <argument>InnerMatcher matcher</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>callable_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matcher_</name><argument_list>(<argument>internal::move(matcher)</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CallableTraits</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>CheckIsValid</name><argument_list>(<argument><expr><name>callable_</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>Impl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>callable_</name></expr></argument>, <argument><expr><name>matcher_</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>CallableTraits</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>StorageType</name> <name>CallableStorageType</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<expr><name>using</name> <name>ResultType</name> <operator>=</operator> <macro><name>decltype</name><argument_list>(<argument>CallableTraits&lt;Callable&gt;::template Invoke&lt;T&gt;(
std::declval&lt;CallableStorageType&gt;(), std::declval&lt;T&gt;())</argument>)</argument_list></macro></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>CallableTraits</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ResultType</name> <name>ResultType</name></expr>;</expr_stmt></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallableStorageType</name><operator>&amp;</operator> <name>callable</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>M</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>callable_</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call>, <macro><name>matcher_</name><argument_list>(<argument>MatcherCast&lt;ResultType&gt;(matcher)</argument>)</argument_list></macro> <block>{}</block></block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is mapped by the given callable to a value that "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is mapped by the given callable to a value that "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T obj</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which is mapped by the given callable to "</literal></expr>;




<expr><name>ResultType</name> <name>result</name> <operator>=</operator>
<name><name>CallableTraits</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>template</name> <call><name><name>Invoke</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>callable_</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>MatchPrintAndExplain</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>matcher_</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>





<decl_stmt><decl><type><name>mutable</name> <name>CallableStorageType</name></type> <name>callable_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ResultType</name></expr></argument>&gt;</argument_list></name></type> <name>matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>CallableStorageType</name></type> <name>callable_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>InnerMatcher</name></type> <name>matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ResultOfMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SizeMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>SizeIsMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>SizeIsMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SizeMatcher</name><operator>&amp;</operator> <name>size_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>size_matcher_</name><argument_list>(<argument>size_matcher</argument>)</argument_list></macro> <block>{
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;Container&gt;(size_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>ContainerView</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>ContainerView</name><operator>::</operator><name>type</name><operator>::</operator><name>size_type</name> <name>SizeType</name></expr>;</expr_stmt></typedef>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SizeMatcher</name><operator>&amp;</operator> <name>size_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>size_matcher_</name><argument_list>(<argument>MatcherCast&lt;SizeType&gt;(size_matcher)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"size "</literal></expr>;
<expr><call><name><name>size_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"size "</literal></expr>;
<expr><call><name><name>size_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>SizeType</name> <name>size</name> <operator>=</operator> <call><name><name>container</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>StringMatchResultListener</name> <name>size_listener</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>result</name> <operator>=</operator> <call><name><name>size_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_listener</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>listener</name>
<operator>&lt;&lt;</operator> <literal type="string">"whose size "</literal> <operator>&lt;&lt;</operator> <name>size</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;
<expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>size_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>result</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>SizeType</name></expr></argument>&gt;</argument_list></name></type> <name>size_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>SizeMatcher</name></type> <name>size_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>SizeIsMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>DistanceMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>BeginEndDistanceIsMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>BeginEndDistanceIsMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DistanceMatcher</name><operator>&amp;</operator> <name>distance_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>distance_matcher_</name><argument_list>(<argument>distance_matcher</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;Container&gt;(distance_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>ContainerView</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>ContainerView</name><operator>::</operator><name>type</name><operator>::</operator><name>const_iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>difference_type</name>
<name>DistanceType</name></expr>;</expr_stmt></typedef>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DistanceMatcher</name><operator>&amp;</operator> <name>distance_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>distance_matcher_</name><argument_list>(<argument>MatcherCast&lt;DistanceType&gt;(distance_matcher)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"distance between begin() and end() "</literal></expr>;
<expr><call><name><name>distance_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"distance between begin() and end() "</literal></expr>;
<expr><call><name><name>distance_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_BEGIN_AND_END_</name></expr></cpp:if>
<expr><name>using</name> <name>std</name><operator>::</operator><name>begin</name></expr>;
<expr><name>using</name> <name>std</name><operator>::</operator><name>end</name></expr>;
<expr><name>DistanceType</name> <name>distance</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>end</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><name>DistanceType</name> <name>distance</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>distance</name><argument_list>(<argument><expr><call><name><name>container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>StringMatchResultListener</name> <name>distance_listener</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>result</name> <operator>=</operator>
<call><name><name>distance_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>distance</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distance_listener</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose distance between begin() and end() "</literal> <operator>&lt;&lt;</operator> <name>distance</name>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;
<expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>distance_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>result</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>DistanceType</name></expr></argument>&gt;</argument_list></name></type> <name>distance_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>DistanceMatcher</name></type> <name>distance_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>BeginEndDistanceIsMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};











<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ContainerEqMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <name>View</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>type</name> <name>StlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>const_reference</name> <name>StlContainerReference</name></expr>;</expr_stmt></typedef>



<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ContainerEqMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Container</name><operator>&amp;</operator> <name>expected</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>expected_</name><argument_list>(<argument>View::Copy(expected)</argument>)</argument_list></macro> <block>{


<expr><operator>(</operator><name>void</name><operator>)</operator><name>testing</name><operator>::</operator><call><name><name>StaticAssertTypeEq</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>,
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"equals "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>expected_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"does not equal "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>expected_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>LhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const LhsContainer&amp; lhs</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>LhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>LhsView</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsView</name><operator>::</operator><name>type</name> <name>LhsStlContainer</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>StlContainerReference</name></type> <name>lhs_stl_container</name> <init>= <expr><name>LhsView</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lhs_stl_container</name> <operator>==</operator> <name>expected_</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <specifier>const</specifier> <name>os</name> <operator>=</operator> <call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>os</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>printed_header</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>typename</name> <name>LhsStlContainer</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator>
<call><name><name>lhs_stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>lhs_stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>internal</name><operator>::</operator><call><name>ArrayAwareFind</name><argument_list>(<argument><expr><call><name><name>expected_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>expected_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>expected_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>printed_header</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"which has these unexpected elements: "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>printed_header</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<decl_stmt><decl><type><name>bool</name></type> <name>printed_header2</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>expected_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>expected_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>internal</name><operator>::</operator><call><name>ArrayAwareFind</name><argument_list>(
<argument><expr><call><name><name>lhs_stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>lhs_stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>lhs_stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>printed_header2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>printed_header</name></expr> ?</condition><then> <expr><literal type="string">",\nand"</literal></expr> </then><else>: <expr><literal type="string">"which"</literal></expr></else></ternary><operator>)</operator>
<operator>&lt;&lt;</operator> <literal type="string">" doesn't have these expected elements: "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>printed_header2</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>StlContainer</name></type> <name>expected_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ContainerEqMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<struct>struct <name>LessComparator</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>lhs</name><operator>,</operator> <specifier>const</specifier> <name>U</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>lhs</name> <operator>&lt;</operator> <name>rhs</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Comparator</name></expr></argument>, <argument><expr><name>typename</name> <name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>WhenSortedByMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>WhenSortedByMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Comparator</name><operator>&amp;</operator> <name>comparator</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ContainerMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>comparator_</name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>LhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>LhsContainer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;LhsContainer&gt;(comparator_, matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>LhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>LhsContainer</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>LhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>LhsView</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsView</name><operator>::</operator><name>type</name> <name>LhsStlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsView</name><operator>::</operator><name>const_reference</name> <name>LhsStlContainerReference</name></expr>;</expr_stmt></typedef>


<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>RemoveConstFromKey</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>LhsStlContainer</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>LhsValue</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Comparator</name><operator>&amp;</operator> <name>comparator</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ContainerMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>comparator_</name><argument_list>(<argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"(when sorted) "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"(when sorted) "</literal></expr>;
<expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>LhsContainer lhs</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>LhsStlContainerReference</name> <name>lhs_stl_container</name> <operator>=</operator> <name>LhsView</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>LhsValue</name></expr></argument>&gt;</argument_list></name> <call><name>sorted_container</name><argument_list>(<argument><expr><call><name><name>lhs_stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>lhs_stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><operator>::</operator><name>std</name><operator>::</operator><call><name>sort</name><argument_list>(
<argument><expr><call><name><name>sorted_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sorted_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>comparator_</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<return>return <expr><call><name><name>matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>sorted_container</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

*listener &lt;&lt; "which is "</block><empty_stmt>;</empty_stmt></if></if_stmt>
<call><name>UniversalPrint</name><argument_list>(<argument><expr><name>sorted_container</name></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">" when sorted"</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>inner_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>sorted_container</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>Comparator</name></type> <name>comparator_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>LhsValue</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>Comparator</name></type> <name>comparator_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ContainerMatcher</name></type> <name>matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>WhenSortedByMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TupleMatcher</name></expr></argument>, <argument><expr><name>typename</name> <name>RhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PointwiseMatcher</name> <block>{<block_content>
<expr_stmt><expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><operator>!</operator><name><name>IsHashTable</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>RhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_UnorderedPointwise_with_hash_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RhsContainer</name></expr></argument>&gt;</argument_list></name> <name>RhsView</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RhsView</name><operator>::</operator><name>type</name> <name>RhsStlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RhsStlContainer</name><operator>::</operator><name>value_type</name> <name>RhsValue</name></expr>;</expr_stmt></typedef>



<expr_stmt><expr><call><name>PointwiseMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TupleMatcher</name><operator>&amp;</operator> <name>tuple_matcher</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>RhsContainer</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>tuple_matcher_</name><argument_list>(<argument><expr><name>tuple_matcher</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>rhs_</name><argument_list>(<argument>RhsView::Copy(rhs)</argument>)</argument_list></macro> <expr><block>{


<expr><operator>(</operator><name>void</name><operator>)</operator><name>testing</name><operator>::</operator><call><name><name>StaticAssertTypeEq</name><argument_list type="generic">&lt;<argument><expr><name>RhsContainer</name></expr></argument>,
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>RhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>LhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>LhsContainer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><operator>!</operator><name><name>IsHashTable</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>LhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_UnorderedPointwise_with_hash_tables</name></expr></argument>)</argument_list></call></expr>;

<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;LhsContainer&gt;(tuple_matcher_, rhs_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>LhsContainer</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>LhsContainer</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;
<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>LhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>LhsView</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsView</name><operator>::</operator><name>type</name> <name>LhsStlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsView</name><operator>::</operator><name>const_reference</name> <name>LhsStlContainerReference</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>LhsStlContainer</name><operator>::</operator><name>value_type</name> <name>LhsValue</name></expr>;</expr_stmt></typedef>




<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LhsValue</name><operator>&amp;</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>RhsValue</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>InnerMatcherArg</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TupleMatcher</name><operator>&amp;</operator> <name>tuple_matcher</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>RhsStlContainer</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list></call>

<operator>:</operator> <call><name>mono_tuple_matcher_</name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcherArg</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>tuple_matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>rhs_</name><argument_list>(<argument>rhs</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"contains "</literal> <operator>&lt;&lt;</operator> <call><name><name>rhs_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">" values, where each value and its corresponding value in "</literal></expr>;
<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>RhsStlContainer</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><name>rhs_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;
<expr><call><name><name>mono_tuple_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>
<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't contain exactly "</literal> <operator>&lt;&lt;</operator> <call><name><name>rhs_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">" values, or contains a value x at some index i"</literal>
<operator>&lt;&lt;</operator> <literal type="string">" where x and the i-th value of "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>rhs_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;
<expr><call><name><name>mono_tuple_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>LhsContainer lhs</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>LhsStlContainerReference</name> <name>lhs_stl_container</name> <operator>=</operator> <name>LhsView</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>size_t</name> <name>actual_size</name> <operator>=</operator> <call><name><name>lhs_stl_container</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>actual_size</name> <operator>!=</operator> <call><name><name>rhs_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which contains "</literal> <operator>&lt;&lt;</operator> <name>actual_size</name> <operator>&lt;&lt;</operator> <literal type="string">" values"</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>

typename LhsStlContainer::const_iterator left = lhs_stl_container.begin(</block></if></if_stmt>)</block></expr>;</expr_stmt>
<expr_stmt><expr><name>typename</name> <name>RhsStlContainer</name><operator>::</operator><name>const_iterator</name> <name>right</name> <operator>=</operator> <call><name><name>rhs_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>actual_size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>left</name></expr><operator>,</operator> <expr><operator>++</operator><name>right</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>inner_listener</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>mono_tuple_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(
<argument><expr><call><name>InnerMatcherArg</name><argument_list>(<argument><expr><call><name><name>ImplicitCast_</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LhsValue</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ImplicitCast_</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RhsValue</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"where the value pair ("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><operator>*</operator><name>left</name></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><operator>*</operator><name>right</name></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">") at index #"</literal> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" don't match"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>mono_tuple_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(
<argument><expr><call><name>InnerMatcherArg</name><argument_list>(<argument><expr><call><name><name>ImplicitCast_</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>LhsValue</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>left</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ImplicitCast_</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RhsValue</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcherArg</name></expr></argument>&gt;</argument_list></name></type> <name>mono_tuple_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RhsStlContainer</name></type> <name>rhs_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>TupleMatcher</name></type> <name>tuple_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>RhsStlContainer</name></type> <name>rhs_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PointwiseMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>QuantifierMatcherImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <type><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name></type> <name>View</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>type</name> <name>StlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>const_reference</name> <name>StlContainerReference</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>value_type</name> <name>Element</name></expr>;</expr_stmt></typedef>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>InnerMatcher</name><operator>&gt;</operator>
<name>explicit</name> <macro><name>QuantifierMatcherImpl</name><argument_list>(<argument>InnerMatcher inner_matcher</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>inner_matcher_</name><argument_list>(
<argument>testing::SafeMatcherCast&lt;const Element&amp;&gt;(inner_matcher)</argument>)</argument_list></macro> <block>{}</block>




<name>bool</name> <macro><name>MatchAndExplainImpl</name><argument_list>(<argument>bool all_elements_should_match</argument>,
<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>StlContainerReference</name> <name>stl_container</name> <operator>=</operator> <name>View</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size_t</name> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<for>for <control>(<init><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr><operator>,</operator> <expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>inner_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>matches</name> <init>= <expr><call><name><name>inner_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>matches</name> <operator>!=</operator> <name>all_elements_should_match</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose element #"</literal> <operator>&lt;&lt;</operator> <name>i</name>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>matches</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><name>all_elements_should_match</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>
}
return <expr_stmt><expr><name>all_elements_should_match</name></expr>;</expr_stmt>
}

protected:
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>QuantifierMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ContainsMatcherImpl</name> <range>: <expr><name>public</name> <name><name>QuantifierMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name> <macro><name>ContainsMatcherImpl</name><argument_list>(<argument>InnerMatcher inner_matcher</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>QuantifierMatcherImpl</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><name>inner_matcher</name><operator>)</operator> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"contains at least one element that "</literal></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't contain any element that "</literal></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>MatchAndExplainImpl</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>container</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ContainsMatcherImpl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>EachMatcherImpl</name> <range>: <expr><name>public</name> <name><name>QuantifierMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name> <macro><name>EachMatcherImpl</name><argument_list>(<argument>InnerMatcher inner_matcher</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>QuantifierMatcherImpl</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><name>inner_matcher</name><operator>)</operator> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"only contains elements that "</literal></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"contains some element that "</literal></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>inner_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>MatchAndExplainImpl</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>container</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>EachMatcherImpl</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ContainsMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>ContainsMatcher</name><argument_list>(<argument>M m</argument>)</argument_list></macro> : <macro><name>inner_matcher_</name><argument_list>(<argument>m</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new ContainsMatcherImpl&lt;Container&gt;(inner_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>M</name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ContainsMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>EachMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>EachMatcher</name><argument_list>(<argument>M m</argument>)</argument_list></macro> : <macro><name>inner_matcher_</name><argument_list>(<argument>m</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new EachMatcherImpl&lt;Container&gt;(inner_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>M</name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>EachMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<struct>struct <name>Rank1</name> <block>{}</block>;</struct>
<decl_stmt><decl><type><name><name>struct</name> <name>Rank0</name></name></type> <range>: <expr><name>Rank1</name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>pair_getters</name> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<expr_stmt><expr><name>using</name> <name>std</name><operator>::</operator><name>get</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>First</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>x</name></expr></argument>, <argument><expr><name>Rank1</name></expr></argument>)</argument_list> -&gt; <name>decltype</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>First</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>x</name></expr></argument>, <argument><expr><name>Rank0</name></expr></argument>)</argument_list> -&gt; <name>decltype</name><argument_list>(<argument><expr><operator>(</operator><name><name>x</name><operator>.</operator><name>first</name></name><operator>)</operator></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name><name>x</name><operator>.</operator><name>first</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>Second</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>x</name></expr></argument>, <argument><expr><name>Rank1</name></expr></argument>)</argument_list> -&gt; <name>decltype</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>Second</name><argument_list>(<argument><expr><name>T</name><operator>&amp;</operator> <name>x</name></expr></argument>, <argument><expr><name>Rank0</name></expr></argument>)</argument_list> -&gt; <name>decltype</name><argument_list>(<argument><expr><operator>(</operator><name><name>x</name><operator>.</operator><name>second</name></name><operator>)</operator></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name><name>x</name><operator>.</operator><name>second</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>T</name><operator>::</operator><name>first_type</name><operator>&amp;</operator> <macro><name>First</name><argument_list>(<argument>T&amp; x</argument>, <argument>Rank0</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>first</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>typename</name> <name>T</name><operator>::</operator><name>first_type</name><operator>&amp;</operator> <macro><name>First</name><argument_list>(<argument>const T&amp; x</argument>, <argument>Rank0</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>first</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>T</name><operator>::</operator><name>second_type</name><operator>&amp;</operator> <macro><name>Second</name><argument_list>(<argument>T&amp; x</argument>, <argument>Rank0</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>second</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>typename</name> <name>T</name><operator>::</operator><name>second_type</name><operator>&amp;</operator> <macro><name>Second</name><argument_list>(<argument>const T&amp; x</argument>, <argument>Rank0</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>second</name></name></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>PairType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>KeyMatcherImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>PairType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>PairType</argument>)</argument_list></macro> <expr_stmt><expr><name>RawPairType</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RawPairType</name><operator>::</operator><name>first_type</name> <name>KeyType</name></expr>;</expr_stmt></typedef>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>InnerMatcher</name><operator>&gt;</operator>
<name>explicit</name> <macro><name>KeyMatcherImpl</name><argument_list>(<argument>InnerMatcher inner_matcher</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>inner_matcher_</name><argument_list>(
<argument>testing::SafeMatcherCast&lt;const KeyType&amp;&gt;(inner_matcher)</argument>)</argument_list></macro> <block>{
}</block>


<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>PairType key_value</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>StringMatchResultListener</name> <name>inner_listener</name></expr>;
<expr><specifier>const</specifier> <name>bool</name> <name>match</name> <operator>=</operator> <call><name><name>inner_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(
<argument><expr><name>pair_getters</name><operator>::</operator><call><name>First</name><argument_list>(<argument><expr><name>key_value</name></expr></argument>, <argument><expr><call><name>Rank0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>inner_listener</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>explanation</name> <operator>=</operator> <call><name><name>inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>explanation</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose first field is a value "</literal> <operator>&lt;&lt;</operator> <name>explanation</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
}


virtual <decl_stmt><decl><type><name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has a key that "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't have a key that "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>inner_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>KeyType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>inner_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>KeyMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>KeyMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>KeyMatcher</name><argument_list>(<argument>M m</argument>)</argument_list></macro> : <macro><name>matcher_for_key_</name><argument_list>(<argument>m</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>PairType</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>PairType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new KeyMatcherImpl&lt;PairType&gt;(matcher_for_key_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>M</name></type> <name>matcher_for_key_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>KeyMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>PairType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PairMatcherImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>PairType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>PairType</argument>)</argument_list></macro> <expr_stmt><expr><name>RawPairType</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RawPairType</name><operator>::</operator><name>first_type</name> <name>FirstType</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RawPairType</name><operator>::</operator><name>second_type</name> <name>SecondType</name></expr>;</expr_stmt></typedef>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>FirstMatcher</name></expr><operator>,</operator> <expr><name>typename</name> <name>SecondMatcher</name><operator>&gt;</operator>
<macro><name>PairMatcherImpl</name><argument_list>(<argument>FirstMatcher first_matcher</argument>, <argument>SecondMatcher second_matcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>first_matcher_</name><argument_list>(
<argument><expr><name>testing</name><operator>::</operator><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FirstType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>first_matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>second_matcher_</name><argument_list>(
<argument>testing::SafeMatcherCast&lt;const SecondType&amp;&gt;(second_matcher)</argument>)</argument_list></macro> <expr><block>{
}</block>


<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has a first field that "</literal></expr>;
<expr><call><name><name>first_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", and has a second field that "</literal></expr>;
<expr><call><name><name>second_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has a first field that "</literal></expr>;
<expr><call><name><name>first_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", or has a second field that "</literal></expr>;
<expr><call><name><name>second_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>PairType a_pair</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<return>return <expr><call><name><name>first_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>pair_getters</name><operator>::</operator><call><name>First</name><argument_list>(<argument><expr><name>a_pair</name></expr></argument>, <argument><expr><call><name>Rank0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>second_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>pair_getters</name><operator>::</operator><call><name>Second</name><argument_list>(<argument><expr><name>a_pair</name></expr></argument>, <argument><expr><call><name>Rank0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<name>StringMatchResultListener</name> <name>first_inner_listener</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>first_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>pair_getters</name><operator>::</operator><call><name>First</name><argument_list>(<argument><expr><name>a_pair</name></expr></argument>, <argument><expr><call><name>Rank0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>first_inner_listener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose first field does not match"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>first_inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>second_inner_listener</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>second_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>pair_getters</name><operator>::</operator><call><name>Second</name><argument_list>(<argument><expr><name>a_pair</name></expr></argument>, <argument><expr><call><name>Rank0</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>second_inner_listener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose second field does not match"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>second_inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ExplainSuccess</name><argument_list>(<argument><expr><call><name><name>first_inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>second_inner_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
}

private:
<decl_stmt><decl><type><name>void</name></type> <name>ExplainSuccess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>first_explanation</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>second_explanation</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose both fields match"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>first_explanation</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">", where the first field is a value "</literal> <operator>&lt;&lt;</operator> <name>first_explanation</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>second_explanation</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>first_explanation</name> <operator>!=</operator> <literal type="string">""</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"and "</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"where "</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"the second field is a value "</literal> <operator>&lt;&lt;</operator> <name>second_explanation</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FirstType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>first_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SecondType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>second_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PairMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstMatcher</name></expr></argument>, <argument><expr><name>typename</name> <name>SecondMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PairMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>PairMatcher</name><argument_list>(<argument>FirstMatcher first_matcher</argument>, <argument>SecondMatcher second_matcher</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>first_matcher_</name><argument_list>(<argument><expr><name>first_matcher</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>second_matcher_</name><argument_list>(<argument>second_matcher</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>PairType</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>PairType</name><operator>&gt;</operator> <operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(
<argument>new PairMatcherImpl&lt;PairType&gt;(
first_matcher_, second_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>FirstMatcher</name></type> <name>first_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>SecondMatcher</name></type> <name>second_matcher_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>PairMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ElementsAreMatcherImpl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name> <name>View</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>type</name> <name>StlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>const_reference</name> <name>StlContainerReference</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>value_type</name> <name>Element</name></expr>;</expr_stmt></typedef>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIter</name></expr></argument>&gt;</argument_list></name></type>
<name>ElementsAreMatcherImpl</name><parameter_list>(<parameter><decl><type><name>InputIter</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>InputIter</name></type> <name>last</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name>first</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>matchers_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>first</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>count</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is empty"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>count</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has 1 element that "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"has "</literal> <operator>&lt;&lt;</operator> <call><name>Elements</name><argument_list>(<argument><expr><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" where\n"</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"element #"</literal> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">",\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>count</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"isn't empty"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"doesn't have "</literal> <operator>&lt;&lt;</operator> <call><name>Elements</name><argument_list>(<argument><expr><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">", or\n"</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"element #"</literal> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>matchers_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>DescribeNegationTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", or\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>MatchAndExplain</name><argument_list>(<argument><expr><name>Container</name> <name>container</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const <block>{<block_content>



<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>listener_interested</name> <init>= <expr><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>explanations</name><argument_list>(<argument><expr><call><name>count</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>StlContainerReference</name></type> <name>stl_container</name> <init>= <expr><name>View</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>exam_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>mismatch_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>




<for>for <control>(<init>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>exam_pos</name> <operator>!=</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr><operator>,</operator> <expr><operator>++</operator><name>exam_pos</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>match</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>listener_interested</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>matchers_</name><index>[<expr><name>exam_pos</name></expr>]</index></name><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>explanations</name><index>[<expr><name>exam_pos</name></expr>]</index></name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <name><name>matchers_</name><index>[<expr><name>exam_pos</name></expr>]</index></name><operator>.</operator><call><name>Matches</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mismatch_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>





<decl_stmt><decl><type><name>size_t</name></type> <name>actual_count</name> <init>= <expr><name>exam_pos</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>actual_count</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>actual_count</name> <operator>!=</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>listener_interested</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>actual_count</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which has "</literal> <operator>&lt;&lt;</operator> <call><name>Elements</name><argument_list>(<argument><expr><name>actual_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mismatch_found</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>listener_interested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose element #"</literal> <operator>&lt;&lt;</operator> <name>exam_pos</name> <operator>&lt;&lt;</operator> <literal type="string">" doesn't match"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><name><name>explanations</name><index>[<expr><name>exam_pos</name></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>listener_interested</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>reason_printed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <call><name>count</name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>s</name> <operator>=</operator> <name><name>explanations</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>s</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reason_printed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">",\nand "</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose element #"</literal> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">" matches, "</literal> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reason_printed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<function><type><specifier>static</specifier> <name>Message</name></type> <name>Elements</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Message</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>count</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">" element"</literal></expr> </then><else>: <expr><literal type="string">" elements"</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>size_t</name> <macro><name>count</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>matchers_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ElementsAreMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};





<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>MatchMatrix</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>MatchMatrix</name><argument_list>(<argument>size_t num_elements</argument>, <argument>size_t num_matchers</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>num_elements_</name><argument_list>(<argument><expr><name>num_elements</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>num_matchers_</name><argument_list>(<argument><expr><name>num_matchers</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>matched_</name><argument_list>(<argument>num_elements_* num_matchers_</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{
}</block>

<name>size_t</name> <macro><name>LhsSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>num_elements_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>size_t</name> <macro><name>RhsSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>num_matchers_</name></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasEdge</name><argument_list>(<argument><expr><name>size_t</name> <name>ilhs</name></expr></argument>, <argument><expr><name>size_t</name> <name>irhs</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name><name>matched_</name><index>[<expr><call><name>SpaceIndex</name><argument_list>(<argument><expr><name>ilhs</name></expr></argument>, <argument><expr><name>irhs</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>SetEdge</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>ilhs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>irhs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>matched_</name><index>[<expr><call><name>SpaceIndex</name><argument_list>(<argument><expr><name>ilhs</name></expr></argument>, <argument><expr><name>irhs</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>b</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>NextGraph</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Randomize</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>DebugString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>size_t</name></type> <name>SpaceIndex</name><argument_list>(<argument><expr><name>size_t</name> <name>ilhs</name></expr></argument>, <argument><expr><name>size_t</name> <name>irhs</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>ilhs</name> <operator>*</operator> <name>num_matchers_</name> <operator>+</operator> <name>irhs</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>num_elements_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_matchers_</name></decl>;</decl_stmt>




<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <name>matched_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>ElementMatcherPair</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ElementMatcherPair</name></expr></argument>&gt;</argument_list></name> <name>ElementMatcherPairs</name></expr>;</expr_stmt></typedef>



<function_decl><type><name>GTEST_API_</name> <name>ElementMatcherPairs</name></type>
<name>FindMaxBipartiteMatching</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MatchMatrix</name><modifier>&amp;</modifier></type> <name>g</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>UnorderedMatcherRequire</name> <block>{
<enum>enum <name>Flags</name> <block>{
<decl><name>Superset</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,
<decl><name>Subset</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>ExactMatch</name> <init>= <expr><name>Superset</name> <operator>|</operator> <name>Subset</name></expr></init></decl>,
}</block>;</enum>
}</block>;</struct>




<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>UnorderedElementsAreMatcherImplBase</name> <block>{<block_content>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>explicit</name></type> <name>UnorderedElementsAreMatcherImplBase</name><argument_list>(
<argument><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <name>matcher_flags</name></expr></argument>)</argument_list>
<range>: <macro><name>match_flags_</name><argument_list>(<argument>matcher_flags</argument>)</argument_list></macro> <expr><block>{}</block></expr></range></decl></decl_stmt>




<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MatcherDescriberInterface</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MatcherDescriberVec</name></expr>;</expr_stmt></typedef>


<decl_stmt><decl><type><name>void</name></type> <name>DescribeToImpl</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DescribeNegationToImpl</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>VerifyMatchMatrix</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>element_printouts</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MatchMatrix</name><operator>&amp;</operator> <name>matrix</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>FindPairing</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatchMatrix</name><operator>&amp;</operator> <name>matrix</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>MatcherDescriberVec</name><modifier>&amp;</modifier></type> <name>matcher_describers</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>matcher_describers_</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Message</name></type> <name>Elements</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Message</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>n</name> <operator>&lt;&lt;</operator> <literal type="string">" element"</literal> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <macro><name>match_flags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>match_flags_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <name>match_flags_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>MatcherDescriberVec</name></type> <name>matcher_describers_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>UnorderedElementsAreMatcherImplBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>UnorderedElementsAreMatcherImpl</name>
<range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Container</name></expr></argument>&gt;</argument_list></name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>UnorderedElementsAreMatcherImplBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name> <name>View</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>type</name> <name>StlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>const_reference</name> <name>StlContainerReference</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>const_iterator</name> <name>StlContainerConstIterator</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>StlContainer</name><operator>::</operator><name>value_type</name> <name>Element</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIter</name></expr></argument>&gt;</argument_list></name></type>
<name>UnorderedElementsAreMatcherImpl</name><argument_list>(<argument><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <name>matcher_flags</name></expr></argument>,
<argument><expr><name>InputIter</name> <name>first</name></expr></argument>, <argument><expr><name>InputIter</name> <name>last</name></expr></argument>)</argument_list>
<range>: <macro><name>UnorderedElementsAreMatcherImplBase</name><argument_list>(<argument>matcher_flags</argument>)</argument_list></macro> <expr><block>{
<for>for <control>(<init>;</init> <condition><expr><name>first</name> <operator>!=</operator> <name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>first</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>matchers_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>matcher_describers</name><argument_list>()</argument_list></call><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><call><name><name>matchers_</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetDescriber</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}


virtual void DescribeTo(::std::ostream* os</block></for>) <specifier>const</specifier> <block>{
<return>return <expr><name>UnorderedElementsAreMatcherImplBase</name><operator>::</operator><call><name>DescribeToImpl</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>UnorderedElementsAreMatcherImplBase</name><operator>::</operator><call><name>DescribeNegationToImpl</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Container container</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>StlContainerReference</name> <name>stl_container</name> <operator>=</operator> <name>View</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>element_printouts</name></expr>;
<expr><name>MatchMatrix</name> <name>matrix</name> <operator>=</operator>
<call><name>AnalyzeElements</name><argument_list>(<argument><expr><call><name><name>stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>element_printouts</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>matrix</name><operator>.</operator><name>LhsSize</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>matrix</name><operator>.</operator><name>RhsSize</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>

if (match_flags(</block></if></if_stmt>) <operator>==</operator> <name>UnorderedMatcherRequire</name><operator>::</operator><name>ExactMatch</name>)</block> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>matrix</name><operator>.</operator><name>LhsSize</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>matrix</name><operator>.</operator><name>RhsSize</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name><name>matrix</name><operator>.</operator><name>LhsSize</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which has "</literal> <operator>&lt;&lt;</operator> <call><name>Elements</name><argument_list>(<argument><expr><call><name><name>matrix</name><operator>.</operator><name>LhsSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>
}

return VerifyMatchMatrix(element_printouts</block><operator>,</operator> <expr_stmt><expr><name>matrix</name></expr><operator>,</operator> <expr><name>listener</name></expr></expr_stmt></if></if_stmt>) <operator>&amp;&amp;</operator>
<call><name>FindPairing</name><argument_list>(<argument><expr><name>matrix</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></block></block></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ElementIter</name></expr></argument>&gt;</argument_list></name>
<name>MatchMatrix</name></type> <name>AnalyzeElements</name><argument_list>(<argument><expr><name>ElementIter</name> <name>elem_first</name></expr></argument>, <argument><expr><name>ElementIter</name> <name>elem_last</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>element_printouts</name></expr></argument>,
<argument><expr><name>MatchResultListener</name><operator>*</operator> <name>listener</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>element_printouts</name><operator>-&gt;</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <name>did_match</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_elements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>elem_first</name> <operator>!=</operator> <name>elem_last</name></expr>;</condition> <incr><expr><operator>++</operator><name>num_elements</name></expr><operator>,</operator> <expr><operator>++</operator><name>elem_first</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>element_printouts</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>PrintToString</name><argument_list>(<argument><expr><operator>*</operator><name>elem_first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>irhs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>irhs</name> <operator>!=</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>irhs</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>did_match</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><call><name>Matches</name><argument_list>(<argument><expr><name><name>matchers_</name><index>[<expr><name>irhs</name></expr>]</index></name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>*</operator><name>elem_first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<decl_stmt><decl><type><name>MatchMatrix</name></type> <name>matrix</name><argument_list>(<argument><expr><name>num_elements</name></expr></argument>, <argument><expr><call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>did_match_iter</name> <operator>=</operator> <call><name><name>did_match</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>ilhs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ilhs</name> <operator>!=</operator> <name>num_elements</name></expr>;</condition> <incr><expr><operator>++</operator><name>ilhs</name></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>irhs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>irhs</name> <operator>!=</operator> <call><name><name>matchers_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>irhs</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>matrix</name><operator>.</operator><name>SetEdge</name></name><argument_list>(<argument><expr><name>ilhs</name></expr></argument>, <argument><expr><name>irhs</name></expr></argument>, <argument><expr><operator>*</operator><name>did_match_iter</name><operator>++</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>matrix</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>matchers_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>UnorderedElementsAreMatcherImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Target</name><operator>&gt;</operator>
struct <name>CastAndAppendTransform</name> <block>{
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Arg</name></expr></argument>&gt;</argument_list></name>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Target</name></expr></argument>&gt;</argument_list></name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>Arg</name><operator>&amp;</operator> <name>a</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>Target</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block></expr>
}</block></expr></expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>UnorderedElementsAreMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>UnorderedElementsAreMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatcherTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>args</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>View</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>value_type</name> <name>Element</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>MatcherVec</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>MatcherVec</name></type> <name>matchers</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>matchers</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TransformTupleValues</name><argument_list>(<argument><expr><call><name><name>CastAndAppendTransform</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>matchers_</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><call><name>back_inserter</name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new UnorderedElementsAreMatcherImpl&lt;Container&gt;(
UnorderedMatcherRequire::ExactMatch, matchers.begin(), matchers.end())</argument>)</argument_list></macro>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>MatcherTuple</name></type> <name>matchers_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>UnorderedElementsAreMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherTuple</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ElementsAreMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ElementsAreMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MatcherTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>args</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><operator>!</operator><name><name>IsHashTable</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><name>use_UnorderedElementsAre_with_hash_tables</name></expr></argument>)</argument_list></call></expr>;

<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>View</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>View</name><operator>::</operator><name>value_type</name> <name>Element</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>MatcherVec</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>MatcherVec</name></type> <name>matchers</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>matchers</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TransformTupleValues</name><argument_list>(<argument><expr><call><name><name>CastAndAppendTransform</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Element</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>matchers_</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><call><name>back_inserter</name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new ElementsAreMatcherImpl&lt;Container&gt;(
matchers.begin(), matchers.end())</argument>)</argument_list></macro>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>MatcherTuple</name></type> <name>matchers_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ElementsAreMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>UnorderedElementsAreArrayMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>&gt;</argument_list></name></type>
<name>UnorderedElementsAreArrayMatcher</name><argument_list>(<argument><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <name>match_flags</name></expr></argument>,
<argument><expr><name>Iter</name> <name>first</name></expr></argument>, <argument><expr><name>Iter</name> <name>last</name></expr></argument>)</argument_list>
<range>: <expr><call><name>match_flags_</name><argument_list>(<argument><expr><name>match_flags</name></expr></argument>)</argument_list></call></expr></range></decl>, <decl><type ref="prev"/><name>matchers_</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new UnorderedElementsAreMatcherImpl&lt;Container&gt;(
match_flags_, matchers_.begin(), matchers_.end())</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>UnorderedMatcherRequire</name><operator>::</operator><name>Flags</name> <name>match_flags_</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>matchers_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>UnorderedElementsAreArrayMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ElementsAreArrayMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Iter</name><operator>&gt;</operator>
<macro><name>ElementsAreArrayMatcher</name><argument_list>(<argument>Iter first</argument>, <argument>Iter last</argument>)</argument_list></macro> <operator>:</operator> <macro><name>matchers_</name><argument_list>(<argument>first</argument>, <argument>last</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Container</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>GTEST_COMPILE_ASSERT_</name><argument_list>(
<argument><expr><operator>!</operator><name><name>IsHashTable</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>use_UnorderedElementsAreArray_with_hash_tables</name></expr></argument>)</argument_list></call></expr>;

<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new ElementsAreMatcherImpl&lt;Container&gt;(
matchers_.begin(), matchers_.end())</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>matchers_</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ElementsAreArrayMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>










<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>typename</name> <name>Second</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>BoundSecondMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>BoundSecondMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Tuple2Matcher</name><operator>&amp;</operator> <name>tm</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Second</name><operator>&amp;</operator> <name>second</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>tuple2_matcher_</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>second_value_</name><argument_list>(<argument>second</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;T&gt;(tuple2_matcher_, second_value_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>









<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>BoundSecondMatcher</name><operator>&amp;</operator> <operator>)</operator> <block>{
<expr><call><name>GTEST_LOG_</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"BoundSecondMatcher should never be assigned."</literal></expr>;
}</block>

<name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Impl</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>&gt;</argument_list></name> <name>ArgTuple</name></expr>;</expr_stmt></typedef>

<call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Tuple2Matcher</name><operator>&amp;</operator> <name>tm</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Second</name><operator>&amp;</operator> <name>second</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>mono_tuple2_matcher_</name><argument_list>(<argument><expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>,
<macro><name>second_value_</name><argument_list>(<argument>second</argument>)</argument_list></macro> <block>{}</block></block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"and "</literal></expr>;
<expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>second_value_</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;
<expr><call><name><name>mono_tuple2_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>T x</argument>, <argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>mono_tuple2_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><call><name>ArgTuple</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>second_value_</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></init></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>mono_tuple2_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Second</name></type> <name>second_value_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Tuple2Matcher</name></type> <name>tuple2_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Second</name></type> <name>second_value_</name></decl>;</decl_stmt>
};





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>typename</name> <name>Second</name></expr></argument>&gt;</argument_list></name>
<name><name>BoundSecondMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>&gt;</argument_list></name></type> <name>MatcherBindSecond</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>Tuple2Matcher</name><modifier>&amp;</modifier></type> <name>tm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Second</name><modifier>&amp;</modifier></type> <name>second</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>BoundSecondMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>second</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>FormatMatcherDescription</name><argument_list>(<argument>bool negation</argument>,
<argument>const char* matcher_name</argument>,
<argument>const Strings&amp; param_values</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueMatcher</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>OptionalMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>OptionalMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueMatcher</name><operator>&amp;</operator> <name>value_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>value_matcher_</name><argument_list>(<argument>value_matcher</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Optional</name></expr></argument>&gt;</argument_list></name>
<name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>Optional</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>MakeMatcher</name><argument_list>(<argument>new Impl&lt;Optional&gt;(value_matcher_)</argument>)</argument_list></macro>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Optional</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Impl</name> <range>: <expr><name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>Optional</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><argument_list>(<argument>Optional</argument>)</argument_list></macro> <expr_stmt><expr><name>OptionalView</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>OptionalView</name><operator>::</operator><name>value_type</name> <name>ValueType</name></expr>;</expr_stmt></typedef>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>Impl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueMatcher</name><operator>&amp;</operator> <name>value_matcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>value_matcher_</name><argument_list>(<argument>MatcherCast&lt;ValueType&gt;(value_matcher)</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"value "</literal></expr>;
<expr><call><name><name>value_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>void</name> <macro><name>DescribeNegationTo</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"value "</literal></expr>;
<expr><call><name><name>value_matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>virtual</name> <name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>Optional optional</argument>,
<argument>MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optional</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"which is not engaged"</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
const ValueType&amp; value = *optional</block><empty_stmt>;</empty_stmt></if></if_stmt>
<name>StringMatchResultListener</name> <name>value_listener</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>value_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose value "</literal> <operator>&lt;&lt;</operator> <call><name>PrintToString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>match</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>value_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ValueType</name></expr></argument>&gt;</argument_list></name></type> <name>value_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>Impl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>ValueMatcher</name></type> <name>value_matcher_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>OptionalMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<decl_stmt><decl><type><name>namespace</name></type> <name>variant_matcher</name> <block>{<block_content>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>holds_alternative</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>get</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>VariantMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>explicit</name></type> <name>VariantMatcher</name><argument_list>(<argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher</name></expr></argument>)</argument_list>
<range>: <macro><name>matcher_</name><argument_list>(<argument>internal::move(matcher)</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Variant</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const Variant&amp; value</argument>,
<argument>::testing::MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>holds_alternative</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

if (!holds_alternative&lt;T&gt;(value</block></if></if_stmt>))</block> <block>{
<expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose value is not of type '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"'"</literal></expr>;
<return>return <expr><name>false</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>elem</name> <init>= <expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>elem_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose value "</literal> <operator>&lt;&lt;</operator> <call><name>PrintToString</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>match</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>elem_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is a variant&lt;&gt; with value of type '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"' and the value "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is a variant&lt;&gt; with value of type other than '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"' or the value "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetTypeName</name><argument_list>()</argument_list></macro> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_RTTI</name></expr></cpp:if>
<macro><name>GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_</name><argument_list>(
<argument>return internal::GetTypeName&lt;T&gt;()</argument>)</argument_list></macro>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="string">"the element type"</literal></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

namespace <macro><name>any_cast_matcher</name></macro> <block>{<block_content>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>any_cast</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>AnyCastMatcher</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>explicit</name></type> <name>AnyCastMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list>
<range>: <macro><name>matcher_</name><argument_list>(<argument>matcher</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>AnyType</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>MatchAndExplain</name><argument_list>(<argument>const AnyType&amp; value</argument>,
<argument>::testing::MatchResultListener* listener</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>listener</name><operator>-&gt;</operator><name>IsInterested</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>ptr</name> <init>= <expr><call><name><name>any_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

const T* elem = any_cast&lt;T&gt;(&amp;value</block></if></if_stmt>)</block></expr></range></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>elem</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose value is not of type '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"'"</literal></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>elem_listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>match</name> <init>= <expr><call><name><name>matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><operator>*</operator><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_listener</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>listener</name> <operator>&lt;&lt;</operator> <literal type="string">"whose value "</literal> <operator>&lt;&lt;</operator> <call><name>PrintToString</name><argument_list>(<argument><expr><operator>*</operator><name>elem</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>match</name></expr> ?</condition><then> <expr><literal type="string">" matches"</literal></expr> </then><else>: <expr><literal type="string">" doesn't match"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>elem_listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>listener</name><operator>-&gt;</operator><name>stream</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>match</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>DescribeTo</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an 'any' type with value of type '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"' and the value "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>DescribeNegationTo</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"is an 'any' type with value of type other than '"</literal> <operator>&lt;&lt;</operator> <call><name>GetTypeName</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"' or the value "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>matcher_</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetTypeName</name><argument_list>()</argument_list></macro> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_RTTI</name></expr></cpp:if>
<macro><name>GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_</name><argument_list>(
<argument>return internal::GetTypeName&lt;T&gt;()</argument>)</argument_list></macro>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="string">"the element type"</literal></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <name>matcher_</name></expr>;</expr_stmt>
</block_content>}</block><empty_stmt>;</empty_stmt>

}
}
















<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>ElementsAreArray</name><argument_list>(<argument>Iter first</argument>, <argument>Iter last</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>T</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>ElementsAreArray</name><argument_list>(
<argument>const T* pointer</argument>, <argument>size_t count</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ElementsAreArray</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>pointer</name> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>ElementsAreArray</name><argument_list>(
<argument>const T (&amp;array)[N]</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ElementsAreArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>ElementsAreArray</name><argument_list>(<argument>const Container&amp; container</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ElementsAreArray</name><argument_list>(<argument><expr><call><name><name>container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>ElementsAreArray</name><argument_list>(<argument>::std::initializer_list&lt;T&gt; xs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ElementsAreArray</name><argument_list>(<argument><expr><call><name><name>xs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>xs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>














<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAreArray</name><argument_list>(<argument>Iter first</argument>, <argument>Iter last</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>T</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name>UnorderedMatcherRequire</name><operator>::</operator><name>ExactMatch</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAreArray</name><argument_list>(<argument>const T* pointer</argument>, <argument>size_t count</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>UnorderedElementsAreArray</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>pointer</name> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAreArray</name><argument_list>(<argument>const T (&amp;array)[N]</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>UnorderedElementsAreArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAreArray</name><argument_list>(<argument>const Container&amp; container</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>UnorderedElementsAreArray</name><argument_list>(<argument><expr><call><name><name>container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAreArray</name><argument_list>(<argument>::std::initializer_list&lt;T&gt; xs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>UnorderedElementsAreArray</name><argument_list>(<argument><expr><call><name><name>xs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>xs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>AnythingMatcher</name> <name>_</name> <operator>=</operator> <block>{}</block></expr>;</expr_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>A</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <name>internal</name><operator>::</operator><call><name><name>AnyMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>An</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>A</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>EqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>Eq</name><argument_list>(<argument>T x</argument>)</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name><name>EqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>Matcher</name><argument_list>(<argument>T value</argument>)</argument_list></macro> <block>{ <expr><operator>*</operator><name>this</name> <operator>=</operator> <call><name>Eq</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>; }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>internal</name><operator>::</operator><name><name>MatcherCastImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>CastImpl</name><argument_list>(
<argument>const M&amp; value</argument>,
<argument>internal::BooleanConstant&lt;false&gt;</argument> ,
<argument>internal::BooleanConstant&lt;false&gt;</argument> )</argument_list></macro> <block>{
<return>return <expr><call><name>Eq</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>













<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Lhs</name></expr></argument>, <argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Lhs</name></expr></argument>&gt;</argument_list></name></type> <name>TypedEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Rhs</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>Eq</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>GeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name> <macro><name>Ge</name><argument_list>(<argument>Rhs x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>GeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>GtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name> <macro><name>Gt</name><argument_list>(<argument>Rhs x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>GtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>LeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name> <macro><name>Le</name><argument_list>(<argument>Rhs x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>LeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>LtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name> <macro><name>Lt</name><argument_list>(<argument>Rhs x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>LtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Rhs</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>NeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name> <macro><name>Ne</name><argument_list>(<argument>Rhs x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>NeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Rhs</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>IsNullMatcher</name></expr></argument> &gt;</argument_list></name></type> <name>IsNull</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>IsNullMatcher</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>NotNullMatcher</name></expr></argument> &gt;</argument_list></name></type> <name>NotNull</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>NotNullMatcher</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>RefMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <macro><name>Ref</name><argument_list>(<argument>T&amp; x</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>RefMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>DoubleEq</name><argument_list>(<argument>double rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveDoubleEq</name><argument_list>(<argument>double rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>DoubleNear</name><argument_list>(
<argument>double rhs</argument>, <argument>double max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveDoubleNear</name><argument_list>(
<argument>double rhs</argument>, <argument>double max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>FloatEq</name><argument_list>(<argument>float rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveFloatEq</name><argument_list>(<argument>float rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>FloatNear</name><argument_list>(
<argument>float rhs</argument>, <argument>float max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveFloatNear</name><argument_list>(
<argument>float rhs</argument>, <argument>float max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PointeeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name> <macro><name>Pointee</name><argument_list>(
<argument>const InnerMatcher&amp; inner_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>PointeeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>inner_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_RTTI</name></expr></cpp:if>






<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>WhenDynamicCastToMatcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>WhenDynamicCastTo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>inner_matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>WhenDynamicCastToMatcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>inner_matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>FieldType</name></expr></argument>, <argument><expr><name>typename</name> <name>FieldMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>internal</name><operator>::</operator><name><name>FieldMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>FieldType</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>Field</name><argument_list>(
<argument><expr><name>FieldType</name> <name>Class</name><operator>::</operator><operator>*</operator><name>field</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>FieldMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>FieldMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>FieldType</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FieldType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>




</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>FieldType</name></expr></argument>, <argument><expr><name>typename</name> <name>FieldMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>FieldMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>FieldType</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>Field</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>field_name</name></expr></argument>, <argument><expr><name>FieldType</name> <name>Class</name><operator>::</operator><operator>*</operator><name>field</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FieldMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>FieldMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>FieldType</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>field_name</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FieldType</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyType</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>PropertyMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>, <argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>Property</name><argument_list>(<argument><expr><macro><name>PropertyType</name> <argument_list>(<argument>Class::*property</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PropertyMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>PropertyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>,
<argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>property</name></expr></argument>,
<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>PropertyType</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>




</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyType</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>PropertyMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>, <argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>Property</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>property_name</name></expr></argument>,
<argument><expr><macro><name>PropertyType</name> <argument_list>(<argument>Class::*property</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PropertyMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>PropertyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>,
<argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>property_name</name></expr></argument>, <argument><expr><name>property</name></expr></argument>,
<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>PropertyType</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyType</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>PropertyMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>, <argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>Property</name><argument_list>(<argument><expr><macro><name>PropertyType</name> <argument_list>(<argument>Class::*property</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PropertyMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>PropertyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>,
<argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>property</name></expr></argument>,
<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>PropertyType</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Class</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyType</name></expr></argument>, <argument><expr><name>typename</name> <name>PropertyMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>PropertyMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>, <argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>Property</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>property_name</name></expr></argument>,
<argument><expr><macro><name>PropertyType</name> <argument_list>(<argument>Class::*property</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PropertyMatcher</name><operator>&amp;</operator> <name>matcher</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>PropertyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>PropertyType</name></expr></argument>,
<argument><expr><name>PropertyType</name> <operator>(</operator><name>Class</name><operator>::</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>property_name</name></expr></argument>, <argument><expr><name>property</name></expr></argument>,
<argument><expr><call><name><name>MatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REFERENCE_TO_CONST_</name><operator>(</operator><name>PropertyType</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Callable</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>ResultOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>, <argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name> <macro><name>ResultOf</name><argument_list>(
<argument>Callable callable</argument>, <argument>InnerMatcher matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ResultOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Callable</name></expr></argument>, <argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>callable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrEq</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrNe</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrCaseEq</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrCaseNe</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>HasSubstrMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>HasSubstr</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>substring</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>HasSubstrMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StartsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StartsWith</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>prefix</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StartsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>EndsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>EndsWith</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>suffix</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>EndsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>MatchesRegexMatcher</name></expr></argument>&gt;</argument_list></name></type> <name>MatchesRegex</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>RE</name><operator>*</operator> <name>regex</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>MatchesRegexMatcher</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>MatchesRegexMatcher</name></expr></argument>&gt;</argument_list></name></type> <name>MatchesRegex</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>regex</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <macro><name>MatchesRegex</name><argument_list>(<argument>new internal::RE(regex)</argument>)</argument_list></macro>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>MatchesRegexMatcher</name></expr></argument>&gt;</argument_list></name></type> <name>ContainsRegex</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>RE</name><operator>*</operator> <name>regex</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>MatchesRegexMatcher</name><argument_list>(<argument><expr><name>regex</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>MatchesRegexMatcher</name></expr></argument>&gt;</argument_list></name></type> <name>ContainsRegex</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>regex</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <macro><name>ContainsRegex</name><argument_list>(<argument>new internal::RE(regex)</argument>)</argument_list></macro>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_WSTRING</name> <operator>||</operator> <name>GTEST_HAS_STD_WSTRING</name></expr></cpp:if>



<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrEq</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>StrNe</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>StrCaseEq</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>StrCaseNe</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>str</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StrEqualityMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>HasSubstrMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>HasSubstr</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>substring</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>HasSubstrMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>StartsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>StartsWith</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>prefix</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>StartsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>EndsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>EndsWith</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>suffix</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>EndsWithMatcher</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>wstring</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Eq2Matcher</name> <macro><name>Eq</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Eq2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Ge2Matcher</name> <macro><name>Ge</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Ge2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Gt2Matcher</name> <macro><name>Gt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Gt2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Le2Matcher</name> <macro><name>Le</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Le2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Lt2Matcher</name> <macro><name>Lt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Lt2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name>Ne2Matcher</name> <macro><name>Ne</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>internal</name><operator>::</operator><call><name>Ne2Matcher</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>FloatEq</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>DoubleEq</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveFloatEq</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveDoubleEq</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>FloatNear</name><argument_list>(<argument>float max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>DoubleNear</name><argument_list>(<argument>double max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveFloatNear</name><argument_list>(
<argument>float max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <macro><name>NanSensitiveDoubleNear</name><argument_list>(
<argument>double max_abs_error</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>FloatingEq2Matcher</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>max_abs_error</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>NotMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name> <macro><name>Not</name><argument_list>(<argument>InnerMatcher m</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>NotMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Predicate</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>TrulyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Predicate</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>Truly</name><parameter_list>(<parameter><decl><type><name>Predicate</name></type> <name>pred</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name><name>TrulyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Predicate</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SizeMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>SizeIsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>SizeMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>SizeIs</name><argument_list>(<argument>const SizeMatcher&amp; size_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>SizeIsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>SizeMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>size_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>DistanceMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>BeginEndDistanceIsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DistanceMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>BeginEndDistanceIs</name><argument_list>(<argument>const DistanceMatcher&amp; distance_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>BeginEndDistanceIsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>DistanceMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>distance_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>ContainerEqMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type>
<name>ContainerEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Container</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>


<typedef>typedef <macro><name>GTEST_REMOVE_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name><name>ContainerEqMatcher</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Comparator</name></expr></argument>, <argument><expr><name>typename</name> <name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>WhenSortedByMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Comparator</name></expr></argument>, <argument><expr><name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>WhenSortedBy</name><argument_list>(<argument>const Comparator&amp; comparator</argument>,
<argument>const ContainerMatcher&amp; container_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>WhenSortedByMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Comparator</name></expr></argument>, <argument><expr><name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>comparator</name></expr></argument>, <argument><expr><name>container_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>WhenSortedByMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>LessComparator</name></expr></argument>, <argument><expr><name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>WhenSorted</name><argument_list>(<argument>const ContainerMatcher&amp; container_matcher</argument>)</argument_list></macro> <block>{
<return>return
<expr><name>internal</name><operator>::</operator><call><name><name>WhenSortedByMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>LessComparator</name></expr></argument>, <argument><expr><name>ContainerMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name>LessComparator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>container_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TupleMatcher</name></expr></argument>, <argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PointwiseMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TupleMatcher</name></expr></argument>,
<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>Container</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<macro><name>Pointwise</name><argument_list>(<argument>const TupleMatcher&amp; tuple_matcher</argument>, <argument>const Container&amp; rhs</argument>)</argument_list></macro> <block>{



<typedef>typedef <macro><name>GTEST_REMOVE_CONST_</name><argument_list>(<argument>Container</argument>)</argument_list></macro> <expr_stmt><expr><name>RawContainer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>PointwiseMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TupleMatcher</name></expr></argument>, <argument><expr><name>RawContainer</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>tuple_matcher</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>


template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>TupleMatcher</name></expr><operator>,</operator> <expr><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PointwiseMatcher</name><argument_list type="generic">&lt;<argument><expr><name>TupleMatcher</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <macro><name>Pointwise</name><argument_list>(
<argument>const TupleMatcher&amp; tuple_matcher</argument>, <argument>std::initializer_list&lt;T&gt; rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Pointwise</name><argument_list>(<argument><expr><name>tuple_matcher</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>












<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>typename</name> <name>RhsContainer</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>BoundSecondMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator>
<name>RhsContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedPointwise</name><argument_list>(<argument>const Tuple2Matcher&amp; tuple2_matcher</argument>,
<argument>const RhsContainer&amp; rhs_container</argument>)</argument_list></macro> <block>{



<typedef>typedef <macro><name>GTEST_REMOVE_CONST_</name><argument_list>(<argument>RhsContainer</argument>)</argument_list></macro> <expr_stmt><expr><name>RawRhsContainer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>



<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>RawRhsContainer</name></expr></argument>&gt;</argument_list></name> <name>RhsView</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RhsView</name><operator>::</operator><name>type</name> <name>RhsStlContainer</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>RhsStlContainer</name><operator>::</operator><name>value_type</name> <name>Second</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>const</specifier> <name>RhsStlContainer</name><modifier>&amp;</modifier></type> <name>rhs_stl_container</name> <init>=
<expr><name>RhsView</name><operator>::</operator><call><name>ConstReference</name><argument_list>(<argument><expr><name>rhs_container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>BoundSecondMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>matchers</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>typename</name> <name>RhsStlContainer</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>rhs_stl_container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>rhs_stl_container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>matchers</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name>MatcherBindSecond</name><argument_list>(<argument><expr><name>tuple2_matcher</name></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<return>return <expr><call><name>UnorderedElementsAreArray</name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call></expr>;</return>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>


template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Tuple2Matcher</name></expr><operator>,</operator> <expr><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>BoundSecondMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Tuple2Matcher</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<macro><name>UnorderedPointwise</name><argument_list>(<argument>const Tuple2Matcher&amp; tuple2_matcher</argument>,
<argument>std::initializer_list&lt;T&gt; rhs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>UnorderedPointwise</name><argument_list>(<argument><expr><name>tuple2_matcher</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



















<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>ContainsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name> <macro><name>Contains</name><argument_list>(<argument>M matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ContainsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




























<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>IsSupersetOf</name><argument_list>(<argument>Iter first</argument>, <argument>Iter last</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>T</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name>UnorderedMatcherRequire</name><operator>::</operator><name>Superset</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSupersetOf</name><argument_list>(
<argument>const T* pointer</argument>, <argument>size_t count</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSupersetOf</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>pointer</name> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSupersetOf</name><argument_list>(
<argument>const T (&amp;array)[N]</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSupersetOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>IsSupersetOf</name><argument_list>(<argument>const Container&amp; container</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSupersetOf</name><argument_list>(<argument><expr><call><name><name>container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSupersetOf</name><argument_list>(
<argument>::std::initializer_list&lt;T&gt; xs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSupersetOf</name><argument_list>(<argument><expr><call><name><name>xs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>xs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
























<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>IsSubsetOf</name><argument_list>(<argument>Iter first</argument>, <argument>Iter last</argument>)</argument_list></macro> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>Iter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>T</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name>UnorderedMatcherRequire</name><operator>::</operator><name>Subset</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSubsetOf</name><argument_list>(
<argument>const T* pointer</argument>, <argument>size_t count</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSubsetOf</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>pointer</name> <operator>+</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSubsetOf</name><argument_list>(
<argument>const T (&amp;array)[N]</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSubsetOf</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name>
<macro><name>IsSubsetOf</name><argument_list>(<argument>const Container&amp; container</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSubsetOf</name><argument_list>(<argument><expr><call><name><name>container</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>container</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_INITIALIZER_LIST_</name></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>UnorderedElementsAreArrayMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>IsSubsetOf</name><argument_list>(
<argument>::std::initializer_list&lt;T&gt; xs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsSubsetOf</name><argument_list>(<argument><expr><call><name><name>xs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>xs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




























<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>EachMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name> <macro><name>Each</name><argument_list>(<argument>M matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>EachMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>KeyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name> <macro><name>Key</name><argument_list>(<argument>M inner_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>KeyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>inner_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FirstMatcher</name></expr></argument>, <argument><expr><name>typename</name> <name>SecondMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>PairMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FirstMatcher</name></expr></argument>, <argument><expr><name>SecondMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>Pair</name><argument_list>(<argument>FirstMatcher first_matcher</argument>, <argument>SecondMatcher second_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>PairMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FirstMatcher</name></expr></argument>, <argument><expr><name>SecondMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>first_matcher</name></expr></argument>, <argument><expr><name>second_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>MatcherAsPredicate</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name> <macro><name>Matches</name><argument_list>(<argument>M matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>MatcherAsPredicate</name><argument_list type="generic">&lt;<argument><expr><name>M</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>Value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>M</name></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>testing</name><operator>::</operator><call><call><name>Matches</name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>ExplainMatchResult</name><parameter_list>(
<parameter><decl><type><name>M</name></type> <name>matcher</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>MatchResultListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>MatchAndExplain</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>string</name> <macro><name>DescribeMatcher</name><argument_list>(<argument>const M&amp; matcher</argument>, <argument>bool negation = false</argument>)</argument_list></macro> <block>{
<expr><operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>ss</name></expr>;
<expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>monomorphic_matcher</name> <operator>=</operator> <call><name><name>SafeMatcherCast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>negation</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>monomorphic_matcher</name><operator>.</operator><name>DescribeNegationTo</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>monomorphic_matcher</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name><name>ss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr>;</return>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>


template <expr_stmt><expr><operator>&lt;</operator><name>typename</name><operator>...</operator> <name>Args</name><operator>&gt;</operator>
<name>internal</name><operator>::</operator><name><name>AllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <macro><name>AllOf</name><argument_list>(
<argument>const Args&amp;... matchers</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>AllOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>matchers</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>AnyOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <macro><name>AnyOf</name><argument_list>(
<argument>const Args&amp;... matchers</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>AnyOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>matchers</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;<argument><expr><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>ElementsAre</name><argument_list>(<argument>const Args&amp;... matchers</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>ElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>make_tuple</name><argument_list>(<argument><expr><name>matchers</name><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>internal</name><operator>::</operator><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<macro><name>UnorderedElementsAre</name><argument_list>(<argument>const Args&amp;... matchers</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>UnorderedElementsAreMatcher</name><argument_list type="generic">&lt;
<argument><expr><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>decay</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Args</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>make_tuple</name><argument_list>(<argument><expr><name>matchers</name><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>InnerMatcher</name></type> <name>AllArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InnerMatcher</name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>matcher</name></expr>;</return> </block_content>}</block></function>









<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>internal</name><operator>::</operator><name><name>OptionalMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ValueMatcher</name></expr></argument>&gt;</argument_list></name> <macro><name>Optional</name><argument_list>(
<argument>const ValueMatcher&amp; value_matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>internal</name><operator>::</operator><call><name><name>OptionalMatcher</name><argument_list type="generic">&lt;<argument><expr><name>ValueMatcher</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value_matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>any_cast_matcher</name><operator>::</operator><name><name>AnyCastMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>AnyWith</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name>any_cast_matcher</name><operator>::</operator><call><name><name>AnyCastMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>variant_matcher</name><operator>::</operator><name><name>VariantMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>VariantWith</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>matcher</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakePolymorphicMatcher</name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><name>variant_matcher</name><operator>::</operator><call><name><name>VariantMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>matcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_THAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>matcher</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT1(::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_THAT</name><parameter_list>(<parameter><type><name>value</name></type></parameter>, <parameter><type><name>matcher</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT1(::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)</cpp:value></cpp:define>


}

GTEST_DISABLE_MSC_WARNINGS_POP_<expr><operator>(</operator><operator>)</operator></expr>




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/custom/gmock-matchers.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
