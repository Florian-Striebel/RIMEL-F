<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googlemock/include/gmock/internal/gmock-internal-utils.h">





































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-generated-internal-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4100</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4805</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>JoinAsTuple</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Strings</name><operator>&amp;</operator> <name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>ConvertIdentifierNameToWords</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>id_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Pointer</name><operator>&gt;</operator>
struct <name>PointeeOf</name> <block>{


<typedef>typedef <expr_stmt><expr><name>typename</name> <name>Pointer</name><operator>::</operator><name>element_type</name> <name>type</name></expr>;</expr_stmt></typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name><name>PointeeOf</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Pointer</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>typename</name> <name>Pointer</name><operator>::</operator><name>element_type</name><operator>*</operator> <macro><name>GetRawPointer</name><argument_list>(<argument>const Pointer&amp; p</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>p</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Element</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>Element</name><modifier>*</modifier></type> <name>GetRawPointer</name><parameter_list>(<parameter><decl><type><name>Element</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>p</name></expr>;</return> </block_content>}</block></function>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>LinkedPtrLessThan</name> <block>{
<expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>lhs</name><operator>,</operator>
<specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>lhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name><name>rhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;









<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>GTEST_OS_SYMBIAN</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_STLP_NO_WCHAR_T</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_NATIVE_WCHAR_T_DEFINED</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_WCHAR_T_IS_NATIVE_</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__WCHAR_UNSIGNED__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&lt;</operator> <literal type="number">9</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_HAS_SIGNED_WCHAR_T_</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






enum <expr><name>TypeKind</name> <block>{
<expr><name>kBool</name></expr>, <expr><name>kInteger</name></expr>, <expr><name>kFloatingPoint</name></expr>, <expr><name>kOther</name></expr>
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name>KindOf</name> <block>{
enum <expr><block>{ <expr><name>value</name> <operator>=</operator> <name>kOther</name></expr> }</block></expr>;
}</block></expr>;


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_DECLARE_KIND_</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>kind</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>template &lt;&gt; struct KindOf&lt;type&gt; { enum { value = kind }; }</cpp:value></cpp:define>


<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>kBool</name></expr></argument>)</argument_list></call></expr>;


<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>signed char</argument>, <argument>kInteger</argument>)</argument_list></macro>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>unsigned char</argument>, <argument>kInteger</argument>)</argument_list></macro>;
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>short</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>unsigned short</argument>, <argument>kInteger</argument>)</argument_list></macro>;
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>unsigned int</argument>, <argument>kInteger</argument>)</argument_list></macro>;
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>unsigned long</argument>, <argument>kInteger</argument>)</argument_list></macro>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GMOCK_WCHAR_T_IS_NATIVE_</name></expr></cpp:if>
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>wchar_t</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>Int64</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>UInt64</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>)</argument_list></call></expr>;


<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>kFloatingPoint</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument><expr><name>double</name></expr></argument>, <argument><expr><name>kFloatingPoint</name></expr></argument>)</argument_list></call></expr>;
<macro><name>GMOCK_DECLARE_KIND_</name><argument_list>(<argument>long double</argument>, <argument>kFloatingPoint</argument>)</argument_list></macro>;

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GMOCK_DECLARE_KIND_</name></cpp:undef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_KIND_OF_</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static_cast&lt; ::testing::internal::TypeKind&gt;( ::testing::internal::KindOf&lt;type&gt;::value)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_IS_SIGNED_</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(static_cast&lt;T&gt;(-1) &lt; 0)</cpp:value></cpp:define>










<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>TypeKind</name> <name>kFromKind</name></expr></argument>, <argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>TypeKind</name> <name>kToKind</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name>LosslessArithmeticConvertibleImpl</name> <operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>true_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>true_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>, <argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>true_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>bool_constant</name><operator>&lt;</operator>


<operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>GMOCK_IS_SIGNED_</name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GMOCK_IS_SIGNED_</name><argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>GMOCK_IS_SIGNED_</name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GMOCK_IS_SIGNED_</name><argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>&gt;</operator> <block>{}</block></expr>;

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GMOCK_IS_SIGNED_</name></cpp:undef>



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kBool</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;<argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kInteger</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;
<argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>kFloatingPoint</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name>public</name> <name>bool_constant</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator> <block>{}</block></expr>;








<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
struct <name>LosslessArithmeticConvertible</name>
<operator>:</operator> <name>public</name> <name><name>LosslessArithmeticConvertibleImpl</name><argument_list type="generic">&lt;
<argument><expr><name>GMOCK_KIND_OF_</name><operator>(</operator><name>From</name><operator>)</operator></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>GMOCK_KIND_OF_</name><operator>(</operator><name>To</name><operator>)</operator></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;



<expr><name>class</name> <name>FailureReporterInterface</name> <block>{
<expr><name>public</name><operator>:</operator>

enum <name>FailureType</name> <block>{
<expr><name>kNonfatal</name></expr>, <expr><name>kFatal</name></expr>
}</block></expr>;

<expr><name>virtual</name> <operator>~</operator><macro><name>FailureReporterInterface</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>ReportFailure</name><argument_list>(<argument>FailureType type</argument>, <argument>const char* file</argument>, <argument>int line</argument>,
<argument>const std::string&amp; message</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;


<expr><name>GTEST_API_</name> <name>FailureReporterInterface</name><operator>*</operator> <call><name>GetFailureReporter</name><argument_list>()</argument_list></call></expr>;






<expr><specifier>inline</specifier> <name>void</name> <macro><name>Assert</name><argument_list>(<argument>bool condition</argument>, <argument>const char* file</argument>, <argument>int line</argument>,
<argument>const std::string&amp; msg</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>condition</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GetFailureReporter</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>ReportFailure</name><argument_list>(<argument><expr><name>FailureReporterInterface</name><operator>::</operator><name>kFatal</name></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
<namespace><specifier>inline</specifier> void <name>Assert</name>(<name>bool</name> <name>condition</name><operator>,</operator> const <name>char</name>* <name>file</name><operator>,</operator> <name>int</name> <name>line</name></namespace></block></if></if_stmt>) <block>{
<expr><call><name>Assert</name><argument_list>(<argument><expr><name>condition</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Assertion failed."</literal></expr></argument>)</argument_list></call></expr>;
}</block></block>



<specifier>inline</specifier> <name>void</name> <macro><name>Expect</name><argument_list>(<argument>bool condition</argument>, <argument>const char* file</argument>, <argument>int line</argument>,
<argument>const std::string&amp; msg</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>condition</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GetFailureReporter</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>ReportFailure</name><argument_list>(<argument><expr><name>FailureReporterInterface</name><operator>::</operator><name>kNonfatal</name></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
<namespace><specifier>inline</specifier> void <name>Expect</name>(<name>bool</name> <name>condition</name><operator>,</operator> const <name>char</name>* <name>file</name><operator>,</operator> <name>int</name> <name>line</name></namespace></block></if></if_stmt>) <block>{
<expr><call><name>Expect</name><argument_list>(<argument><expr><name>condition</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Expectation failed."</literal></expr></argument>)</argument_list></call></expr>;
}</block></block>


enum <name>LogSeverity</name> <block>{
<expr><name>kInfo</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>kWarning</name> <operator>=</operator> <literal type="number">1</literal></expr>
}</block></expr>;




<expr><specifier>const</specifier> <name>char</name> <name><name>kInfoVerbosity</name><index>[]</index></name> <operator>=</operator> <literal type="string">"info"</literal></expr>;

<expr><specifier>const</specifier> <name>char</name> <name><name>kWarningVerbosity</name><index>[]</index></name> <operator>=</operator> <literal type="string">"warning"</literal></expr>;

<expr><specifier>const</specifier> <name>char</name> <name><name>kErrorVerbosity</name><index>[]</index></name> <operator>=</operator> <literal type="string">"error"</literal></expr>;



<expr><name>GTEST_API_</name> <name>bool</name> <macro><name>LogIsVisible</name><argument_list>(<argument>LogSeverity severity</argument>)</argument_list></macro></expr>;








<expr><name>GTEST_API_</name> <name>void</name> <macro><name>Log</name><argument_list>(<argument>LogSeverity severity</argument>, <argument>const std::string&amp; message</argument>,
<argument>int stack_frames_to_skip</argument>)</argument_list></macro></expr>;







<expr><name>class</name> <name>WithoutMatchers</name> <block>{
<expr><name>private</name><operator>:</operator>
<macro><name>WithoutMatchers</name><argument_list>()</argument_list></macro> <block>{}</block>
<name>friend</name> <name>GTEST_API_</name> <name>WithoutMatchers</name> <call><name>GetWithoutMatchers</name><argument_list>()</argument_list></call></expr>;
}</block></expr>;


<expr><name>GTEST_API_</name> <name>WithoutMatchers</name> <call><name>GetWithoutMatchers</name><argument_list>()</argument_list></call></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name>is_reference</name> <operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name>true_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name> struct <name>type_equals</name> <operator>:</operator> <name>public</name> <name>false_type</name> <block>{}</block></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>type_equals</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name>true_type</name> <block>{}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name>remove_reference</name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>remove_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name>DecayArray</name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name> struct <name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name><name>T</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>type</name>;</typedef>
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>DecayArray</name><argument_list type="generic">&lt;<argument><expr><name><name>T</name><index>[]</index></name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>type</name>;</typedef>
}</block></expr>;



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4717</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>T</name> <macro><name>Invalid</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Internal error: attempt to return invalid value"</literal></expr></argument>)</argument_list></call></expr>;



<return>return <expr><call><name><name>Invalid</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

















<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>RawContainer</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>StlContainerView</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <type><name>RawContainer</name></type> <name>type</name>;</typedef></block></expr>
<typedef>typedef <type><specifier>const</specifier> <name>type</name><modifier>&amp;</modifier></type> <name>const_reference</name>;</typedef>

<specifier>static</specifier> <name>const_reference</name> <macro><name>ConstReference</name><argument_list>(<argument>const RawContainer&amp; container</argument>)</argument_list></macro> <block>{

<expr><name>testing</name><operator>::</operator><call><name><name>StaticAssertTypeEq</name><argument_list type="generic">&lt;<argument><expr><name>RawContainer</name></expr></argument>,
<argument><expr><name>GTEST_REMOVE_CONST_</name><operator>(</operator><name>RawContainer</name><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>container</name></expr>;</return>
}</block>
<specifier>static</specifier> <name>type</name> <macro><name>Copy</name><argument_list>(<argument>const RawContainer&amp; container</argument>)</argument_list></macro> <block>{ <return>return <expr><name>container</name></expr>;</return> }</block>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Element</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name><name>Element</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <macro><name>GTEST_REMOVE_CONST_</name><argument_list>(<argument>Element</argument>)</argument_list></macro> <expr_stmt><expr><name>RawElement</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>NativeArray</name><argument_list type="generic">&lt;<argument><expr><name>RawElement</name></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>





<typedef>typedef <type><specifier>const</specifier> <name>type</name></type> <name>const_reference</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>const_reference</name></type> <name>ConstReference</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>Element</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>)</argument_list> <block>{<block_content>

<expr_stmt><expr><name>testing</name><operator>::</operator><call><name><name>StaticAssertTypeEq</name><argument_list type="generic">&lt;<argument><expr><name>Element</name></expr></argument>, <argument><expr><name>RawElement</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_SYMBIAN</name></expr></cpp:if>













<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Element</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>,
<argument><expr><call><name>RelationToSourceReference</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><call><name>RelationToSourceReference</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>type</name></type> <name>Copy</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>Element</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>array</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>)</argument_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_SYMBIAN</name></expr></cpp:if>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Element</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><call><name>RelationToSourceCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><call><name>RelationToSourceCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ElementPointer</name></expr></argument>, <argument><expr><name>typename</name> <name>Size</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>StlContainerView</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>ElementPointer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <macro><name>GTEST_REMOVE_CONST_</name><argument_list>(
<argument>typename internal::PointeeOf&lt;ElementPointer&gt;::type</argument>)</argument_list></macro> <expr_stmt><expr><name>RawElement</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name><name>NativeArray</name><argument_list type="generic">&lt;<argument><expr><name>RawElement</name></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><specifier>const</specifier> <name>type</name></type> <name>const_reference</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>const_reference</name></type> <name>ConstReference</name><argument_list>(
<argument><expr><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>ElementPointer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>array</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationToSourceReference</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>type</name></type> <name>Copy</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>testing</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>ElementPointer</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>array</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>type</name><argument_list>(<argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationToSourceCopy</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name><name>StlContainerView</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></decl>;</decl_stmt>




<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>RemoveConstFromKey</name> <block>{
<typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>K</name></expr><operator>,</operator> <expr><name>typename</name> <name>V</name><operator>&gt;</operator>
struct <name><name>RemoveConstFromKey</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>K</name></expr></argument>, <argument><expr><name>V</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <block>{
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>K</name></expr></argument>, <argument><expr><name>V</name></expr></argument>&gt;</argument_list></name> <name>type</name></expr>;</expr_stmt></typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>bool</name> <name>kValue</name><operator>&gt;</operator>
struct <name>BooleanConstant</name> <block>{}</block></expr>;</expr_stmt>



<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>IllegalDoDefault</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>size_t</name><operator>...</operator> <name>Is</name><operator>&gt;</operator> struct <name>int_pack</name> <block>{ <typedef>typedef <type><name>int_pack</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>Pack</name></expr><operator>,</operator> <expr><name>size_t</name> <name>I</name><operator>&gt;</operator> struct <name>append</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name><modifier>...</modifier> <name>Is</name></expr></argument>, <argument><expr><name>size_t</name> <name>I</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>append</name><argument_list type="generic">&lt;<argument><expr><name><name>int_pack</name><argument_list type="generic">&lt;<argument><expr><name>Is</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>I</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name><name>int_pack</name><argument_list type="generic">&lt;<argument><expr><name>Is</name><modifier>...</modifier></expr></argument>, <argument><expr><name>I</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>size_t</name> <name>C</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>make_int_pack</name> <range>: <expr><name><name>append</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name><name>make_int_pack</name><argument_list type="generic">&lt;<argument><expr><name>C</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>, <argument><expr><name>C</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct</type> <name><name>make_int_pack</name><argument_list type="generic">&lt;<argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <range>: <expr><name><name>int_pack</name><argument_list type="generic">&lt;&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>, <argument><expr><name>typename</name> <name>Tuple</name></expr></argument>, <argument><expr><name>size_t</name><modifier>...</modifier> <name>Idx</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>ApplyImpl</name><argument_list>(<argument><expr><name>F</name><operator>&amp;&amp;</operator> <name>f</name></expr></argument>, <argument><expr><name>Tuple</name><operator>&amp;&amp;</operator> <name>args</name></expr></argument>, <argument><expr><name><name>int_pack</name><argument_list type="generic">&lt;<argument><expr><name>Idx</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> -&gt; <name>decltype</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><call><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>Idx</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>std</name><operator>::</operator><call><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>Idx</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>, <argument><expr><name>typename</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name>
<specifier>auto</specifier></type> <name>Apply</name><argument_list>(<argument><expr><name>F</name><operator>&amp;&amp;</operator> <name>f</name></expr></argument>, <argument><expr><name>Tuple</name><operator>&amp;&amp;</operator> <name>args</name></expr></argument>)</argument_list>
-&gt; <name>decltype</name><argument_list>(<argument><expr><call><name>ApplyImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>make_int_pack</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>ApplyImpl</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>make_int_pack</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
