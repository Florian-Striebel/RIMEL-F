<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googlemock/include/gmock/gmock-spec-builders.h">



























































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sstream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/gmock-actions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/gmock-cardinalities.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/gmock-matchers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-internal-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gmock/internal/gmock-port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_EXCEPTIONS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdexcept&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4251</literal></argument> \
)</argument_list></macro>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>


<decl_stmt><decl><type><name>class</name></type> <name>Expectation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ExpectationSet</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>FunctionMocker</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ExpectationBase</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>TypedExpectation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ExpectationTester</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>FunctionMockerBase</name></decl>;</decl_stmt>












<function_decl><type><name>GTEST_API_</name></type> <name>GTEST_DECLARE_STATIC_MUTEX_</name><parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>class</name></type> <name>UntypedActionResultHolderBase</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>UntypedFunctionMockerBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>UntypedFunctionMockerBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>UntypedFunctionMockerBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<function_decl><type><name>bool</name></type> <name>VerifyAndClearExpectationsLocked</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>ClearDefaultActionsLocked</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>










<decl_stmt><decl><type><name>virtual</name> <name>UntypedActionResultHolderBase</name><modifier>*</modifier></type> <name>UntypedPerformDefaultAction</name><argument_list>(
<argument><expr><name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>call_description</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>UntypedActionResultHolderBase</name><modifier>*</modifier></type> <name>UntypedPerformAction</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_action</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>UntypedDescribeUninterestingCall</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>







<decl_stmt><decl><type><name>virtual</name> <specifier>const</specifier> <name>ExpectationBase</name><modifier>*</modifier></type> <name>UntypedFindMatchingExpectation</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator><operator>*</operator> <name>untyped_action</name></expr></argument>, <argument><expr><name>bool</name><operator>*</operator> <name>is_excessive</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>what</name></expr></argument>, <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>why</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>UntypedPrintArgs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>RegisterOwner</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>SetOwnerAndName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <macro><name>MockObject</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>Name</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<function_decl><type><name>UntypedActionResultHolderBase</name><modifier>*</modifier></type> <name>UntypedInvokeWith</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>untyped_args</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UntypedOnCallSpecs</name></expr>;</expr_stmt></typedef>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ExpectationBase</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>UntypedExpectations</name></expr>;</expr_stmt></typedef>



<function_decl><type><name>Expectation</name></type> <name>GetHandleOf</name><parameter_list>(<parameter><decl><type><name>ExpectationBase</name><modifier>*</modifier></type> <name>exp</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj_</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>UntypedOnCallSpecs</name></type> <name>untyped_on_call_specs_</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>UntypedExpectations</name></type> <name>untyped_expectations_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>UntypedOnCallSpecBase</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>UntypedOnCallSpecBase</name><argument_list>(<argument>const char* a_file</argument>, <argument>int a_line</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>file_</name><argument_list>(<argument><expr><name>a_file</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>line_</name><argument_list>(<argument><expr><name>a_line</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>last_clause_</name><argument_list>(<argument>kNone</argument>)</argument_list></macro> <expr><block>{}</block>


<specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>file</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>file_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>int</name> <macro><name>line</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>line_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>protected</name>:</label>

<enum>enum <name>Clause</name> <block>{


<decl><name>kNone</name></decl>,
<decl><name>kWith</name></decl>,
<decl><name>kWillByDefault</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>void</name></type> <name>AssertSpecProperty</name><argument_list>(<argument><expr><name>bool</name> <name>property</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>failure_message</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>property</name></expr></argument>, <argument><expr><name>file_</name></expr></argument>, <argument><expr><name>line_</name></expr></argument>, <argument><expr><name>failure_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>bool</name> <name>property</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>failure_message</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Expect</name><argument_list>(<argument><expr><name>property</name></expr></argument>, <argument><expr><name>file_</name></expr></argument>, <argument><expr><name>line_</name></expr></argument>, <argument><expr><name>failure_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line_</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Clause</name></type> <name>last_clause_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>OnCallSpec</name> <range>: <expr><name>public</name> <name>UntypedOnCallSpecBase</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentMatcherTuple</name> <name>ArgumentMatcherTuple</name></expr>;</expr_stmt></typedef>



<macro><name>OnCallSpec</name><argument_list>(<argument>const char* a_file</argument>, <argument>int a_line</argument>,
<argument>const ArgumentMatcherTuple&amp; matchers</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>UntypedOnCallSpecBase</name><argument_list>(<argument><expr><name>a_file</name></expr></argument>, <argument><expr><name>a_line</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>matchers_</name><argument_list>(<argument><expr><name>matchers</name></expr></argument>)</argument_list></call></expr><operator>,</operator>




<macro><name>extra_matcher_</name><argument_list>(<argument>A&lt;const ArgumentTuple&amp;&gt;()</argument>)</argument_list></macro> <expr><block>{
}</block>


<name>OnCallSpec</name><operator>&amp;</operator> <macro><name>With</name><argument_list>(<argument>const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m</argument>)</argument_list></macro> <block>{

<expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;</operator> <name>kWith</name></expr></argument>,
<argument><expr><literal type="string">".With() cannot appear "</literal>
<literal type="string">"more than once in an ON_CALL()."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>last_clause_</name> <operator>=</operator> <name>kWith</name></expr>;

<expr><name>extra_matcher_</name> <operator>=</operator> <name>m</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>OnCallSpec</name><modifier>&amp;</modifier></type> <name>WillByDefault</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>action</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;</operator> <name>kWillByDefault</name></expr></argument>,
<argument><expr><literal type="string">".WillByDefault() must appear "</literal>
<literal type="string">"exactly once in an ON_CALL()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kWillByDefault</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>action</name><operator>.</operator><name>IsDoDefault</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"DoDefault() cannot be used in ON_CALL()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>action_</name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>bool</name></type> <name>Matches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>TupleMatches</name><argument_list>(<argument><expr><name>matchers_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>extra_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>GetAction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>AssertSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>==</operator> <name>kWillByDefault</name></expr></argument>,
<argument><expr><literal type="string">".WillByDefault() must appear exactly "</literal>
<literal type="string">"once in an ON_CALL()."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>action_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>













<decl_stmt><decl><type><name>ArgumentMatcherTuple</name></type> <name>matchers_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>extra_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></type> <name>action_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<enum>enum <name>CallReaction</name> <block>{
<decl><name>kAllow</name></decl>,
<decl><name>kWarn</name></decl>,
<decl><name>kFail</name></decl>,
}</block>;</enum>

</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>Mock</name> <block>{<block_content>
<label><name>public</name>:</label>




<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AllowLeak</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)</block_content></block></decl>;</decl_stmt>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>VerifyAndClearExpectations</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>VerifyAndClear</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UntypedFunctionMockerBase</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>FunctionMockerBase</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>NiceMock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>NaggyMock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>M</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>StrictMock</name></decl>;</decl_stmt>



<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AllowUninterestingCalls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>



<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>WarnUninterestingCalls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>



<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FailUninterestingCalls</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>



<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UnregisterCallReaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>



<expr_stmt><expr><specifier>static</specifier> <name>internal</name><operator>::</operator><name>CallReaction</name> <macro><name>GetReactionOnUninterestingCalls</name><argument_list>(
<argument>const void* mock_obj</argument>)</argument_list></macro>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>g_gmock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>VerifyAndClearExpectationsLocked</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ClearDefaultActionsLocked</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>)</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>Register</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>mock_obj</name></expr></argument>,
<argument><expr><name>internal</name><operator>::</operator><name>UntypedFunctionMockerBase</name><operator>*</operator> <name>mocker</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>g_gmock_mutex</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RegisterUseByOnCallOrExpectCall</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>mock_obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl/></parameter></parameter_list>internal::g_gmock_mutex</function_decl>)<empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>UnregisterLocked</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>UntypedFunctionMockerBase</name><operator>*</operator> <name>mocker</name></expr></argument>)</argument_list>
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>g_gmock_mutex</name></expr></argument>)</argument_list></decl>;</decl_stmt>
};






















<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>Expectation</name> <block>{<block_content>
<label><name>public</name>:</label>

<expr_stmt><expr><call><name>Expectation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>Expectation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>










<expr_stmt><expr><call><name>Expectation</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>ExpectationBase</name><operator>&amp;</operator> <name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>Expectation</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>expectation_base_</name> <operator>==</operator> <name><name>rhs</name><operator>.</operator><name>expectation_base_</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>Expectation</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExpectationSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Sequence</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>ExpectationBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>UntypedFunctionMockerBase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>FunctionMockerBase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>TypedExpectation</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>Less</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>Expectation</name><operator>&amp;</operator> <name>lhs</name><operator>,</operator> <specifier>const</specifier> <name>Expectation</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>lhs</name><operator>.</operator><name>expectation_base_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name><name>rhs</name><operator>.</operator><name>expectation_base_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>Expectation</name></expr></argument>, <argument><expr><name>Less</name></expr></argument>&gt;</argument_list></name> <name>Set</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><call><name>Expectation</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ExpectationBase</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>expectation_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ExpectationBase</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator>
<macro><name>expectation_base</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>expectation_base_</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>ExpectationBase</name></expr></argument>&gt;</argument_list></name> <name>expectation_base_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>














<decl_stmt><decl><type><name>class</name></type> <name>ExpectationSet</name> <block>{<block_content>
<label><name>public</name>:</label>

<typedef>typedef <expr_stmt><expr><name>Expectation</name><operator>::</operator><name>Set</name><operator>::</operator><name>const_iterator</name> <name>const_iterator</name></expr>;</expr_stmt></typedef>


<typedef>typedef <expr_stmt><expr><name>Expectation</name><operator>::</operator><name>Set</name><operator>::</operator><name>value_type</name> <name>value_type</name></expr>;</expr_stmt></typedef>


<macro><name>ExpectationSet</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>




<macro><name>ExpectationSet</name><argument_list>(<argument>internal::ExpectationBase&amp; exp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>this</name> <operator>+=</operator> <call><name>Expectation</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>




<macro><name>ExpectationSet</name><argument_list>(<argument>const Expectation&amp; e</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>this</name> <operator>+=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block>






<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>ExpectationSet</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>expectations_</name> <operator>==</operator> <name><name>rhs</name><operator>.</operator><name>expectations_</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>ExpectationSet</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>ExpectationSet</name><operator>&amp;</operator> <name>operator</name><operator>+=</operator><operator>(</operator><specifier>const</specifier> <name>Expectation</name><operator>&amp;</operator> <name>e</name><operator>)</operator> <block>{
<expr><call><name><name>expectations_</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>int</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>expectations_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>expectations_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>expectations_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>Expectation</name><operator>::</operator><name>Set</name> <name>expectations_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>Sequence</name> <block>{<block_content>
<label><name>public</name>:</label>

<expr_stmt><expr><call><name>Sequence</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>last_expectation_</name><argument_list>(<argument>new Expectation</argument>)</argument_list></macro> <block>{}</block>



<name>void</name> <macro><name>AddExpectation</name><argument_list>(<argument>const Expectation&amp; expectation</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>




<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Expectation</name></expr></argument>&gt;</argument_list></name> <name>last_expectation_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

























<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>InSequence</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>InSequence</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>InSequence</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>sequence_created_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>InSequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt> <expr_stmt><expr><name>GTEST_ATTRIBUTE_UNUSED_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>



<decl_stmt><decl><type><name>GTEST_API_</name> <specifier>extern</specifier> <name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><expr><name>Sequence</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>g_gmock_implicit_sequence</name></decl>;</decl_stmt>















<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>ExpectationBase</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>ExpectationBase</name><argument_list>(<argument>const char* file</argument>, <argument>int line</argument>, <argument>const std::string&amp; source_text</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>ExpectationBase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>file</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>file_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>int</name> <macro><name>line</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>line_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>source_text</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>source_text_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Cardinality</name><operator>&amp;</operator> <macro><name>cardinality</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>cardinality_</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>DescribeLocationTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <call><name>FormatFileLocation</name><argument_list>(<argument><expr><call><name>file</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>line</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>DescribeCallCountTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>MaybeDescribeExtraMatcherTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>Expectation</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UntypedFunctionMockerBase</name></decl>;</decl_stmt>

<enum>enum <name>Clause</name> <block>{

<decl><name>kNone</name></decl>,
<decl><name>kWith</name></decl>,
<decl><name>kTimes</name></decl>,
<decl><name>kInSequence</name></decl>,
<decl><name>kAfter</name></decl>,
<decl><name>kWillOnce</name></decl>,
<decl><name>kWillRepeatedly</name></decl>,
<decl><name>kRetiresOnSaturation</name></decl>
}</block>;</enum>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UntypedActions</name></expr>;</expr_stmt></typedef>



<function_decl><type><name>virtual</name> <name>Expectation</name></type> <name>GetHandle</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>AssertSpecProperty</name><argument_list>(<argument><expr><name>bool</name> <name>property</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>failure_message</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>property</name></expr></argument>, <argument><expr><name>file_</name></expr></argument>, <argument><expr><name>line_</name></expr></argument>, <argument><expr><name>failure_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>bool</name> <name>property</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>failure_message</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>Expect</name><argument_list>(<argument><expr><name>property</name></expr></argument>, <argument><expr><name>file_</name></expr></argument>, <argument><expr><name>line_</name></expr></argument>, <argument><expr><name>failure_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<function_decl><type><name>void</name></type> <name>SpecifyCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Cardinality</name><modifier>&amp;</modifier></type> <name>cardinality</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>cardinality_specified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>cardinality_specified_</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>set_cardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Cardinality</name><modifier>&amp;</modifier></type> <name>a_cardinality</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>cardinality_</name> <operator>=</operator> <name>a_cardinality</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function_decl><type><name>void</name></type> <name>RetireAllPreRequisites</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>is_retired</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<macro><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>retired_</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>Retire</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retired_</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>IsSatisfied</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<macro><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>cardinality</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsSatisfiedByCallCount</name><argument_list>(<argument><expr><name>call_count_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>IsSaturated</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<macro><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>cardinality</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsSaturatedByCallCount</name><argument_list>(<argument><expr><name>call_count_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>IsOverSaturated</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<macro><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>cardinality</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsOverSaturatedByCallCount</name><argument_list>(<argument><expr><name>call_count_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>AllPrerequisitesAreSatisfied</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>FindUnsatisfiedPrerequisites</name><argument_list>(<argument><expr><name>ExpectationSet</name><operator>*</operator> <name>result</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>int</name> <macro><name>call_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<macro><name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>call_count_</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>IncrementCallCount</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>call_count_</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>





<expr_stmt><expr><name>void</name> <macro><name>CheckActionCountIfNotDone</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>Sequence</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>ExpectationTester</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Function</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>TypedExpectation</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>UntypedTimes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Cardinality</name><modifier>&amp;</modifier></type> <name>a_cardinality</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line_</name></decl>;</decl_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>source_text_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>cardinality_specified_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Cardinality</name></type> <name>cardinality_</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>ExpectationSet</name></type> <name>immediate_prerequisites_</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>call_count_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>retired_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UntypedActions</name></type> <name>untyped_actions_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>extra_matcher_specified_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>repeated_action_specified_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>retires_on_saturation_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Clause</name></type> <name>last_clause_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>bool</name></type> <name>action_count_checked_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>Mutex</name></type> <name>mutex_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>ExpectationBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TypedExpectation</name> <range>: <expr><name>public</name> <name>ExpectationBase</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentMatcherTuple</name> <name>ArgumentMatcherTuple</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef>

<macro><name>TypedExpectation</name><argument_list>(<argument>FunctionMockerBase&lt;F&gt;* owner</argument>, <argument>const char* a_file</argument>, <argument>int a_line</argument>,
<argument>const std::string&amp; a_source_text</argument>,
<argument>const ArgumentMatcherTuple&amp; m</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ExpectationBase</name><argument_list>(<argument><expr><name>a_file</name></expr></argument>, <argument><expr><name>a_line</name></expr></argument>, <argument><expr><name>a_source_text</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>owner_</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>matchers_</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr><operator>,</operator>




<expr><call><name>extra_matcher_</name><argument_list>(<argument><expr><call><name><name>A</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>repeated_action_</name><argument_list>(<argument>DoDefault()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>virtual</name> <operator>~</operator><macro><name>TypedExpectation</name><argument_list>()</argument_list></macro> <block>{


<expr><call><name>CheckActionCountIfNotDone</name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><expr><name>UntypedActions</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>untyped_actions_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>untyped_actions_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>delete</name></type> <name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt/>}</block_content>
}


TypedExpectation&amp; With(const Matcher&lt;const ArgumentTuple&amp;&gt;&amp; m</block></for>) <block>{
<if_stmt><if>if <condition>(<expr><name>last_clause_</name> <operator>==</operator> <name>kWith</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>false</name></expr></argument>,
<argument><expr><literal type="string">".With() cannot appear "</literal>
<literal type="string">"more than once in an EXPECT_CALL()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;</operator> <name>kWith</name></expr></argument>,
<argument><expr><literal type="string">".With() must be the first "</literal>
<literal type="string">"clause in an EXPECT_CALL()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
last_clause_ = kWith</block></block><empty_stmt>;</empty_stmt></if></if_stmt>

<name>extra_matcher_</name> <operator>=</operator> <name>m</name></block></block></expr>;</expr_stmt>
<expr_stmt><expr><name>extra_matcher_specified_</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>Times</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Cardinality</name><modifier>&amp;</modifier></type> <name>a_cardinality</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ExpectationBase</name><operator>::</operator><call><name>UntypedTimes</name><argument_list>(<argument><expr><name>a_cardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>Times</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Times</name><argument_list>(<argument><expr><call><name>Exactly</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>InSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;=</operator> <name>kInSequence</name></expr></argument>,
<argument><expr><literal type="string">".InSequence() cannot appear after .After(),"</literal>
<literal type="string">" .WillOnce(), .WillRepeatedly(), or "</literal>
<literal type="string">".RetiresOnSaturation()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kInSequence</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>AddExpectation</name></name><argument_list>(<argument><expr><call><name>GetHandle</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>InSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InSequence</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>InSequence</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>InSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InSequence</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>InSequence</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>InSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s4</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InSequence</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>InSequence</name><argument_list>(<argument><expr><name>s4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>InSequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s4</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Sequence</name><modifier>&amp;</modifier></type> <name>s5</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>InSequence</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>, <argument><expr><name>s4</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>InSequence</name><argument_list>(<argument><expr><name>s5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>After</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;=</operator> <name>kAfter</name></expr></argument>,
<argument><expr><literal type="string">".After() cannot appear after .WillOnce(),"</literal>
<literal type="string">" .WillRepeatedly(), or "</literal>
<literal type="string">".RetiresOnSaturation()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kAfter</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ExpectationSet</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>s</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>s</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>immediate_prerequisites_</name> <operator>+=</operator> <operator>*</operator><name>it</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>After</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>After</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>After</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>After</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>After</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>After</name><argument_list>(<argument><expr><name>s3</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>After</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s4</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>After</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>After</name><argument_list>(<argument><expr><name>s4</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>After</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s3</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s4</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExpectationSet</name><modifier>&amp;</modifier></type> <name>s5</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>After</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>, <argument><expr><name>s4</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>After</name><argument_list>(<argument><expr><name>s5</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>WillOnce</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>action</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;=</operator> <name>kWillOnce</name></expr></argument>,
<argument><expr><literal type="string">".WillOnce() cannot appear after "</literal>
<literal type="string">".WillRepeatedly() or .RetiresOnSaturation()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kWillOnce</name></expr>;</expr_stmt>

<macro><name>untyped_actions_</name></macro><expr_stmt><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>new Action&lt;F&gt;(action)</argument>)</argument_list></macro></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cardinality_specified</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_cardinality</name><argument_list>(<argument><expr><call><name>Exactly</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>untyped_actions_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>WillRepeatedly</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>action</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>last_clause_</name> <operator>==</operator> <name>kWillRepeatedly</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>false</name></expr></argument>,
<argument><expr><literal type="string">".WillRepeatedly() cannot appear "</literal>
<literal type="string">"more than once in an EXPECT_CALL()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;</operator> <name>kWillRepeatedly</name></expr></argument>,
<argument><expr><literal type="string">".WillRepeatedly() cannot appear "</literal>
<literal type="string">"after .RetiresOnSaturation()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kWillRepeatedly</name></expr>;</expr_stmt>
<expr_stmt><expr><name>repeated_action_specified_</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>repeated_action_</name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cardinality_specified</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_cardinality</name><argument_list>(<argument><expr><call><name>AtLeast</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>untyped_actions_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>CheckActionCountIfNotDone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>TypedExpectation</name><modifier>&amp;</modifier></type> <name>RetiresOnSaturation</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ExpectSpecProperty</name><argument_list>(<argument><expr><name>last_clause_</name> <operator>&lt;</operator> <name>kRetiresOnSaturation</name></expr></argument>,
<argument><expr><literal type="string">".RetiresOnSaturation() cannot appear "</literal>
<literal type="string">"more than once."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_clause_</name> <operator>=</operator> <name>kRetiresOnSaturation</name></expr>;</expr_stmt>
<expr_stmt><expr><name>retires_on_saturation_</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>CheckActionCountIfNotDone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><specifier>const</specifier> <name>ArgumentMatcherTuple</name><operator>&amp;</operator> <macro><name>matchers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>matchers_</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>extra_matcher</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>extra_matcher_</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>repeated_action</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>repeated_action_</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>MaybeDescribeExtraMatcherTo</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>extra_matcher_specified_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Expected args: "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>extra_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Function</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>FunctionMockerBase</name></decl>;</decl_stmt>



<function><type><name>virtual</name> <name>Expectation</name></type> <name>GetHandle</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>owner_</name><operator>-&gt;</operator><name>GetHandleOf</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><name>bool</name></type> <name>Matches</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>TupleMatches</name><argument_list>(<argument><expr><name>matchers_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>extra_matcher_</name><operator>.</operator><name>Matches</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ShouldHandleArguments</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>CheckActionCountIfNotDone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name>is_retired</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AllPrerequisitesAreSatisfied</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>Matches</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>ExplainMatchResultTo</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_retired</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Expected: the expectation is active\n"</literal>
<operator>&lt;&lt;</operator> <literal type="string">" Actual: it is retired\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>Matches</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupleMatches</name><argument_list>(<argument><expr><name>matchers_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ExplainMatchFailureTupleTo</name><argument_list>(<argument><expr><name>matchers_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>StringMatchResultListener</name></type> <name>listener</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>extra_matcher_</name><operator>.</operator><name>MatchAndExplain</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>listener</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Expected args: "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>extra_matcher_</name><operator>.</operator><name>DescribeTo</name></name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n Actual: don't match"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>internal</name><operator>::</operator><call><name>PrintIfNotEmpty</name><argument_list>(<argument><expr><call><name><name>listener</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>AllPrerequisitesAreSatisfied</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Expected: all pre-requisites are satisfied\n"</literal>
<operator>&lt;&lt;</operator> <literal type="string">" Actual: the following immediate pre-requisites "</literal>
<operator>&lt;&lt;</operator> <literal type="string">"are not satisfied:\n"</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExpectationSet</name></type> <name>unsatisfied_prereqs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FindUnsatisfiedPrerequisites</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unsatisfied_prereqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ExpectationSet</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>unsatisfied_prereqs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>unsatisfied_prereqs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>it</name><operator>-&gt;</operator><name>expectation_base</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>DescribeLocationTo</name><argument_list>(<argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"pre-requisite #"</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>++</operator> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" (end of pre-requisites)\n"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"The call matches the expectation.\n"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>GetCurrentAction</name><argument_list>(
<argument><expr><specifier>const</specifier> <name><name>FunctionMockerBase</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>mocker</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name> <init>= <expr><call><name>call_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>,
<argument><expr><literal type="string">"call_count() is &lt;= 0 when GetCurrentAction() is "</literal>
<literal type="string">"called - this should never happen."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>action_count</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>untyped_actions_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>action_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>repeated_action_specified_</name> <operator>&amp;&amp;</operator>
<name>count</name> <operator>&gt;</operator> <name>action_count</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>ss</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DescribeLocationTo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <literal type="string">"Actions ran out in "</literal> <operator>&lt;&lt;</operator> <call><name>source_text</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"...\n"</literal>
<operator>&lt;&lt;</operator> <literal type="string">"Called "</literal> <operator>&lt;&lt;</operator> <name>count</name> <operator>&lt;&lt;</operator> <literal type="string">" times, but only "</literal>
<operator>&lt;&lt;</operator> <name>action_count</name> <operator>&lt;&lt;</operator> <literal type="string">" WillOnce()"</literal>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>action_count</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">" is"</literal></expr> </then><else>: <expr><literal type="string">"s are"</literal></expr></else></ternary><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="string">" specified - "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>mocker</name><operator>-&gt;</operator><name>DescribeDefaultActionTo</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Log</name><argument_list>(<argument><expr><name>kWarning</name></expr></argument>, <argument><expr><call><name><name>ss</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>count</name> <operator>&lt;=</operator> <name>action_count</name></expr> ?</condition><then>
<expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>untyped_actions_</name><index>[<expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>repeated_action</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>GetActionForArguments</name><argument_list>(
<argument><expr><specifier>const</specifier> <name><name>FunctionMockerBase</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>mocker</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>what</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>why</name></expr></argument>)</argument_list>
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IsSaturated</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>IncrementCallCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>what</name> <operator>&lt;&lt;</operator> <literal type="string">"Mock function called more times than expected - "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>mocker</name><operator>-&gt;</operator><name>DescribeDefaultActionTo</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DescribeCallCountTo</name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>IncrementCallCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RetireAllPreRequisites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retires_on_saturation_</name> <operator>&amp;&amp;</operator> <call><name>IsSaturated</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Retire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>what</name> <operator>&lt;&lt;</operator> <literal type="string">"Mock function call matches "</literal> <operator>&lt;&lt;</operator> <call><name>source_text</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator><literal type="string">"...\n"</literal></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><operator>(</operator><call><name>GetCurrentAction</name><argument_list>(<argument><expr><name>mocker</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>FunctionMockerBase</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>owner_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ArgumentMatcherTuple</name></type> <name>matchers_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name></type> <name>extra_matcher_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></type> <name>repeated_action_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TypedExpectation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};












<decl_stmt><decl><type><name>GTEST_API_</name> <name>void</name></type> <name>LogWithLocation</name><argument_list>(<argument><expr><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><name>LogSeverity</name> <name>severity</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file</name></expr></argument>, <argument><expr><name>int</name> <name>line</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>message</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>MockSpec</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentMatcherTuple</name>
<name>ArgumentMatcherTuple</name></expr>;</expr_stmt></typedef>



<expr_stmt><expr><call><name>MockSpec</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name><name>FunctionMockerBase</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>function_mocker</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ArgumentMatcherTuple</name><operator>&amp;</operator> <name>matchers</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>function_mocker_</name><argument_list>(<argument><expr><name>function_mocker</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>matchers_</name><argument_list>(<argument>matchers</argument>)</argument_list></macro> <expr><block>{}</block>



<name>internal</name><operator>::</operator><name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>InternalDefaultActionSetAt</name><argument_list>(
<argument>const char* file</argument>, <argument>int line</argument>, <argument>const char* obj</argument>, <argument>const char* call</argument>)</argument_list></macro> <block>{
<expr><call><name>LogWithLocation</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>kInfo</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"ON_CALL("</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>obj</name> <operator>+</operator> <literal type="string">", "</literal> <operator>+</operator> <name>call</name> <operator>+</operator> <literal type="string">") invoked"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>function_mocker_</name><operator>-&gt;</operator><name>AddNewOnCallSpec</name></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>matchers_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>InternalExpectedAt</name><argument_list>(
<argument>const char* file</argument>, <argument>int line</argument>, <argument>const char* obj</argument>, <argument>const char* call</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>source_text</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"EXPECT_CALL("</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>obj</name> <operator>+</operator> <literal type="string">", "</literal> <operator>+</operator>
<name>call</name> <operator>+</operator> <literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>LogWithLocation</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>kInfo</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>source_text</name> <operator>+</operator> <literal type="string">" invoked"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>function_mocker_</name><operator>-&gt;</operator><name>AddNewExpectation</name></name><argument_list>(
<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>source_text</name></expr></argument>, <argument><expr><name>matchers_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>MockSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>internal</name><operator>::</operator><name>WithoutMatchers</name><operator>&amp;</operator><operator>,</operator> <name>void</name><operator>*</operator> <specifier>const</specifier><operator>)</operator> <block>{
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Function</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>FunctionMocker</name></expr>;</expr_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>FunctionMockerBase</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <specifier>const</specifier> <name>function_mocker_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ArgumentMatcherTuple</name></type> <name>matchers_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>MockSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>










<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ReferenceOrValueWrapper</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>explicit</name></macro> <macro><name>ReferenceOrValueWrapper</name><argument_list>(<argument>T value</argument>)</argument_list></macro>
: <macro><name>value_</name><argument_list>(<argument>::testing::internal::move(value)</argument>)</argument_list></macro> <block>{<block_content>
</block_content>}</block>




<function><type><name>T</name></type> <name>Unwrap</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>::</operator><name>testing</name><operator>::</operator><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>value_</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>





<expr_stmt><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <macro><name>Peek</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>value_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name></type> <name>value_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>ReferenceOrValueWrapper</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>


<typedef>typedef <type><name>T</name><modifier>&amp;</modifier></type> <name>reference</name>;</typedef>
<macro><name>explicit</name></macro> <macro><name>ReferenceOrValueWrapper</name><argument_list>(<argument>reference ref</argument>)</argument_list></macro>
: <macro><name>value_ptr_</name><argument_list>(<argument>&amp;ref</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<function><type><name>T</name><modifier>&amp;</modifier></type> <name>Unwrap</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>value_ptr_</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <macro><name>Peek</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><name>value_ptr_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name><modifier>*</modifier></type> <name>value_ptr_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4355</literal></argument>)</argument_list></macro>










<decl_stmt><decl><type><name>class</name></type> <name>UntypedActionResultHolderBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>UntypedActionResultHolderBase</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>PrintAsActionResult</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ActionResultHolder</name> <range>: <expr><name>public</name> <name>UntypedActionResultHolderBase</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>T</name> <macro><name>Unwrap</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>result_</name><operator>.</operator><name>Unwrap</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>virtual</name> <name>void</name> <macro><name>PrintAsActionResult</name><argument_list>(<argument>::std::ostream* os</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\n Returns: "</literal></expr>;

<expr><name><name>UniversalPrinter</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Print</name><argument_list>(<argument><expr><call><name><name>result_</name><operator>.</operator><name>Peek</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ActionResultHolder</name><operator>*</operator> <macro><name>PerformDefaultAction</name><argument_list>(
<argument>const FunctionMockerBase&lt;F&gt;* func_mocker</argument>,
<argument>typename RvalueRef&lt;typename Function&lt;F&gt;::ArgumentTuple&gt;::type args</argument>,
<argument>const std::string&amp; call_description</argument>)</argument_list></macro> <block>{
<return>return <expr><name>new</name> <call><name>ActionResultHolder</name><argument_list>(<argument><expr><call><name>Wrapper</name><argument_list>(<argument><expr><call><name><name>func_mocker</name><operator>-&gt;</operator><name>PerformDefaultAction</name></name><argument_list>(
<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>call_description</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ActionResultHolder</name><operator>*</operator> <macro><name>PerformAction</name><argument_list>(
<argument>const Action&lt;F&gt;&amp; action</argument>,
<argument>typename RvalueRef&lt;typename Function&lt;F&gt;::ArgumentTuple&gt;::type args</argument>)</argument_list></macro> <block>{
<return>return <expr><name>new</name> <call><name>ActionResultHolder</name><argument_list>(
<argument><expr><call><name>Wrapper</name><argument_list>(<argument><expr><call><name><name>action</name><operator>.</operator><name>Perform</name></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator></expr>
<typedef>typedef <type><name><name>ReferenceOrValueWrapper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>Wrapper</name>;</typedef>

<name>explicit</name> <macro><name>ActionResultHolder</name><argument_list>(<argument>Wrapper result</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>result_</name><argument_list>(<argument>::testing::internal::move(result)</argument>)</argument_list></macro> <block>{
}</block></block>

<name>Wrapper</name> <name>result_</name></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ActionResultHolder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name></type> <name><name>ActionResultHolder</name><argument_list type="generic">&lt;<argument><expr><name>void</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name>UntypedActionResultHolderBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>void</name> <macro><name>Unwrap</name><argument_list>()</argument_list></macro> <block>{ }</block>

<name>virtual</name> <name>void</name> <macro><name>PrintAsActionResult</name><argument_list>(<argument>::std::ostream*</argument> )</argument_list></macro> <specifier>const</specifier> <block>{}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ActionResultHolder</name><operator>*</operator> <macro><name>PerformDefaultAction</name><argument_list>(
<argument>const FunctionMockerBase&lt;F&gt;* func_mocker</argument>,
<argument>typename RvalueRef&lt;typename Function&lt;F&gt;::ArgumentTuple&gt;::type args</argument>,
<argument>const std::string&amp; call_description</argument>)</argument_list></macro> <block>{
<expr><call><name><name>func_mocker</name><operator>-&gt;</operator><name>PerformDefaultAction</name></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>call_description</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>new</name> <name>ActionResultHolder</name></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>ActionResultHolder</name><operator>*</operator> <macro><name>PerformAction</name><argument_list>(
<argument>const Action&lt;F&gt;&amp; action</argument>,
<argument>typename RvalueRef&lt;typename Function&lt;F&gt;::ArgumentTuple&gt;::type args</argument>)</argument_list></macro> <block>{
<expr><call><name><name>action</name><operator>.</operator><name>Perform</name></name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>new</name> <name>ActionResultHolder</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<macro><name>ActionResultHolder</name><argument_list>()</argument_list></macro> <block>{}</block>
<call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ActionResultHolder</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>FunctionMockerBase</name> <range>: <expr><name>public</name> <name>UntypedFunctionMockerBase</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Result</name> <name>Result</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name> <name>ArgumentTuple</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentMatcherTuple</name> <name>ArgumentMatcherTuple</name></expr>;</expr_stmt></typedef>

<macro><name>FunctionMockerBase</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>




<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>FunctionMockerBase</name><argument_list>()</argument_list></macro>
<macro><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument>g_gmock_mutex</argument>)</argument_list></macro> <block>{
<expr><name>MutexLock</name> <call><name>l</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_gmock_mutex</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>VerifyAndClearExpectationsLocked</name><argument_list>()</argument_list></call></expr>;
<expr><name>Mock</name><operator>::</operator><call><name>UnregisterLocked</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>ClearDefaultActionsLocked</name><argument_list>()</argument_list></call></expr>;
}</block>




<specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>FindOnCallSpec</name><argument_list>(
<argument>const ArgumentTuple&amp; args</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><expr><name>UntypedOnCallSpecs</name><operator>::</operator><name>const_reverse_iterator</name> <name>it</name>
<operator>=</operator> <call><name><name>untyped_on_call_specs_</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>untyped_on_call_specs_</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>spec</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>spec</name><operator>-&gt;</operator><name>Matches</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>spec</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
}








Result <macro><name>PerformDefaultAction</name><argument_list>(
<argument>typename RvalueRef&lt;typename Function&lt;F&gt;::ArgumentTuple&gt;::type args</argument>,
<argument>const std::string&amp; call_description</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <specifier>const</specifier> <name>spec</name> <operator>=</operator>
<call><name><name>this</name><operator>-&gt;</operator><name>FindOnCallSpec</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>spec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>spec</name><operator>-&gt;</operator><name>GetAction</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>Perform</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>message</name> <operator>=</operator>
<name>call_description</name> <operator>+</operator>
<literal type="string">"\n The mock function has no default action "</literal>
<literal type="string">"set, and its return type has no default value set."</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_EXCEPTIONS</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Exists</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>throw</name> <name>std</name><operator>::</operator><call><name>runtime_error</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Exists</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name><name>DefaultValue</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Get</name><argument_list>()</argument_list></call></expr>;</return>
}






virtual <decl_stmt><decl><type><name>UntypedActionResultHolderBase</name><modifier>*</modifier></type> <name>UntypedPerformDefaultAction</name><argument_list>(
<argument><expr><name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>call_description</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>ArgumentTuple</name><modifier>*</modifier></type> <name>args</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentTuple</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>ResultHolder</name><operator>::</operator><call><name>PerformDefaultAction</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><operator>*</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>call_description</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>virtual</name> <name>UntypedActionResultHolderBase</name><modifier>*</modifier></type> <name>UntypedPerformAction</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_action</name></expr></argument>, <argument><expr><name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>)</argument_list> const <block>{<block_content>


<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></type> <name>action</name> <init>= <expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_action</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ArgumentTuple</name><modifier>*</modifier></type> <name>args</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentTuple</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>ResultHolder</name><operator>::</operator><call><name>PerformAction</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>internal</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><operator>*</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function><type><name>virtual</name> <name>void</name></type> <name>ClearDefaultActionsLocked</name><parameter_list>()</parameter_list>
GTEST_EXCLUSIVE_LOCK_REQUIRED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>








<decl_stmt><decl><type><name>UntypedOnCallSpecs</name></type> <name>specs_to_delete</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>untyped_on_call_specs_</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>specs_to_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>Unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>UntypedOnCallSpecs</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator>
<call><name><name>specs_to_delete</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>specs_to_delete</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>delete</name></type> <name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>Lock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Function</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <name>class</name></type> <name>MockSpec</name></decl>;</decl_stmt>

<typedef>typedef <type><name><name>ActionResultHolder</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>&gt;</argument_list></name></type> <name>ResultHolder</name>;</typedef>




<decl_stmt><decl><type><name>Result</name></type> <name>InvokeWith</name><argument_list>(
<argument><expr><name>typename</name> <name><name>RvalueRef</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name><name>Function</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>ArgumentTuple</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>args</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>


<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>untyped_args</name> <init>= <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ResultHolder</name></expr></argument>&gt;</argument_list></name></type> <name>holder</name><argument_list>(
<argument><expr><call><name><name>DownCast_</name><argument_list type="generic">&lt;<argument><expr><name>ResultHolder</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>this</name><operator>-&gt;</operator><name>UntypedInvokeWith</name></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name><name>holder</name><operator>-&gt;</operator><name>Unwrap</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>AddNewOnCallSpec</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ArgumentMatcherTuple</name><modifier>&amp;</modifier></type> <name>m</name></decl></parameter>)</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl><type><name>g_gmock_mutex</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Mock</name><operator>::</operator><call><name>RegisterUseByOnCallOrExpectCall</name><argument_list>(<argument><expr><call><name>MockObject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>on_call_spec</name> <init>= <expr><name>new</name> <call><name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>untyped_on_call_specs_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>on_call_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>on_call_spec</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>AddNewExpectation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file</name></expr></argument>, <argument><expr><name>int</name> <name>line</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>source_text</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ArgumentMatcherTuple</name><operator>&amp;</operator> <name>m</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>Mock</name><operator>::</operator><call><name>RegisterUseByOnCallOrExpectCall</name><argument_list>(<argument><expr><call><name>MockObject</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>expectation</name> <init>=
<expr><name>new</name> <call><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>source_text</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ExpectationBase</name></expr></argument>&gt;</argument_list></name></type> <name>untyped_expectation</name><parameter_list>(<parameter><decl><type><name>expectation</name></type></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><call><name><name>untyped_expectations_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>untyped_expectation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Sequence</name><modifier>*</modifier> <specifier>const</specifier></type> <name>implicit_sequence</name> <init>= <expr><call><name><name>g_gmock_implicit_sequence</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>implicit_sequence</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>implicit_sequence</name><operator>-&gt;</operator><name>AddExpectation</name></name><argument_list>(<argument><expr><call><name>Expectation</name><argument_list>(<argument><expr><name>untyped_expectation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>*</operator><name>expectation</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Func</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name></type> <name>TypedExpectation</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>DescribeDefaultActionTo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>OnCallSpec</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>spec</name> <init>= <expr><call><name>FindOnCallSpec</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>spec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>internal</name><operator>::</operator><name><name>type_equals</name><argument_list type="generic">&lt;<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>void</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr> ?</condition><then>
<expr><literal type="string">"returning directly.\n"</literal></expr> </then><else>:
<expr><literal type="string">"returning default value.\n"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"taking default action specified at:\n"</literal>
<operator>&lt;&lt;</operator> <call><name>FormatFileLocation</name><argument_list>(<argument><expr><call><name><name>spec</name><operator>-&gt;</operator><name>file</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>spec</name><operator>-&gt;</operator><name>line</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>UntypedDescribeUninterestingCall</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type> <name>args</name> <init>=
<expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"Uninteresting mock function call - "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DescribeDefaultActionTo</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">" Function call: "</literal> <operator>&lt;&lt;</operator> <call><name>Name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

















<decl_stmt><decl><type><name>virtual</name> <specifier>const</specifier> <name>ExpectationBase</name><modifier>*</modifier></type> <name>UntypedFindMatchingExpectation</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator><operator>*</operator> <name>untyped_action</name></expr></argument>, <argument><expr><name>bool</name><operator>*</operator> <name>is_excessive</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>what</name></expr></argument>, <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>why</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type> <name>args</name> <init>=
<expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MutexLock</name></type> <name>l</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_gmock_mutex</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>exp</name> <init>= <expr><call><name><name>this</name><operator>-&gt;</operator><name>FindMatchingExpectationLocked</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>this</name><operator>-&gt;</operator><name>FormatUnexpectedCallMessageLocked</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><operator>*</operator><name>is_excessive</name> <operator>=</operator> <call><name><name>exp</name><operator>-&gt;</operator><name>IsSaturated</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>Action</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>action</name> <init>= <expr><call><name><name>exp</name><operator>-&gt;</operator><name>GetActionForArguments</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>why</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name><name>action</name><operator>-&gt;</operator><name>IsDoDefault</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>action</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>untyped_action</name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
<return>return <expr><name>exp</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>UntypedPrintArgs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name><operator>*</operator> <name>untyped_args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ArgumentTuple</name><modifier>&amp;</modifier></type> <name>args</name> <init>=
<expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>untyped_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UniversalPrint</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>FindMatchingExpectationLocked</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>typename</name> <name>UntypedExpectations</name><operator>::</operator><name>const_reverse_iterator</name> <name>it</name> <operator>=</operator>
<call><name><name>untyped_expectations_</name><operator>.</operator><name>rbegin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>untyped_expectations_</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>exp</name> <init>=
<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>it</name><operator>-&gt;</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>exp</name><operator>-&gt;</operator><name>ShouldHandleArguments</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>exp</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>FormatUnexpectedCallMessageLocked</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>os</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>why</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"\nUnexpected mock function call - "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DescribeDefaultActionTo</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>os</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintTriedExpectationsLocked</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>PrintTriedExpectationsLocked</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>ArgumentTuple</name><operator>&amp;</operator> <name>args</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>*</operator> <name>why</name></expr></argument>)</argument_list> const
<name>GTEST_EXCLUSIVE_LOCK_REQUIRED_</name><argument_list>(<argument><expr><name>g_gmock_mutex</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>g_gmock_mutex</name><operator>.</operator><name>AssertHeld</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>count</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>untyped_expectations_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>why</name> <operator>&lt;&lt;</operator> <literal type="string">"Google Mock tried the following "</literal> <operator>&lt;&lt;</operator> <name>count</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal>
<operator>&lt;&lt;</operator> <operator>(</operator><ternary><condition><expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"expectation, but it didn't match"</literal></expr> </then><else>:
<expr><literal type="string">"expectations, but none matched"</literal></expr></else></ternary><operator>)</operator>
<operator>&lt;&lt;</operator> <literal type="string">":\n"</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier> <specifier>const</specifier></type> <name>expectation</name> <init>=
<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name><name>TypedExpectation</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>untyped_expectations_</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>why</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>expectation</name><operator>-&gt;</operator><name>DescribeLocationTo</name></name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>why</name> <operator>&lt;&lt;</operator> <literal type="string">"tried expectation #"</literal> <operator>&lt;&lt;</operator> <name>i</name> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>why</name> <operator>&lt;&lt;</operator> <call><name><name>expectation</name><operator>-&gt;</operator><name>source_text</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"...\n"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>expectation</name><operator>-&gt;</operator><name>ExplainMatchResultTo</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>expectation</name><operator>-&gt;</operator><name>DescribeCallCountTo</name></name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>













<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>FunctionMockerBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};

<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>









<decl_stmt><decl><type><name>void</name></type> <name>ReportUninterestingCall</name><argument_list>(<argument><expr><name>CallReaction</name> <name>reaction</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>msg</name></expr></argument>)</argument_list></decl>;</decl_stmt>

}






using <expr_stmt><expr><name>internal</name><operator>::</operator><name>MockSpec</name></expr>;</expr_stmt>
















<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>Const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>x</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><specifier>inline</specifier> <name>Expectation</name><operator>::</operator><call><name>Expectation</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>ExpectationBase</name><operator>&amp;</operator> <name>exp</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>expectation_base_</name><argument_list>(<argument>exp.GetHandle().expectation_base()</argument>)</argument_list></macro> <block>{}</block></expr></expr_stmt>

}

GTEST_DISABLE_MSC_WARNINGS_POP_<expr><operator>(</operator><operator>)</operator></expr>































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GMOCK_ON_CALL_IMPL_</name><parameter_list>(<parameter><type><name>mock_expr</name></type></parameter>, <parameter><type><name>Setter</name></type></parameter>, <parameter><type><name>call</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((mock_expr).gmock_##call)(::testing::internal::GetWithoutMatchers(), NULL) .Setter(__FILE__, __LINE__, #mock_expr, #call)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ON_CALL</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>call</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GMOCK_ON_CALL_IMPL_(obj, InternalDefaultActionSetAt, call)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_CALL</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>call</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GMOCK_ON_CALL_IMPL_(obj, InternalExpectedAt, call)</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
