<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googletest/include/gtest/gtest.h">


















































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GTEST_INCLUDE_GTEST_GTEST_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_INCLUDE_GTEST_GTEST_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-death-test.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-param-test.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-printers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest_prod.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-test-part.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-typed-test.h"</cpp:file></cpp:include>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4251</literal></argument> \
)</argument_list></macro>
















<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4805</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name><name>4100</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>also_run_disabled_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>break_on_failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>catch_exceptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>GTEST_DECLARE_string_</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_string_</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>install_failure_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>list_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_string_</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>print_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>print_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_DECLARE_int32_</name><argument_list>(<argument><expr><name>random_seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_int32_</name><argument_list>(<argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>show_internal_stack_frames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>shuffle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>GTEST_DECLARE_int32_</name><argument_list>(<argument><expr><name>stack_trace_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>throw_on_failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>GTEST_DECLARE_string_</name><argument_list>(<argument><expr><name>stream_result_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_USE_OWN_FLAGFILE_FLAG_</name></expr></cpp:if>
<expr_stmt><expr><call><name>GTEST_DECLARE_string_</name><argument_list>(<argument><expr><name>flagfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>kMaxStackTraceDepth</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AssertHelper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DefaultGlobalTestPartResultReporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExecDeathTest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NoExecDeathTest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FinalSuccessChecker</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GTestFlagSaver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StreamingListenerTest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestResultAccessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestEventListenersAccessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestEventRepeater</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnitTestRecordPropertyTestHelper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>WindowsDeathTest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FuchsiaDeathTest</name></decl>;</decl_stmt>
<function_decl><type><name>class</name> <name>UnitTestImpl</name><modifier>*</modifier></type> <name>GetUnitTestImpl</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ReportFailureInUnknownLocation</name><argument_list>(<argument><expr><name>TestPartResult</name><operator>::</operator><name>Type</name> <name>result_type</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>message</name></expr></argument>)</argument_list></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>Test</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnitTest</name></decl>;</decl_stmt>
















































































<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>AssertionResult</name> <block>{<block_content>
<label><name>public</name>:</label>


<expr_stmt><expr><call><name>AssertionResult</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AssertionResult</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1910</literal></expr></cpp:if>
<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4800</literal></argument> )</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>explicit</name></type> <name>AssertionResult</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>success</name></expr></argument>,
<argument><expr><name>typename</name> <name>internal</name><operator>::</operator><name><name>EnableIf</name><argument_list type="generic">&lt;
<argument><expr><operator>!</operator><name>internal</name><operator>::</operator><name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>AssertionResult</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><operator>*</operator>
<operator>=</operator> <name>NULL</name></expr></argument>)</argument_list>
<range>: <macro><name>success_</name><argument_list>(<argument>success</argument>)</argument_list></macro> <expr><block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1910</literal></expr></cpp:if>
<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<name>AssertionResult</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><name>AssertionResult</name> <name>other</name><operator>)</operator> <block>{
<expr><call><name>swap</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<expr_stmt><expr><name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>success_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>AssertionResult</name> <name>operator</name><operator>!</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>message</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>message_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>?</operator> <call><name><name>message_</name><operator>-&gt;</operator><name>c_str</name></name><argument_list>()</argument_list></call> <operator>:</operator> <literal type="string">""</literal></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>failure_message</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>message</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>AssertionResult</name><operator>&amp;</operator> <name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>value</name><operator>)</operator> <block>{
<expr><call><name>AppendMessage</name><argument_list>(<argument><expr><call><name>Message</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>AssertionResult</name><operator>&amp;</operator> <name>operator</name><operator>&lt;&lt;</operator><operator>(</operator>
<operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <call>(<modifier>*</modifier><name>basic_manipulator</name>)<argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>ostream</name><operator>&amp;</operator> <name>stream</name></expr></argument>)</argument_list></call><operator>)</operator> <block>{
<expr><call><name>AppendMessage</name><argument_list>(<argument><expr><call><name>Message</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>basic_manipulator</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>

<function><type><name>void</name></type> <name>AppendMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Message</name><modifier>&amp;</modifier></type> <name>a_message</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>message_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>message_</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><name>new</name> <operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>message_</name><operator>-&gt;</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>a_message</name><operator>.</operator><name>GetString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>AssertionResult</name><modifier>&amp;</modifier></type> <name>other</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>success_</name></decl>;</decl_stmt>




<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>message_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>AssertionSuccess</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>AssertionFailure</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>AssertionFailure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Message</name><modifier>&amp;</modifier></type> <name>msg</name></decl></parameter>)</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt>




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest_pred_impl.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>
























<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>Test</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestInfo</name></decl>;</decl_stmt>



<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name>SetUpTestCaseFunc</name> <name>SetUpTestCaseFunc</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name>TearDownTestCaseFunc</name> <name>TearDownTestCaseFunc</name></expr>;</expr_stmt></typedef>


<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>Test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>







<function><type><specifier>static</specifier> <name>void</name></type> <name>SetUpTestCase</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>TearDownTestCase</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasFatalFailure</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasNonfatalFailure</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsSkipped</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>HasFailure</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>HasFatalFailure</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>HasNonfatalFailure</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>














<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>key</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>key</name></expr></argument>, <argument><expr><name>int</name> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>protected</name>:</label>

<expr_stmt><expr><call><name>Test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>SetUp</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>TearDown</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>HasSameFixtureClass</name><parameter_list>()</parameter_list>;</function_decl>







<function_decl><type><name>virtual</name> <name>void</name></type> <name>TestBody</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>void</name></type> <name>Run</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><name>void</name></type> <name>DeleteSelf_</name><parameter_list>()</parameter_list> <block>{<block_content> <decl_stmt><decl><type><name>delete</name></type> <name>this</name></decl>;</decl_stmt> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt; <argument><expr><name>GTEST_FLAG_SAVER_</name></expr></argument> &gt;</argument_list></name> <name>gtest_flag_saver_</name></expr>;</expr_stmt>

















<struct>struct <name>Setup_should_be_spelled_SetUp</name> <block>{}</block>;</struct>
<function><type><name>virtual</name> <name>Setup_should_be_spelled_SetUp</name><modifier>*</modifier></type> <name>Setup</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>Test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <expr_stmt><expr><name>internal</name><operator>::</operator><name>TimeInMillis</name> <name>TimeInMillis</name></expr>;</expr_stmt></typedef>





<decl_stmt><decl><type><name>class</name></type> <name>TestProperty</name> <block>{<block_content>
<label><name>public</name>:</label>



<expr_stmt><expr><call><name>TestProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>a_key</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>a_value</name></expr></argument>)</argument_list></call> <operator>:</operator>
<call><name>key_</name><argument_list>(<argument><expr><name>a_key</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>value_</name><argument_list>(<argument>a_value</argument>)</argument_list></macro> <expr><block>{
}</block>


<specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>key</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>key_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>value</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>value_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>SetValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>new_value</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>value_</name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>key_</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>value_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>TestResult</name> <block>{<block_content>
<label><name>public</name>:</label>

<expr_stmt><expr><call><name>TestResult</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>~</operator><call><name>TestResult</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>int</name> <macro><name>total_part_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>test_property_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Passed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>Skipped</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Skipped</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Failed</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>HasFatalFailure</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>HasNonfatalFailure</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>TimeInMillis</name> <macro><name>elapsed_time</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>elapsed_time_</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>TestPartResult</name><modifier>&amp;</modifier></type> <name>GetTestPartResult</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>TestProperty</name><modifier>&amp;</modifier></type> <name>GetTestProperty</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UnitTest</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>DefaultGlobalTestPartResultReporter</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>ExecDeathTest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>TestResultAccessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UnitTestImpl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>WindowsDeathTest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>FuchsiaDeathTest</name></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestPartResult</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>test_part_results</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>test_part_results_</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestProperty</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>test_properties</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>test_properties_</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>set_elapsed_time</name><parameter_list>(<parameter><decl><type><name>TimeInMillis</name></type> <name>elapsed</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>elapsed_time_</name> <operator>=</operator> <name>elapsed</name></expr>;</expr_stmt> </block_content>}</block></function>







<decl_stmt><decl><type><name>void</name></type> <name>RecordProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>xml_element</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TestProperty</name><operator>&amp;</operator> <name>test_property</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ValidateTestProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>xml_element</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TestProperty</name><operator>&amp;</operator> <name>test_property</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>AddTestPartResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestPartResult</name><modifier>&amp;</modifier></type> <name>test_part_result</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>int</name> <macro><name>death_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>death_test_count_</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>int</name></type> <name>increment_death_test_count</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>++</operator><name>death_test_count_</name></expr>;</return> </block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>ClearTestPartResults</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>internal</name><operator>::</operator><name>Mutex</name> <name>test_properites_mutex_</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestPartResult</name></expr></argument>&gt;</argument_list></name> <name>test_part_results_</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestProperty</name></expr></argument>&gt;</argument_list></name> <name>test_properties_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>death_test_count_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TimeInMillis</name></type> <name>elapsed_time_</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>












<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>TestInfo</name> <block>{<block_content>
<label><name>public</name>:</label>


<expr_stmt><expr><operator>~</operator><call><name>TestInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>test_case_name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>test_case_name_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>name_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>type_param</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>type_param_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>type_param_</name><operator>-&gt;</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>value_param</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>value_param_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>value_param_</name><operator>-&gt;</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>file</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>location_</name><operator>.</operator><name>file</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>line</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>location_</name><operator>.</operator><name>line</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>is_in_another_shard</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>is_in_another_shard_</name></expr>;</return> }</block></expr></expr_stmt>

















<expr_stmt><expr><name>bool</name> <macro><name>should_run</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>should_run_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>is_reportable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><name>matches_filter_</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_in_another_shard_</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>TestResult</name><operator>*</operator> <macro><name>result</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><name>result_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_DEATH_TEST</name></expr></cpp:if>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>DefaultDeathTestFactory</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Test</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestCase</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UnitTestImpl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>StreamingListenerTest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>TestInfo</name><operator>*</operator> <name>internal</name><operator>::</operator><macro><name>MakeAndRegisterTestInfo</name><argument_list>(
<argument>const char* test_case_name</argument>,
<argument>const char* name</argument>,
<argument>const char* type_param</argument>,
<argument>const char* value_param</argument>,
<argument>internal::CodeLocation code_location</argument>,
<argument>internal::TypeId fixture_class_id</argument>,
<argument>Test::SetUpTestCaseFunc set_up_tc</argument>,
<argument>Test::TearDownTestCaseFunc tear_down_tc</argument>,
<argument>internal::TestFactoryBase* factory</argument>)</argument_list></macro></expr>;</expr_stmt>



<macro><name>TestInfo</name><argument_list>(<argument>const std::string&amp; test_case_name</argument>,
<argument>const std::string&amp; name</argument>,
<argument>const char* a_type_param</argument>,
<argument>const char* a_value_param</argument>,
<argument>internal::CodeLocation a_code_location</argument>,
<argument>internal::TypeId fixture_class_id</argument>,
<argument>internal::TestFactoryBase* factory</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<function><type><name>int</name></type> <name>increment_death_test_count</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>result_</name><operator>.</operator><name>increment_death_test_count</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>Run</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ClearTestResult</name><parameter_list>(<parameter><decl><type><name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>test_info</name><operator>-&gt;</operator><name>result_</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>test_case_name_</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>name_</name></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>type_param_</name></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>value_param_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name>CodeLocation</name> <name>location_</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>TypeId</name> <name>fixture_class_id_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>should_run_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_disabled_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>matches_filter_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_in_another_shard_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name>TestFactoryBase</name><operator>*</operator> <specifier>const</specifier> <name>factory_</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>TestResult</name></type> <name>result_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};




<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>TestCase</name> <block>{<block_content>
<label><name>public</name>:</label>












<macro><name>TestCase</name><argument_list>(<argument>const char* name</argument>, <argument>const char* a_type_param</argument>,
<argument>Test::SetUpTestCaseFunc set_up_tc</argument>,
<argument>Test::TearDownTestCaseFunc tear_down_tc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>TestCase</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>name_</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>type_param</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>type_param_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>type_param_</name><operator>-&gt;</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>should_run</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>should_run_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>successful_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>skipped_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>failed_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>test_to_run_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>total_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Passed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Failed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>failed_test_count</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TimeInMillis</name> <macro><name>elapsed_time</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>elapsed_time_</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>GetTestInfo</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TestResult</name><operator>&amp;</operator> <macro><name>ad_hoc_test_result</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ad_hoc_test_result_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Test</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UnitTestImpl</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>test_info_list</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>test_info_list_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>test_info_list</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>test_info_list_</name></expr>;</return>
}</block></expr></expr_stmt>



<function_decl><type><name>TestInfo</name><modifier>*</modifier></type> <name>GetMutableTestInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>set_should_run</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>should</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>should_run_</name> <operator>=</operator> <name>should</name></expr>;</expr_stmt> </block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>AddTestInfo</name><parameter_list>(<parameter><decl><type><name>TestInfo</name> <modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ClearResult</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ClearTestCaseResult</name><parameter_list>(<parameter><decl><type><name>TestCase</name><modifier>*</modifier></type> <name>test_case</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>test_case</name><operator>-&gt;</operator><name>ClearResult</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>Run</name><parameter_list>()</parameter_list>;</function_decl>



<function><type><name>void</name></type> <name>RunSetUpTestCase</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>set_up_tc_</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>



<function><type><name>void</name></type> <name>RunTearDownTestCase</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call>(<modifier>*</modifier><name>tear_down_tc_</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestPassed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>should_run</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>test_info</name><operator>-&gt;</operator><name>result</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>Passed</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestSkipped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>should_run</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>test_info</name><operator>-&gt;</operator><name>result</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>Skipped</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestFailed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>should_run</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>test_info</name><operator>-&gt;</operator><name>result</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestReportableDisabled</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>is_reportable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>test_info</name><operator>-&gt;</operator><name>is_disabled_</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestDisabled</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>test_info</name><operator>-&gt;</operator><name>is_disabled_</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>TestReportable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>is_reportable</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldRunTest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>*</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>test_info</name><operator>-&gt;</operator><name>should_run</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>void</name></type> <name>ShuffleTests</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>Random</name><operator>*</operator> <name>random</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>UnshuffleTests</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>name_</name></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>type_param_</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>test_info_list_</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>test_indices_</name></expr>;</expr_stmt>

<expr_stmt><expr><name>Test</name><operator>::</operator><name>SetUpTestCaseFunc</name> <name>set_up_tc_</name></expr>;</expr_stmt>

<expr_stmt><expr><name>Test</name><operator>::</operator><name>TearDownTestCaseFunc</name> <name>tear_down_tc_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>should_run_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TimeInMillis</name></type> <name>elapsed_time_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TestResult</name></type> <name>ad_hoc_test_result_</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestCase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};















<decl_stmt><decl><type><name>class</name></type> <name>Environment</name> <block>{<block_content>
<label><name>public</name>:</label>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>Environment</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>SetUp</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <macro><name>TearDown</name><argument_list>()</argument_list></macro> <block>{}</block>
<name>private</name><operator>:</operator>


struct <name>Setup_should_be_spelled_SetUp</name> <block>{}</block></expr>;</expr_stmt>
<function><type><name>virtual</name> <name>Setup_should_be_spelled_SetUp</name><modifier>*</modifier></type> <name>Setup</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>NULL</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_EXCEPTIONS</name></expr></cpp:if>


<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>AssertionException</name>
<range>: <expr><name>public</name> <name>internal</name><operator>::</operator><name>GoogleTestFailureException</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>AssertionException</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TestPartResult</name><operator>&amp;</operator> <name>result</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>GoogleTestFailureException</name><argument_list>(<argument>result</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr></range></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<decl_stmt><decl><type><name>class</name></type> <name>TestEventListener</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>TestEventListener</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <call><name>OnTestProgramStart</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnitTest</name><operator>&amp;</operator> <name>unit_test</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestIterationStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>iteration</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnEnvironmentsSetUpStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnEnvironmentsSetUpEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestCaseStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestCase</name><modifier>&amp;</modifier></type> <name>test_case</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>&amp;</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestPartResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestPartResult</name><modifier>&amp;</modifier></type> <name>test_part_result</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestInfo</name><modifier>&amp;</modifier></type> <name>test_info</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestCaseEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestCase</name><modifier>&amp;</modifier></type> <name>test_case</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnEnvironmentsTearDownStart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnEnvironmentsTearDownEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestIterationEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>iteration</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>void</name></type> <name>OnTestProgramEnd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnitTest</name><modifier>&amp;</modifier></type> <name>unit_test</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>EmptyTestEventListener</name> <range>: <expr><name>public</name> <name>TestEventListener</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <name>void</name> <macro><name>OnTestProgramStart</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestIterationStart</name><argument_list>(<argument>const UnitTest&amp;</argument> ,
<argument>int</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnEnvironmentsSetUpStart</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnEnvironmentsSetUpEnd</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestCaseStart</name><argument_list>(<argument>const TestCase&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestStart</name><argument_list>(<argument>const TestInfo&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestPartResult</name><argument_list>(<argument>const TestPartResult&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestEnd</name><argument_list>(<argument>const TestInfo&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestCaseEnd</name><argument_list>(<argument>const TestCase&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnEnvironmentsTearDownStart</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnEnvironmentsTearDownEnd</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestIterationEnd</name><argument_list>(<argument>const UnitTest&amp;</argument> ,
<argument>int</argument> )</argument_list></macro> <block>{}</block>
<name>virtual</name> <name>void</name> <macro><name>OnTestProgramEnd</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{}</block></expr>
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>TestEventListeners</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TestEventListeners</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>TestEventListeners</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<function_decl><type><name>void</name></type> <name>Append</name><parameter_list>(<parameter><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>Release</name><parameter_list>(<parameter><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>TestEventListener</name><operator>*</operator> <macro><name>default_result_printer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>default_result_printer_</name></expr>;</return>
}</block></expr></expr_stmt>








<expr_stmt><expr><name>TestEventListener</name><operator>*</operator> <macro><name>default_xml_generator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>default_xml_generator_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TestInfo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>DefaultGlobalTestPartResultReporter</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>NoExecDeathTest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>TestEventListenersAccessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UnitTestImpl</name></expr>;</expr_stmt>



<function_decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>repeater</name><parameter_list>()</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>SetDefaultResultPrinter</name><parameter_list>(<parameter><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>SetDefaultXmlGenerator</name><parameter_list>(<parameter><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>listener</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>EventForwardingEnabled</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>SuppressEventForwarding</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>TestEventRepeater</name><operator>*</operator> <name>repeater_</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>default_result_printer_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TestEventListener</name><modifier>*</modifier></type> <name>default_xml_generator_</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestEventListeners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>UnitTest</name> <block>{<block_content>
<label><name>public</name>:</label>



<function_decl><type><specifier>static</specifier> <name>UnitTest</name><modifier>*</modifier></type> <name>GetInstance</name><parameter_list>()</parameter_list>;</function_decl>







<expr_stmt><expr><name>int</name> <macro><name>Run</name><argument_list>()</argument_list></macro> <name>GTEST_MUST_USE_RESULT_</name></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>original_working_dir</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TestCase</name><operator>*</operator> <macro><name>current_test_case</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TestInfo</name><operator>*</operator> <macro><name>current_test_info</name><argument_list>()</argument_list></macro> <specifier>const</specifier>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>random_seed</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>internal</name><operator>::</operator><name>ParameterizedTestCaseRegistry</name><operator>&amp;</operator> <macro><name>parameterized_test_registry</name><argument_list>()</argument_list></macro>
<call><name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>successful_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>failed_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>total_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>int</name> <macro><name>test_case_to_run_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>successful_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>skipped_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>failed_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>total_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>test_to_run_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>TimeInMillis</name> <macro><name>start_timestamp</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>TimeInMillis</name> <macro><name>elapsed_time</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Passed</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>Failed</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>TestCase</name><modifier>*</modifier></type> <name>GetTestCase</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>TestResult</name><operator>&amp;</operator> <macro><name>ad_hoc_test_result</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function_decl><type><name>TestEventListeners</name><modifier>&amp;</modifier></type> <name>listeners</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>









<function_decl><type><name>Environment</name><modifier>*</modifier></type> <name>AddEnvironment</name><parameter_list>(<parameter><decl><type><name>Environment</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>void</name></type> <name>AddTestPartResult</name><argument_list>(<argument><expr><name>TestPartResult</name><operator>::</operator><name>Type</name> <name>result_type</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file_name</name></expr></argument>,
<argument><expr><name>int</name> <name>line_number</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>message</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>os_stack_trace</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>RecordProperty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>key</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>TestCase</name><modifier>*</modifier></type> <name>GetMutableTestCase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>UnitTestImpl</name><operator>*</operator> <macro><name>impl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>impl_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>UnitTestImpl</name><operator>*</operator> <macro><name>impl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>impl_</name></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ScopedTrace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Test</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>AssertHelper</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>StreamingListenerTest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>UnitTestRecordPropertyTestHelper</name></expr>;</expr_stmt>
<function_decl><type><name>friend</name> <name>Environment</name><modifier>*</modifier></type> <name>AddGlobalTestEnvironment</name><parameter_list>(<parameter><decl><type><name>Environment</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>friend</name> <name>internal</name><operator>::</operator><name>UnitTestImpl</name><operator>*</operator> <name>internal</name><operator>::</operator><call><name>GetUnitTestImpl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>void</name> <name>internal</name><operator>::</operator><macro><name>ReportFailureInUnknownLocation</name><argument_list>(
<argument>TestPartResult::Type result_type</argument>,
<argument>const std::string&amp; message</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><call><name>UnitTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>UnitTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>PushGTestTrace</name><argument_list>(<argument><expr><specifier>const</specifier> <name>internal</name><operator>::</operator><name>TraceInfo</name><operator>&amp;</operator> <name>trace</name></expr></argument>)</argument_list>
<name>GTEST_LOCK_EXCLUDED_</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>PopGTestTrace</name><parameter_list>()</parameter_list>
GTEST_LOCK_EXCLUDED_<parameter_list>(<parameter><decl><type><name>mutex_</name></type></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>mutable</name> <name>internal</name><operator>::</operator><name>Mutex</name> <name>mutex_</name></expr>;</expr_stmt>





<expr_stmt><expr><name>internal</name><operator>::</operator><name>UnitTestImpl</name><operator>*</operator> <name>impl_</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>UnitTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



















<function><type><specifier>inline</specifier> <name>Environment</name><modifier>*</modifier></type> <name>AddGlobalTestEnvironment</name><parameter_list>(<parameter><decl><type><name>Environment</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>UnitTest</name><operator>::</operator><call><name>GetInstance</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>AddEnvironment</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>InitGoogleTest</name><parameter_list>(<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>InitGoogleTest</name><parameter_list>(<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>AssertionResult</name></type> <name>CmpHelperEQFailure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T1</name><modifier>&amp;</modifier></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T2</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>EqFailure</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>,
<argument><expr><name>rhs_expression</name></expr></argument>,
<argument><expr><call><name>FormatForComparisonFailureMessage</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>FormatForComparisonFailureMessage</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>AssertionResult</name></type> <name>CmpHelperEQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T1</name><modifier>&amp;</modifier></type> <name>lhs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T2</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>AssertionSuccess</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>CmpHelperEQFailure</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>, <argument><expr><name>rhs_expression</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperEQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><name>BiggestInt</name></type> <name>lhs</name></decl></parameter>,
<parameter><decl><type><name>BiggestInt</name></type> <name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>lhs_is_null_literal</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>EqHelper</name> <block>{<block_content>
<label><name>public</name>:</label>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>AssertionResult</name></type> <name>Compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T1</name><modifier>&amp;</modifier></type> <name>lhs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T2</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>CmpHelperEQ</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>, <argument><expr><name>rhs_expression</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>AssertionResult</name></type> <name>Compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><name>BiggestInt</name></type> <name>lhs</name></decl></parameter>,
<parameter><decl><type><name>BiggestInt</name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>CmpHelperEQ</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>, <argument><expr><name>rhs_expression</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>class</name></type> <name><name>EqHelper</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>AssertionResult</name></type> <name>Compare</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>lhs_expression</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>rhs_expression</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>T1</name><operator>&amp;</operator> <name>lhs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>T2</name><operator>&amp;</operator> <name>rhs</name></expr></argument>,





<argument><expr><name>typename</name> <name><name>EnableIf</name><argument_list type="generic">&lt;<argument><expr><operator>!</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name><operator>*</operator> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>CmpHelperEQ</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>, <argument><expr><name>rhs_expression</name></expr></argument>, <argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>AssertionResult</name></type> <name>Compare</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,






<parameter><decl><type><name>Secret</name><modifier>*</modifier></type></decl></parameter> ,
<parameter><decl><type><name>T</name><modifier>*</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>CmpHelperEQ</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>, <argument><expr><name>rhs_expression</name></expr></argument>,
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>AssertionResult</name></type> <name>CmpHelperOpFailure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>T1</name><modifier>&amp;</modifier></type> <name>val1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T2</name><modifier>&amp;</modifier></type> <name>val2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>AssertionFailure</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Expected: ("</literal> <operator>&lt;&lt;</operator> <name>expr1</name> <operator>&lt;&lt;</operator> <literal type="string">") "</literal> <operator>&lt;&lt;</operator> <name>op</name> <operator>&lt;&lt;</operator> <literal type="string">" ("</literal> <operator>&lt;&lt;</operator> <name>expr2</name>
<operator>&lt;&lt;</operator> <literal type="string">"), actual: "</literal> <operator>&lt;&lt;</operator> <call><name>FormatForComparisonFailureMessage</name><argument_list>(<argument><expr><name>val1</name></expr></argument>, <argument><expr><name>val2</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">" vs "</literal> <operator>&lt;&lt;</operator> <call><name>FormatForComparisonFailureMessage</name><argument_list>(<argument><expr><name>val2</name></expr></argument>, <argument><expr><name>val1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_IMPL_CMP_HELPER_</name><parameter_list>(<parameter><type><name>op_name</name></type></parameter>, <parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>template &lt;typename T1, typename T2&gt;AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, const T1&amp; val1, const T2&amp; val2) {if (val1 op val2) {return AssertionSuccess();} else {return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);}}GTEST_API_ AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)</cpp:value></cpp:define>















<expr_stmt><expr><call><name>GTEST_IMPL_CMP_HELPER_</name><argument_list>(<argument><expr><name>NE</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_IMPL_CMP_HELPER_</name><argument_list>(<argument><expr><name>LE</name></expr></argument>, <argument><expr><operator>&lt;=</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_IMPL_CMP_HELPER_</name><argument_list>(<argument><expr><name>LT</name></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_IMPL_CMP_HELPER_</name><argument_list>(<argument><expr><name>GE</name></expr></argument>, <argument><expr><operator>&gt;=</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_IMPL_CMP_HELPER_</name><argument_list>(<argument><expr><name>GT</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GTEST_IMPL_CMP_HELPER_</name></cpp:undef>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTREQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTRCASEEQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTRNE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTRCASENE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTREQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>CmpHelperSTRNE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s1_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s2_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>)</parameter_list>;</function_decl>

</block_content>}</block></decl></decl_stmt>









<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsSubstring</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle_expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack_expr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsSubstring</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle_expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack_expr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>needle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>haystack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsNotSubstring</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle_expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack_expr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsNotSubstring</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>needle_expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>haystack_expr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>needle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name><modifier>*</modifier></type> <name>haystack</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsSubstring</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>needle_expr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>haystack_expr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>needle</name></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>haystack</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsNotSubstring</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>needle_expr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>haystack_expr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>needle</name></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>haystack</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_STD_WSTRING</name></expr></cpp:if>
<decl_stmt><decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsSubstring</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>needle_expr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>haystack_expr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>needle</name></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>haystack</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>IsNotSubstring</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>needle_expr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>haystack_expr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>needle</name></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>wstring</name><operator>&amp;</operator> <name>haystack</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>








<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RawType</name></expr></argument>&gt;</argument_list></name>
<name>AssertionResult</name></type> <name>CmpHelperFloatingPointEQ</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>lhs_expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>rhs_expression</name></decl></parameter>,
<parameter><decl><type><name>RawType</name></type> <name>lhs_value</name></decl></parameter>,
<parameter><decl><type><name>RawType</name></type> <name>rhs_value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>RawType</name></expr></argument>&gt;</argument_list></name></type> <name>lhs</name><argument_list>(<argument><expr><name>lhs_value</name></expr></argument>)</argument_list></decl>, <decl><type ref="prev"/><name>rhs</name><argument_list>(<argument><expr><name>rhs_value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>lhs</name><operator>.</operator><name>AlmostEquals</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>AssertionSuccess</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>lhs_ss</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lhs_ss</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><call><name>setprecision</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>RawType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>digits10</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>lhs_value</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name>stringstream</name> <name>rhs_ss</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rhs_ss</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><call><name>setprecision</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>RawType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>digits10</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>rhs_value</name></expr>;</expr_stmt>

<return>return <expr><call><name>EqFailure</name><argument_list>(<argument><expr><name>lhs_expression</name></expr></argument>,
<argument><expr><name>rhs_expression</name></expr></argument>,
<argument><expr><call><name>StringStreamToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhs_ss</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>StringStreamToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhs_ss</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>DoubleNearPredFormat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr2</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>abs_error_expr</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>val1</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>val2</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>abs_error</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>AssertHelper</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>AssertHelper</name><argument_list>(<argument>TestPartResult::Type type</argument>,
<argument>const char* file</argument>,
<argument>int line</argument>,
<argument>const char* message</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>AssertHelper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>Message</name><operator>&amp;</operator> <name>message</name><operator>)</operator> <specifier>const</specifier></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>




<struct>struct <name>AssertHelperData</name> <block>{
<macro><name>AssertHelperData</name><argument_list>(<argument>TestPartResult::Type t</argument>,
<argument>const char* srcfile</argument>,
<argument>int line_num</argument>,
<argument>const char* msg</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>type</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>file</name><argument_list>(<argument><expr><name>srcfile</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>line</name><argument_list>(<argument><expr><name>line_num</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>message</name><argument_list>(<argument>msg</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>TestPartResult</name><operator>::</operator><name>Type</name> <specifier>const</specifier> <name>type</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>line</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <specifier>const</specifier> <name>message</name></expr>;</expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>AssertHelperData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>AssertHelperData</name><modifier>*</modifier> <specifier>const</specifier></type> <name>data_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>AssertHelper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>



































<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>WithParamInterface</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name>T</name></type> <name>ParamType</name>;</typedef>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>WithParamInterface</name><argument_list>()</argument_list></macro> <block>{}</block>






<specifier>const</specifier> <name>ParamType</name><operator>&amp;</operator> <macro><name>GetParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>parameter_</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"GetParam() can only be called inside a value-parameterized test "</literal>
<operator>&lt;&lt;</operator> <literal type="string">"-- did you intend to write TEST_P instead of TEST_F?"</literal></expr>;
<return>return <expr><operator>*</operator><name>parameter_</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SetParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParamType</name><modifier>*</modifier></type> <name>parameter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>parameter_</name> <operator>=</operator> <name>parameter</name></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ParamType</name><modifier>*</modifier></type> <name>parameter_</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TestClass</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>internal</name><operator>::</operator><name>ParameterizedTestFactory</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>T</name><operator>*</operator> <name><name>WithParamInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>parameter_</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TestWithParam</name> <range>: <expr><name>public</name> <name>Test</name></expr></range></decl>, <decl><type ref="prev"/><name>public</name> <name><name>WithParamInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SKIP</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_SKIP_("Skipped")</cpp:value></cpp:define>



















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_FAILURE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_NONFATAL_FAILURE_("Failed")</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_FAILURE_AT</name><parameter_list>(<parameter><type><name>file</name></type></parameter>, <parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_MESSAGE_AT_(file, line, "Failed", ::testing::TestPartResult::kNonFatalFailure)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_FAIL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_FATAL_FAILURE_("Failed")</cpp:value></cpp:define>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_FAIL</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAIL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_FAIL()</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SUCCEED</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_SUCCESS_("Succeeded")</cpp:value></cpp:define>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_SUCCEED</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUCCEED</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>GTEST_SUCCEED()</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>expected_exception</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NO_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_ANY_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>expected_exception</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_NO_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_ANY_THROW</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_TRUE</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_FALSE</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_TRUE</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_BOOLEAN_(condition, #condition, false, true, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_FALSE</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>

















































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal:: EqHelper&lt;GTEST_IS_NULL_LITERAL_(val1)&gt;::Compare, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_LE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_LT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_GE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_GT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal:: EqHelper&lt;GTEST_IS_NULL_LITERAL_(val1)&gt;::Compare, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_NE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_LE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_LT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_GE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_ASSERT_GT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_EQ</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_EQ(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_NE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_NE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_NE(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_LE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_LE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_LE(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_LT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_LT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_LT(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_GE</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_GE</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_GE(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_ASSERT_GT</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_GT</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_ASSERT_GT(val1, val2)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_STREQ</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_STRNE</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_STRCASEEQ</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_STRCASENE</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_STREQ</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_STRNE</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_STRCASEEQ</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, s1, s2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_STRCASENE</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</cpp:value></cpp:define>
















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_FLOAT_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_DOUBLE_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_FLOAT_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_DOUBLE_EQ</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, val1, val2)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NEAR</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>, <parameter><type><name>abs_error</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, abs_error)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_NEAR</name><parameter_list>(<parameter><type><name>val1</name></type></parameter>, <parameter><type><name>val2</name></type></parameter>, <parameter><type><name>abs_error</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, val1, val2, abs_error)</cpp:value></cpp:define>










<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>FloatLE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr2</name></decl></parameter>,
<parameter><decl><type><name>float</name></type> <name>val1</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>val2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>DoubleLE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>expr2</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>val1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val2</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_WINDOWS</name></expr></cpp:if>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_HRESULT_SUCCEEDED</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_HRESULT_SUCCEEDED</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_HRESULT_FAILED</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_HRESULT_FAILED</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_NO_FATAL_FAILURE</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_NO_FATAL_FAILURE</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)</cpp:value></cpp:define>












<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>ScopedTrace</name> <block>{<block_content>
<label><name>public</name>:</label>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name></type>
<name>ScopedTrace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>PushTrace</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>(</operator><call><name>Message</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>message</name><operator>)</operator><operator>.</operator><call><name>GetString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>ScopedTrace</name><argument_list>(<argument>const char* file</argument>, <argument>int line</argument>, <argument>const char* message</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>PushTrace</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_GLOBAL_STRING</name></expr></cpp:if>
<macro><name>ScopedTrace</name><argument_list>(<argument>const char* file</argument>, <argument>int line</argument>, <argument>const ::string&amp; message</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>PushTrace</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>ScopedTrace</name><argument_list>(<argument>const char* file</argument>, <argument>int line</argument>, <argument>const std::string&amp; message</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>PushTrace</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>





<expr_stmt><expr><operator>~</operator><call><name>ScopedTrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>PushTrace</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file</name></expr></argument>, <argument><expr><name>int</name> <name>line</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <name>message</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ScopedTrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt> <expr_stmt><expr><name>GTEST_ATTRIBUTE_UNUSED_</name></expr>;</expr_stmt>


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCOPED_TRACE</name><parameter_list>(<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>::testing::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(__FILE__, __LINE__, (message))</cpp:value></cpp:define>


































<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T1</name></expr></argument>, <argument><expr><name>typename</name> <name>T2</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>StaticAssertTypeEq</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>internal</name><operator>::</operator><call><name><name>StaticAssertTypeEqHelper</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST</name><parameter_list>(<parameter><type><name>test_case_name</name></type></parameter>, <parameter><type><name>test_name</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>GTEST_TEST_(test_case_name, test_name, ::testing::Test, ::testing::internal::GetTestTypeId())</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>GTEST_DONT_DEFINE_TEST</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>test_case_name</name></type></parameter>, <parameter><type><name>test_name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_TEST(test_case_name, test_name)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_F</name><parameter_list>(<parameter><type><name>test_fixture</name></type></parameter>, <parameter><type><name>test_name</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>GTEST_TEST_(test_fixture, test_name, test_fixture, ::testing::internal::GetTypeId&lt;test_fixture&gt;())</cpp:value></cpp:define>





<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>TempDir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}









int <macro><name>RUN_ALL_TESTS</name><argument_list>()</argument_list></macro> <expr_stmt><expr><name>GTEST_MUST_USE_RESULT_</name></expr>;</expr_stmt>

<function><type><specifier>inline</specifier> <name>int</name></type> <name>RUN_ALL_TESTS</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>::</operator><name>testing</name><operator>::</operator><name>UnitTest</name><operator>::</operator><call><name>GetInstance</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>Run</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
