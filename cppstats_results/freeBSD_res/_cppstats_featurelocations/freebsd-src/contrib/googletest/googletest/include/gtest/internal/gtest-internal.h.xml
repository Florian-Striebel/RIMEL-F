<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googletest/include/gtest/internal/gtest-internal.h">



































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-port.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_LINUX</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_EXCEPTIONS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdexcept&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iomanip&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-message.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-filepath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-type-util.h"</cpp:file></cpp:include>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_CONCAT_TOKEN_</name><parameter_list>(<parameter><type><name>foo</name></type></parameter>, <parameter><type><name>bar</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_CONCAT_TOKEN_IMPL_(foo, bar)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_CONCAT_TOKEN_IMPL_</name><parameter_list>(<parameter><type><name>foo</name></type></parameter>, <parameter><type><name>bar</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>foo ##bar</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_STRINGIFY_</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#name</cpp:value></cpp:define>

<decl_stmt><decl><type><name>class</name></type> <name>ProtocolMessage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>namespace</name></type> <name>proto2</name> <block>{<block_content> <decl_stmt><decl><type><name>class</name></type> <name>Message</name></decl>;</decl_stmt> </block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>AssertionResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Test</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TestPartResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnitTest</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<operator>::</operator><name>std</name><operator>::</operator><name>string</name> <call><name>PrintToString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>

<struct_decl>struct <name>TraceInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>TestInfoImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnitTestImpl</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GTEST_API_</name> <specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>kStackTraceMarker</name><index>[]</index></name></decl>;</decl_stmt>















<function_decl><type><name>char</name></type> <name>IsNullLiteralHelper</name><parameter_list>(<parameter><decl><type><name>Secret</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>char</name> <argument_list>(<argument><expr><operator>&amp;</operator><call><name>IsNullLiteralHelper</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GTEST_ELLIPSIS_NEEDS_POD_</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_IS_NULL_LITERAL_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>false</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_IS_NULL_LITERAL_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(::testing::internal::IsNullLiteralHelper(x)) == 1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>AppendUserMessage</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>gtest_msg</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Message</name><operator>&amp;</operator> <name>user_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_EXCEPTIONS</name></expr></cpp:if>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4275</literal></argument> \
)</argument_list></macro>







<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>GoogleTestFailureException</name> <range>: <expr><name>public</name> <operator>::</operator><name>std</name><operator>::</operator><name>runtime_error</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>GoogleTestFailureException</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TestPartResult</name><operator>&amp;</operator> <name>failure</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>edit_distance</name> <block>{<block_content>





<enum>enum <name>EditType</name> <block>{ <decl><name>kMatch</name></decl>, <decl><name>kAdd</name></decl>, <decl><name>kRemove</name></decl>, <decl><name>kReplace</name></decl> }</block>;</enum>
<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EditType</name></expr></argument>&gt;</argument_list></name> <call><name>CalculateOptimalEdits</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>left</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EditType</name></expr></argument>&gt;</argument_list></name> <call><name>CalculateOptimalEdits</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>left</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>CreateUnifiedDiff</name><argument_list>(<argument>const std::vector&lt;std::string&gt;&amp; left</argument>,
<argument>const std::vector&lt;std::string&gt;&amp; right</argument>,
<argument>size_t context = <literal type="number">2</literal></argument>)</argument_list></macro></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>





<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>DiffStrings</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>left</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>right</name></expr></argument>,
<argument><expr><name>size_t</name><operator>*</operator> <name>total_line_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
















<decl_stmt><decl><type><name>GTEST_API_</name> <name>AssertionResult</name></type> <name>EqFailure</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>expected_expression</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>actual_expression</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>expected_value</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>actual_value</name></expr></argument>,
<argument><expr><name>bool</name> <name>ignoring_case</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>GetBoolAssertionFailureMessage</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>AssertionResult</name><operator>&amp;</operator> <name>assertion_result</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>expression_text</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>actual_predicate_value</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>expected_predicate_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






























<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RawType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>FloatingPoint</name> <block>{<block_content>
<label><name>public</name>:</label>


<typedef>typedef <expr_stmt><expr><name>typename</name> <name>TypeWithSize</name><operator>&lt;</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RawType</name></expr></argument>)</argument_list></sizeof><operator>&gt;</operator><operator>::</operator><name>UInt</name> <name>Bits</name></expr>;</expr_stmt></typedef>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kBitCount</name> <init>= <expr><literal type="number">8</literal><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>RawType</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kFractionBitCount</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>RawType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>digits</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kExponentBitCount</name> <init>= <expr><name>kBitCount</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>kFractionBitCount</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Bits</name></type> <name>kSignBitMask</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Bits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><name>kBitCount</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Bits</name></type> <name>kFractionBitMask</name> <init>=
<expr><operator>~</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Bits</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><name>kExponentBitCount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Bits</name></type> <name>kExponentBitMask</name> <init>= <expr><operator>~</operator><operator>(</operator><name>kSignBitMask</name> <operator>|</operator> <name>kFractionBitMask</name><operator>)</operator></expr></init></decl>;</decl_stmt>













<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>kMaxUlps</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>







<function><type><name>explicit</name></type> <name>FloatingPoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RawType</name><modifier>&amp;</modifier></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>u_</name><operator>.</operator><name>value_</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt> </block_content>}</block></function>






<function><type><specifier>static</specifier> <name>RawType</name></type> <name>ReinterpretBits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bits</name></type> <name>bits</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FloatingPoint</name></type> <name>fp</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fp</name><operator>.</operator><name>u_</name><operator>.</operator><name>bits_</name></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>
<return>return <expr><name><name>fp</name><operator>.</operator><name>u_</name><operator>.</operator><name>value_</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>RawType</name></type> <name>Infinity</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ReinterpretBits</name><argument_list>(<argument><expr><name>kExponentBitMask</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>RawType</name></type> <name>Max</name><parameter_list>()</parameter_list>;</function_decl>




<expr_stmt><expr><specifier>const</specifier> <name>Bits</name> <operator>&amp;</operator><macro><name>bits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>u_</name><operator>.</operator><name>bits_</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>Bits</name> <macro><name>exponent_bits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>kExponentBitMask</name> <operator>&amp;</operator> <name><name>u_</name><operator>.</operator><name>bits_</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>Bits</name> <macro><name>fraction_bits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>kFractionBitMask</name> <operator>&amp;</operator> <name><name>u_</name><operator>.</operator><name>bits_</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>Bits</name> <macro><name>sign_bit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>kSignBitMask</name> <operator>&amp;</operator> <name><name>u_</name><operator>.</operator><name>bits_</name></name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>is_nan</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><operator>(</operator><call><name>exponent_bits</name><argument_list>()</argument_list></call> <operator>==</operator> <name>kExponentBitMask</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>fraction_bits</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>AlmostEquals</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FloatingPoint</name><operator>&amp;</operator> <name>rhs</name></expr></argument>)</argument_list> const <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>is_nan</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>rhs</name><operator>.</operator><name>is_nan</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>DistanceBetweenSignAndMagnitudeNumbers</name><argument_list>(<argument><expr><name><name>u_</name><operator>.</operator><name>bits_</name></name></expr></argument>, <argument><expr><name><name>rhs</name><operator>.</operator><name>u_</name><operator>.</operator><name>bits_</name></name></expr></argument>)</argument_list></call>
<operator>&lt;=</operator> <name>kMaxUlps</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>

<union>union <name>FloatingPointUnion</name> <block>{
<decl_stmt><decl><type><name>RawType</name></type> <name>value_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bits</name></type> <name>bits_</name></decl>;</decl_stmt>
}</block>;</union>
















<function><type><specifier>static</specifier> <name>Bits</name></type> <name>SignAndMagnitudeToBiased</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bits</name> <modifier>&amp;</modifier></type><name>sam</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>kSignBitMask</name> <operator>&amp;</operator> <name>sam</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>~</operator><name>sam</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>kSignBitMask</name> <operator>|</operator> <name>sam</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>Bits</name></type> <name>DistanceBetweenSignAndMagnitudeNumbers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bits</name> <modifier>&amp;</modifier></type><name>sam1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Bits</name> <modifier>&amp;</modifier></type><name>sam2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bits</name></type> <name>biased1</name> <init>= <expr><call><name>SignAndMagnitudeToBiased</name><argument_list>(<argument><expr><name>sam1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Bits</name></type> <name>biased2</name> <init>= <expr><call><name>SignAndMagnitudeToBiased</name><argument_list>(<argument><expr><name>sam2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>biased1</name> <operator>&gt;=</operator> <name>biased2</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>biased1</name> <operator>-</operator> <name>biased2</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>biased2</name> <operator>-</operator> <name>biased1</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>FloatingPointUnion</name></type> <name>u_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>float</name> <name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>Max</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>FLT_MAX</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>double</name> <name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>Max</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>DBL_MAX</name></expr>;</return> }</block></expr></expr_stmt>



<typedef>typedef <type><name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>float</name></expr></argument>&gt;</argument_list></name></type> <name>Float</name>;</typedef>
<typedef>typedef <type><name><name>FloatingPoint</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name></type> <name>Double</name>;</typedef>







<typedef>typedef <type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>TypeId</name>;</typedef>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TypeIdHelper</name> <block>{<block_content>
<label><name>public</name>:</label>



<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>dummy_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>TypeIdHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>dummy_</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>TypeId</name></type> <name>GetTypeId</name><parameter_list>()</parameter_list> <block>{<block_content>




<return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>TypeIdHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>dummy_</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>GTEST_API_</name> <name>TypeId</name></type> <name>GetTestTypeId</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>TestFactoryBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>TestFactoryBase</name><argument_list>()</argument_list></macro> <block>{}</block>



<name>virtual</name> <name>Test</name><operator>*</operator> <call><name>CreateTest</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<macro><name>TestFactoryBase</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestFactoryBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TestClass</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TestFactoryImpl</name> <range>: <expr><name>public</name> <name>TestFactoryBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <name>Test</name><operator>*</operator> <macro><name>CreateTest</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>new</name> <name>TestClass</name></expr>;</return> }</block>
}</expr>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_WINDOWS</name></expr></cpp:if>





<expr><name>GTEST_API_</name> <name>AssertionResult</name> <macro><name>IsHRESULTSuccess</name><argument_list>(<argument>const char* expr</argument>,
<argument>long hr</argument>)</argument_list></macro></expr>;
<expr><name>GTEST_API_</name> <name>AssertionResult</name> <macro><name>IsHRESULTFailure</name><argument_list>(<argument>const char* expr</argument>,
<argument>long hr</argument>)</argument_list></macro></expr>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>SetUpTestCaseFunc</name>)<parameter_list>()</parameter_list>;</function_decl></typedef></block></expr></range></decl></decl_stmt>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>TearDownTestCaseFunc</name>)<parameter_list>()</parameter_list>;</function_decl></typedef>

<struct>struct <name>CodeLocation</name> <block>{
<macro><name>CodeLocation</name><argument_list>(<argument>const std::string&amp; a_file</argument>, <argument>int a_line</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>file</name><argument_list>(<argument><expr><name>a_file</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>line</name><argument_list>(<argument>a_line</argument>)</argument_list></macro> <expr><block>{}</block>

<name>std</name><operator>::</operator><name>string</name> <name>file</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
}</block>;</struct>



















<function_decl><type><name>GTEST_API_</name> <name>TestInfo</name><modifier>*</modifier></type> <name>MakeAndRegisterTestInfo</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>test_case_name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>type_param</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>value_param</name></decl></parameter>,
<parameter><decl><type><name>CodeLocation</name></type> <name>code_location</name></decl></parameter>,
<parameter><decl><type><name>TypeId</name></type> <name>fixture_class_id</name></decl></parameter>,
<parameter><decl><type><name>SetUpTestCaseFunc</name></type> <name>set_up_tc</name></decl></parameter>,
<parameter><decl><type><name>TearDownTestCaseFunc</name></type> <name>tear_down_tc</name></decl></parameter>,
<parameter><decl><type><name>TestFactoryBase</name><modifier>*</modifier></type> <name>factory</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>SkipPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>pstr</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_TYPED_TEST</name> <operator>||</operator> <name>GTEST_HAS_TYPED_TEST_P</name></expr></cpp:if>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4251</literal></argument> \
)</argument_list></macro>


<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>TypedTestCasePState</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TypedTestCasePState</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>registered_</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>




<name>bool</name> <macro><name>AddTestName</name><argument_list>(<argument>const char* file</argument>, <argument>int line</argument>, <argument>const char* case_name</argument>,
<argument>const char* test_name</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>registered_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s Test %s must be defined before "</literal>
<literal type="string">"REGISTER_TYPED_TEST_CASE_P(%s, ...).\n"</literal></expr></argument>,
<argument><expr><call><name>FormatFileLocation</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>test_name</name></expr></argument>, <argument><expr><name>case_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>posix</name><operator>::</operator><call><name>Abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
registered_tests_.insert(
::std::make_pair(test_name</block><operator>,</operator> <expr_stmt><expr><call><name>CodeLocation</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></expr_stmt></if></if_stmt>))</block></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>TestExists</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>test_name</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>registered_tests_</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>test_name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>CodeLocation</name><modifier>&amp;</modifier></type> <name>GetCodeLocation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>test_name</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>RegisteredTestsMap</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>registered_tests_</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>test_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>it</name> <operator>!=</operator> <call><name><name>registered_tests_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>it</name><operator>-&gt;</operator><name>second</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function_decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>VerifyRegisteredTestNames</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>registered_tests</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>CodeLocation</name></expr></argument>&gt;</argument_list></name> <name>RegisteredTestsMap</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>bool</name></type> <name>registered_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RegisteredTestsMap</name></type> <name>registered_tests_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>



<function><type><specifier>inline</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>SkipComma</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>comma</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>comma</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>++</operator><name>comma</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content/>}</block></while>
<return>return <expr><name>comma</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><specifier>inline</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetPrefixUntilComma</name><argument_list>(<argument>const char* str</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>comma</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><name>comma</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>str</name></expr> </then><else>: <expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>SplitString</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>, <argument><expr><name>char</name> <name>delimiter</name></expr></argument>,
<argument><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt; <argument><expr><operator>::</operator><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>dest</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<struct>struct <name>DefaultNameGenerator</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetName</name><argument_list>(<argument>int i</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>StreamableToString</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Provided</name> <operator>=</operator> <name>DefaultNameGenerator</name><operator>&gt;</operator>
struct <name>NameGeneratorSelector</name> <block>{
<typedef>typedef <type><name>Provided</name></type> <name>type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NameGenerator</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>GenerateNamesRecursively</name><argument_list>(<argument><expr><name>Types0</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NameGenerator</name></expr></argument>, <argument><expr><name>typename</name> <name>Types</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>GenerateNamesRecursively</name><argument_list>(<argument><expr><name>Types</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>result</name></expr></argument>, <argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> <block>{<block_content>
<macro><name>result</name></macro><expr_stmt><expr><operator>-&gt;</operator><macro><name>push_back</name><argument_list>(<argument>NameGenerator::template GetName&lt;typename Types::Head&gt;(i)</argument>)</argument_list></macro></expr>;</expr_stmt>
<macro><name>GenerateNamesRecursively</name></macro><expr_stmt><expr><operator>&lt;</operator><name>NameGenerator</name><operator>&gt;</operator><operator>(</operator><name>typename</name> <name>Types</name><operator>::</operator><call><name>Tail</name><argument_list>()</argument_list></call><operator>,</operator> <name>result</name><operator>,</operator>
<name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NameGenerator</name></expr></argument>, <argument><expr><name>typename</name> <name>Types</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>GenerateNames</name><argument_list>()</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>result</name></expr>;
<expr><call><name><name>GenerateNamesRecursively</name><argument_list type="generic">&lt;<argument><expr><name>NameGenerator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>Types</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>result</name></expr>;</return>
}</block></expr></expr_stmt>








<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>GTEST_TEMPLATE_</name> <name>Fixture</name></expr></argument>, <argument><expr><name>class</name> <name>TestSel</name></expr></argument>, <argument><expr><name>typename</name> <name>Types</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TypeParameterizedTest</name> <block>{<block_content>
<label><name>public</name>:</label>




<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Register</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>prefix</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CodeLocation</name><operator>&amp;</operator> <name>code_location</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>case_name</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>test_names</name></expr></argument>, <argument><expr><name>int</name> <name>index</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>type_names</name> <operator>=</operator>
<call><name><name>GenerateNames</name><argument_list type="generic">&lt;<argument><expr><name>DefaultNameGenerator</name></expr></argument>, <argument><expr><name>Types</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>Types</name><operator>::</operator><name>Head</name> <name>Type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name><name>Fixture</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name></type> <name>FixtureClass</name>;</typedef>
<typedef>typedef <type><name>typename</name></type> <name>GTEST_BIND_</name><argument_list>(<argument><expr><name>TestSel</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list> <name>TestClass</name>;</typedef>



<macro><name>MakeAndRegisterTestInfo</name><argument_list>(
<argument>(std::string(prefix) + (prefix[<literal type="number">0</literal>] == <literal type="char">'\0'</literal> ? <literal type="string">""</literal> : <literal type="string">"/"</literal>) + case_name +
<literal type="string">"/"</literal> + type_names[index])
.c_str()</argument>,
<argument>StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str()</argument>,
<argument>GetTypeName&lt;Type&gt;().c_str()</argument>,
<argument>NULL</argument>,
<argument>code_location</argument>, <argument>GetTypeId&lt;FixtureClass&gt;()</argument>, <argument>TestClass::SetUpTestCase</argument>,
<argument>TestClass::TearDownTestCase</argument>, <argument>new TestFactoryImpl&lt;TestClass&gt;</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<return>return <expr><name><name>TypeParameterizedTest</name><argument_list type="generic">&lt;<argument><expr><name>Fixture</name></expr></argument>, <argument><expr><name>TestSel</name></expr></argument>,
<argument><expr><name>typename</name> <name>Types</name><operator>::</operator><name>Tail</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Register</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>,
<argument><expr><name>code_location</name></expr></argument>,
<argument><expr><name>case_name</name></expr></argument>,
<argument><expr><name>test_names</name></expr></argument>,
<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>type_names</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>GTEST_TEMPLATE_</name> <name>Fixture</name></expr></argument>, <argument><expr><name>class</name> <name>TestSel</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TypeParameterizedTest</name><argument_list type="generic">&lt;<argument><expr><name>Fixture</name></expr></argument>, <argument><expr><name>TestSel</name></expr></argument>, <argument><expr><name>Types0</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Register</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> , <argument><expr><specifier>const</specifier> <name>CodeLocation</name><operator>&amp;</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> , <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> ,
<argument><expr><name>int</name></expr></argument> ,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <operator>=</operator>
<name>std</name><operator>::</operator><call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument> )</argument_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>GTEST_TEMPLATE_</name> <name>Fixture</name></expr></argument>, <argument><expr><name>typename</name> <name>Tests</name></expr></argument>, <argument><expr><name>typename</name> <name>Types</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TypeParameterizedTestCase</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Register</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>prefix</name></expr></argument>, <argument><expr><name>CodeLocation</name> <name>code_location</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TypedTestCasePState</name><operator>*</operator> <name>state</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>case_name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>test_names</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>type_names</name> <operator>=</operator>
<call><name><name>GenerateNames</name><argument_list type="generic">&lt;<argument><expr><name>DefaultNameGenerator</name></expr></argument>, <argument><expr><name>Types</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>test_name</name> <operator>=</operator> <call><name>StripTrailingSpaces</name><argument_list>(
<argument><expr><call><name>GetPrefixUntilComma</name><argument_list>(<argument><expr><name>test_names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>state</name><operator>-&gt;</operator><name>TestExists</name></name><argument_list>(<argument><expr><name>test_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to get code location for test %s.%s at %s."</literal></expr></argument>,
<argument><expr><name>case_name</name></expr></argument>, <argument><expr><call><name><name>test_name</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>FormatFileLocation</name><argument_list>(<argument><expr><call><name><name>code_location</name><operator>.</operator><name>file</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>code_location</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>posix</name><operator>::</operator><call><name>Abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>CodeLocation</name><modifier>&amp;</modifier></type> <name>test_location</name> <init>= <expr><call><name><name>state</name><operator>-&gt;</operator><name>GetCodeLocation</name></name><argument_list>(<argument><expr><name>test_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>typename</name> <name>Tests</name><operator>::</operator><name>Head</name> <name>Head</name></expr>;</expr_stmt></typedef>


<expr_stmt><expr><name><name>TypeParameterizedTest</name><argument_list type="generic">&lt;<argument><expr><name>Fixture</name></expr></argument>, <argument><expr><name>Head</name></expr></argument>, <argument><expr><name>Types</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Register</name><argument_list>(
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>test_location</name></expr></argument>, <argument><expr><name>case_name</name></expr></argument>, <argument><expr><name>test_names</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>type_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><name><name>TypeParameterizedTestCase</name><argument_list type="generic">&lt;<argument><expr><name>Fixture</name></expr></argument>, <argument><expr><name>typename</name> <name>Tests</name><operator>::</operator><name>Tail</name></expr></argument>,
<argument><expr><name>Types</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Register</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>code_location</name></expr></argument>,
<argument><expr><name>state</name></expr></argument>, <argument><expr><name>case_name</name></expr></argument>,
<argument><expr><call><name>SkipComma</name><argument_list>(<argument><expr><name>test_names</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>type_names</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>GTEST_TEMPLATE_</name> <name>Fixture</name></expr></argument>, <argument><expr><name>typename</name> <name>Types</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>TypeParameterizedTestCase</name><argument_list type="generic">&lt;<argument><expr><name>Fixture</name></expr></argument>, <argument><expr><name>Templates0</name></expr></argument>, <argument><expr><name>Types</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>Register</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> , <argument><expr><specifier>const</specifier> <name>CodeLocation</name><operator>&amp;</operator></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TypedTestCasePState</name><operator>*</operator></expr></argument> ,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> , <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator></expr></argument> ,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <operator>=</operator>
<name>std</name><operator>::</operator><call><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument> )</argument_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>GetCurrentOsStackTraceExceptTop</name><argument_list>(
<argument>UnitTest* unit_test</argument>, <argument>int skip_count</argument>)</argument_list></macro></expr>;</expr_stmt>





<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>AlwaysTrue</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><specifier>inline</specifier> <name>bool</name></type> <name>AlwaysFalse</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><call><name>AlwaysTrue</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>




<struct>struct <macro><name>GTEST_API_</name></macro> <name>ConstCharPtr</name> <block>{
<expr_stmt><expr><call><name>ConstCharPtr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>str</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>value</name><argument_list>(<argument>str</argument>)</argument_list></macro> <block>{}</block>
<name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>






<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>Random</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>UInt32</name></type> <name>kMaxRange</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>

<macro><name>explicit</name></macro> <macro><name>Random</name><argument_list>(<argument>UInt32 seed</argument>)</argument_list></macro> : <macro><name>state_</name><argument_list>(<argument>seed</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<function><type><name>void</name></type> <name>Reseed</name><parameter_list>(<parameter><decl><type><name>UInt32</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>state_</name> <operator>=</operator> <name>seed</name></expr>;</expr_stmt> </block_content>}</block></function>



<function_decl><type><name>UInt32</name></type> <name>Generate</name><parameter_list>(<parameter><decl><type><name>UInt32</name></type> <name>range</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>UInt32</name></type> <name>state_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>Random</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name> <name>T2</name><operator>&gt;</operator>
struct <name>CompileAssertTypesEqual</name></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name><name>CompileAssertTypesEqual</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;</expr_stmt>




<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>RemoveReference</name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name><name>RemoveReference</name><argument_list type="generic">&lt;<argument><expr><name>T</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_REMOVE_REFERENCE_</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typename ::testing::internal::RemoveReference&lt;T&gt;::type</cpp:value></cpp:define>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>RemoveConst</name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name><name>RemoveConst</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>T</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>




<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>size_t</name> <name>N</name><operator>&gt;</operator>
struct <name><name>RemoveConst</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>T</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>RemoveConst</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name><name>type</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</expr_stmt></typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1400</literal></expr></cpp:if>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name></expr><operator>,</operator> <expr><name>size_t</name> <name>N</name><operator>&gt;</operator>
struct <name><name>RemoveConst</name><argument_list type="generic">&lt;<argument><expr><name><name>T</name><index>[<expr><name>N</name></expr>]</index></name></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>RemoveConst</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name><name>type</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</expr_stmt></typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_REMOVE_CONST_</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typename ::testing::internal::RemoveConst&lt;T&gt;::type</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><parameter_list>(<parameter><type><name>T</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))</cpp:value></cpp:define>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ImplicitlyConvertible</name> <block>{<block_content>
<label><name>private</name>:</label>






<expr_stmt><expr><specifier>static</specifier> <name>typename</name> <name><name>AddReference</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <call><name>MakeFrom</name><argument_list>()</argument_list></call></expr>;</expr_stmt>











<function_decl><type><specifier>static</specifier> <name>char</name></type> <name>Helper</name><parameter_list>(<parameter><decl><type><name>To</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>static</specifier> <call><name>char</name> <argument_list>(<argument><expr><operator>&amp;</operator><call><name>Helper</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>



<label><name>public</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>= <expr><call><name>__is_convertible</name><argument_list>(<argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>



<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4244</literal></argument>)</argument_list></macro>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>bool</name></type> <name>value</name> <init>=
<expr><sizeof>sizeof<argument_list>(<argument><expr><call><name>Helper</name><argument_list>(<argument><expr><name>ImplicitlyConvertible</name><operator>::</operator><call><name>MakeFrom</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<macro><name>GTEST_DISABLE_MSC_WARNINGS_POP_</name><argument_list>()</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>, <argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>bool</name> <name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>IsAProtocolMessage</name>
<range>: <expr><name>public</name> <name><name>bool_constant</name><argument_list type="generic">&lt;
<argument><expr><name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>ProtocolMessage</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name><name>ImplicitlyConvertible</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name><operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <operator>::</operator><name>proto2</name><operator>::</operator><name>Message</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr></range></decl>;</decl_stmt>

























<typedef>typedef <type><name>int</name></type> <name>IsContainer</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<expr_stmt><expr><name>template</name> <operator>&lt;</operator><name>class</name> <name>C</name></expr><operator>,</operator>
<expr><name>class</name> <name>Iterator</name> <operator>=</operator> <call><name>decltype</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><call><name><name>declval</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>C</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>class</name> <operator>=</operator> <call><name>decltype</name><argument_list>(<argument><expr><operator>::</operator><name>std</name><operator>::</operator><call><name><name>declval</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>C</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>class</name> <operator>=</operator> <call><name>decltype</name><argument_list>(<argument><expr><operator>++</operator><operator>::</operator><name>std</name><operator>::</operator><call><name><name>declval</name><argument_list type="generic">&lt;<argument><expr><name>Iterator</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>class</name> <operator>=</operator> <call><name>decltype</name><argument_list>(<argument><expr><operator>*</operator><operator>::</operator><name>std</name><operator>::</operator><call><name><name>declval</name><argument_list type="generic">&lt;<argument><expr><name>Iterator</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><name>class</name> <operator>=</operator> <name>typename</name> <name>C</name><operator>::</operator><name>const_iterator</name><operator>&gt;</operator>
<name>IsContainer</name> <macro><name>IsContainerTest</name><argument_list>(<argument>int</argument> )</argument_list></macro> <block>{
<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>IsContainer</name></type> <name>IsContainerTest</name><argument_list>(<argument><expr><name>int</name></expr></argument> ,
<argument><expr><name>typename</name> <name>C</name><operator>::</operator><name>iterator</name><operator>*</operator> <operator>=</operator> <name>NULL</name></expr></argument>,
<argument><expr><name>typename</name> <name>C</name><operator>::</operator><name>const_iterator</name><operator>*</operator> <operator>=</operator> <name>NULL</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>char</name></type> <name>IsNotContainer</name>;</typedef>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>C</name></expr></argument>&gt;</argument_list></name>
<name>IsNotContainer</name></type> <name>IsContainerTest</name><parameter_list>(<parameter><decl><type><name>long</name></type></decl></parameter> )</parameter_list> <block>{<block_content> <return>return <expr><literal type="char">'\0'</literal></expr>;</return> </block_content>}</block></function>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>IsHashTable</name> <block>{
<expr><name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>char</name> <macro><name>test</name><argument_list>(<argument>typename U::hasher*</argument>, <argument>typename U::reverse_iterator*</argument>)</argument_list></macro></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>int</name> <macro><name>test</name><argument_list>(<argument>typename U::hasher*</argument>, <argument>...</argument>)</argument_list></macro></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>char</name> <call><name>test</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>test</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;
}</block></expr>;</expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>bool</name> <name><name>IsHashTable</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;</expr_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>VoidT</name> <block>{
<typedef>typedef <type><name>void</name></type> <name>value_type</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <operator>=</operator> <name>void</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>HasValueType</name> <range>: <expr><name>false_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>HasValueType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name><name>VoidT</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <range>: <expr><name>true_type</name> <block>{
}</block></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><name>template</name> <operator>&lt;</operator><name>typename</name> <name>C</name></expr><operator>,</operator>
<expr><name>bool</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>IsContainerTest</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IsContainer</name></expr></argument>)</argument_list></sizeof></expr><operator>,</operator>
<expr><name>bool</name> <operator>=</operator> <name><name>HasValueType</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>&gt;</operator>
struct <name>IsRecursiveContainerImpl</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>C</name></expr></argument>, <argument><expr><name>bool</name> <name>HV</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>IsRecursiveContainerImpl</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>HV</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name>false_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>C</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>IsRecursiveContainerImpl</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name>false_type</name> <block>{}</block></expr></range></decl>;</decl_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>C</name><operator>&gt;</operator>
struct <name><name>IsRecursiveContainerImpl</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_LANG_CXX11</name></expr></cpp:if>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>IteratorTraits</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>C</name><operator>::</operator><name>const_iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name>
<name>value_type</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>IteratorTraits</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>C</name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value_type</name> <name>value_type</name></expr>;</expr_stmt></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>value_type</name></expr></argument>, <argument><expr><name>C</name></expr></argument>&gt;</argument_list></name></type> <name>type</name>;</typedef>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>C</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>IsRecursiveContainer</name> <range>: <expr><name>public</name> <name><name>IsRecursiveContainerImpl</name><argument_list type="generic">&lt;<argument><expr><name>C</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <block>{}</block></expr></range></decl>;</decl_stmt>





<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>bool</name><operator>&gt;</operator> struct <name>EnableIf</name></expr>;</expr_stmt>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>EnableIf</name><argument_list type="generic">&lt;<argument><expr><name>true</name></expr></argument>&gt;</argument_list></name> <block>{ <typedef>typedef <type><name>void</name></type> <name>type</name>;</typedef> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>







<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>ArrayEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name><modifier>*</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>ArrayEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>lhs</name> <operator>==</operator> <name>rhs</name></expr>;</return> </block_content>}</block></function>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name></type> <name>ArrayEq</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>T</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhs</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>, <argument><expr><specifier>const</specifier> <call><name>U</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhs</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>internal</name><operator>::</operator><call><name>ArrayEq</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>ArrayEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>U</name><modifier>*</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>internal</name><operator>::</operator><call><name>ArrayEq</name><argument_list>(<argument><expr><name><name>lhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rhs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Iter</name></expr></argument>, <argument><expr><name>typename</name> <name>Element</name></expr></argument>&gt;</argument_list></name>
<name>Iter</name></type> <name>ArrayAwareFind</name><parameter_list>(<parameter><decl><type><name>Iter</name></type> <name>begin</name></decl></parameter>, <parameter><decl><type><name>Iter</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Element</name><modifier>&amp;</modifier></type> <name>elem</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>Iter</name></type> <name>it</name> <init>= <expr><name>begin</name></expr></init></decl>;</init> <condition><expr><name>it</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>internal</name><operator>::</operator><call><name>ArrayEq</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>it</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>end</name></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>CopyArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>U</name><modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>CopyArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>U</name><modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt> </block_content>}</block></function>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>, <argument><expr><name>size_t</name> <name>N</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>CopyArray</name><argument_list>(<argument><expr><specifier>const</specifier> <call><name>T</name><argument_list>(<argument><expr><operator>&amp;</operator><name>from</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>, <argument><expr><call><name>U</name><argument_list>(<argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call><index>[<expr><name>N</name></expr>]</index></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>internal</name><operator>::</operator><call><name>CopyArray</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><operator>*</operator><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>CopyArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>U</name><modifier>*</modifier></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>internal</name><operator>::</operator><call><name>CopyArray</name><argument_list>(<argument><expr><name><name>from</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>to</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<struct>struct <name>RelationToSourceReference</name> <block>{}</block>;</struct>
<struct>struct <name>RelationToSourceCopy</name> <block>{}</block>;</struct>









<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Element</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>NativeArray</name> <block>{<block_content>
<label><name>public</name>:</label>

<typedef>typedef <type><name>Element</name></type> <name>value_type</name>;</typedef>
<typedef>typedef <type><name>Element</name><modifier>*</modifier></type> <name>iterator</name>;</typedef>
<typedef>typedef <type><specifier>const</specifier> <name>Element</name><modifier>*</modifier></type> <name>const_iterator</name>;</typedef>


<macro><name>NativeArray</name><argument_list>(<argument>const Element* array</argument>, <argument>size_t count</argument>, <argument>RelationToSourceReference</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>InitRef</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>NativeArray</name><argument_list>(<argument>const Element* array</argument>, <argument>size_t count</argument>, <argument>RelationToSourceCopy</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>InitCopy</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>NativeArray</name><argument_list>(<argument>const NativeArray&amp; rhs</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>this</name><operator>-&gt;*</operator><name><name>rhs</name><operator>.</operator><name>clone_</name></name><operator>)</operator><operator>(</operator><name><name>rhs</name><operator>.</operator><name>array_</name></name><operator>,</operator> <name><name>rhs</name><operator>.</operator><name>size_</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><operator>~</operator><macro><name>NativeArray</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>clone_</name> <operator>!=</operator> <operator>&amp;</operator><name>NativeArray</name><operator>::</operator><name>InitRef</name></expr>)</condition><block type="pseudo"><block_content>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>array_</name></decl>;</decl_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>size_t</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>size_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>array_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>array_</name> <operator>+</operator> <name>size_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>NativeArray</name><operator>&amp;</operator> <name>rhs</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>rhs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ArrayEq</name><argument_list>(<argument><expr><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rhs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<enum>enum <block>{
<decl><name>kCheckTypeIsNotConstOrAReference</name> <init>= <expr><name><name>StaticAssertTypeEqHelper</name><argument_list type="generic">&lt;
<argument><expr><name>Element</name></expr></argument>, <argument><expr><name>GTEST_REMOVE_REFERENCE_AND_CONST_</name><operator>(</operator><name>Element</name><operator>)</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></init></decl>
}</block>;</enum>


<function><type><name>void</name></type> <name>InitCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Element</name><modifier>*</modifier></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>a_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Element</name><modifier>*</modifier> <specifier>const</specifier></type> <name>copy</name> <init>= <expr><name>new</name> <name><name>Element</name><index>[<expr><name>a_size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CopyArray</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>a_size</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>array_</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size_</name> <operator>=</operator> <name>a_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>clone_</name> <operator>=</operator> <operator>&amp;</operator><name>NativeArray</name><operator>::</operator><name>InitCopy</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>InitRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Element</name><modifier>*</modifier></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>a_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>array_</name> <operator>=</operator> <name>array</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size_</name> <operator>=</operator> <name>a_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>clone_</name> <operator>=</operator> <operator>&amp;</operator><name>NativeArray</name><operator>::</operator><name>InitRef</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>Element</name><modifier>*</modifier></type> <name>array_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size_</name></decl>;</decl_stmt>
<expr_stmt><expr><call><call><name>void</name> <argument_list>(<argument><expr><name>NativeArray</name><operator>::</operator><operator>*</operator><name>clone_</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>Element</name><operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_ASSIGN_</name><argument_list>(<argument><expr><name>NativeArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}
}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_MESSAGE_AT_</name><parameter_list>(<parameter><type><name>file</name></type></parameter>, <parameter><type><name>line</name></type></parameter>, <parameter><type><name>message</name></type></parameter>, <parameter><type><name>result_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>::testing::internal::AssertHelper(result_type, file, line, message) = ::testing::Message()</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_MESSAGE_</name><parameter_list>(<parameter><type><name>message</name></type></parameter>, <parameter><type><name>result_type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_MESSAGE_AT_(__FILE__, __LINE__, message, result_type)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_FATAL_FAILURE_</name><parameter_list>(<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_NONFATAL_FAILURE_</name><parameter_list>(<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SUCCESS_</name><parameter_list>(<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SKIP_</name><parameter_list>(<parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (::testing::internal::AlwaysTrue()) { statement; }</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_THROW_</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>expected_exception</name></type></parameter>, <parameter><type><name>fail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::ConstCharPtr gtest_msg = "") { bool gtest_caught_expected = false; try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (expected_exception const&amp;) { gtest_caught_expected = true; } catch (...) { gtest_msg.value = "Expected: " #statement " throws an exception of type " #expected_exception ".\n Actual: it throws a different type."; goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); } if (!gtest_caught_expected) { gtest_msg.value = "Expected: " #statement " throws an exception of type " #expected_exception ".\n Actual: it throws nothing."; goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__): fail(gtest_msg.value)</cpp:value></cpp:define>

























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_NO_THROW_</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>fail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (...) { goto GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testnothrow_, __LINE__): fail("Expected: " #statement " doesn't throw an exception.\n" " Actual: it throws.")</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_ANY_THROW_</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>fail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { bool gtest_caught_any = false; try { GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); } catch (...) { gtest_caught_any = true; } if (!gtest_caught_any) { goto GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testanythrow_, __LINE__): fail("Expected: " #statement " throws an exception.\n" " Actual: it doesn't.")</cpp:value></cpp:define>





















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_BOOLEAN_</name><parameter_list>(<parameter><type><name>expression</name></type></parameter>, <parameter><type><name>text</name></type></parameter>, <parameter><type><name>actual</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>fail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (const ::testing::AssertionResult gtest_ar_ = ::testing::AssertionResult(expression)) ; else fail(::testing::internal::GetBoolAssertionFailureMessage(gtest_ar_, text, #actual, #expected).c_str())</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_NO_FATAL_FAILURE_</name><parameter_list>(<parameter><type><name>statement</name></type></parameter>, <parameter><type><name>fail</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GTEST_AMBIGUOUS_ELSE_BLOCKER_ if (::testing::internal::AlwaysTrue()) { ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); if (gtest_fatal_failure_checker.has_new_fatal_failure()) { goto GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__); } } else GTEST_CONCAT_TOKEN_(gtest_label_testnofatal_, __LINE__): fail("Expected: " #statement " doesn't generate new fatal " "failures in the current thread.\n" " Actual: it does.")</cpp:value></cpp:define>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_CLASS_NAME_</name><parameter_list>(<parameter><type><name>test_case_name</name></type></parameter>, <parameter><type><name>test_name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>test_case_name##_##test_name##_Test</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_TEST_</name><parameter_list>(<parameter><type><name>test_case_name</name></type></parameter>, <parameter><type><name>test_name</name></type></parameter>, <parameter><type><name>parent_class</name></type></parameter>, <parameter><type><name>parent_id</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {public:GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}private:virtual void TestBody();static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_case_name, test_name));};::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::test_info_ =::testing::internal::MakeAndRegisterTestInfo(#test_case_name, #test_name, NULL, NULL, ::testing::internal::CodeLocation(__FILE__, __LINE__), (parent_id), parent_class::SetUpTestCase, parent_class::TearDownTestCase, new ::testing::internal::TestFactoryImpl&lt;GTEST_TEST_CLASS_NAME_(test_case_name, test_name)&gt;);void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()</cpp:value></cpp:define>






















<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
