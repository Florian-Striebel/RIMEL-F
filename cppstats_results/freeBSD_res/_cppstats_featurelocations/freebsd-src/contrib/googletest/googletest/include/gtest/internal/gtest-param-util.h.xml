<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googletest/include/gtest/internal/gtest-param-util.h">

































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PARAM_UTIL_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-linked_ptr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-port.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-printers.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ParamType</name><operator>&gt;</operator>
struct <name>TestParamInfo</name> <block>{
<macro><name>TestParamInfo</name><argument_list>(<argument>const ParamType&amp; a_param</argument>, <argument>size_t an_index</argument>)</argument_list></macro> <operator>:</operator>
<expr><call><name>param</name><argument_list>(<argument><expr><name>a_param</name></expr></argument>)</argument_list></call></expr>,
<macro><name>index</name><argument_list>(<argument>an_index</argument>)</argument_list></macro> <expr><block>{}</block>
<name>ParamType</name> <name>param</name></expr>;
<expr><name>size_t</name> <name>index</name></expr>;
}</block></expr>;</expr_stmt>



<struct>struct <name>PrintToStringParamName</name> <block>{
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ParamType</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>string</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name><name>TestParamInfo</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>info</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>PrintToString</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>param</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>







<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>ReportInvalidTestCaseType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>test_case_name</name></decl></parameter>,
<parameter><decl><type><name>CodeLocation</name></type> <name>code_location</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>ParamGeneratorInterface</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>ParamGenerator</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParamIteratorInterface</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>ParamIteratorInterface</name><argument_list>()</argument_list></macro> <block>{}</block>



<name>virtual</name> <specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>BaseGenerator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>Advance</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<expr_stmt><expr><name>virtual</name> <name>ParamIteratorInterface</name><operator>*</operator> <macro><name>Clone</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>T</name><operator>*</operator> <macro><name>Current</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>Equals</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParamIteratorInterface</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list> const <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParamIterator</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name>T</name></type> <name>value_type</name>;</typedef>
<typedef>typedef <type><specifier>const</specifier> <name>T</name><modifier>&amp;</modifier></type> <name>reference</name>;</typedef>
<typedef>typedef <type><name>ptrdiff_t</name></type> <name>difference_type</name>;</typedef>


<expr_stmt><expr><call><name>ParamIterator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParamIterator</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>other.impl_-&gt;Clone()</argument>)</argument_list></macro> <block>{}</block>
<name>ParamIterator</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>ParamIterator</name><operator>&amp;</operator> <name>other</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><name>this</name> <operator>!=</operator> <operator>&amp;</operator><name>other</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>impl_</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><call><name><name>other</name><operator>.</operator><name>impl_</name><operator>-&gt;</operator><name>Clone</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>T</name><operator>&amp;</operator> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name><name>impl_</name><operator>-&gt;</operator><name>Current</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>T</name><operator>*</operator> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Current</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block>

ParamIterator&amp; operator++(</block></decl>) <block>{<block_content>
<expr_stmt><expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Advance</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></decl_stmt>

<expr_stmt><expr><name>ParamIterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name> <operator>)</operator> <block>{
<expr><name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>clone</name> <operator>=</operator> <call><name><name>impl_</name><operator>-&gt;</operator><name>Clone</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Advance</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>ParamIterator</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>ParamIterator</name><operator>&amp;</operator> <name>other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>impl_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>impl_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>impl_</name><operator>-&gt;</operator><name>Equals</name></name><argument_list>(<argument><expr><operator>*</operator><name><name>other</name><operator>.</operator><name>impl_</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>ParamIterator</name><operator>&amp;</operator> <name>other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>other</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name><name>ParamGenerator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></decl>;</decl_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ParamIterator</name><argument_list>(<argument><expr><name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>
<name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>impl_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParamGeneratorInterface</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name>T</name></type> <name>ParamType</name>;</typedef>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>ParamGeneratorInterface</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>Begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>End</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParamGenerator</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name><name>ParamIterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>iterator</name>;</typedef>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ParamGenerator</name><argument_list>(<argument><expr><name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>impl</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>impl</argument>)</argument_list></macro> <block>{}</block>
<call><name>ParamGenerator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParamGenerator</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>impl_</name><argument_list>(<argument>other.impl_</argument>)</argument_list></macro> <block>{}</block>

<name>ParamGenerator</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>ParamGenerator</name><operator>&amp;</operator> <name>other</name><operator>)</operator> <block>{
<expr><name>impl_</name> <operator>=</operator> <name><name>other</name><operator>.</operator><name>impl_</name></name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><call><name><name>impl_</name><operator>-&gt;</operator><name>Begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>iterator</name><argument_list>(<argument><expr><call><name><name>impl_</name><operator>-&gt;</operator><name>End</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>impl_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>IncrementT</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>RangeGenerator</name> <range>: <expr><name>public</name> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>RangeGenerator</name><argument_list>(<argument>T begin</argument>, <argument>T end</argument>, <argument>IncrementT step</argument>)</argument_list></macro>
<operator>:</operator> <call><name>begin_</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>end_</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>step_</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>, <macro><name>end_index_</name><argument_list>(<argument>CalculateEndIndex(begin, end, step)</argument>)</argument_list></macro> <expr><block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>RangeGenerator</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>Begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>begin_</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>step_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>End</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>end_</name></expr></argument>, <argument><expr><name>end_index_</name></expr></argument>, <argument><expr><name>step_</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>class</name> <name>Iterator</name> <operator>:</operator> <name>public</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Iterator</name><argument_list>(<argument>const ParamGeneratorInterface&lt;T&gt;* base</argument>, <argument>T value</argument>, <argument>int index</argument>,
<argument>IncrementT step</argument>)</argument_list></macro>
<operator>:</operator> <call><name>base_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>value_</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>index_</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>, <macro><name>step_</name><argument_list>(<argument>step</argument>)</argument_list></macro> <expr><block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>Iterator</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>BaseGenerator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>base_</name></expr>;</return>
}</block>
<name>virtual</name> <name>void</name> <macro><name>Advance</name><argument_list>()</argument_list></macro> <block>{
<expr><name>value_</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>value_</name> <operator>+</operator> <name>step_</name></expr></argument>)</argument_list></call></expr>;
<expr><name>index_</name><operator>++</operator></expr>;
}</block>
<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>Clone</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <specifier>const</specifier> <name>T</name><operator>*</operator> <macro><name>Current</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><name>value_</name></expr>;</return> }</block>
<name>virtual</name> <name>bool</name> <macro><name>Equals</name><argument_list>(<argument>const ParamIteratorInterface&lt;T&gt;&amp; other</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><call><name>BaseGenerator</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>BaseGenerator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"The program attempted to compare iterators "</literal>
<operator>&lt;&lt;</operator> <literal type="string">"from different generators."</literal> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><name>endl</name></expr>;
<expr><specifier>const</specifier> <name>int</name> <name>other_index</name> <operator>=</operator>
<call><name><name>CheckedDowncastToActualType</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>other</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>index_</name></expr>;
<return>return <expr><name>index_</name> <operator>==</operator> <name>other_index</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<call><name>Iterator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Iterator</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>,
<expr><call><name>base_</name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>base_</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>value_</name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>value_</name></name></expr></argument>)</argument_list></call></expr>, <expr><call><name>index_</name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>index_</name></name></expr></argument>)</argument_list></call></expr>,
<macro><name>step_</name><argument_list>(<argument>other.step_</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>Iterator</name><operator>&amp;</operator> <name>other</name><operator>)</operator></expr>;

<expr><specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <specifier>const</specifier> <name>base_</name></expr>;
<expr><name>T</name> <name>value_</name></expr>;
<expr><name>int</name> <name>index_</name></expr>;
<expr><specifier>const</specifier> <name>IncrementT</name> <name>step_</name></expr>;
}</block></expr>;

<expr><specifier>static</specifier> <name>int</name> <macro><name>CalculateEndIndex</name><argument_list>(<argument>const T&amp; begin</argument>,
<argument>const T&amp; end</argument>,
<argument>const IncrementT&amp; step</argument>)</argument_list></macro> <block>{
<expr><name>int</name> <name>end_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<for>for <control>(<init><decl><type><name>T</name></type> <name>i</name> <init>= <expr><name>begin</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>step</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>end_index</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for></block></expr>
<return>return <expr><name>end_index</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>RangeGenerator</name><operator>&amp;</operator> <name>other</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>begin_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name></type> <name>end_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>IncrementT</name></type> <name>step_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>end_index_</name></decl>;</decl_stmt>
};






<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ValuesInIteratorRangeGenerator</name> <range>: <expr><name>public</name> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ForwardIterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>ValuesInIteratorRangeGenerator</name><argument_list>(<argument>ForwardIterator begin</argument>, <argument>ForwardIterator end</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>container_</name><argument_list>(<argument>begin</argument>, <argument>end</argument>)</argument_list></macro> <block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>ValuesInIteratorRangeGenerator</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>Begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>container_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>End</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><call><name><name>container_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>ContainerType</name></expr>;</expr_stmt></typedef>

<name>class</name> <name>Iterator</name> <operator>:</operator> <name>public</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Iterator</name><argument_list>(<argument>const ParamGeneratorInterface&lt;T&gt;* base</argument>,
<argument>typename ContainerType::const_iterator iterator</argument>)</argument_list></macro>
<operator>:</operator> <call><name>base_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>, <macro><name>iterator_</name><argument_list>(<argument>iterator</argument>)</argument_list></macro> <expr><block>{}</block>
<name>virtual</name> <operator>~</operator><macro><name>Iterator</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>BaseGenerator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>base_</name></expr>;</return>
}</block>
<name>virtual</name> <name>void</name> <macro><name>Advance</name><argument_list>()</argument_list></macro> <block>{
<expr><operator>++</operator><name>iterator_</name></expr>;
<expr><call><name><name>value_</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;
}</block>
<name>virtual</name> <name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <macro><name>Clone</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>new</name> <call><name>Iterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>







<name>virtual</name> <specifier>const</specifier> <name>T</name><operator>*</operator> <macro><name>Current</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>value_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<macro><name>value_</name></macro><expr_stmt><expr><operator>.</operator><macro><name>reset</name><argument_list>(<argument>new T(*iterator_)</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>value_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>virtual</name> <name>bool</name> <macro><name>Equals</name><argument_list>(<argument>const ParamIteratorInterface&lt;T&gt;&amp; other</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><call><name>BaseGenerator</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>other</name><operator>.</operator><name>BaseGenerator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"The program attempted to compare iterators "</literal>
<operator>&lt;&lt;</operator> <literal type="string">"from different generators."</literal> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><name>endl</name></expr>;
<return>return <expr><name>iterator_</name> <operator>==</operator>
<call><name><name>CheckedDowncastToActualType</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>other</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>iterator_</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<call><name>Iterator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Iterator</name><operator>&amp;</operator> <name>other</name></expr></argument>)</argument_list></call>


<operator>:</operator> <call><name><name>ParamIteratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<call><name>base_</name><argument_list>(<argument><expr><name><name>other</name><operator>.</operator><name>base_</name></name></expr></argument>)</argument_list></call>,
<macro><name>iterator_</name><argument_list>(<argument>other.iterator_</argument>)</argument_list></macro> <block>{}</block></block>

<specifier>const</specifier> <name><name>ParamGeneratorInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <specifier>const</specifier> <name>base_</name></expr></range></decl>;</decl_stmt>
<expr_stmt><expr><name>typename</name> <name>ContainerType</name><operator>::</operator><name>const_iterator</name> <name>iterator_</name></expr>;</expr_stmt>





<decl_stmt><decl><type><name>mutable</name> <name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name></expr></argument>&gt;</argument_list></name></type> <name>value_</name></decl>;</decl_stmt>
};


<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ValuesInIteratorRangeGenerator</name><operator>&amp;</operator> <name>other</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ContainerType</name></type> <name>container_</name></decl>;</decl_stmt>
};





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ParamType</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name>string</name> <macro><name>DefaultParamName</name><argument_list>(<argument>const TestParamInfo&lt;ParamType&gt;&amp; info</argument>)</argument_list></macro> <block>{
<expr><name>Message</name> <name>name_stream</name></expr>;
<expr><name>name_stream</name> <operator>&lt;&lt;</operator> <name><name>info</name><operator>.</operator><name>index</name></name></expr>;
<return>return <expr><call><name><name>name_stream</name><operator>.</operator><name>GetString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ParamType</name></expr></argument>, <argument><expr><name>class</name> <name>ParamNameGenFunctor</name></expr></argument>&gt;</argument_list></name>
<name>ParamNameGenFunctor</name></type> <name>GetParamNameGen</name><parameter_list>(<parameter><decl><type><name>ParamNameGenFunctor</name></type> <name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>ParamType</name><operator>&gt;</operator>
struct <name>ParamNameGenFunc</name> <block>{
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>Type</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>TestParamInfo</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ParamType</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name><name>ParamNameGenFunc</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name> <operator>*</operator><macro><name>GetParamNameGen</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>DefaultParamName</name></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TestClass</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParameterizedTestFactory</name> <range>: <expr><name>public</name> <name>TestFactoryBase</name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>TestClass</name><operator>::</operator><name>ParamType</name> <name>ParamType</name></expr>;</expr_stmt></typedef>
<name>explicit</name> <macro><name>ParameterizedTestFactory</name><argument_list>(<argument>ParamType parameter</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>parameter_</name><argument_list>(<argument>parameter</argument>)</argument_list></macro> <block>{}</block></block>
<name>virtual</name> <name>Test</name><operator>*</operator> <macro><name>CreateTest</name><argument_list>()</argument_list></macro> <block>{
<expr><name>TestClass</name><operator>::</operator><call><name>SetParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parameter_</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>new</name> <call><name>TestClass</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParamType</name></type> <name>parameter_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ParameterizedTestFactory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ParamType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TestMetaFactoryBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>TestMetaFactoryBase</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>TestFactoryBase</name><operator>*</operator> <macro><name>CreateTestFactory</name><argument_list>(<argument>ParamType parameter</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>









<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TestCase</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TestMetaFactory</name>
<range>: <expr><name>public</name> <name><name>TestMetaFactoryBase</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TestCase</name><operator>::</operator><name>ParamType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>TestCase</name><operator>::</operator><name>ParamType</name> <name>ParamType</name></expr>;</expr_stmt></typedef>

<macro><name>TestMetaFactory</name><argument_list>()</argument_list></macro> <block>{}</block></block>

<name>virtual</name> <name>TestFactoryBase</name><operator>*</operator> <macro><name>CreateTestFactory</name><argument_list>(<argument>ParamType parameter</argument>)</argument_list></macro> <block>{
<return>return <expr><name>new</name> <call><name><name>ParameterizedTestFactory</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>TestMetaFactory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};











<decl_stmt><decl><type><name>class</name></type> <name>ParameterizedTestCaseInfoBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>ParameterizedTestCaseInfoBase</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <macro><name>GetTestCaseName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>TypeId</name> <macro><name>GetTestCaseTypeId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>RegisterTests</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<label><name>protected</name>:</label>
<macro><name>ParameterizedTestCaseInfoBase</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ParameterizedTestCaseInfoBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>








<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TestCase</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ParameterizedTestCaseInfo</name> <range>: <expr><name>public</name> <name>ParameterizedTestCaseInfoBase</name> <block>{
<expr><name>public</name><operator>:</operator></expr>



<typedef>typedef <expr_stmt><expr><name>typename</name> <name>TestCase</name><operator>::</operator><name>ParamType</name> <name>ParamType</name></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>

<typedef>typedef <function_decl><type><name><name>ParamGenerator</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name></type>(<name>GeneratorCreationFunc</name>)<parameter_list>()</parameter_list>;</function_decl></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>ParamNameGenFunc</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name> <name>ParamNameGeneratorFunc</name></expr>;</expr_stmt></typedef>

<macro><name>explicit</name></macro> <macro><name>ParameterizedTestCaseInfo</name><argument_list>(
<argument>const char* name</argument>, <argument>CodeLocation code_location</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>test_case_name_</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>code_location_</name><argument_list>(<argument>code_location</argument>)</argument_list></macro> <expr><block>{}</block>


<name>virtual</name> <specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <macro><name>GetTestCaseName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>test_case_name_</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>TypeId</name> <macro><name>GetTestCaseTypeId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>GetTypeId</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>






<function><type><name>void</name></type> <name>AddTestPattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>test_case_name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>test_base_name</name></decl></parameter>,
<parameter><decl><type><name><name>TestMetaFactoryBase</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><modifier>*</modifier></type> <name>meta_factory</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>tests_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><macro><name>linked_ptr</name></macro><operator>&lt;</operator><name>TestInfo</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name>TestInfo</name><argument_list>(<argument><expr><name>test_case_name</name></expr></argument>,
<argument><expr><name>test_base_name</name></expr></argument>,
<argument><expr><name>meta_factory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name>int</name></type> <name>AddTestCaseInstantiation</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>instantiation_name</name></expr></argument>,
<argument><expr><name>GeneratorCreationFunc</name><operator>*</operator> <name>func</name></expr></argument>,
<argument><expr><name>ParamNameGeneratorFunc</name><operator>*</operator> <name>name_func</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file</name></expr></argument>, <argument><expr><name>int</name> <name>line</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>instantiations_</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><call><name>InstantiationInfo</name><argument_list>(<argument><expr><name>instantiation_name</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>name_func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>virtual</name> <name>void</name></type> <name>RegisterTests</name><parameter_list>()</parameter_list> <block>{<block_content>
<for>for <control>(<init><expr><name>typename</name> <name>TestInfoContainer</name><operator>::</operator><name>iterator</name> <name>test_it</name> <operator>=</operator> <call><name><name>tests_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>test_it</name> <operator>!=</operator> <call><name><name>tests_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>test_it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TestInfo</name></expr></argument>&gt;</argument_list></name></type> <name>test_info</name> <init>= <expr><operator>*</operator><name>test_it</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>typename</name> <name>InstantiationContainer</name><operator>::</operator><name>iterator</name> <name>gen_it</name> <operator>=</operator>
<call><name><name>instantiations_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>gen_it</name> <operator>!=</operator> <call><name><name>instantiations_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition>
<incr><expr><operator>++</operator><name>gen_it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>instantiation_name</name> <operator>=</operator> <name><name>gen_it</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>ParamGenerator</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name></type> <name>generator</name><argument_list>(<argument><expr><call>(<modifier>*</modifier><name><name>gen_it</name><operator>-&gt;</operator><name>generator</name></name>)<argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParamNameGeneratorFunc</name><modifier>*</modifier></type> <name>name_func</name> <init>= <expr><name><name>gen_it</name><operator>-&gt;</operator><name>name_func</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name> <init>= <expr><name><name>gen_it</name><operator>-&gt;</operator><name>file</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>gen_it</name><operator>-&gt;</operator><name>line</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>test_case_name</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><operator>!</operator><call><name><name>instantiation_name</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_case_name</name> <operator>=</operator> <name>instantiation_name</name> <operator>+</operator> <literal type="string">"/"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>test_case_name</name> <operator>+=</operator> <name><name>test_info</name><operator>-&gt;</operator><name>test_case_base_name</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>test_param_names</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>typename</name> <name><name>ParamGenerator</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>param_it</name> <operator>=</operator>
<call><name><name>generator</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>param_it</name> <operator>!=</operator> <call><name><name>generator</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>param_it</name></expr><operator>,</operator> <expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Message</name></type> <name>test_name_stream</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>param_name</name> <operator>=</operator> <call><name>name_func</name><argument_list>(
<argument><expr><call><name><name>TestParamInfo</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>param_it</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><call><name>IsValidParamName</name><argument_list>(<argument><expr><name>param_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Parameterized test name '"</literal> <operator>&lt;&lt;</operator> <name>param_name</name>
<operator>&lt;&lt;</operator> <literal type="string">"' is invalid, in "</literal> <operator>&lt;&lt;</operator> <name>file</name>
<operator>&lt;&lt;</operator> <literal type="string">" line "</literal> <operator>&lt;&lt;</operator> <name>line</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><name>endl</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><call><name><name>test_param_names</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>param_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Duplicate parameterized test name '"</literal> <operator>&lt;&lt;</operator> <name>param_name</name>
<operator>&lt;&lt;</operator> <literal type="string">"', in "</literal> <operator>&lt;&lt;</operator> <name>file</name> <operator>&lt;&lt;</operator> <literal type="string">" line "</literal> <operator>&lt;&lt;</operator> <name>line</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><name>endl</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>test_param_names</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>param_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_name_stream</name> <operator>&lt;&lt;</operator> <name><name>test_info</name><operator>-&gt;</operator><name>test_base_name</name></name> <operator>&lt;&lt;</operator> <literal type="string">"/"</literal> <operator>&lt;&lt;</operator> <name>param_name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MakeAndRegisterTestInfo</name><argument_list>(
<argument><expr><call><name><name>test_case_name</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>test_name_stream</name><operator>.</operator><name>GetString</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>PrintToString</name><argument_list>(<argument><expr><operator>*</operator><name>param_it</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>c_str</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>code_location_</name></expr></argument>,
<argument><expr><call><name>GetTestCaseTypeId</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TestCase</name><operator>::</operator><name>SetUpTestCase</name></expr></argument>,
<argument><expr><name>TestCase</name><operator>::</operator><name>TearDownTestCase</name></expr></argument>,
<argument><expr><call><name><name>test_info</name><operator>-&gt;</operator><name>test_meta_factory</name><operator>-&gt;</operator><name>CreateTestFactory</name></name><argument_list>(<argument><expr><operator>*</operator><name>param_it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<label><name>private</name>:</label>


<struct>struct <name>TestInfo</name> <block>{
<expr_stmt><expr><call><name>TestInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>a_test_case_base_name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>a_test_base_name</name></expr></argument>,
<argument><expr><name><name>TestMetaFactoryBase</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>a_test_meta_factory</name></expr></argument>)</argument_list></call> <operator>:</operator>
<call><name>test_case_base_name</name><argument_list>(<argument><expr><name>a_test_case_base_name</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>test_base_name</name><argument_list>(<argument><expr><name>a_test_base_name</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>test_meta_factory</name><argument_list>(<argument>a_test_meta_factory</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>test_case_base_name</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>test_base_name</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>TestMetaFactoryBase</name><argument_list type="generic">&lt;<argument><expr><name>ParamType</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></type> <name>test_meta_factory</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>linked_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TestInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>TestInfoContainer</name></expr>;</expr_stmt></typedef>



<struct>struct <name>InstantiationInfo</name> <block>{
<macro><name>InstantiationInfo</name><argument_list>(<argument>const std::string &amp;name_in</argument>,
<argument>GeneratorCreationFunc* generator_in</argument>,
<argument>ParamNameGeneratorFunc* name_func_in</argument>,
<argument>const char* file_in</argument>,
<argument>int line_in</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>name</name><argument_list>(<argument><expr><name>name_in</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>generator</name><argument_list>(<argument><expr><name>generator_in</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>name_func</name><argument_list>(<argument><expr><name>name_func_in</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>file</name><argument_list>(<argument><expr><name>file_in</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>line</name><argument_list>(<argument>line_in</argument>)</argument_list></macro> <expr><block>{}</block>

<name>std</name><operator>::</operator><name>string</name> <name>name</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>GeneratorCreationFunc</name><modifier>*</modifier></type> <name>generator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParamNameGeneratorFunc</name><modifier>*</modifier></type> <name>name_func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <expr_stmt><expr><operator>::</operator><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>InstantiationInfo</name></expr></argument>&gt;</argument_list></name> <name>InstantiationContainer</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsValidParamName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>name</name></expr></argument>)</argument_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>name</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>std</name><operator>::</operator><name>string</name><operator>::</operator><name>size_type</name> <name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <call><name><name>name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>index</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>test_case_name_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CodeLocation</name></type> <name>code_location_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TestInfoContainer</name></type> <name>tests_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InstantiationContainer</name></type> <name>instantiations_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ParameterizedTestCaseInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
};







<decl_stmt><decl><type><name>class</name></type> <name>ParameterizedTestCaseRegistry</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>ParameterizedTestCaseRegistry</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><operator>~</operator><macro><name>ParameterizedTestCaseRegistry</name><argument_list>()</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>TestCaseInfoContainer</name><operator>::</operator><name>iterator</name> <name>it</name> <operator>=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>delete</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
<expr_stmt/>}</block_content>
}



template &lt;class TestCase&gt;
ParameterizedTestCaseInfo&lt;TestCase&gt;* GetTestCasePatternHolder(
const char* test_case_name</block><operator>,</operator>
<expr_stmt><expr><name>CodeLocation</name> <name>code_location</name></expr></expr_stmt></for>) <block>{
<expr><name><name>ParameterizedTestCaseInfo</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>typed_test_info</name> <operator>=</operator> <name>NULL</name></expr>;
<for>for <control>(<init><expr><name>TestCaseInfoContainer</name><operator>::</operator><name>iterator</name> <name>it</name> <operator>=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>GetTestCaseName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>test_case_name</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>GetTestCaseTypeId</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>GetTypeId</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>ReportInvalidTestCaseType</name><argument_list>(<argument><expr><name>test_case_name</name></expr></argument>, <argument><expr><name>code_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>posix</name><operator>::</operator><call><name>Abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>



<expr_stmt><expr><name>typed_test_info</name> <operator>=</operator> <call><name><name>CheckedDowncastToActualType</name><argument_list type="generic">&lt;
<argument><expr><name><name>ParameterizedTestCaseInfo</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
break</block></block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>
}
if (typed_test_info == NULL</block></if></if_stmt>)</block_content> <block>{<block_content>
<expr_stmt><expr><name>typed_test_info</name> <operator>=</operator> <name>new</name> <call><name><name>ParameterizedTestCaseInfo</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>test_case_name</name></expr></argument>, <argument><expr><name>code_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>test_case_infos_</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>typed_test_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return typed_test_info</block></block><empty_stmt>;</empty_stmt></for>
}</block>
<name>void</name> <macro><name>RegisterTests</name><argument_list>()</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>TestCaseInfoContainer</name><operator>::</operator><name>iterator</name> <name>it</name> <operator>=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>it</name> <operator>!=</operator> <call><name><name>test_case_infos_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>RegisterTests</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

private:
typedef ::std::vector&lt;ParameterizedTestCaseInfoBase*&gt; TestCaseInfoContainer</block><empty_stmt>;</empty_stmt></for>

<name>TestCaseInfoContainer</name> <name>test_case_infos_</name></block></block></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>ParameterizedTestCaseRegistry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
