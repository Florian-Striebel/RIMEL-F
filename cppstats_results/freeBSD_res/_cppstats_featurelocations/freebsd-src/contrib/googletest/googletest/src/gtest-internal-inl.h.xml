<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/googletest/googletest/src/gtest-internal-inl.h">
































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GTEST_SRC_GTEST_INTERNAL_INL_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GTEST_SRC_GTEST_INTERNAL_INL_H_</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32_WCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/internal/gtest-port.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_CAN_STREAM_RESULTS_</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_WINDOWS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtest/gtest-spi.h"</cpp:file></cpp:include>

<macro><name>GTEST_DISABLE_MSC_WARNINGS_PUSH_</name><argument_list>(<argument><literal type="number">4251</literal></argument> \
)</argument_list></macro>

<decl_stmt><decl><type><name>namespace</name></type> <name>testing</name> <block>{<block_content>






<expr_stmt><expr><call><name>GTEST_DECLARE_bool_</name><argument_list>(<argument><expr><name>death_test_use_fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>



<decl_stmt><decl><type><name>GTEST_API_</name> <specifier>extern</specifier> <specifier>const</specifier> <name>TypeId</name></type> <name>kTestTypeIdInGoogleTest</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kAlsoRunDisabledTestsFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"also_run_disabled_tests"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kBreakOnFailureFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"break_on_failure"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kCatchExceptionsFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"catch_exceptions"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kColorFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"color"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kFilterFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"filter"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kListTestsFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"list_tests"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kOutputFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"output"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kPrintTimeFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"print_time"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kPrintUTF8Flag</name><index>[]</index></name> <init>= <expr><literal type="string">"print_utf8"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kRandomSeedFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"random_seed"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kRepeatFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"repeat"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kShuffleFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"shuffle"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kStackTraceDepthFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"stack_trace_depth"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kStreamResultToFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"stream_result_to"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kThrowOnFailureFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"throw_on_failure"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>kFlagfileFlag</name><index>[]</index></name> <init>= <expr><literal type="string">"flagfile"</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>kMaxRandomSeed</name> <init>= <expr><literal type="number">99999</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GTEST_API_</name> <specifier>extern</specifier> <name>bool</name></type> <name>g_help_flag</name></decl>;</decl_stmt>


<function_decl><type><name>GTEST_API_</name> <name>TimeInMillis</name></type> <name>GetTimeInMillis</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>ShouldUseColor</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>stdout_is_tty</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>FormatTimeInMillisAsSeconds</name><argument_list>(<argument>TimeInMillis ms</argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>FormatEpochTimeInMillisAsIso8601</name><argument_list>(<argument>TimeInMillis ms</argument>)</argument_list></macro></expr>;</expr_stmt>





<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>ParseInt32Flag</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>Int32</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><specifier>inline</specifier> <name>int</name></type> <name>GetRandomSeedFromFlag</name><parameter_list>(<parameter><decl><type><name>Int32</name></type> <name>random_seed_flag</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>raw_seed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>random_seed_flag</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then>
<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetTimeInMillis</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>random_seed_flag</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>normalized_seed</name> <init>=
<macro><name>static_cast</name></macro><expr><operator>&lt;</operator><name>int</name><operator>&gt;</operator><operator>(</operator><operator>(</operator><name>raw_seed</name> <operator>-</operator> <literal type="number">1U</literal><operator>)</operator> <operator>%</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>kMaxRandomSeed</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><name>normalized_seed</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>inline</specifier> <name>int</name></type> <name>GetNextRandomSeed</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>&lt;=</operator> <name>seed</name> <operator>&amp;&amp;</operator> <name>seed</name> <operator>&lt;=</operator> <name>kMaxRandomSeed</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Invalid random seed "</literal> <operator>&lt;&lt;</operator> <name>seed</name> <operator>&lt;&lt;</operator> <literal type="string">" - must be in [1, "</literal>
<operator>&lt;&lt;</operator> <name>kMaxRandomSeed</name> <operator>&lt;&lt;</operator> <literal type="string">"]."</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>next_seed</name> <init>= <expr><name>seed</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>next_seed</name> <operator>&gt;</operator> <name>kMaxRandomSeed</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>next_seed</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>GTestFlagSaver</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>GTestFlagSaver</name><argument_list>()</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>also_run_disabled_tests_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>also_run_disabled_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>break_on_failure_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>break_on_failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>catch_exceptions_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>catch_exceptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>color_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>death_test_style_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>death_test_style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>death_test_use_fork_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>death_test_use_fork</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filter_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>internal_run_death_test_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>internal_run_death_test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list_tests_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>list_tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>output_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>print_time_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>print_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>print_utf8_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>print_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>random_seed_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>random_seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repeat_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shuffle_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>shuffle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stack_trace_depth_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>stack_trace_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_result_to_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>stream_result_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>throw_on_failure_</name> <operator>=</operator> <call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>throw_on_failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><operator>~</operator><macro><name>GTestFlagSaver</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>also_run_disabled_tests</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>also_run_disabled_tests_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>break_on_failure</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>break_on_failure_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>catch_exceptions</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>catch_exceptions_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>color</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>color_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>death_test_style</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>death_test_style_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>death_test_use_fork</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>death_test_use_fork_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>filter</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>filter_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>internal_run_death_test</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>internal_run_death_test_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>list_tests</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>list_tests_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>output_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>print_time</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>print_time_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>print_utf8</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>print_utf8_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>random_seed</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>random_seed_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>repeat</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>repeat_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>shuffle</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>shuffle_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>stack_trace_depth</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>stack_trace_depth_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>stream_result_to</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>stream_result_to_</name></expr>;
<expr><call><name>GTEST_FLAG</name><argument_list>(<argument><expr><name>throw_on_failure</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>throw_on_failure_</name></expr>;
}</block>

<name>private</name><operator>:</operator>

<name>bool</name> <name>also_run_disabled_tests_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>break_on_failure_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>catch_exceptions_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>color_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>death_test_style_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>death_test_use_fork_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>filter_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>internal_run_death_test_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>list_tests_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>output_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>print_time_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>print_utf8_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name>Int32</name> <name>random_seed_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name>Int32</name> <name>repeat_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>shuffle_</name></decl>;</decl_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name>Int32</name> <name>stack_trace_depth_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>stream_result_to_</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>throw_on_failure_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt> <expr_stmt><expr><name>GTEST_ATTRIBUTE_UNUSED_</name></expr>;</expr_stmt>







<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>CodePointToUtf8</name><argument_list>(<argument>UInt32 code_point</argument>)</argument_list></macro></expr>;</expr_stmt>














<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>WideStringToUtf8</name><argument_list>(<argument>const wchar_t* str</argument>, <argument>int num_chars</argument>)</argument_list></macro></expr>;</expr_stmt>





<function_decl><type><name>void</name></type> <name>WriteToShardStatusFileIfNeeded</name><parameter_list>()</parameter_list>;</function_decl>







<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>ShouldShard</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>total_shards_str</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>shard_index_str</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>in_subprocess_for_death_test</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>GTEST_API_</name> <name>Int32</name></type> <name>Int32FromEnvOrDie</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>env_var</name></decl></parameter>, <parameter><decl><type><name>Int32</name></type> <name>default_val</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>ShouldRunTestOnShard</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>total_shards</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shard_index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>test_id</name></decl></parameter>)</parameter_list>;</function_decl>





<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Container</name></expr></argument>, <argument><expr><name>typename</name> <name>Predicate</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>int</name></type> <name>CountIf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Container</name><modifier>&amp;</modifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>Predicate</name></type> <name>predicate</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>typename</name> <name>Container</name><operator>::</operator><name>const_iterator</name> <name>it</name> <operator>=</operator> <call><name><name>c</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>it</name> <operator>!=</operator> <call><name><name>c</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>it</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>predicate</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Container</name></expr></argument>, <argument><expr><name>typename</name> <name>Functor</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>ForEach</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Container</name><modifier>&amp;</modifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>Functor</name></type> <name>functor</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>for_each</name><argument_list>(<argument><expr><call><name><name>c</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>c</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>functor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>E</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>E</name></type> <name>GetElementOr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>E</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>v</name></expr></argument>, <argument><expr><name>int</name> <name>i</name></expr></argument>, <argument><expr><name>E</name> <name>default_value</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>&gt;=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>default_value</name></expr> </then><else>: <expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>E</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>ShuffleRange</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>Random</name><operator>*</operator> <name>random</name></expr></argument>, <argument><expr><name>int</name> <name>begin</name></expr></argument>, <argument><expr><name>int</name> <name>end</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>E</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>v</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>v</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>begin</name> <operator>&amp;&amp;</operator> <name>begin</name> <operator>&lt;=</operator> <name>size</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Invalid shuffle range start "</literal> <operator>&lt;&lt;</operator> <name>begin</name> <operator>&lt;&lt;</operator> <literal type="string">": must be in range [0, "</literal>
<operator>&lt;&lt;</operator> <name>size</name> <operator>&lt;&lt;</operator> <literal type="string">"]."</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>begin</name> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>end</name> <operator>&lt;=</operator> <name>size</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Invalid shuffle range finish "</literal> <operator>&lt;&lt;</operator> <name>end</name> <operator>&lt;&lt;</operator> <literal type="string">": must be in range ["</literal>
<operator>&lt;&lt;</operator> <name>begin</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal> <operator>&lt;&lt;</operator> <name>size</name> <operator>&lt;&lt;</operator> <literal type="string">"]."</literal></expr>;</expr_stmt>



<for>for <control>(<init><decl><type><name>int</name></type> <name>range_width</name> <init>= <expr><name>end</name> <operator>-</operator> <name>begin</name></expr></init></decl>;</init> <condition><expr><name>range_width</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>range_width</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>last_in_range</name> <init>= <expr><name>begin</name> <operator>+</operator> <name>range_width</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>selected</name> <init>= <expr><name>begin</name> <operator>+</operator> <call><name><name>random</name><operator>-&gt;</operator><name>Generate</name></name><argument_list>(<argument><expr><name>range_width</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>swap</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>v</name><operator>)</operator><index>[<expr><name>selected</name></expr>]</index></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>v</name><operator>)</operator><index>[<expr><name>last_in_range</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>E</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>Shuffle</name><argument_list>(<argument><expr><name>internal</name><operator>::</operator><name>Random</name><operator>*</operator> <name>random</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>E</name></expr></argument>&gt;</argument_list></name><operator>*</operator> <name>v</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>ShuffleRange</name><argument_list>(<argument><expr><name>random</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>v</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>Delete</name><parameter_list>(<parameter><decl><type><name>T</name><modifier>*</modifier></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>delete</name></type> <name>x</name></decl>;</decl_stmt>
</block_content>}</block></function>




<decl_stmt><decl><type><name>class</name></type> <name>TestPropertyKeyIs</name> <block>{<block_content>
<label><name>public</name>:</label>



<decl_stmt><decl><type><name>explicit</name></type> <name>TestPropertyKeyIs</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>key</name></expr></argument>)</argument_list> <range>: <macro><name>key_</name><argument_list>(<argument>key</argument>)</argument_list></macro> <expr><block>{}</block>


<name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>TestProperty</name><operator>&amp;</operator> <name>test_property</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>test_property</name><operator>.</operator><name>key</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>key_</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>key_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>











<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>UnitTestOptions</name> <block>{<block_content>
<label><name>public</name>:</label>



<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>GetOutputFormat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>GetAbsolutePathToOutputFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>








<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PatternMatchesString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>FilterMatchesTest</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>test_case_name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>test_name</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_WINDOWS</name></expr></cpp:if>





<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>GTestShouldProcessSEH</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>exception_code</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>MatchesFilter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>name</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>filter</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function_decl><type><name>GTEST_API_</name> <name>FilePath</name></type> <name>GetCurrentExecutableName</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>class</name></type> <name>OsStackTraceGetterInterface</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>OsStackTraceGetterInterface</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>OsStackTraceGetterInterface</name><argument_list>()</argument_list></macro> <block>{}</block>







<name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>CurrentStackTrace</name><argument_list>(<argument>int max_depth</argument>, <argument>int skip_count</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>UponLeavingGTest</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name>kElidedFramesMarker</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>OsStackTraceGetterInterface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>OsStackTraceGetter</name> <range>: <expr><name>public</name> <name>OsStackTraceGetterInterface</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>OsStackTraceGetter</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>std</name><operator>::</operator><name>string</name> <macro><name>CurrentStackTrace</name><argument_list>(<argument>int max_depth</argument>, <argument>int skip_count</argument>)</argument_list></macro></expr>;
<expr><name>virtual</name> <name>void</name> <call><name>UponLeavingGTest</name><argument_list>()</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_ABSL</name></expr></cpp:if>
<name>Mutex</name> <name>mutex_</name></expr>;





<expr><name>void</name><operator>*</operator> <name>caller_frame_</name> <operator>=</operator> <name>nullptr</name></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>OsStackTraceGetter</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<struct>struct <name>TraceInfo</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>message</name></expr>;</expr_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name></type> <name>DefaultGlobalTestPartResultReporter</name>
<range>: <expr><name>public</name> <name>TestPartResultReporterInterface</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>DefaultGlobalTestPartResultReporter</name><argument_list>(<argument><expr><name>UnitTestImpl</name><operator>*</operator> <name>unit_test</name></expr></argument>)</argument_list></call></expr>;


<expr><name>virtual</name> <name>void</name> <call><name>ReportTestPartResult</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TestPartResult</name><operator>&amp;</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>UnitTestImpl</name><operator>*</operator> <specifier>const</specifier> <name>unit_test_</name></expr>;

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>DefaultGlobalTestPartResultReporter</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>DefaultPerThreadTestPartResultReporter</name>
<range>: <expr><name>public</name> <name>TestPartResultReporterInterface</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>DefaultPerThreadTestPartResultReporter</name><argument_list>(<argument><expr><name>UnitTestImpl</name><operator>*</operator> <name>unit_test</name></expr></argument>)</argument_list></call></expr>;


<expr><name>virtual</name> <name>void</name> <call><name>ReportTestPartResult</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TestPartResult</name><operator>&amp;</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>UnitTestImpl</name><operator>*</operator> <specifier>const</specifier> <name>unit_test_</name></expr>;

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>DefaultPerThreadTestPartResultReporter</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name> <name>GTEST_API_</name></type> <name>UnitTestImpl</name> <block>{<block_content>
<label><name>public</name>:</label>
<function_decl><type><name>explicit</name></type> <name>UnitTestImpl</name><parameter_list>(<parameter><decl><type><name>UnitTest</name><modifier>*</modifier></type> <name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>UnitTestImpl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>









<function_decl><type><name>TestPartResultReporterInterface</name><modifier>*</modifier></type> <name>GetGlobalTestPartResultReporter</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>SetGlobalTestPartResultReporter</name><parameter_list>(
<parameter><decl><type><name>TestPartResultReporterInterface</name><modifier>*</modifier></type> <name>reporter</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TestPartResultReporterInterface</name><modifier>*</modifier></type> <name>GetTestPartResultReporterForCurrentThread</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>SetTestPartResultReporterForCurrentThread</name><parameter_list>(
<parameter><decl><type><name>TestPartResultReporterInterface</name><modifier>*</modifier></type> <name>reporter</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>int</name> <macro><name>successful_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>failed_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>total_test_case_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>int</name> <macro><name>test_case_to_run_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>successful_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>skipped_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>failed_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>disabled_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>reportable_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>total_test_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>test_to_run_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>TimeInMillis</name> <macro><name>start_timestamp</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>start_timestamp_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>TimeInMillis</name> <macro><name>elapsed_time</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>elapsed_time_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>Passed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>Failed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>failed_test_case_count</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>ad_hoc_test_result</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>Failed</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>TestCase</name><modifier>*</modifier></type> <name>GetTestCase</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>GetElementOr</name><argument_list>(<argument><expr><name>test_case_indices_</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>test_cases_</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function><type><name>TestCase</name><modifier>*</modifier></type> <name>GetMutableTestCase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name> <init>= <expr><call><name>GetElementOr</name><argument_list>(<argument><expr><name>test_case_indices_</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>test_cases_</name><index>[<expr><name>index</name></expr>]</index></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><name>TestEventListeners</name><modifier>*</modifier></type> <name>listeners</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>&amp;</operator><name>listeners_</name></expr>;</return> </block_content>}</block></function>



<function_decl><type><name>TestResult</name><modifier>*</modifier></type> <name>current_test_result</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><specifier>const</specifier> <name>TestResult</name><operator>*</operator> <macro><name>ad_hoc_test_result</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>&amp;</operator><name>ad_hoc_test_result_</name></expr>;</return> }</block></expr></expr_stmt>






<function_decl><type><name>void</name></type> <name>set_os_stack_trace_getter</name><parameter_list>(<parameter><decl><type><name>OsStackTraceGetterInterface</name><modifier>*</modifier></type> <name>getter</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>OsStackTraceGetterInterface</name><modifier>*</modifier></type> <name>os_stack_trace_getter</name><parameter_list>()</parameter_list>;</function_decl>











<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>CurrentOsStackTraceExceptTop</name><argument_list>(<argument>int skip_count</argument>)</argument_list></macro> <name>GTEST_NO_INLINE_</name></expr>;</expr_stmt>











<decl_stmt><decl><type><name>TestCase</name><modifier>*</modifier></type> <name>GetTestCase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>test_case_name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>type_param</name></expr></argument>,
<argument><expr><name>Test</name><operator>::</operator><name>SetUpTestCaseFunc</name> <name>set_up_tc</name></expr></argument>,
<argument><expr><name>Test</name><operator>::</operator><name>TearDownTestCaseFunc</name> <name>tear_down_tc</name></expr></argument>)</argument_list></decl>;</decl_stmt>








<decl_stmt><decl><type><name>void</name></type> <name>AddTestInfo</name><argument_list>(<argument><expr><name>Test</name><operator>::</operator><name>SetUpTestCaseFunc</name> <name>set_up_tc</name></expr></argument>,
<argument><expr><name>Test</name><operator>::</operator><name>TearDownTestCaseFunc</name> <name>tear_down_tc</name></expr></argument>,
<argument><expr><name>TestInfo</name><operator>*</operator> <name>test_info</name></expr></argument>)</argument_list> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><call><name><name>original_working_dir_</name><operator>.</operator><name>IsEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>original_working_dir_</name><operator>.</operator><name>Set</name></name><argument_list>(<argument><expr><name>FilePath</name><operator>::</operator><call><name>GetCurrentDir</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>original_working_dir_</name><operator>.</operator><name>IsEmpty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Failed to get the current working directory."</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GetTestCase</name><argument_list>(<argument><expr><call><name><name>test_info</name><operator>-&gt;</operator><name>test_case_name</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>test_info</name><operator>-&gt;</operator><name>type_param</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>set_up_tc</name></expr></argument>,
<argument><expr><name>tear_down_tc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>AddTestInfo</name><argument_list>(<argument><expr><name>test_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><name>internal</name><operator>::</operator><name>ParameterizedTestCaseRegistry</name><operator>&amp;</operator> <macro><name>parameterized_test_registry</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>parameterized_test_registry_</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>set_current_test_case</name><parameter_list>(<parameter><decl><type><name>TestCase</name><modifier>*</modifier></type> <name>a_current_test_case</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>current_test_case_</name> <operator>=</operator> <name>a_current_test_case</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>set_current_test_info</name><parameter_list>(<parameter><decl><type><name>TestInfo</name><modifier>*</modifier></type> <name>a_current_test_info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>current_test_info_</name> <operator>=</operator> <name>a_current_test_info</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function_decl><type><name>void</name></type> <name>RegisterParameterizedTests</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>RunAllTests</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>ClearNonAdHocTestResult</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ForEach</name><argument_list>(<argument><expr><name>test_cases_</name></expr></argument>, <argument><expr><name>TestCase</name><operator>::</operator><name>ClearTestCaseResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ClearAdHocTestResult</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ad_hoc_test_result_</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function_decl><type><name>void</name></type> <name>RecordProperty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TestProperty</name><modifier>&amp;</modifier></type> <name>test_property</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>ReactionToSharding</name> <block>{
<decl><name>HONOR_SHARDING_PROTOCOL</name></decl>,
<decl><name>IGNORE_SHARDING_PROTOCOL</name></decl>
}</block>;</enum>







<function_decl><type><name>int</name></type> <name>FilterTests</name><parameter_list>(<parameter><decl><type><name>ReactionToSharding</name></type> <name>shard_tests</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ListTestsMatchingFilter</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>TestCase</name><operator>*</operator> <macro><name>current_test_case</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>current_test_case_</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>TestInfo</name><modifier>*</modifier></type> <name>current_test_info</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>current_test_info_</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>TestInfo</name><operator>*</operator> <macro><name>current_test_info</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>current_test_info_</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Environment</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>environments</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>environments_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TraceInfo</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>gtest_trace_stack</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><operator>(</operator><call><name><name>gtest_trace_stack_</name><operator>.</operator><name>pointer</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TraceInfo</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>gtest_trace_stack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>gtest_trace_stack_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_DEATH_TEST</name></expr></cpp:if>
<function><type><name>void</name></type> <name>InitDeathTestSubprocessControlInfo</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>internal_run_death_test_flag_</name><operator>.</operator><name>reset</name></name><argument_list>(<argument><expr><call><name>ParseInternalRunDeathTestFlag</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><specifier>const</specifier> <name>InternalRunDeathTestFlag</name><operator>*</operator> <macro><name>internal_run_death_test_flag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>internal_run_death_test_flag_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>DeathTestFactory</name><operator>*</operator> <macro><name>death_test_factory</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>death_test_factory_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>SuppressTestEventsIfInSubprocess</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ReplaceDeathTestFactory</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function_decl><type><name>void</name></type> <name>ConfigureXmlOutput</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_CAN_STREAM_RESULTS_</name></expr></cpp:if>


<function_decl><type><name>void</name></type> <name>ConfigureStreamingOutput</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function_decl><type><name>void</name></type> <name>PostFlagParsingInit</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>int</name> <macro><name>random_seed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>random_seed_</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>Random</name><operator>*</operator> <macro><name>random</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>&amp;</operator><name>random_</name></expr>;</return> }</block></expr></expr_stmt>



<function_decl><type><name>void</name></type> <name>ShuffleTests</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>UnshuffleTests</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>catch_exceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>catch_exceptions_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>testing</name><operator>::</operator><name>UnitTest</name></expr>;</expr_stmt>



<function><type><name>void</name></type> <name>set_catch_exceptions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>catch_exceptions_</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt> </block_content>}</block></function>


<decl_stmt><decl><type><name>UnitTest</name><modifier>*</modifier> <specifier>const</specifier></type> <name>parent_</name></decl>;</decl_stmt>



<expr_stmt><expr><name>internal</name><operator>::</operator><name>FilePath</name> <name>original_working_dir_</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>DefaultGlobalTestPartResultReporter</name></type> <name>default_global_test_part_result_reporter_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DefaultPerThreadTestPartResultReporter</name></type>
<name>default_per_thread_test_part_result_reporter_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TestPartResultReporterInterface</name><modifier>*</modifier></type> <name>global_test_part_result_repoter_</name></decl>;</decl_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>Mutex</name> <name>global_test_part_result_reporter_mutex_</name></expr>;</expr_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><expr><name>TestPartResultReporterInterface</name><operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>per_thread_test_part_result_reporter_</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Environment</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>environments_</name></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TestCase</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>test_cases_</name></expr>;</expr_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>test_case_indices_</name></expr>;</expr_stmt>



<expr_stmt><expr><name>internal</name><operator>::</operator><name>ParameterizedTestCaseRegistry</name> <name>parameterized_test_registry_</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>parameterized_tests_registered_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>last_death_test_case_</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>TestCase</name><modifier>*</modifier></type> <name>current_test_case_</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>TestInfo</name><modifier>*</modifier></type> <name>current_test_info_</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name>TestResult</name></type> <name>ad_hoc_test_result_</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>TestEventListeners</name></type> <name>listeners_</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>OsStackTraceGetterInterface</name><modifier>*</modifier></type> <name>os_stack_trace_getter_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>post_flag_parse_init_performed_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>random_seed_</name></decl>;</decl_stmt>


<expr_stmt><expr><name>internal</name><operator>::</operator><name>Random</name> <name>random_</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TimeInMillis</name></type> <name>start_timestamp_</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TimeInMillis</name></type> <name>elapsed_time_</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_DEATH_TEST</name></expr></cpp:if>


<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name>InternalRunDeathTestFlag</name></expr></argument>&gt;</argument_list></name> <name>internal_run_death_test_flag_</name></expr>;</expr_stmt>
<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name>internal</name><operator>::</operator><name>DeathTestFactory</name></expr></argument>&gt;</argument_list></name> <name>death_test_factory_</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>internal</name><operator>::</operator><name><name>ThreadLocal</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>TraceInfo</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <name>gtest_trace_stack_</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>catch_exceptions_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>UnitTestImpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function><type><specifier>inline</specifier> <name>UnitTestImpl</name><modifier>*</modifier></type> <name>GetUnitTestImpl</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>UnitTest</name><operator>::</operator><call><name>GetInstance</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>impl</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_USES_SIMPLE_RE</name></expr></cpp:if>



<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsInSet</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsAsciiDigit</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsAsciiPunct</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsRepeat</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsAsciiWhiteSpace</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsAsciiWordChar</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>IsValidEscape</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>AtomMatchesChar</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>escaped</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>ValidateRegex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>regex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>MatchRegexAtHead</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>regex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>MatchRepetitionAndRegexAtHead</name><parameter_list>(
<parameter><decl><type><name>bool</name></type> <name>escaped</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>repeat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>regex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>bool</name></type> <name>MatchRegexAnywhere</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>regex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>ParseGoogleTestFlagsOnly</name><parameter_list>(<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>GTEST_API_</name> <name>void</name></type> <name>ParseGoogleTestFlagsOnly</name><parameter_list>(<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_HAS_DEATH_TEST</name></expr></cpp:if>



<expr_stmt><expr><name>GTEST_API_</name> <name>std</name><operator>::</operator><name>string</name> <call><name>GetLastErrnoDescription</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Integer</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>ParseNaturalNumber</name><argument_list>(<argument><expr><specifier>const</specifier> <operator>::</operator><name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>str</name></expr></argument>, <argument><expr><name>Integer</name><operator>*</operator> <name>number</name></expr></argument>)</argument_list> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name><name>str</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsDigit</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>end</name></decl>;</decl_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_OS_WINDOWS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>


<typedef>typedef <type><name>unsigned</name> <name>__int64</name></type> <name>BiggestConvertible</name>;</typedef>
<decl_stmt><decl><type><specifier>const</specifier> <name>BiggestConvertible</name></type> <name>parsed</name> <init>= <expr><call><name>_strtoui64</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>BiggestConvertible</name>;</typedef>
<decl_stmt><decl><type><specifier>const</specifier> <name>BiggestConvertible</name></type> <name>parsed</name> <init>= <expr><call><name>strtoull</name><argument_list>(<argument><expr><call><name><name>str</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>parse_success</name> <init>= <expr><operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>parsed</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Integer</name></type> <name>result</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Integer</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>parsed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>parse_success</name> <operator>&amp;&amp;</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>BiggestConvertible</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>parsed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>number</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<decl_stmt><decl><type><name>class</name></type> <name>TestResultAccessor</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>RecordProperty</name><argument_list>(<argument><expr><name>TestResult</name><operator>*</operator> <name>test_result</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>xml_element</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TestProperty</name><operator>&amp;</operator> <name>property</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>test_result</name><operator>-&gt;</operator><name>RecordProperty</name></name><argument_list>(<argument><expr><name>xml_element</name></expr></argument>, <argument><expr><name>property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ClearTestPartResults</name><parameter_list>(<parameter><decl><type><name>TestResult</name><modifier>*</modifier></type> <name>test_result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>test_result</name><operator>-&gt;</operator><name>ClearTestPartResults</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>testing</name><operator>::</operator><name>TestPartResult</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <macro><name>test_part_results</name><argument_list>(
<argument>const TestResult&amp; test_result</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>test_result</name><operator>.</operator><name>test_part_results</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GTEST_CAN_STREAM_RESULTS_</name></expr></cpp:if>


<decl_stmt><decl><type><name>class</name></type> <name>StreamingListener</name> <range>: <expr><name>public</name> <name>EmptyTestEventListener</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>class</name> <name>AbstractSocketWriter</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><macro><name>AbstractSocketWriter</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>void</name> <call><name>Send</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>message</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>virtual</name> <name>void</name> <macro><name>CloseConnection</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>SendLn</name><argument_list>(<argument>const std::string&amp; message</argument>)</argument_list></macro> <block>{ <expr><call><name>Send</name><argument_list>(<argument><expr><name>message</name> <operator>+</operator> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr>;


<expr><name>class</name> <name>SocketWriter</name> <operator>:</operator> <name>public</name> <name>AbstractSocketWriter</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SocketWriter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>host</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>port</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>sockfd_</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>host_name_</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>, <macro><name>port_num_</name><argument_list>(<argument>port</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>MakeConnection</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>virtual</name> <operator>~</operator><macro><name>SocketWriter</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>sockfd_</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CloseConnection</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>


<name>virtual</name> <name>void</name> <macro><name>Send</name><argument_list>(<argument>const std::string&amp; message</argument>)</argument_list></macro> <block>{
<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>sockfd_</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"Send() can be called only when there is a connection."</literal></expr>;

<expr><specifier>const</specifier> <name>int</name> <name>len</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>message</name><operator>.</operator><name>length</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>sockfd_</name></expr></argument>, <argument><expr><call><name><name>message</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GTEST_LOG_</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"stream_result_to: failed to stream to "</literal>
<operator>&lt;&lt;</operator> <name>host_name_</name> <operator>&lt;&lt;</operator> <literal type="string">":"</literal> <operator>&lt;&lt;</operator> <name>port_num_</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

private:

void MakeConnection(</block></if></if_stmt>)</block></expr>;


<expr><name>void</name> <macro><name>CloseConnection</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>GTEST_CHECK_</name><argument_list>(<argument><expr><name>sockfd_</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"CloseConnection() can be called only when there is a connection."</literal></expr>;

<expr><call><name>close</name><argument_list>(<argument><expr><name>sockfd_</name></expr></argument>)</argument_list></call></expr>;
<expr><name>sockfd_</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;
}</block>

<name>int</name> <name>sockfd_</name></expr>;
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>host_name_</name></expr>;
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>port_num_</name></expr>;

<expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>SocketWriter</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;


<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>UrlEncode</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;

<expr><call><name>StreamingListener</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>host</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name><operator>&amp;</operator> <name>port</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>socket_writer_</name><argument_list>(<argument>new SocketWriter(host, port)</argument>)</argument_list></macro> <block>{
<expr><call><name>Start</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>explicit</name> <call><name>StreamingListener</name><argument_list>(<argument><expr><name>AbstractSocketWriter</name><operator>*</operator> <name>socket_writer</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>socket_writer_</name><argument_list>(<argument>socket_writer</argument>)</argument_list></macro> <block>{ <expr><call><name>Start</name><argument_list>()</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>OnTestProgramStart</name><argument_list>(<argument>const UnitTest&amp;</argument> )</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestProgramStart"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestProgramEnd</name><argument_list>(<argument>const UnitTest&amp; unit_test</argument>)</argument_list></macro> <block>{


<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestProgramEnd&amp;passed="</literal> <operator>+</operator> <call><name>FormatBool</name><argument_list>(<argument><expr><call><name><name>unit_test</name><operator>.</operator><name>Passed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;


<expr><call><name><name>socket_writer_</name><operator>-&gt;</operator><name>CloseConnection</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestIterationStart</name><argument_list>(<argument>const UnitTest&amp;</argument> , <argument>int iteration</argument>)</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestIterationStart&amp;iteration="</literal> <operator>+</operator>
<call><name>StreamableToString</name><argument_list>(<argument><expr><name>iteration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestIterationEnd</name><argument_list>(<argument>const UnitTest&amp; unit_test</argument>, <argument>int</argument> )</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestIterationEnd&amp;passed="</literal> <operator>+</operator>
<call><name>FormatBool</name><argument_list>(<argument><expr><call><name><name>unit_test</name><operator>.</operator><name>Passed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"&amp;elapsed_time="</literal> <operator>+</operator>
<call><name>StreamableToString</name><argument_list>(<argument><expr><call><name><name>unit_test</name><operator>.</operator><name>elapsed_time</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"ms"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestCaseStart</name><argument_list>(<argument>const TestCase&amp; test_case</argument>)</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"event=TestCaseStart&amp;name="</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>test_case</name><operator>.</operator><name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestCaseEnd</name><argument_list>(<argument>const TestCase&amp; test_case</argument>)</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestCaseEnd&amp;passed="</literal> <operator>+</operator> <call><name>FormatBool</name><argument_list>(<argument><expr><call><name><name>test_case</name><operator>.</operator><name>Passed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>+</operator> <literal type="string">"&amp;elapsed_time="</literal> <operator>+</operator> <call><name>StreamableToString</name><argument_list>(<argument><expr><call><name><name>test_case</name><operator>.</operator><name>elapsed_time</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>+</operator> <literal type="string">"ms"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestStart</name><argument_list>(<argument>const TestInfo&amp; test_info</argument>)</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><literal type="string">"event=TestStart&amp;name="</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name><name>test_info</name><operator>.</operator><name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestEnd</name><argument_list>(<argument>const TestInfo&amp; test_info</argument>)</argument_list></macro> <block>{
<expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestEnd&amp;passed="</literal> <operator>+</operator>
<call><name>FormatBool</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>test_info</name><operator>.</operator><name>result</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>-&gt;</operator><call><name>Passed</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="string">"&amp;elapsed_time="</literal> <operator>+</operator>
<call><name>StreamableToString</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>test_info</name><operator>.</operator><name>result</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>-&gt;</operator><call><name>elapsed_time</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">"ms"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>OnTestPartResult</name><argument_list>(<argument>const TestPartResult&amp; test_part_result</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>char</name><operator>*</operator> <name>file_name</name> <operator>=</operator> <call><name><name>test_part_result</name><operator>.</operator><name>file_name</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>file_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>file_name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"event=TestPartResult&amp;file="</literal> <operator>+</operator> <call><name>UrlEncode</name><argument_list>(<argument><expr><name>file_name</name></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="string">"&amp;line="</literal> <operator>+</operator> <call><name>StreamableToString</name><argument_list>(<argument><expr><call><name><name>test_part_result</name><operator>.</operator><name>line_number</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
<literal type="string">"&amp;message="</literal> <operator>+</operator> <call><name>UrlEncode</name><argument_list>(<argument><expr><call><name><name>test_part_result</name><operator>.</operator><name>message</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
}</block>

<name>private</name><operator>:</operator>

<name>void</name> <macro><name>SendLn</name><argument_list>(<argument>const std::string&amp; message</argument>)</argument_list></macro> <block>{ <expr><call><name><name>socket_writer_</name><operator>-&gt;</operator><name>SendLn</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>; }</block>



<name>void</name> <macro><name>Start</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>SendLn</name><argument_list>(<argument><expr><literal type="string">"gtest_streaming_protocol_version=1.0"</literal></expr></argument>)</argument_list></call></expr>; }</block>

<name>std</name><operator>::</operator><name>string</name> <macro><name>FormatBool</name><argument_list>(<argument>bool value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>value</name> <operator>?</operator> <literal type="string">"1"</literal> <operator>:</operator> <literal type="string">"0"</literal></expr>;</return> }</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>scoped_ptr</name><argument_list type="generic">&lt;<argument><expr><name>AbstractSocketWriter</name></expr></argument>&gt;</argument_list></name></type> <name>socket_writer_</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GTEST_DISALLOW_COPY_AND_ASSIGN_</name><argument_list>(<argument><expr><name>StreamingListener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></decl></decl_stmt>
}

GTEST_DISABLE_MSC_WARNINGS_POP_<expr><operator>(</operator><operator>)</operator></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
