<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libedit/filecomplete.c">






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SCCSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>__RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: filecomplete.c,v 1.68 2021/05/05 14:49:59 christos Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"el.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filecomplete.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>wchar_t</name></type> <name><name>break_chars</name><index>[]</index></name> <init>= <expr><literal type="string">L" \t\n\"\\'`@$&gt;&lt;=;|&amp;{("</literal></expr></init></decl>;</decl_stmt>











<function><type><name>char</name> <modifier>*</modifier></type>
<name>fn_tilde_expand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>txt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_POSIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_DRAFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pwres</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pwbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>txt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>txt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>txt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>temp</name> <operator>-</operator> <name>txt</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>txt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>getpwuid_r</name><argument_list>(<argument><expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwres</name></expr></argument>, <argument><expr><name>pwbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>&amp;</operator><name>pass</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_GETPW_R_DRAFT</name></expr></cpp:elif>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <call><name>getpwuid_r</name><argument_list>(<argument><expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwres</name></expr></argument>, <argument><expr><name>pwbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>getpwnam_r</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwres</name></expr></argument>, <argument><expr><name>pwbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pass</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_GETPW_R_DRAFT</name></expr></cpp:elif>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <call><name>getpwnam_r</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwres</name></expr></argument>, <argument><expr><name>pwbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pass</name> <operator>=</operator> <call><name>getpwnam</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>txt</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>, <argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>needs_escaping</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<case>case <expr><literal type="char">')'</literal></expr>:</case>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<case>case <expr><literal type="char">';'</literal></expr>:</case>
<case>case <expr><literal type="char">'`'</literal></expr>:</case>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<case>case <expr><literal type="char">'='</literal></expr>:</case>
<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<case>case <expr><literal type="char">'{'</literal></expr>:</case>
<case>case <expr><literal type="char">'}'</literal></expr>:</case>
<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>needs_dquote_escaping</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<case>case <expr><literal type="char">'`'</literal></expr>:</case>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>wchar_t</name> <modifier>*</modifier></type>
<name>unescape_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>unescaped</name> <init>= <expr><call><name>el_calloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>string</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>unescaped</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>string</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>unescaped</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>string</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>unescaped</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>unescaped</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>escape_filename</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type> <name>el</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>single_match</name></decl></parameter>,
<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>app_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>original_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>escaped_character_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>newlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_quoted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>d_quoted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escaped_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name><name>el</name><operator>-&gt;</operator><name>el_line</name><operator>.</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>append_char</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>temp</name> <operator>!=</operator> <name><name>el</name><operator>-&gt;</operator><name>el_line</name><operator>.</operator><name>cursor</name></name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>d_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s_quoted</name> <operator>=</operator> <operator>!</operator><name>s_quoted</name></expr>;</expr_stmt></block_content></block></if>



<if type="elseif">else if <condition>(<expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>s_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>d_quoted</name> <operator>=</operator> <operator>!</operator><name>d_quoted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>temp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>




<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>filename</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>original_len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s_quoted</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>escaped_character_count</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>d_quoted</name> <operator>&amp;&amp;</operator> <call><name>needs_dquote_escaping</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>escaped_character_count</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s_quoted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>d_quoted</name> <operator>&amp;&amp;</operator> <call><name>needs_escaping</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>escaped_character_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>original_len</name> <operator>+</operator> <name>escaped_character_count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s_quoted</name> <operator>||</operator> <name>d_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newlen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>single_match</name> <operator>&amp;&amp;</operator> <name>app_func</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newlen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>escaped_str</name> <operator>=</operator> <call><name>el_malloc</name><argument_list>(<argument><expr><name>newlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>filename</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>needs_escaping</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name>s_quoted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>s_quoted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>d_quoted</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>needs_dquote_escaping</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>single_match</name> <operator>&amp;&amp;</operator> <name>app_func</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>append_char</name> <operator>=</operator> <call><name>app_func</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>append_char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s_quoted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>d_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>append_char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>append_char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>single_match</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>append_char</name> <operator>&amp;&amp;</operator> <name><name>append_char</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>d_quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>escaped_str</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>escaped_str</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>char</name> <modifier>*</modifier></type>
<name>fn_filename_completion_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>DIR</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dirname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dirpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>filename_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nptr</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nptr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>nptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strcpy</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>temp</name> <operator>-</operator> <name>text</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>nptr</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
<sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nptr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dirname</name> <operator>=</operator> <name>nptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>text</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirpath</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dirname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dirname</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dirpath</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"./"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>dirname</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dirpath</name> <operator>=</operator> <call><name>fn_tilde_expand</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dirpath</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dirpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>filename_len</name> <operator>=</operator> <ternary><condition><expr><name>filename</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>filename_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>filename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_STRUCT_DIRENT_D_NAMLEN</name></expr></cpp:if>
<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>d_namlen</name></name> <operator>&gt;=</operator> <name>filename_len</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>filename_len</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>filename_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_STRUCT_DIRENT_D_NAMLEN</name></expr></cpp:if>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>d_namlen</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>append_char_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expname</name> <init>= <expr><ternary><condition><expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'~'</literal></expr> ?</condition><then> <expr><call><name>fn_tilde_expand</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rs</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><ternary><condition><expr><name>expname</name></expr> ?</condition><then> <expr><name>expname</name></expr> </then><else>: <expr><name>name</name></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>stbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>stbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rs</name> <operator>=</operator> <literal type="string">"/"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>expname</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>expname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>rs</name></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>completion_matches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>completion_matches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>genfunc</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>match_list</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>retstr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prevstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>match_list_len</name></decl>, <decl><type ref="prev"/><name>max_equal</name></decl>, <decl><type ref="prev"/><name>which</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>matches</name></decl>;</decl_stmt>

<expr_stmt><expr><name>matches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>match_list_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>retstr</name> <operator>=</operator> <call>(<modifier>*</modifier><name>genfunc</name>) <argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>matches</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>matches</name> <operator>+</operator> <literal type="number">3</literal> <operator>&gt;=</operator> <name>match_list_len</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nmatch_list</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>matches</name> <operator>+</operator> <literal type="number">3</literal> <operator>&gt;=</operator> <name>match_list_len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match_list_len</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>nmatch_list</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>match_list</name></expr></argument>,
<argument><expr><name>match_list_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nmatch_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nmatch_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>match_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>match_list</name> <operator>=</operator> <name>nmatch_list</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>match_list</name><index>[<expr><operator>++</operator><name>matches</name></expr>]</index></name> <operator>=</operator> <name>retstr</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_list</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>which</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prevstr</name> <operator>=</operator> <name><name>match_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_equal</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>prevstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>which</name> <operator>&lt;=</operator> <name>matches</name></expr>;</condition> <incr><expr><name>which</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_equal</name> <operator>&amp;&amp;</operator>
<name><name>prevstr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>match_list</name><index>[<expr><name>which</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name>max_equal</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>retstr</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>max_equal</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>retstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>retstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>match_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name><name>match_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>max_equal</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>match_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>retstr</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>match_list</name><index>[<expr><name>matches</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>match_list</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>_fn_qsort_string_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>i2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>i1</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>i2</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>fn_display_match_list</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type> <name>el</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>matches</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>width</name></decl></parameter>,
<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>app_func</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>line</name></decl>, <decl><type ref="prev"/><name>lines</name></decl>, <decl><type ref="prev"/><name>col</name></decl>, <decl><type ref="prev"/><name>cols</name></decl>, <decl><type ref="prev"/><name>thisguy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>screenwidth</name> <init>= <expr><name><name>el</name><operator>-&gt;</operator><name>el_terminal</name><operator>.</operator><name>t_size</name><operator>.</operator><name>h</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>app_func</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>app_func</name> <operator>=</operator> <name>append_char_function</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>matches</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name><operator>--</operator></expr>;</expr_stmt>





<expr_stmt><expr><name>cols</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>screenwidth</name> <operator>/</operator> <operator>(</operator><name>width</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cols</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>lines</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>+</operator> <name>cols</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>cols</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>_fn_qsort_string_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>line</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>line</name> <operator>&lt;</operator> <name>lines</name></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name>cols</name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>thisguy</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>col</name> <operator>*</operator> <name>lines</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>thisguy</name> <operator>&gt;=</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>col</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>matches</name><index>[<expr><name>thisguy</name></expr>]</index></name></expr></argument>,
<argument><expr><call>(<modifier>*</modifier><name>app_func</name>)<argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>thisguy</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>, <argument><expr><literal type="string">"%-*s"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>width</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>thisguy</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>wchar_t</name> <modifier>*</modifier></type>
<name>find_word_to_complete</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>cursor</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>buffer</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>word_break</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>special_prefixes</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type> <name>length</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>do_unescape</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>ctemp</name> <init>= <expr><name>cursor</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>ctemp</name> <operator>&gt;</operator> <name>buffer</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>ctemp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<expr_stmt><expr><name>ctemp</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctemp</name> <operator>&lt;=</operator> <name>buffer</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>wcschr</name><argument_list>(<argument><expr><name>word_break</name></expr></argument>, <argument><expr><name><name>ctemp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ctemp</name> <operator>-</operator> <name>buffer</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ctemp</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctemp</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>special_prefixes</name> <operator>&amp;&amp;</operator> <call><name>wcschr</name><argument_list>(<argument><expr><name>special_prefixes</name></expr></argument>, <argument><expr><name><name>ctemp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ctemp</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>cursor</name> <operator>-</operator> <name>ctemp</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ctemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <name><name>ctemp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ctemp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>do_unescape</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>unescaped_word</name> <init>= <expr><call><name>unescape_string</name><argument_list>(<argument><expr><name>ctemp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>unescaped_word</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>unescaped_word</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>el_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>wcsncpy</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>ctemp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>temp</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>temp</name></expr>;</return>
</block_content>}</block></function>













<function><type><name>int</name></type>
<name>fn_complete2</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type><name>el</name></decl></parameter>,
<parameter><function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>complete_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>(<modifier>*</modifier><name>attempted_completion_function</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>word_break</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>special_prefixes</name></decl></parameter>,
<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>app_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>query_items</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>completion_type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>over</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>point</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>LineInfoW</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>matches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>completion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>what_to_do</name> <init>= <expr><literal type="char">'\t'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>CC_NORM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>do_unescape</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FN_QUOTE_MATCH</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>el</name><operator>-&gt;</operator><name>el_state</name><operator>.</operator><name>lastcmd</name></name> <operator>==</operator> <name><name>el</name><operator>-&gt;</operator><name>el_state</name><operator>.</operator><name>thiscmd</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>what_to_do</name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>completion_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>completion_type</name> <operator>=</operator> <name>what_to_do</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>complete_func</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>complete_func</name> <operator>=</operator> <name>fn_filename_completion_function</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>app_func</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>app_func</name> <operator>=</operator> <name>append_char_function</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>el_wline</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>find_word_to_complete</name><argument_list>(<argument><expr><name><name>li</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>,
<argument><expr><name><name>li</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>word_break</name></expr></argument>, <argument><expr><name>special_prefixes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>do_unescape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>point</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>point</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>li</name><operator>-&gt;</operator><name>cursor</name></name> <operator>-</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>li</name><operator>-&gt;</operator><name>lastchar</name></name> <operator>-</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>attempted_completion_function</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cur_off</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>li</name><operator>-&gt;</operator><name>cursor</name></name> <operator>-</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>matches</name> <operator>=</operator> <call>(<modifier>*</modifier><name>attempted_completion_function</name>)<argument_list>(
<argument><expr><call><name>ct_encode_string</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>el</name><operator>-&gt;</operator><name>el_scratch</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>cur_off</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>cur_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>attempted_completion_function</name> <operator>||</operator>
<operator>(</operator><name>over</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>over</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>matches</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>matches</name> <operator>=</operator> <call><name>completion_matches</name><argument_list>(
<argument><expr><call><name>ct_encode_string</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>el</name><operator>-&gt;</operator><name>el_scratch</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>complete_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>over</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>over</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>matches</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>matches_num</name></decl>, <decl><type ref="prev"/><name>maxlen</name></decl>, <decl><type ref="prev"/><name>match_len</name></decl>, <decl><type ref="prev"/><name>match_display</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>single_match</name> <init>= <expr><name><name>matches</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>matches</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>CC_REFRESH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_deletestr</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FN_QUOTE_MATCH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>completion</name> <operator>=</operator> <call><name>escape_filename</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>single_match</name></expr></argument>, <argument><expr><name>app_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>completion</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>completion</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out2</name>;</goto></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>el_winsertstr</name><argument_list>(<argument><expr><name>el</name></expr></argument>,
<argument><expr><call><name>ct_decode_string</name><argument_list>(<argument><expr><name>completion</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>el</name><operator>-&gt;</operator><name>el_scratch</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>single_match</name> <operator>&amp;&amp;</operator> <name>attempted_completion_function</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FN_QUOTE_MATCH</name><operator>)</operator></expr>)</condition>
<block>{<block_content>






<expr_stmt><expr><call><name>el_winsertstr</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><call><name>ct_decode_string</name><argument_list>(
<argument><expr><call>(<modifier>*</modifier><name>app_func</name>)<argument_list>(<argument><expr><name>completion</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>el</name><operator>-&gt;</operator><name>el_scratch</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>completion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>single_match</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>what_to_do</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <name>what_to_do</name> <operator>==</operator> <literal type="char">'?'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>





<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>maxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>match_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>match_len</name> <operator>&gt;</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>match_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>matches_num</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>matches_num</name> <operator>&gt;</operator> <name>query_items</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>,
<argument><expr><literal type="string">"Display all %zu possibilities? (y or n) "</literal></expr></argument>,
<argument><expr><name>matches_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getc</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'y'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match_display</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_outfile</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match_display</name></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><call><name>fn_display_match_list</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>,
<argument><expr><name>matches_num</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr><name>app_func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>CC_REDISPLAY</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>matches</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>el_beep</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>el_beep</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>CC_NORM</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<label><name>out2</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name><name>matches</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>fn_complete</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type><name>el</name></decl></parameter>,
<parameter><function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>complete_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>(<modifier>*</modifier><name>attempted_completion_function</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>word_break</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>special_prefixes</name></decl></parameter>,
<parameter><function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>app_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>query_items</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>completion_type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>over</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>point</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>fn_complete2</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>complete_func</name></expr></argument>, <argument><expr><name>attempted_completion_function</name></expr></argument>,
<argument><expr><name>word_break</name></expr></argument>, <argument><expr><name>special_prefixes</name></expr></argument>, <argument><expr><name>app_func</name></expr></argument>, <argument><expr><name>query_items</name></expr></argument>,
<argument><expr><name>completion_type</name></expr></argument>, <argument><expr><name>over</name></expr></argument>, <argument><expr><name>point</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>attempted_completion_function</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>FN_QUOTE_MATCH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type>
<name>_el_fn_complete</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name></expr></argument>, <argument><expr><name>int</name> <name>ch</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>fn_complete</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>break_chars</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">100</literal></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>unsigned</name> <name>char</name></type>
<name>_el_fn_sh_complete</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>_el_fn_complete</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
