<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libedit/readline.c">






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SCCSID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>__RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: readline.c,v 1.168 2021/09/10 18:51:36 rillig Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vis.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"readline/readline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"el.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fcns.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"filecomplete.h"</cpp:file></cpp:include>

<function_decl><type><name>void</name></type> <name>rl_prep_terminal</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rl_deprep_terminal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAB</name></cpp:macro> <cpp:value>'\r'</cpp:value></cpp:define>






<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_library_version</name> <init>= <expr><literal type="string">"EditLine wrapper"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_readline_version</name> <init>= <expr><name>RL_READLINE_VERSION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>empty</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>expand_chars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'\t'</literal></expr>, <expr><literal type="char">'\n'</literal></expr>, <expr><literal type="char">'='</literal></expr>, <expr><literal type="char">'('</literal></expr>, <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>break_chars</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'\t'</literal></expr>, <expr><literal type="char">'\n'</literal></expr>, <expr><literal type="char">'"'</literal></expr>, <expr><literal type="char">'\\'</literal></expr>, <expr><literal type="char">'\''</literal></expr>, <expr><literal type="char">'`'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'$'</literal></expr>,
<expr><literal type="char">'&gt;'</literal></expr>, <expr><literal type="char">'&lt;'</literal></expr>, <expr><literal type="char">'='</literal></expr>, <expr><literal type="char">';'</literal></expr>, <expr><literal type="char">'|'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'{'</literal></expr>, <expr><literal type="char">'('</literal></expr>, <expr><literal type="char">'\0'</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_readline_name</name> <init>= <expr><name>empty</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>rl_instream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>rl_outstream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_point</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rl_line_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rl_vcpfunc_t</name> <modifier>*</modifier></type><name>rl_linefunc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rl_hook_func_t</name> <modifier>*</modifier></type><name>rl_event_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KEYMAP_ENTRY_ARRAY</name></type> <name>emacs_standard_keymap</name></decl>,
<decl><type ref="prev"/><name>emacs_meta_keymap</name></decl>,
<decl><type ref="prev"/><name>emacs_ctlx_keymap</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>int</name></type> <name>rl_catch_signals</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_catch_sigwinch</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>history_base</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>history_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>history_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_input_history</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>history_expansion_char</name> <init>= <expr><literal type="char">'!'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>history_subst_char</name> <init>= <expr><literal type="char">'^'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>history_no_expand_chars</name> <init>= <expr><name>expand_chars</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Function</name> <modifier>*</modifier></type><name>history_inhibit_expansion_function</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>history_arg_extract</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>int</name></type> <name>rl_inhibit_completion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_attempted_completion_over</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_basic_word_break_characters</name> <init>= <expr><name>break_chars</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rl_completer_word_break_characters</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_completer_quote_characters</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_basic_quote_characters</name> <init>= <expr><literal type="string">"\"'"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rl_compentry_func_t</name> <modifier>*</modifier></type><name>rl_completion_entry_function</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>rl_completion_word_break_hook</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<decl_stmt><decl><type><name>rl_completion_func_t</name> <modifier>*</modifier></type><name>rl_attempted_completion_function</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Function</name> <modifier>*</modifier></type><name>rl_pre_input_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Function</name> <modifier>*</modifier></type><name>rl_startup1_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>rl_getc_function</name>)<parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rl_terminal_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_already_prompted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_filename_completion_desired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_ignore_completion_duplicates</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>readline_echoing_p</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_rl_print_completions_horizontally</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VFunction</name> <modifier>*</modifier></type><name>rl_redisplay_function</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Function</name> <modifier>*</modifier></type><name>rl_startup_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VFunction</name> <modifier>*</modifier></type><name>rl_completion_display_matches_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VFunction</name> <modifier>*</modifier></type><name>rl_prep_term_function</name> <init>= <expr><operator>(</operator><name>VFunction</name> <operator>*</operator><operator>)</operator><name>rl_prep_terminal</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VFunction</name> <modifier>*</modifier></type><name>rl_deprep_term_function</name> <init>= <expr><operator>(</operator><name>VFunction</name> <operator>*</operator><operator>)</operator><name>rl_deprep_terminal</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>KEYMAP_ENTRY_ARRAY</name></type> <name>emacs_meta_keymap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rl_readline_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_rl_complete_mark_directories</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rl_icppfunc_t</name> <modifier>*</modifier></type><name>rl_directory_completion_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_completion_suppress_append</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rl_sort_completion_matches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_rl_completion_prefix_display_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>_rl_echoing_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>history_max_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rl_display_prompt</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rl_prompt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>rl_completion_type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>rl_completion_query_items</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rl_special_prefixes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>rl_completion_append_character</name> <init>= <expr><literal type="char">' '</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>History</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>EditLine</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>rl_command_func_t</name> <modifier>*</modifier></type><name><name>map</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>jmp_buf</name></type> <name>topbuf</name></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>_el_rl_complete</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>_el_rl_tstp</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_get_prompt</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_getc_function</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>wchar_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_history_expand_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_rl_compat_sub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_rl_event_read_char</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>wchar_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_rl_update_pos</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>HIST_ENTRY</name></type> <name>rl_he</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_get_prompt</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><name>rl_already_prompted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>rl_prompt</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>

<name>_getc_function</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wchar_t</name> <operator>*</operator><name>c</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call>(<modifier>*</modifier><name>rl_getc_function</name>)<argument_list>(<argument><expr><name>rl_instream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_resize_fun</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>LineInfo</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ap</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>li</name> <operator>=</operator> <call><name>el_line</name><argument_list>(<argument><expr><name>el</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ap</name> <operator>=</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_default_history_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><literal type="string">"/.history"</literal></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>path</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s/.history"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>int</name></type>
<name>rl_set_prompt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prompt</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rl_prompt</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>rl_prompt</name></expr></argument>, <argument><expr><name>prompt</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rl_prompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>rl_prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rl_prompt</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rl_prompt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>rl_prompt</name></expr></argument>, <argument><expr><name>RL_PROMPT_END_IGNORE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>RL_PROMPT_START_IGNORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>RL_PROMPT_START_IGNORE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>rl_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>editmode</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>termios</name></name></type> <name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>history_end</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rl_instream</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rl_instream</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rl_outstream</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rl_outstream</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>tcgetattr</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>rl_instream</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>t</name><operator>.</operator><name>c_lflag</name></name> <operator>&amp;</operator> <name>ECHO</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>editmode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>el_init_internal</name><argument_list>(<argument><expr><name>rl_readline_name</name></expr></argument>, <argument><expr><name>rl_instream</name></expr></argument>, <argument><expr><name>rl_outstream</name></expr></argument>,
<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>rl_instream</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>rl_outstream</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NO_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>editmode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_EDITMODE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>history_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <operator>!</operator><name>h</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SETSIZE</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>history_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max_input_history</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_HIST</name></expr></argument>, <argument><expr><name>history</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_RESIZE</name></expr></argument>, <argument><expr><name>_resize_fun</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl_line_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>rl_getc_function</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_GETCFN</name></expr></argument>, <argument><expr><name>_getc_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>rl_set_prompt</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>history_end</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_PROMPT_ESC</name></expr></argument>, <argument><expr><name>_get_prompt</name></expr></argument>, <argument><expr><name>RL_PROMPT_START_IGNORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_SIGNAL</name></expr></argument>, <argument><expr><name>rl_catch_signals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_EDITOR</name></expr></argument>, <argument><expr><literal type="string">"emacs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rl_terminal_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_TERMINAL</name></expr></argument>, <argument><expr><name>rl_terminal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_get</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_TERMINAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl_terminal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>





<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_ADDFN</name></expr></argument>, <argument><expr><literal type="string">"rl_complete"</literal></expr></argument>,
<argument><expr><literal type="string">"ReadLine compatible completion function"</literal></expr></argument>,
<argument><expr><name>_el_rl_complete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"^I"</literal></expr></argument>, <argument><expr><literal type="string">"rl_complete"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_ADDFN</name></expr></argument>, <argument><expr><literal type="string">"rl_tstp"</literal></expr></argument>,
<argument><expr><literal type="string">"ReadLine compatible suspend function"</literal></expr></argument>,
<argument><expr><name>_el_rl_tstp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"^Z"</literal></expr></argument>, <argument><expr><literal type="string">"rl_tstp"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"^R"</literal></expr></argument>, <argument><expr><literal type="string">"em-inc-search-prev"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[1~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-beg"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[4~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-end"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[7~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-beg"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[8~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-end"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[H"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-beg"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[F"</literal></expr></argument>, <argument><expr><literal type="string">"ed-move-to-end"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[3~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-delete-next-char"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[2~"</literal></expr></argument>, <argument><expr><literal type="string">"ed-quoted-insert"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[1;5C"</literal></expr></argument>, <argument><expr><literal type="string">"em-next-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[1;5D"</literal></expr></argument>, <argument><expr><literal type="string">"ed-prev-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[5C"</literal></expr></argument>, <argument><expr><literal type="string">"em-next-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e[5D"</literal></expr></argument>, <argument><expr><literal type="string">"ed-prev-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e\\e[C"</literal></expr></argument>, <argument><expr><literal type="string">"em-next-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">"\\e\\e[D"</literal></expr></argument>, <argument><expr><literal type="string">"ed-prev-word"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>el_source</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>_resize_fun</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl_line_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_rl_update_pos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tty_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>TCSADRAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>char</name> <modifier>*</modifier></type>
<name>readline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>prompt</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>used_event_hook</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>h</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rl_startup_hook</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name>rl_startup_hook</name>)<argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tty_init</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>rl_done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>setjmp</name><argument_list>(<argument><expr><name>topbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>rl_set_prompt</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rl_pre_input_hook</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name>rl_pre_input_hook</name>)<argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rl_event_hook</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>el_flags</name></name> <operator>&amp;</operator> <name>NO_TTY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_GETCFN</name></expr></argument>, <argument><expr><name>_rl_event_read_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>used_event_hook</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rl_event_hook</name> <operator>&amp;&amp;</operator> <name>used_event_hook</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_GETCFN</name></expr></argument>, <argument><expr><name>EL_BUILTIN_GETCFN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>used_event_hook</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rl_already_prompted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>el_gets</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>strcspn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_GETSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>history_length</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>

<label><name>out</name>:</label>
<expr_stmt><expr><call><name>tty_end</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>TCSADRAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>using_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>history_offset</name> <operator>=</operator> <name>history_length</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_rl_compat_sub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>with</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>globally</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>with_len</name></decl>, <decl><type ref="prev"/><name>what_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>with_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>what_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <operator>*</operator><name>what</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>what_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>with_len</name> <operator>-</operator> <name>what_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>globally</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>what_len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>result</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <operator>*</operator><name>what</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>what_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>with</name></expr></argument>, <argument><expr><name>with_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>+=</operator> <name>with_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>what_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>globally</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_search_pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_search_match</name></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_history_event</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qchar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>sign</name></decl>, <decl><type ref="prev"/><name>sub</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>begin</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>*</operator><name>cindex</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <name>history_expansion_char</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <name>history_expansion_char</name> <operator>||</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_FIRST</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>cindex</name> <operator>=</operator> <ternary><condition><expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name></expr>?</condition><then> <expr><operator>(</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></then><else>:<expr><name>idx</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="char">'0'</literal> <operator>&lt;=</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;&amp;</operator> <literal type="char">'0'</literal> <operator>&lt;=</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>history_length</name> <operator>-</operator> <name>num</name> <operator>+</operator> <name>history_base</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>he</name> <operator>=</operator> <call><name>history_get</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>cindex</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<return>return <expr><name><name>he</name><operator>-&gt;</operator><name>line</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sub</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sub</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sub</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal>
<operator>||</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <name>qchar</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>idx</name> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>begin</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>last_search_pat</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>last_search_pat</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pat</name> <operator>=</operator> <name>last_search_pat</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pat</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>cmd</name> <operator>+</operator> <name>begin</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>last_search_pat</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>last_search_pat</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>last_search_pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_search_pat</name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>history_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>history_search_prefix</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>rl_outstream</name></expr></argument>, <argument><expr><literal type="string">"%s: Event not found\n"</literal></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>last_search_pat</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>&amp;&amp;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>last_search_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_search_match</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>last_search_pat</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>cindex</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rptr</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SET</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getfrom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cmdp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>search</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>*</operator><name>cmdp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>what</name> <init>= <expr><call><name>el_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>fromp</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>what</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>*</operator><name>fromp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>!=</operator> <name>delim</name></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nwhat</name></decl>;</decl_stmt>
<expr_stmt><expr><name>nwhat</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>size</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nwhat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nwhat</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>*</operator><name>fromp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmdp</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>what</name> <operator>=</operator> <name>nwhat</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>what</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cmd</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>what</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmdp</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>what</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>search</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fromp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmdp</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>getto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cmdp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>from_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>*</operator><name>cmdp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>with</name> <init>= <expr><call><name>el_realloc</name><argument_list>(<argument><expr><operator>*</operator><name>top</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>with</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>with</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>!=</operator> <name>delim</name></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>from_len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nwith</name></decl>;</decl_stmt>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>from_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nwith</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>with</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nwith</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nwith</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>with</name> <operator>=</operator> <name>nwith</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>with</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>from_len</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>cmd</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>delim</name> <operator>||</operator> <operator>*</operator><operator>(</operator><name>cmd</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'&amp;'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>with</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>cmd</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cmd</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>with</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>with</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmdp</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>*</operator><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>top</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmdp</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>replace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aptr</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><operator>*</operator><name>tmp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>aptr</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>aptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>*</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <name>aptr</name></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>int</name></type>
<name>_history_expand_command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cmdlen</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>search</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aptr</name></decl>, <decl><type ref="prev"/><name>delim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>to</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>has_mods</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p_on</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>g_on</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>aptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">":^*$"</literal></expr></argument>, <argument><expr><name><name>command</name><index>[<expr><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>





<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'!'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>get_history_event</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>command</name><index>[<expr><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>has_mods</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>command</name><index>[<expr><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aptr</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>aptr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator>
<operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>offs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>qchar</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qchar</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>offs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>command</name><index>[<expr><name>offs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator></expr>
?</condition><then> <expr><literal type="char">'"'</literal></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>get_history_event</name><argument_list>(<argument><expr><name>command</name> <operator>+</operator> <name>offs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><name>qchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>has_mods</name> <operator>=</operator> <name><name>command</name><index>[<expr><name>offs</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>aptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_mods</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>aptr</name></expr> ?</condition><then> <expr><name>aptr</name></expr> </then><else>: <expr><name>ptr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>command</name> <operator>+</operator> <name>offs</name> <operator>+</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>last_search_match</name></expr> ?</condition><then> <expr><name>last_search_match</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"^*$-0123456789"</literal></expr></argument>, <argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <literal type="char">'0'</literal> <operator>&lt;=</operator> <operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>start</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>cmd</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <literal type="char">'0'</literal> <operator>&lt;=</operator> <operator>*</operator><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>end</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>cmd</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>cmd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>history_arg_extract</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><ternary><condition><expr><name>aptr</name></expr>?</condition><then> <expr><name>aptr</name></expr></then><else>:<expr><name>ptr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>rl_outstream</name></expr></argument>, <argument><expr><literal type="string">"%s: Bad word specifier"</literal></expr></argument>,
<argument><expr><name>command</name> <operator>+</operator> <name>offs</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><ternary><condition><expr><name>aptr</name></expr>?</condition><then> <expr><name>aptr</name></expr></then><else>:<expr><name>ptr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>aptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>cmd</name> <operator>-</operator> <operator>(</operator><name>command</name> <operator>+</operator> <name>offs</name><operator>)</operator><operator>)</operator> <operator>&gt;=</operator> <name>cmdlen</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>cmd</name></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<continue>continue;</continue>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aptr</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>aptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aptr</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>aptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>p_on</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><name>g_on</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>to</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>ev</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>delim</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>cmd</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>delim</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>++</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ev</name> <operator>=</operator> <call><name>getfrom</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>from</name></expr></argument>, <argument><expr><name>search</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ev</name> <operator>=</operator> <call><name>getto</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>aptr</name> <operator>=</operator> <call><name>_rl_compat_sub</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>g_on</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>aptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>g_on</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name><operator>--</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>p_on</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ev</name></expr>;</return>

</block_content>}</block></function>





<function><type><name>int</name></type>
<name>history_expand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>history_expansion_char</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>history_subst_char</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>output</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>output</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>*</operator><name>output</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>history_expansion_char</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>output</name><operator>)</operator><index>[<expr><literal type="number">2</literal></expr>]</index> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>output</name><operator>)</operator><index>[<expr><literal type="number">3</literal></expr>]</index> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>output</name><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>*</operator><name>output</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>output</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_STRING</name><parameter_list>(<parameter><type><name>what</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>fr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (idx + len + 1 &gt; size) { char *nresult = el_realloc(result, (size += len + 1) * sizeof(*nresult)); if (nresult == NULL) { el_free(*output); el_free(fr); return 0; } result = nresult; } (void)strlcpy(&amp;result[idx], what, len + 1); idx += len; }</cpp:value></cpp:define>















<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>qchar</name></decl>, <decl><type ref="prev"/><name>loop_again</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qchar</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>loop_again</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<label><name>loop</name>:</label>
<for>for <control>(<init>;</init> <condition><expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator>
<name><name>str</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>history_expansion_char</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loop_again</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>||</operator> <name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>qchar</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>history_expansion_char</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><name>history_no_expand_chars</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>history_inhibit_expansion_function</name> <operator>||</operator>
<call>(<modifier>*</modifier><name>history_inhibit_expansion_function</name>)<argument_list>(<argument><expr><name>str</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>j</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>loop_again</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>qchar</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal> <operator>)</operator></expr>?</condition><then> <expr><literal type="char">'"'</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>history_expansion_char</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>loop_again</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_STRING</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>start</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>history_expansion_char</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>j</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_STRING</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>_history_expand_command</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>j</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ADD_STRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>add_history</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GDB_411_HACK</name></expr></argument>)</argument_list></call></expr></cpp:if>




<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>*</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>output</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>char</name> <modifier>*</modifier></type>
<name>history_arg_extract</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>history_tokenize</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>arr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>arr</name><index>[<expr><name>max</name></expr>]</index></name></expr>;</condition> <incr><expr><name>max</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name>max</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>max</name> <operator>+</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>start</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name><name>end</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>start</name></expr></argument> &gt;</argument_list></name> <name>max</name> <operator>||</operator>
<operator>(</operator><name>size_t</name><operator>)</operator><name>end</name></expr></argument> &gt;</argument_list></name> <name>max</name> <operator>||</operator> <name>start</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>start</name></expr><operator>,</operator> <expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>start</name></expr><operator>,</operator> <expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strcpy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>end</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<label><name>out</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>history_tokenize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>, <decl><type ref="prev"/><name>delim</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition><incr/>)</control> <block>{<block_content>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>delim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>delim</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>delim</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"()&lt;&gt;;&amp;|$"</literal></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>delim</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"'`\""</literal></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>delim</name> <operator>=</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nresult</name></decl>;</decl_stmt>
<expr_stmt><expr><name>size</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nresult</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nresult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nresult</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>nresult</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>i</name> <operator>-</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>idx</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><name>start</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>stifle_history</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SETSIZE</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>max_input_history</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>history_length</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>history_base</name> <operator>=</operator> <name>history_length</name> <operator>-</operator> <name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>history_length</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>he</name> <operator>=</operator> <call><name>remove_history</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name><name>he</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>he</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>unstifle_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>omax</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SETSIZE</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>omax</name> <operator>=</operator> <name>max_input_history</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_input_history</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
<return>return <expr><name>omax</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>history_is_stifled</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>


<return>return <expr><name>max_input_history</name> <operator>!=</operator> <name>INT_MAX</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_history_tmp_template</name><index>[]</index></name> <init>= <expr><literal type="string">"/tmp/.historyXXXXXX"</literal></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>history_truncate_file</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlines</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>template</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>_history_tmp_template</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>filename</name> <operator>=</operator> <call><name>_default_history_file</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r+"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>template</name></expr></argument>, <argument><expr><name>_history_tmp_template</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>mkstemp</name><argument_list>(<argument><expr><name>template</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<goto>goto <name>out1</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tp</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"r+"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<goto>goto <name>out2</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator>
<operator>(</operator><name>off_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>left</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>left</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out3</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>left</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<while>while <condition>(<expr><operator>--</operator><name>cp</name> <operator>&gt;=</operator> <name>buf</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nlines</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>cp</name> <operator>&gt;=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>nlines</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <name>nlines</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out3</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>off_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<goto>goto <name>out3</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fseeko</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><operator>(</operator><name>off_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name> <operator>+</operator> <operator>(</operator><name>cp</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator>
<operator>(</operator><name>off_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<goto>goto <name>out3</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>left</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>left</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>off</name> <operator>=</operator> <call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>out3</name>:</label>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out2</name>:</label>
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>template</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out1</name>:</label>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>read_history</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>filename</name> <operator>=</operator> <call><name>_default_history_file</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_LOAD</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>errno</name></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>EINVAL</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_GETSIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>history_length</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>history_length</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>EINVAL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>write_history</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>filename</name> <operator>=</operator> <call><name>_default_history_file</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SAVE</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then>
<expr><operator>(</operator><ternary><condition><expr><name>errno</name></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>EINVAL</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>append_history</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>filename</name> <operator>=</operator> <call><name>_default_history_file</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_NSAVE_FP</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>serrno</name> <init>= <expr><ternary><condition><expr><name>errno</name></expr> ?</condition><then> <expr><name>errno</name></expr> </then><else>: <expr><name>EINVAL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>serrno</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>history_get</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>HIST_ENTRY</name></type> <name>she</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_num</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <name>history_base</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_DELDATA</name></expr></argument>, <argument><expr><name>num</name> <operator>-</operator> <name>history_base</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_NEXT_EVDATA</name></expr></argument>, <argument><expr><name><name>ev</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>she</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>she</name><operator>.</operator><name>line</name></name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SET</name></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>she</name></expr>;</return>

<label><name>out</name>:</label>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SET</name></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>add_history</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_ENTER</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_GETSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name>history_length</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>history_base</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>history_offset</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>history_length</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>remove_history</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>he</name> <operator>=</operator> <call><name>el_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_DELDATA</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>he</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>he</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_GETSIZE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>history_length</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>he</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>replace_history_entry</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>histdata_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_num</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_LAST</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>he</name> <operator>=</operator> <call><name>el_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>he</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_NEXT_EVDATA</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>he</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>he</name><operator>-&gt;</operator><name>line</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>ev</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>he</name><operator>-&gt;</operator><name>line</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_REPLACE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SET</name></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>

<return>return <expr><name>he</name></expr>;</return>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>clear_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CLEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>history_offset</name> <operator>=</operator> <name>history_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>where_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>history_offset</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>HIST_ENTRY</name> <modifier>*</modifier><modifier>*</modifier></type><name>_history_listp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HIST_ENTRY</name> <modifier>*</modifier></type><name>_history_list</name></decl>;</decl_stmt>

<function><type><name>HIST_ENTRY</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>history_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier><modifier>*</modifier></type><name>nlp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_LAST</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nlp</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>_history_listp</name></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>history_length</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nlp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>_history_listp</name> <operator>=</operator> <name>nlp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nl</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>_history_list</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>history_length</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>_history_list</name> <operator>=</operator> <name>nl</name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name><name>_history_listp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>_history_list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>_history_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>_history_list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>==</operator> <name>history_length</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_PREV</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<expr_stmt><expr><name><name>_history_listp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>_history_listp</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>current_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_PREV_EVENT</name></expr></argument>, <argument><expr><name>history_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rl_he</name><operator>.</operator><name>line</name></name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rl_he</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><name>rl_he</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>history_total_bytes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do<block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>ev</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ev</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block>
while <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_NEXT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>


<expr_stmt><expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_PREV_EVENT</name></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>history_set_pos</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>history_length</name> <operator>||</operator> <name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>history_offset</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>previous_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>history_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_LAST</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>history_offset</name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><call><name>current_history</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>HIST_ENTRY</name> <modifier>*</modifier></type>
<name>next_history</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>history_offset</name> <operator>&gt;=</operator> <name>history_length</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_LAST</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>history_offset</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><call><name>current_history</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>history_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_num</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>strp</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>ev</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>strp</name> <operator>-</operator> <name><name>ev</name><operator>.</operator><name>str</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><ternary><condition><expr><name>direction</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>H_NEXT</name></expr></then><else>:<expr><name>H_PREV</name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_SET</name></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>history_search_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><ternary><condition><expr><name>direction</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
<expr><name>H_PREV_STR</name></expr> </then><else>: <expr><name>H_NEXT_STR</name></expr></else></ternary></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<decl_stmt><decl><type><name>int</name></type>
<name>history_search_pos</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>str</name></expr></argument>,
<argument><expr><name>int</name> <name>direction</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>pos</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HistEvent</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_num</name></decl>, <decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>pos</name></expr> </then><else>: <expr><operator>-</operator><name>pos</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>curr_num</name> <operator>=</operator> <name><name>ev</name><operator>.</operator><name>num</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>history_set_pos</name><argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>H_CURR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>ev</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>off</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>H_PREV</name></expr> </then><else>: <expr><name>H_NEXT</name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>history</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>H_NEXT_EVENT</name></expr> </then><else>: <expr><name>H_PREV_EVENT</name></expr></else></ternary></expr></argument>, <argument><expr><name>curr_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>char</name> <modifier>*</modifier></type>
<name>tilde_expand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>fn_tilde_expand</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>filename_completion_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>fn_filename_completion_function</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><name>char</name> <modifier>*</modifier></type>
<name>username_completion_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_POSIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_DRAFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name></type> <name>pwres</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pwbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pass</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>text</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>text</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_POSIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETPW_R_DRAFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>getpwent_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pwres</name></expr></argument>, <argument><expr><name>pwbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pwbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>pass</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pass</name> <operator>!=</operator> <call><name>NULL</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<argument_list>(<argument><expr><name>pass</name> <operator>=</operator> <call><name>getpwent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>&amp;&amp;</operator> <name><name>text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>pass</name><operator>-&gt;</operator><name>pw_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>pass</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>endpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name><name>pass</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>
<name>_el_rl_tstp</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>ch</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>kill</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SIGTSTP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CC_NORM</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>_rl_completion_append_character_function</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>dummy</name>
<call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>rl_completion_append_character</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>







<function><type><name>void</name></type>
<name>rl_display_match_list</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>matches</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>fn_display_match_list</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>max</name></expr></argument>,
<argument><expr><name>_rl_completion_append_character_function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<decl_stmt><decl><type><name>int</name></type>
<name>rl_complete</name><argument_list>(<argument><expr><name>int</name> <name>ignore</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>invoking_key</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>ct_buffer_t</name></type> <name>wbreak_conv</name></decl>, <decl><type ref="prev"/><name>sprefix_conv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>breakchars</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rl_inhibit_completion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>arr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>invoking_key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_insertstr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CC_REFRESH</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rl_completion_word_break_hook</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>breakchars</name> <operator>=</operator> <call>(<modifier>*</modifier><name>rl_completion_word_break_hook</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>breakchars</name> <operator>=</operator> <name>rl_basic_word_break_characters</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>_rl_update_pos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<return>return <expr><call><name>fn_complete</name><argument_list>(<argument><expr><name>e</name></expr></argument>,
<argument><expr><operator>(</operator><name>rl_compentry_func_t</name> <operator>*</operator><operator>)</operator><name>rl_completion_entry_function</name></expr></argument>,
<argument><expr><name>rl_attempted_completion_function</name></expr></argument>,
<argument><expr><call><name>ct_decode_string</name><argument_list>(<argument><expr><name>rl_basic_word_break_characters</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wbreak_conv</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ct_decode_string</name><argument_list>(<argument><expr><name>breakchars</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sprefix_conv</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>_rl_completion_append_character_function</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>rl_completion_query_items</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>rl_completion_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl_attempted_completion_over</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>rl_point</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl_end</name></expr></argument>)</argument_list></call></expr>;</return>


</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>
<name>_el_rl_complete</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>ch</name></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>rl_complete</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>








<function><type><name>int</name></type>
<name>rl_bind_key</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>rl_command_func_t</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>rl_insert</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>el_map</name><operator>.</operator><name>key</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>ED_INSERT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>rl_read_key</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>fooarr</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>h</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>el_getc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fooarr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><name>int</name></type>
<name>rl_reset_terminal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>p</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>el_reset</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>int</name></type>
<name>rl_insert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>arr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_push</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_insert_text</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>text</name> <operator>||</operator> <operator>*</operator><name>text</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>el_insertstr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>text</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>int</name></type>
<name>rl_newline</name><argument_list>(<argument><expr><name>int</name> <name>count</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>int</name> <name>c</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>



<return>return <expr><call><name>rl_insert</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type>
<name>rl_bind_wrapper</name><argument_list>(<argument><expr><name>EditLine</name> <operator>*</operator><name>el</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <name>c</name></expr></argument>)</argument_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>map</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CC_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>_rl_update_pos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>map</name><index>[<expr><name>c</name></expr>]</index>)<argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>rl_done</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CC_EOF</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>CC_NORM</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>int</name></type>
<name>rl_add_defun</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rl_command_func_t</name> <modifier>*</modifier></type><name>fun</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>dest</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>c</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>map</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>map</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr>]</index></name> <operator>=</operator> <name>fun</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_ADDFN</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>rl_bind_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vis</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>VIS_WHITE</name><operator>|</operator><name>VIS_NOSLASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_callback_read_char</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>el_gets</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>wbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_UNBUFFERED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>count</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>e</name><operator>-&gt;</operator><name>el_tty</name><operator>.</operator><name>t_c</name><index>[<expr><name>TS_IO</name></expr>]</index><index>[<expr><name>C_EOF</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>count</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><name>count</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>done</name> <operator>&amp;&amp;</operator> <name>rl_linefunc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_UNBUFFERED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>done</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>wbuf</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wbuf</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>wbuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>rl_linefunc</name><operator>)</operator><operator>(</operator><name>wbuf</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_callback_handler_install</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prompt</name></decl></parameter>, <parameter><decl><type><name>rl_vcpfunc_t</name> <modifier>*</modifier></type><name>linefunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rl_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rl_set_prompt</name><argument_list>(<argument><expr><name>prompt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_linefunc</name> <operator>=</operator> <name>linefunc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_UNBUFFERED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_callback_handler_remove</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_UNBUFFERED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_linefunc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_redisplay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>el_tty</name><operator>.</operator><name>t_c</name><index>[<expr><name>TS_IO</name></expr>]</index><index>[<expr><name>C_REPRINT</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_push</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_get_previous_history</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_push</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type>

<name>rl_prep_terminal</name><argument_list>(<argument><expr><name>int</name> <name>meta_flag</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_PREP_TERM</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>
<name>rl_deprep_terminal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_PREP_TERM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_read_init_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>el_source</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_parse_and_bind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Tokenizer</name> <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>tok_init</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tok_str</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>el_parse</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tok_end</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_variable_bind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<return>return <expr><ternary><condition><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_BIND</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_stuff_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_insertstr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>_rl_event_read_char</name><parameter_list>(<parameter><decl><type><name>EditLine</name> <modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>num_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>wc</name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>rl_event_hook</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>rl_event_hook</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FIONREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num_read</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>num_read</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETFL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>O_NDELAY</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>n</name><operator>|</operator><name>O_NDELAY</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>num_read</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>num_read</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>el</name><operator>-&gt;</operator><name>el_infd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>num_read</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>num_read</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rl_event_hook</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>EL_GETCFN</name></expr></argument>, <argument><expr><name>EL_BUILTIN_GETCFN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>wc</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name><operator>)</operator><name>ch</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>num_read</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_rl_update_pos</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>LineInfo</name> <modifier>*</modifier></type><name>li</name> <init>= <expr><call><name>el_line</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rl_point</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>li</name><operator>-&gt;</operator><name>cursor</name></name> <operator>-</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rl_end</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>li</name><operator>-&gt;</operator><name>lastchar</name></name> <operator>-</operator> <name><name>li</name><operator>-&gt;</operator><name>buffer</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rl_line_buffer</name><index>[<expr><name>rl_end</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_get_screen_size</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rows</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_get</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_GETTC</name></expr></argument>, <argument><expr><literal type="string">"li"</literal></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cols</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>el_get</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_GETTC</name></expr></argument>, <argument><expr><literal type="string">"co"</literal></expr></argument>, <argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_set_screen_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_SETTC</name></expr></argument>, <argument><expr><literal type="string">"li"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_SETTC</name></expr></argument>, <argument><expr><literal type="string">"co"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>rl_completion_matches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>rl_compentry_func_t</name> <modifier>*</modifier></type><name>fun</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>match</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>list</name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>match</name> <operator>=</operator> <call>(<modifier>*</modifier><name>fun</name>)<argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>list</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>match</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>max</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nl</name></decl>;</decl_stmt>
<expr_stmt><expr><name>max</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nl</name> <operator>=</operator> <call><name>el_realloc</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>max</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name>nl</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>list</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <name>strcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>SIZE_MAX</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>a</name> <operator>=</operator> <name><name>list</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>a</name> <operator>=</operator> <name>b</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>list</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>el_calloc</name><argument_list>(<argument><expr><name>min</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>min</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>list</name></expr>;</return>

<label><name>out</name>:</label>
<expr_stmt><expr><call><name>el_free</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>rl_filename_completion_function</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>fn_filename_completion_function</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_forced_update_display</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_set</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EL_REFRESH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>_rl_abort_internal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_beep</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>topbuf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>
<name>_rl_qsort_string_compare</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>strcoll</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>, <argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>HISTORY_STATE</name> <modifier>*</modifier></type>
<name>history_get_history_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HISTORY_STATE</name> <modifier>*</modifier></type><name>hs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hs</name> <operator>=</operator> <call><name>el_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>hs</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>history_length</name></expr>;</expr_stmt>
<return>return <expr><name>hs</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type>

<name>rl_kill_text</name><argument_list>(<argument><expr><name>int</name> <name>from</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>int</name> <name>to</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>Keymap</name></type>
<name>rl_make_bare_keymap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Keymap</name></type>
<name>rl_get_keymap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type>

<name>rl_set_keymap</name><argument_list>(<argument><expr><name>Keymap</name> <name>k</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>int</name></type>

<name>rl_generic_bind</name><argument_list>(<argument><expr><name>int</name> <name>type</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator> <name>keyseq</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator> <name>data</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Keymap</name> <name>k</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>int</name></type>

<name>rl_bind_key_in_map</name><argument_list>(<argument><expr><name>int</name> <name>key</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>rl_command_func_t</name> <operator>*</operator><name>fun</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Keymap</name> <name>k</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type>
<name>rl_cleanup_after_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_on_new_line</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_free_line_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type>

<name>rl_set_keyboard_input_timeout</name><argument_list>(<argument><expr><name>int</name> <name>u</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>
<name>rl_resize_terminal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>el_resize</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_reset_after_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rl_prep_term_function</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name>rl_prep_term_function</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rl_echo_signal_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>tty_get_signal_character</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>re_putc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_crlf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>re_putc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_ding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>re_putc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="char">'\a'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>count</name> <operator>&amp;&amp;</operator> <name>key</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rl_set_keymap_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Keymap</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>name</name> <operator>&amp;&amp;</operator> <name>k</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>histdata_t</name></type>
<name>free_history_entry</name><parameter_list>(<parameter><decl><type><name>HIST_ENTRY</name> <modifier>*</modifier></type><name>he</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>he</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>_rl_erase_entire_line</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>
</unit>
