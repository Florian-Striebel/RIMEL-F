<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bmake/parse.c">


































































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"make.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDINT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_COPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_COPY</name></cpp:macro> <cpp:value>MAP_PRIVATE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_FILE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathnames.h"</cpp:file></cpp:include>


<expr_stmt><expr><call><name>MAKE_RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: parse.c,v 1.574 2021/12/12 15:44:41 rillig Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<typedef>typedef <type><struct>struct <name>IFile</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>fromForLoop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cond_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>depending</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_freeIt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_end</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ReadMoreProc</name></type> <name>readMore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>readMoreArg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>
}</block></struct></type> <name>IFile</name>;</typedef>




<typedef>typedef <type><enum>enum <name>ParseSpecial</name> <block>{
<decl><name>SP_ATTRIBUTE</name></decl>,
<decl><name>SP_BEGIN</name></decl>,
<decl><name>SP_DEFAULT</name></decl>,
<decl><name>SP_DELETE_ON_ERROR</name></decl>,
<decl><name>SP_END</name></decl>,
<decl><name>SP_ERROR</name></decl>,
<decl><name>SP_IGNORE</name></decl>,
<decl><name>SP_INCLUDES</name></decl>,
<decl><name>SP_INTERRUPT</name></decl>,
<decl><name>SP_LIBS</name></decl>,

<decl><name>SP_MAIN</name></decl>,
<decl><name>SP_META</name></decl>,
<decl><name>SP_MFLAGS</name></decl>,
<decl><name>SP_NOMETA</name></decl>,
<decl><name>SP_NOMETA_CMP</name></decl>,
<decl><name>SP_NOPATH</name></decl>,
<decl><name>SP_NOT</name></decl>,
<decl><name>SP_NOTPARALLEL</name></decl>,
<decl><name>SP_NULL</name></decl>,
<decl><name>SP_OBJDIR</name></decl>,
<decl><name>SP_ORDER</name></decl>,
<decl><name>SP_PARALLEL</name></decl>,
<decl><name>SP_PATH</name></decl>,
<decl><name>SP_PHONY</name></decl>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl><name>SP_POSIX</name></decl>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl><name>SP_PRECIOUS</name></decl>,
<decl><name>SP_SHELL</name></decl>,
<decl><name>SP_SILENT</name></decl>,
<decl><name>SP_SINGLESHELL</name></decl>,
<decl><name>SP_STALE</name></decl>,
<decl><name>SP_SUFFIXES</name></decl>,
<decl><name>SP_WAIT</name></decl>
}</block></enum></type> <name>ParseSpecial</name>;</typedef>

<typedef>typedef <type><name>List</name></type> <name>SearchPathList</name>;</typedef>
<typedef>typedef <type><name>ListNode</name></type> <name>SearchPathListNode</name>;</typedef>







<decl_stmt><decl><type><specifier>static</specifier> <name>GNode</name> <modifier>*</modifier></type><name>mainNode</name></decl>;</decl_stmt>










<decl_stmt><decl><type><specifier>static</specifier> <name>GNodeList</name> <modifier>*</modifier></type><name>targets</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>






<decl_stmt><decl><type><specifier>static</specifier> <name>StringList</name></type> <name>targCmds</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><specifier>static</specifier> <name>GNode</name> <modifier>*</modifier></type><name>order_pred</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>parseErrors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>












<decl_stmt><decl><type><specifier>static</specifier> <name>Vector</name></type> <name>includes</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>IFile</name> <modifier>*</modifier></type>
<name>GetInclude</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Vector_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>includes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>IFile</name> <modifier>*</modifier></type>
<name>CurFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>GetInclude</name><argument_list>(<argument><expr><name><name>includes</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>parseIncPath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>sysIncPath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>defSysIncPath</name></decl>;</decl_stmt>










<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParseSpecial</name></type> <name>spec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNodeType</name></type> <name>op</name></decl>;</decl_stmt>
}</block> <decl><name><name>parseKeywords</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">".BEGIN"</literal></expr>, <expr><name>SP_BEGIN</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".DEFAULT"</literal></expr>, <expr><name>SP_DEFAULT</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".DELETE_ON_ERROR"</literal></expr>, <expr><name>SP_DELETE_ON_ERROR</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".END"</literal></expr>, <expr><name>SP_END</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".ERROR"</literal></expr>, <expr><name>SP_ERROR</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".EXEC"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_EXEC</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".IGNORE"</literal></expr>, <expr><name>SP_IGNORE</name></expr>, <expr><name>OP_IGNORE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".INCLUDES"</literal></expr>, <expr><name>SP_INCLUDES</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".INTERRUPT"</literal></expr>, <expr><name>SP_INTERRUPT</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".INVISIBLE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_INVISIBLE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".JOIN"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_JOIN</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".LIBS"</literal></expr>, <expr><name>SP_LIBS</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".MADE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_MADE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".MAIN"</literal></expr>, <expr><name>SP_MAIN</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".MAKE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_MAKE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".MAKEFLAGS"</literal></expr>, <expr><name>SP_MFLAGS</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".META"</literal></expr>, <expr><name>SP_META</name></expr>, <expr><name>OP_META</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".MFLAGS"</literal></expr>, <expr><name>SP_MFLAGS</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NOMETA"</literal></expr>, <expr><name>SP_NOMETA</name></expr>, <expr><name>OP_NOMETA</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NOMETA_CMP"</literal></expr>, <expr><name>SP_NOMETA_CMP</name></expr>, <expr><name>OP_NOMETA_CMP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NOPATH"</literal></expr>, <expr><name>SP_NOPATH</name></expr>, <expr><name>OP_NOPATH</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NOTMAIN"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_NOTMAIN</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NOTPARALLEL"</literal></expr>, <expr><name>SP_NOTPARALLEL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NO_PARALLEL"</literal></expr>, <expr><name>SP_NOTPARALLEL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".NULL"</literal></expr>, <expr><name>SP_NULL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".OBJDIR"</literal></expr>, <expr><name>SP_OBJDIR</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".OPTIONAL"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_OPTIONAL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".ORDER"</literal></expr>, <expr><name>SP_ORDER</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".PARALLEL"</literal></expr>, <expr><name>SP_PARALLEL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".PATH"</literal></expr>, <expr><name>SP_PATH</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".PHONY"</literal></expr>, <expr><name>SP_PHONY</name></expr>, <expr><name>OP_PHONY</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><literal type="string">".POSIX"</literal></expr>, <expr><name>SP_POSIX</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{ <expr><literal type="string">".PRECIOUS"</literal></expr>, <expr><name>SP_PRECIOUS</name></expr>, <expr><name>OP_PRECIOUS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".RECURSIVE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_MAKE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".SHELL"</literal></expr>, <expr><name>SP_SHELL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".SILENT"</literal></expr>, <expr><name>SP_SILENT</name></expr>, <expr><name>OP_SILENT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".SINGLESHELL"</literal></expr>, <expr><name>SP_SINGLESHELL</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".STALE"</literal></expr>, <expr><name>SP_STALE</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".SUFFIXES"</literal></expr>, <expr><name>SP_SUFFIXES</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".USE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_USE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".USEBEFORE"</literal></expr>, <expr><name>SP_ATTRIBUTE</name></expr>, <expr><name>OP_USEBEFORE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">".WAIT"</literal></expr>, <expr><name>SP_WAIT</name></expr>, <expr><name>OP_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>



<struct>struct <name>loadedfile</name> <block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>used</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type>
<name>loadedfile_create</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>buflen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lf</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>lf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>loadedfile_destroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>lf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>loadedfile_readMore</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lf</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>lf</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>lf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>lf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>bool</name></type>
<name>load_getsize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>










<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <literal type="number">0x3fffffff</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type>
<name>loadfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>filesize</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <name>STDIN_FILENO</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_getsize</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>filesize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name>filesize</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>filesize</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>filesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name><name>buf</name><operator>.</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>buf</name><operator>.</operator><name>cap</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>cap</name></name> <operator>&gt;</operator> <literal type="number">0x1fffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EFBIG</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"%s: file too large"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_Expand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>buf</name><operator>.</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>cap</name></name> <operator>-</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"%s: read error: %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name><name>buf</name><operator>.</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Buf_EndsWith</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name> <init>= <expr><call><name>loadedfile_create</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>lf</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintStackTrace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>IFile</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>DEBUG</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <call><name>GetInclude</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>includes</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>















<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>IFile</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>entries</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>fname</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>printLineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dirbuf</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"(stdin)"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dirbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>printLineno</name> <operator>=</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>fromForLoop</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <name><name>entries</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fromForLoop</name> <operator>==</operator> <name>printLineno</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>printLineno</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>fromForLoop</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>printLineno</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\tin .include from %s:%d\n"</literal></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>fromForLoop</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\tin .for loop from %s:%d\n"</literal></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseIsEscaped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>active</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>active</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>--</operator><name>c</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>active</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>active</name> <operator>=</operator> <operator>!</operator><name>active</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>RememberLocation</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name> <init>= <expr><call><name>CurFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>ParseFindKeyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><sizeof>sizeof <name>parseKeywords</name></sizeof> <operator>/</operator> <sizeof>sizeof <name><name>parseKeywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>curr</name> <init>= <expr><name>start</name> <operator>+</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>parseKeywords</name><index>[<expr><name>curr</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>curr</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>curr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>curr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition>;</do>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintLocation</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lineno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>dirbuf</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>dir</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fname</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"(stdin)"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" line %u: "</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><literal type="string">".PARSEDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dir</name><operator>.</operator><name>str</name></name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dir</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><name><name>dir</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>dirbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><literal type="string">".PARSEFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>base</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>base</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>str_basename</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\"%s/%s\" line %u: "</literal></expr></argument>,
<argument><expr><name><name>dir</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>base</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseVErrorInternal</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lineno</name></decl></parameter>,
<parameter><decl><type><name>ParseErrorLevel</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>fatal_warning_error_printed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PrintLocation</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>PARSE_WARNING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"warning: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vfprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>PARSE_INFO</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>print_stack_trace</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>PARSE_WARNING</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>opts</name><operator>.</operator><name>parseWarnFatal</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>print_stack_trace</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>parseErrors</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>PARSE_WARNING</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fatal_warning_error_printed</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"parsing warnings being treated as errors"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fatal_warning_error_printed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>print_stack_trace</name>:</label>
<expr_stmt><expr><call><name>PrintStackTrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseErrorInternal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lineno</name></decl></parameter>,
<parameter><decl><type><name>ParseErrorLevel</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseVErrorInternal</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stderr</name> <operator>&amp;&amp;</operator> <name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseVErrorInternal</name><argument_list>(<argument><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>Parse_Error</name><parameter_list>(<parameter><decl><type><name>ParseErrorLevel</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lineno</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>includes</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name> <init>= <expr><call><name>CurFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lineno</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseVErrorInternal</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stderr</name> <operator>&amp;&amp;</operator> <name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseVErrorInternal</name><argument_list>(<argument><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseMessage</name><parameter_list>(<parameter><decl><type><name>ParseErrorLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>levelName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>umsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xmsg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>umsg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Missing argument for \".%s\""</literal></expr></argument>,
<argument><expr><name>levelName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>umsg</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>xmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>xmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <name>PARSE_FATAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PrintOnError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>LinkSource</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>pgn</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>cgn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSpecial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pgn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_DOUBLEDEP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>cohorts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pgn</name> <operator>=</operator> <name><name>pgn</name><operator>-&gt;</operator><name>cohorts</name><operator>.</operator><name>last</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>cgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>++</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSpecial</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#%s: added child %s - %s\n"</literal></expr></argument>,
<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>pgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintNode</name><argument_list>(<argument><expr><name>pgn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintNode</name><argument_list>(<argument><expr><name>cgn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>LinkToTargets</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSpecial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>targets</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LinkSource</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>isSpecial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryApplyDependencyOperator</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>GNodeType</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>OP_OPMASK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_OPMASK</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>op</name> <operator>&amp;</operator> <name>OP_OPMASK</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_OPMASK</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Inconsistent operator for %s"</literal></expr></argument>,
<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_DOUBLEDEP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_OPMASK</name><operator>)</operator> <operator>==</operator> <name>OP_DOUBLEDEP</name></expr>)</condition> <block>{<block_content>












<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>cohort</name></decl>;</decl_stmt>





<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>op</name> <operator>&amp;</operator> <operator>~</operator><name>OP_OPMASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cohort</name> <operator>=</operator> <call><name>Targ_NewInternalNode</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>cohort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>









<expr_stmt><expr><name><name>cohort</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>op</name> <operator>|</operator> <name>OP_INVISIBLE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>cohorts</name></name></expr></argument>, <argument><expr><name>cohort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cohort</name><operator>-&gt;</operator><name>centurion</name></name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>unmade_cohorts</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>cohort</name><operator>-&gt;</operator><name>cohort_num</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cohort</name><operator>-&gt;</operator><name>cohort_num</name></name></sizeof></expr></argument>, <argument><expr><literal type="string">"#%d"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>gn</name><operator>-&gt;</operator><name>unmade_cohorts</name></name> <operator>%</operator> <literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>op</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyDependencyOperator</name><parameter_list>(<parameter><decl><type><name>GNodeType</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>targets</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryApplyDependencyOperator</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourceWait</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isSpecial</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>wait_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>wait_src</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>wait_src</name></expr></argument>, <argument><expr><sizeof>sizeof <name>wait_src</name></sizeof></expr></argument>, <argument><expr><literal type="string">".WAIT_%u"</literal></expr></argument>, <argument><expr><operator>++</operator><name>wait_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_NewInternalNode</name><argument_list>(<argument><expr><name>wait_src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OP_WAIT</name> <operator>|</operator> <name>OP_PHONY</name> <operator>|</operator> <name>OP_DEPENDS</name> <operator>|</operator> <name>OP_NOTMAIN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LinkToTargets</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>isSpecial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencySourceKeyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>keywd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNodeType</name></type> <name>op</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>src</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>!</operator><call><name>ch_isupper</name><argument_list>(<argument><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>keywd</name> <operator>=</operator> <call><name>ParseFindKeyword</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keywd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>parseKeywords</name><index>[<expr><name>keywd</name></expr>]</index></name><operator>.</operator><name>op</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>OP_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ApplyDependencyOperator</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parseKeywords</name><index>[<expr><name>keywd</name></expr>]</index></name><operator>.</operator><name>spec</name> <operator>==</operator> <name>SP_WAIT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseDependencySourceWait</name><argument_list>(<argument><expr><name>specType</name> <operator>!=</operator> <name>SP_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourceMain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>








<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><literal type="string">".TARGETS"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourceOrder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>




<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>order_pred</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>order_pred</name><operator>-&gt;</operator><name>order_succ</name></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>order_pred</name></name></expr></argument>, <argument><expr><name>order_pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#%s: added Order dependency %s - %s\n"</literal></expr></argument>,
<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name><name>order_pred</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintNode</name><argument_list>(<argument><expr><name>order_pred</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintNode</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>order_pred</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourceOther</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>GNodeType</name></type> <name>tOp</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>













<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tOp</name> <operator>!=</operator> <name>OP_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>tOp</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LinkToTargets</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>specType</name> <operator>!=</operator> <name>SP_NOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySource</name><parameter_list>(<parameter><decl><type><name>GNodeType</name></type> <name>tOp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ParseDependencySourceKeyword</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_MAIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencySourceMain</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_ORDER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencySourceOrder</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencySourceOther</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>tOp</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindMainTarget</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mainNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>targets</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_NOTARGET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>MAKE</name></expr></argument>, <argument><expr><literal type="string">"Setting main node to \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mainNode</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_SetMain</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseErrorNoDependency</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;&lt;&lt;&lt;&lt;"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><literal type="string">"======"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;&gt;&gt;&gt;&gt;"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Makefile appears to contain unresolved CVS/RCS/??? merge conflicts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>lstart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirstart</name> <init>= <expr><name>lstart</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirend</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>cpp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirend</name> <operator>=</operator> <name>dirstart</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ch_isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>dirend</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>dirend</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dirend</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unknown directive \"%.*s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dirend</name> <operator>-</operator> <name>dirstart</name><operator>)</operator></expr></argument>, <argument><expr><name>dirstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Invalid line type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyTargetWord</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator>
<operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'('</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ParseIsEscaped</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>









<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nested_p</name> <init>= <expr><name>cp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>nested_val</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_p</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>,
<argument><expr><name>VARE_PARSE_ONLY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <name>nested_p</name> <operator>-</operator> <name>cp</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyTargetSpecial</name><parameter_list>(<parameter><decl><type><name>ParseSpecial</name> <modifier>*</modifier></type><name>inout_specType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
<parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>inout_specType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SP_PATH</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_paths</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>inout_paths</name> <operator>=</operator> <call><name>Lst_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>*</operator><name>inout_paths</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_MAIN</name></expr>:</case>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>inout_specType</name> <operator>=</operator> <name>SP_NOT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>SP_BEGIN</name></expr>:</case>
<case>case <expr><name>SP_END</name></expr>:</case>
<case>case <expr><name>SP_STALE</name></expr>:</case>
<case>case <expr><name>SP_ERROR</name></expr>:</case>
<case>case <expr><name>SP_INTERRUPT</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_NOTMAIN</name> <operator>|</operator> <name>OP_SPECIAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>SP_DEFAULT</name></expr>:</case> <block>{<block_content>







<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>GNode_New</name><argument_list>(<argument><expr><literal type="string">".DEFAULT"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_NOTMAIN</name> <operator>|</operator> <name>OP_TRANSFORM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultNode</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>SP_DELETE_ON_ERROR</name></expr>:</case>
<expr_stmt><expr><name>deleteOnError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_NOTPARALLEL</name></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>maxJobs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_SINGLESHELL</name></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_ORDER</name></expr>:</case>
<expr_stmt><expr><name>order_pred</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencyTargetPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffixName</name></decl></parameter>,
<parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>Suff_GetPath</name><argument_list>(<argument><expr><name>suffixName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Suffix '%s' not defined (yet)"</literal></expr></argument>, <argument><expr><name>suffixName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_paths</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>inout_paths</name> <operator>=</operator> <call><name>Lst_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>*</operator><name>inout_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencyTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name> <modifier>*</modifier></type><name>inout_specType</name></decl></parameter>,
<parameter><decl><type><name>GNodeType</name> <modifier>*</modifier></type><name>out_tOp</name></decl></parameter>, <parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>keywd</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>targetName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>ch_isupper</name><argument_list>(<argument><expr><name><name>targetName</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><name>keywd</name> <operator>=</operator> <call><name>ParseFindKeyword</name><argument_list>(<argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keywd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_specType</name> <operator>==</operator> <name>SP_PATH</name> <operator>&amp;&amp;</operator>
<name><name>parseKeywords</name><index>[<expr><name>keywd</name></expr>]</index></name><operator>.</operator><name>spec</name> <operator>!=</operator> <name>SP_PATH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Mismatched special targets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>inout_specType</name> <operator>=</operator> <name><name>parseKeywords</name><index>[<expr><name>keywd</name></expr>]</index></name><operator>.</operator><name>spec</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_tOp</name> <operator>=</operator> <name><name>parseKeywords</name><index>[<expr><name>keywd</name></expr>]</index></name><operator>.</operator><name>op</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParseDependencyTargetSpecial</name><argument_list>(<argument><expr><name>inout_specType</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>,
<argument><expr><name>inout_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>targetName</name></expr></argument>, <argument><expr><literal type="string">".PATH"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>inout_specType</name> <operator>=</operator> <name>SP_PATH</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseDependencyTargetPath</name><argument_list>(<argument><expr><name>targetName</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>inout_paths</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyTargetMundane</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>targetName</name></decl></parameter>, <parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>curTargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>Dir_HasWildcards</name><argument_list>(<argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>emptyPath</name> <init>= <expr><call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SearchPath_Expand</name><argument_list>(<argument><expr><name>emptyPath</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>, <argument><expr><name>curTargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>emptyPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>curTargs</name></expr></argument>, <argument><expr><name>targetName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<while>while <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><name>curTargs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>targName</name> <init>= <expr><call><name>Lst_Dequeue</name><argument_list>(<argument><expr><name>curTargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><ternary><condition><expr><call><name>Suff_IsTransform</name><argument_list>(<argument><expr><name>targName</name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><call><name>Suff_AddTransform</name><argument_list>(<argument><expr><name>targName</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>targName</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyTargetExtraWarn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>warning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseIsEscaped</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ParseIsEscaped</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\t'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>warning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>warning</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Extra target ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyCheckSpec</name><parameter_list>(<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>specType</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Special and mundane targets don't mix. "</literal>
<literal type="string">"Mundane ones ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_DEFAULT</name></expr>:</case>
<case>case <expr><name>SP_STALE</name></expr>:</case>
<case>case <expr><name>SP_BEGIN</name></expr>:</case>
<case>case <expr><name>SP_END</name></expr>:</case>
<case>case <expr><name>SP_ERROR</name></expr>:</case>
<case>case <expr><name>SP_INTERRUPT</name></expr>:</case>




<case>case <expr><name>SP_NOT</name></expr>:</case>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencyOp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>, <parameter><decl><type><name>GNodeType</name> <modifier>*</modifier></type><name>out_op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_op</name> <operator>=</operator> <name>OP_FORCE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_op</name> <operator>=</operator> <name>OP_DOUBLEDEP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_op</name> <operator>=</operator> <name>OP_DEPENDS</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><ternary><condition><expr><name><name>lstart</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>
?</condition><then> <expr><literal type="string">"Unknown directive"</literal></expr> </then><else>: <expr><literal type="string">"Missing dependency operator"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearPaths</name><parameter_list>(<parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>paths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SearchPathListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>paths</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SearchPath_Clear</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Dir_SetPATH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourcesEmpty</name><parameter_list>(<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>, <parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>specType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SP_SUFFIXES</name></expr>:</case>
<expr_stmt><expr><call><name>Suff_ClearSuffixes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_PRECIOUS</name></expr>:</case>
<expr_stmt><expr><name>allPrecious</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_IGNORE</name></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>ignoreErrors</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_SILENT</name></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>beSilent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_PATH</name></expr>:</case>
<expr_stmt><expr><call><name>ClearPaths</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SP_POSIX</name></expr>:</case>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"%POSIX"</literal></expr></argument>, <argument><expr><literal type="string">"1003.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddToPaths</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>paths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SearchPathListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>paths</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




























<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourceSpecial</name><parameter_list>(<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>specType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SP_SUFFIXES</name></expr>:</case>
<expr_stmt><expr><call><name>Suff_AddSuffix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mainNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_PATH</name></expr>:</case>
<expr_stmt><expr><call><name>AddToPaths</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_INCLUDES</name></expr>:</case>
<expr_stmt><expr><call><name>Suff_AddInclude</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_LIBS</name></expr>:</case>
<expr_stmt><expr><call><name>Suff_AddLib</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_NULL</name></expr>:</case>
<expr_stmt><expr><call><name>Suff_SetNull</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SP_OBJDIR</name></expr>:</case>
<expr_stmt><expr><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencyTargets</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_cp</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lstart</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name> <modifier>*</modifier></type><name>inout_specType</name></decl></parameter>,
<parameter><decl><type><name>GNodeType</name> <modifier>*</modifier></type><name>inout_tOp</name></decl></parameter>,
<parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_paths</name></decl></parameter>,
<parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>curTargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tgt</name> <init>= <expr><operator>*</operator><name>inout_line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>savec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>






<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>tgt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseDependencyTargetWord</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <name>p</name> <operator>-</operator> <name>cp</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseIsEscaped</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>













<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Arch_ParseArchive</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tgt</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Error in archive specification: \"%s\""</literal></expr></argument>,
<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>tgt</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseErrorNoDependency</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>savec</name> <operator>=</operator> <operator>*</operator><name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseDependencyTarget</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>, <argument><expr><name>inout_specType</name></expr></argument>, <argument><expr><name>inout_tOp</name></expr></argument>,
<argument><expr><name>inout_paths</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_specType</name> <operator>==</operator> <name>SP_NOT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tgt</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencyTargetMundane</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>, <argument><expr><name>curTargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>inout_specType</name> <operator>==</operator> <name>SP_PATH</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tgt</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><name>tgt</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"Extra target (%s) ignored"</literal></expr></argument>,
<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>savec</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_specType</name> <operator>!=</operator> <name>SP_NOT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>inout_specType</name> <operator>!=</operator> <name>SP_PATH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencyTargetExtraWarn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>tgt</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tgt</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>tgt</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>tgt</name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ParseIsEscaped</name><argument_list>(<argument><expr><name>lstart</name></expr></argument>, <argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>inout_cp</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_line</name> <operator>=</operator> <name>tgt</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySourcesSpecial</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>, <parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>savec</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>savec</name> <operator>=</operator> <operator>*</operator><name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseDependencySourceSpecial</name><argument_list>(<argument><expr><name>specType</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>savec</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>savec</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDependencySourcesMundane</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>, <parameter><decl><type><name>GNodeType</name></type> <name>tOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>





<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>end</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name>end</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <name><name>end</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>







<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNodeList</name></type> <name>sources</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Arch_ParseArchive</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sources</name></expr></argument>,
<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Error in source archive spec \"%s\""</literal></expr></argument>,
<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sources</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>Lst_Dequeue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sources</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseDependencySource</name><argument_list>(<argument><expr><name>tOp</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>specType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ParseDependencySource</name><argument_list>(<argument><expr><name>tOp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencySources</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>GNodeType</name></type> <name>tOp</name></decl></parameter>,
<parameter><decl><type><name>ParseSpecial</name></type> <name>specType</name></decl></parameter>, <parameter><decl><type><name>SearchPathList</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_paths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseDependencySourcesEmpty</name><argument_list>(<argument><expr><name>specType</name></expr></argument>, <argument><expr><operator>*</operator><name>inout_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_MFLAGS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Main_ParseArgLine</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><operator>*</operator><name>line</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_SHELL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Job_ParseShell</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"improper shell specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>line</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_NOTPARALLEL</name> <operator>||</operator> <name>specType</name> <operator>==</operator> <name>SP_SINGLESHELL</name> <operator>||</operator>
<name>specType</name> <operator>==</operator> <name>SP_DELETE_ON_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>line</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_SUFFIXES</name> <operator>||</operator> <name>specType</name> <operator>==</operator> <name>SP_PATH</name> <operator>||</operator>
<name>specType</name> <operator>==</operator> <name>SP_INCLUDES</name> <operator>||</operator> <name>specType</name> <operator>==</operator> <name>SP_LIBS</name> <operator>||</operator>
<name>specType</name> <operator>==</operator> <name>SP_NULL</name> <operator>||</operator> <name>specType</name> <operator>==</operator> <name>SP_OBJDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseDependencySourcesSpecial</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>,
<argument><expr><operator>*</operator><name>inout_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_paths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Lst_Free</name><argument_list>(<argument><expr><operator>*</operator><name>inout_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_paths</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>specType</name> <operator>==</operator> <name>SP_PATH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Dir_SetPATH</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>inout_paths</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseDependencySourcesMundane</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>, <argument><expr><name>tOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>FindMainTarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




























<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependency</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNodeType</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPathList</name> <modifier>*</modifier></type><name>paths</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GNodeType</name></type> <name>tOp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>StringList</name></type> <name>curTargs</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>ParseSpecial</name></type> <name>specType</name> <init>= <expr><name>SP_NOT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"ParseDependency(%s)\n"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tOp</name> <operator>=</operator> <name>OP_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>paths</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseDependencyTargets</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>specType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tOp</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>paths</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curTargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curTargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curTargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseDependencyCheckSpec</name><argument_list>(<argument><expr><name>specType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseDependencyOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>lstart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>






<expr_stmt><expr><call><name>ApplyDependencyOperator</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParseDependencySources</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>tOp</name></expr></argument>, <argument><expr><name>specType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>paths</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_Free</name><argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curTargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>VarAssignParsed</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eq</name></decl>;</decl_stmt>
}</block></struct></type> <name>VarAssignParsed</name>;</typedef>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>AdjustVarassignOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarAssignParsed</name> <modifier>*</modifier></type><name>pvar</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><name>VarAssign</name> <modifier>*</modifier></type><name>out_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name><name>pvar</name><operator>-&gt;</operator><name>eq</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>name</name> <init>= <expr><name><name>pvar</name><operator>-&gt;</operator><name>nameStart</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarAssignOp</name></type> <name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&gt;</operator> <name>name</name> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_APPEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>&gt;</operator> <name>name</name> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_DEFAULT</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>&gt;</operator> <name>name</name> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_SUBST</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>&gt;</operator> <name>name</name> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_SHELL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_NORMAL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUNSHCMD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<while>while <condition>(<expr><name>op</name> <operator>&gt;</operator> <name>name</name> <operator>&amp;&amp;</operator> <call><name>ch_isspace</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>op</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>&gt;=</operator> <name>name</name> <operator>+</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator>
<name><name>op</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VAR_SHELL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>op</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameEnd</name> <init>= <expr><ternary><condition><expr><name><name>pvar</name><operator>-&gt;</operator><name>nameEnd</name></name> <operator>&lt;</operator> <name>op</name></expr> ?</condition><then> <expr><name><name>pvar</name><operator>-&gt;</operator><name>nameEnd</name></name></expr> </then><else>: <expr><name>op</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>out_var</name><operator>-&gt;</operator><name>varname</name></name> <operator>=</operator> <call><name>bmake_strsedup</name><argument_list>(<argument><expr><name><name>pvar</name><operator>-&gt;</operator><name>nameStart</name></name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out_var</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out_var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>














<function><type><name>bool</name></type>
<name>Parse_IsVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>VarAssign</name> <modifier>*</modifier></type><name>out_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VarAssignParsed</name></type> <name>pvar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>firstSpace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cpp_skip_hspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>nameStart</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>nameEnd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>eq</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>firstSpace</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>firstSpace</name> <operator>=</operator> <name>p</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUNSHCMD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>eq</name></name> <operator>=</operator> <name>p</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>nameEnd</name></name> <operator>=</operator> <ternary><condition><expr><name>firstSpace</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>firstSpace</name></expr> </then><else>: <expr><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cpp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AdjustVarassignOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvar</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>out_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'!'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>eq</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pvar</name><operator>.</operator><name>nameEnd</name></name> <operator>=</operator> <ternary><condition><expr><name>firstSpace</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>firstSpace</name></expr> </then><else>: <expr><name>p</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cpp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AdjustVarassignOp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvar</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>out_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>firstSpace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarCheckSyntax</name><parameter_list>(<parameter><decl><type><name>VarAssignOp</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uvalue</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>VAR_SUBST</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expandedValue</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>VARE_PARSE_ONLY</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>expandedValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expandedValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarAssign_EvalSubst</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uvalue</name></decl></parameter>,
<parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_avalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>evalue</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Var_ExistsExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_SetExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>VARE_KEEP_DOLLAR_UNDEF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Var_SetExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_avalue</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarAssign_EvalShell</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uvalue</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>,
<parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_avalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errfmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdOut</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_UNDEFERR</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmdOut</name> <operator>=</operator> <call><name>Cmd_Exec</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errfmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_SetExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>cmdOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_avalue</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>cmdOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errfmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>, <argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarAssign_Eval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VarAssignOp</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uvalue</name></decl></parameter>,
<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_true_avalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>avalue</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>VAR_APPEND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_AppendExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>VAR_SUBST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarAssign_EvalSubst</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>VAR_SHELL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarAssign_EvalShell</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>VAR_DEFAULT</name> <operator>&amp;&amp;</operator> <call><name>Var_ExistsExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>Var_SetExpand</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>uvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>out_true_avalue</name> <operator>=</operator> <name>avalue</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarAssignSpecial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>avalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAKEOVERRIDES</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Main_ExportMAKEFLAGS</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".CURDIR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>Dir_InitCur</name><argument_list>(<argument><expr><name>avalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Dir_SetPATH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAKE_JOB_PREFIX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Job_SetPrefix</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAKE_EXPORTED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_ExportVars</name><argument_list>(<argument><expr><name>avalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Parse_Var</name><parameter_list>(<parameter><decl><type><name>VarAssign</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>avalue</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VarCheckSyntax</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>VarAssign_Eval</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>op</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avalue</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>VarAssignSpecial</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>, <argument><expr><name><name>avalue</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>avalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MaybeSubMake</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>start</name> <operator>=</operator> <name>cmd</name></expr>;</init> <condition><expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>start</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>endc</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>cmd</name> <operator>||</operator> <operator>!</operator><call><name>ch_isalnum</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isalnum</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>endc</name> <operator>=</operator> <literal type="char">'}'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>endc</name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></else></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'M'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>endc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseAddCmd</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_DOUBLEDEP</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>gn</name><operator>-&gt;</operator><name>cohorts</name><operator>.</operator><name>last</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>cohorts</name><operator>.</operator><name>last</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_HAS_COMMANDS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MaybeSubMake</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_SUBMAKE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>RememberLocation</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

Lst_Append(&amp;gn-&gt;commands, cmd);
Parse_Error(PARSE_WARNING,
"overriding commands for target \"%s\"; "
"previous commands defined at %s: %d ignored",
gn-&gt;name, gn-&gt;fname, gn-&gt;lineno);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"duplicate script for target \"%s\" ignored"</literal></expr></argument>,
<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseErrorInternal</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>gn</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name>PARSE_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"using previous script for \"%s\" defined here"</literal></expr></argument>,
<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Parse_AddIncludeDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name>parseIncPath</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type>
<name>IncludeFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSystem</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>depinc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>silent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slash</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>incdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fullname</name> <operator>=</operator> <ternary><condition><expr><name><name>file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> ?</condition><then> <expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isSystem</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><name>incdir</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>incdir</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>slash</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>file</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"../"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>incdir</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>slash</name></expr></argument>, <argument><expr><literal type="string">"/.."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>slash</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>newName</name> <operator>=</operator> <call><name>str_concat3</name><argument_list>(<argument><expr><name>incdir</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>file</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>newName</name></expr></argument>, <argument><expr><name>parseIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>newName</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>incdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>









<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>suffPath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>suff</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>suffPath</name> <operator>=</operator> <call><name>Suff_GetPath</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>suffPath</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>suffPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>parseIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><ternary><condition><expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sysIncPath</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>defSysIncPath</name></expr> </then><else>: <expr><name>sysIncPath</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fullname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Could not find %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Cannot open %s"</literal></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>loadfile</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Parse_PushInput</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>loadedfile_readMore</name></expr></argument>, <argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>lf</name> <operator>=</operator> <name>lf</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depinc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>doing_depend</name> <operator>=</operator> <name>depinc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseInclude</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>directive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>endc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>silent</name> <init>= <expr><name><name>directive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'i'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>file</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>directive</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>silent</name></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">7</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pp_skip_hspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">".include filename must be delimited by '\"' or '&lt;'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>endc</name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>endc</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>endc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>endc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Unclosed .include filename. '%c' expected"</literal></expr></argument>, <argument><expr><name>endc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xfile</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>xfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>IncludeFile</name><argument_list>(<argument><expr><name><name>file</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>endc</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr></argument>, <argument><expr><name><name>directive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr></argument>, <argument><expr><name>silent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetFilenameVars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirvar</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filevar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>basename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>dirname</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slash</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>basename</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><call><name>bmake_strsedup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>slash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>basename</name> <operator>=</operator> <name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>dirvar</name></expr></argument>, <argument><expr><name><name>dirname</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>filevar</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG5</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"%s: ${%s} = `%s' ${%s} = `%s'\n"</literal></expr></argument>,
<argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>dirvar</name></expr></argument>, <argument><expr><name><name>dirname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>filevar</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetActuallyIncludingFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>IFile</name> <modifier>*</modifier></type><name>incs</name> <init>= <expr><call><name>GetInclude</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>includes</name><operator>.</operator><name>len</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>incs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>fromForLoop</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>incs</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>fname</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseSetParseFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>including</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SetFilenameVars</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">".PARSEDIR"</literal></expr></argument>, <argument><expr><literal type="string">".PARSEFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>including</name> <operator>=</operator> <call><name>GetActuallyIncludingFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>including</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SetFilenameVars</name><argument_list>(<argument><expr><name>including</name></expr></argument>,
<argument><expr><literal type="string">".INCLUDEDFROMDIR"</literal></expr></argument>, <argument><expr><literal type="string">".INCLUDEDFROMFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".INCLUDEDFROMDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".INCLUDEDFROMFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>StrContainsWord</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>strLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wordLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>strLen</name> <operator>&lt;</operator> <name>wordLen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>strLen</name> <operator>-</operator> <name>wordLen</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>wordLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>p</name><index>[<expr><name>wordLen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><name>wordLen</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarContainsWord</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>val</name> <init>= <expr><call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name><name>val</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>StrContainsWord</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseTrackInput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VarContainsWord</name><argument_list>(<argument><expr><name>MAKE_MAKEFILES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKE_MAKEFILES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Parse_PushInput</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name>ReadMoreProc</name></type> <name>readMore</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>readMoreArg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>fromForLoop</name> <init>= <expr><name>name</name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fromForLoop</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>fname</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseTrackInput</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"Parse_PushInput: %s %s, line %d\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>readMore</name> <operator>==</operator> <name>loadedfile_readMore</name></expr> ?</condition><then> <expr><literal type="string">"file"</literal></expr> </then><else>: <expr><literal type="string">".for loop in"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>readMore</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>curFile</name> <operator>=</operator> <call><name>Vector_Push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>fromForLoop</name></name> <operator>=</operator> <name>fromForLoop</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>readMore</name></name> <operator>=</operator> <name>readMore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>readMoreArg</name></name> <operator>=</operator> <name>readMoreArg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>depending</name></name> <operator>=</operator> <name>doing_depend</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>readMore</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name><name>curFile</name><operator>-&gt;</operator><name>readMore</name></name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>readMoreArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_freeIt</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_ptr</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_end</name></name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>cond_depth</name></name> <operator>=</operator> <call><name>Cond_save_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseSetParseFile</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsInclude</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sysv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>||</operator> <name><name>dir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><name><name>dir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>sysv</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dir</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"include"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><operator>!</operator><name>sysv</name> <operator>||</operator> <call><name>ch_isspace</name><argument_list>(<argument><expr><name><name>dir</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYSVINCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsSysVInclude</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsInclude</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>line</name></expr>;</init> <condition><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition><incr/>)</control> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseTraditionalInclude</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>silent</name> <init>= <expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'i'</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name>line</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>silent</name></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">7</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>all_files</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>all_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>file</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Filename missing from \"include\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>file</name> <operator>=</operator> <name>all_files</name></expr>;</init> <condition><expr><operator>!</operator><name>done</name></expr>;</condition> <incr><expr><name>file</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>file</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>IncludeFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>silent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>all_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GMAKEEXPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseGmakeExport</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>variable</name> <init>= <expr><name>line</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>value</name> <operator>=</operator> <name>variable</name></expr>;</init> <condition><expr><operator>*</operator><name>value</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>value</name> <operator>!=</operator> <literal type="char">'='</literal></expr>;</condition> <incr><expr><name>value</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>value</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Variable/Value missing from \"export\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>value</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>




<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseEOF</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name> <init>= <expr><call><name>CurFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>readMore</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>doing_depend</name> <operator>=</operator> <name><name>curFile</name><operator>-&gt;</operator><name>depending</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name><name>curFile</name><operator>-&gt;</operator><name>readMore</name></name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>readMoreArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_freeIt</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_end</name></name> <operator>=</operator> <ternary><condition><expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name><name>curFile</name><operator>-&gt;</operator><name>first_lineno</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>Cond_restore_depth</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>cond_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curFile</name><operator>-&gt;</operator><name>lf</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>loadedfile_destroy</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>lf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_freeIt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Vector_Pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>includes</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".PARSEDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".PARSEFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".INCLUDEDFROMDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".INCLUDEDFROMFILE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>curFile</name> <operator>=</operator> <call><name>CurFile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"ParseEOF: returning to file %s, line %d\n"</literal></expr></argument>,
<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParseSetParseFile</name><argument_list>(<argument><expr><name><name>curFile</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>ParseRawLineResult</name> <block>{
<decl><name>PRLR_LINE</name></decl>,
<decl><name>PRLR_EOF</name></decl>,
<decl><name>PRLR_ERROR</name></decl>
}</block></enum></type> <name>ParseRawLineResult</name>;</typedef>






<function><type><specifier>static</specifier> <name>ParseRawLineResult</name></type>
<name>ParseRawLine</name><parameter_list>(<parameter><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_line</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_line_end</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_firstBackslash</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_firstComment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_end</name> <init>= <expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line_end</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstBackslash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstComment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParseRawLineResult</name></type> <name>res</name> <init>= <expr><name>PRLR_LINE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>buf_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>PRLR_EOF</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator>
<operator>(</operator><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>buf_end</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Zero byte read from file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>PRLR_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>firstBackslash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>firstBackslash</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>lineno</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">2</literal> <operator>==</operator> <name>buf_end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>line_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>line_end</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>line_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&lt;=</operator> <name>buf_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name>firstComment</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>p</name> <operator>&gt;</operator> <name>line</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>firstComment</name> <operator>=</operator> <name>line_end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>line_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>out_line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curFile</name><operator>-&gt;</operator><name>buf_ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_line_end</name> <operator>=</operator> <name>line_end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_firstBackslash</name> <operator>=</operator> <name>firstBackslash</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_firstComment</name> <operator>=</operator> <name>firstComment</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnescapeBackslash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>spaceStart</name> <init>= <expr><name>line</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>src</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dst</name><operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>




<expr_stmt><expr><name>spaceStart</name> <operator>=</operator> <name>dst</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>pp_skip_hspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dst</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></for>


<while>while <condition>(<expr><name>dst</name> <operator>&gt;</operator> <name>spaceStart</name> <operator>&amp;&amp;</operator> <call><name>ch_isspace</name><argument_list>(<argument><expr><name><name>dst</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dst</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <name>GetLineMode</name> <block>{





<decl><name>GLM_NONEMPTY</name></decl>,








<decl><name>GLM_FOR_BODY</name></decl>,









<decl><name>GLM_DOT</name></decl>
}</block></enum></type> <name>GetLineMode</name>;</typedef>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParseGetLine</name><parameter_list>(<parameter><decl><type><name>GetLineMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IFile</name> <modifier>*</modifier></type><name>curFile</name> <init>= <expr><call><name>CurFile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstBackslash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>firstComment</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ParseRawLineResult</name></type> <name>res</name> <init>= <expr><call><name>ParseRawLine</name><argument_list>(<argument><expr><name>curFile</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstBackslash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstComment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>PRLR_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>line_end</name> <operator>==</operator> <name>line</name> <operator>||</operator> <name>firstComment</name> <operator>==</operator> <name>line</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>PRLR_EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>GLM_FOR_BODY</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>line_end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>line_end</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>GLM_FOR_BODY</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>line</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>GLM_DOT</name> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>firstComment</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>firstComment</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>firstBackslash</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>line</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>UnescapeBackslash</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>firstBackslash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>line</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseSkippedBranches</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name>ParseGetLine</name><argument_list>(<argument><expr><name>GLM_DOT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>Cond_EvalLine</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>COND_PARSE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>













</block_content>}</block></while>

<return>return <expr><name>line</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseForLoop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstLineno</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>For_Eval</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>firstLineno</name> <operator>=</operator> <call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>lineno</name></expr>;</expr_stmt>


<do>do <block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ParseGetLine</name><argument_list>(<argument><expr><name>GLM_FOR_BODY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Unexpected end of file in .for loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>For_Accum</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><call><name>For_Run</name><argument_list>(<argument><expr><name>firstLineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParseReadLine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ParseGetLine</name><argument_list>(<argument><expr><name>GLM_NONEMPTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>line</name></expr>;</return></block_content></block></if></if_stmt>





<switch>switch <condition>(<expr><call><name>Cond_EvalLine</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>COND_SKIP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseSkippedBranches</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<continue>continue;</continue>
<case>case <expr><name>COND_PARSE</name></expr>:</case>
<continue>continue;</continue>
<case>case <expr><name>COND_INVALID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ParseForLoop</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>line</name></expr>;</return>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FinishDependencyGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>targets</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>targets</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Suff_EndTransform</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_HAS_COMMANDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>Lst_Free</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>targets</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseLine_ShellCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>cpp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>targets</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Unassociated shell command \"%s\""</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>targets</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ParseAddCmd</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targCmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseDirective</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>dir</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IsInclude</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseInclude</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dir</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ch_isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>dir</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pp_skip_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"undef"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_Undef</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"export"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_Export</name><argument_list>(<argument><expr><name>VEM_PLAIN</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"export-env"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_Export</name><argument_list>(<argument><expr><name>VEM_ENV</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"export-literal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_Export</name><argument_list>(<argument><expr><name>VEM_LITERAL</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"unexport"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_UnExport</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"unexport-env"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_UnExport</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseMessage</name><argument_list>(<argument><expr><name>PARSE_INFO</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseMessage</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseMessage</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseVarassign</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VarAssign</name></type> <name>var</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Parse_IsVar</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FinishDependencyGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Parse_Var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>FindSemicolon</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'}'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseDependencyLine</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shellcmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>






<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>semicolon</name> <init>= <expr><call><name>FindSemicolon</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>semicolon</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>semicolon</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>shellcmd</name> <operator>=</operator> <name>semicolon</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
































<expr_stmt><expr><name>emode</name> <operator>=</operator> <ternary><condition><expr><name><name>opts</name><operator>.</operator><name>strict</name></name></expr> ?</condition><then> <expr><name>VARE_WANTRES</name></expr> </then><else>: <expr><name>VARE_UNDEFERR</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>targets</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_Free</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>targets</name> <operator>=</operator> <call><name>Lst_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParseDependency</name><argument_list>(<argument><expr><name>expanded_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expanded_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shellcmd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseLine_ShellCommand</name><argument_list>(<argument><expr><name>shellcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseLine</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>







<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>ParseDirective</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ParseLine_ShellCommand</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYSVINCLUDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>IsSysVInclude</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>ParseTraditionalInclude</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GMAKEEXPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"export"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ch_isspace</name><argument_list>(<argument><expr><name><name>line</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>ParseGmakeExport</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>ParseVarassign</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FinishDependencyGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParseDependencyLine</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>Parse_File</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>loadedfile</name></name> <modifier>*</modifier></type><name>lf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lf</name> <operator>=</operator> <call><name>loadfile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>targets</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"(stdin)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Parse_PushInput</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>loadedfile_readMore</name></expr></argument>, <argument><expr><name>lf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>lf</name> <operator>=</operator> <name>lf</name></expr>;</expr_stmt>

<do>do <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>line</name> <operator>=</operator> <call><name>ParseReadLine</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>PARSE</name></expr></argument>, <argument><expr><literal type="string">"ParseReadLine (%d): '%s'\n"</literal></expr></argument>,
<argument><expr><call><name>CurFile</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>lineno</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseLine</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

</block_content>}</block> while <condition>(<expr><call><name>ParseEOF</name><argument_list>()</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><call><name>FinishDependencyGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>parseErrors</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Fatal errors encountered -- cannot continue"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintOnError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Parse_Init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>mainNode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseIncPath</name> <operator>=</operator> <call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sysIncPath</name> <operator>=</operator> <call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>defSysIncPath</name> <operator>=</operator> <call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Vector_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>includes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IFile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Parse_End</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_DoneCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targCmds</name></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>targets</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>defSysIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>sysIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>parseIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>includes</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Vector_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>Parse_MainName</name><parameter_list>(<parameter><decl><type><name>GNodeList</name> <modifier>*</modifier></type><name>mainList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mainNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Punt</name><argument_list>(<argument><expr><literal type="string">"no target to make."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>mainList</name></expr></argument>, <argument><expr><name>mainNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mainNode</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_DOUBLEDEP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_AppendAll</name><argument_list>(<argument><expr><name>mainList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>mainNode</name><operator>-&gt;</operator><name>cohorts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><literal type="string">".TARGETS"</literal></expr></argument>, <argument><expr><name><name>mainNode</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>Parse_NumErrors</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>parseErrors</name></expr>;</return>
</block_content>}</block></function>
</unit>
