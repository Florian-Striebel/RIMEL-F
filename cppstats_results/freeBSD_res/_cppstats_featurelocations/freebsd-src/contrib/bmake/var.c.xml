<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bmake/var.c">





























































































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_REGEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;regex.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"make.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_INTTYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDINT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIMITS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"metachar.h"</cpp:file></cpp:include>


<expr_stmt><expr><call><name>MAKE_RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: var.c,v 1.973 2021/12/12 20:45:48 sjg Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




















<typedef>typedef <type><struct>struct <name>Var</name> <block>{





<decl_stmt><decl><type><name>FStr</name></type> <name>name</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Buffer</name></type> <name>val</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>fromCmd</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>fromEnv</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>readOnly</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>inUse</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>exported</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>reexport</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block></struct></type> <name>Var</name>;</typedef>








<typedef>typedef <type><enum>enum <name>VarExportedMode</name> <block>{
<decl><name>VAR_EXPORTED_NONE</name></decl>,
<decl><name>VAR_EXPORTED_SOME</name></decl>,
<decl><name>VAR_EXPORTED_ALL</name></decl>
}</block></enum></type> <name>VarExportedMode</name>;</typedef>

<typedef>typedef <type><enum>enum <name>UnexportWhat</name> <block>{

<decl><name>UNEXPORT_NAMED</name></decl>,




<decl><name>UNEXPORT_ALL</name></decl>,




<decl><name>UNEXPORT_ENV</name></decl>
}</block></enum></type> <name>UnexportWhat</name>;</typedef>


<typedef>typedef <type><struct>struct <name>PatternFlags</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>subGlobal</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>subOnce</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>anchorStart</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>anchorEnd</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block></struct></type> <name>PatternFlags</name>;</typedef>


<typedef>typedef <type><struct>struct <name>SepBuf</name> <block>{
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>needSep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>sep</name></decl>;</decl_stmt>
}</block></struct></type> <name>SepBuf</name>;</typedef>






<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>savedEnv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>char</name></type> <name><name>var_Error</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>









<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>varUndefined</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKE_SAVE_DOLLARS</name></cpp:macro> <cpp:value>".MAKE.SAVE_DOLLARS"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>save_dollars</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>






















<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>SCOPE_CMDLINE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>SCOPE_GLOBAL</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>SCOPE_INTERNAL</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VarExportedMode</name></type> <name>var_exportedVars</name> <init>= <expr><name>VAR_EXPORTED_NONE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>VarEvalMode_Name</name><index>[]</index><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="string">"parse-only"</literal></expr>,
<expr><literal type="string">"eval"</literal></expr>,
<expr><literal type="string">"eval-defined"</literal></expr>,
<expr><literal type="string">"eval-keep-dollar"</literal></expr>,
<expr><literal type="string">"eval-keep-undefined"</literal></expr>,
<expr><literal type="string">"eval-keep-dollar-and-undefined"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>VarNew</name><parameter_list>(<parameter><decl><type><name>FStr</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fromEnv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>value_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>bmake_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>value_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>fromCmd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>fromEnv</name></name> <operator>=</operator> <name>fromEnv</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>=</operator> <name>readOnly</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>inUse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>exported</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reexport</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Substring</name></type>
<name>CanonicalVarname</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>name</name><operator>.</operator><name>start</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>name</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".ALLSRC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>ALLSRC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".ARCHIVE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>ARCHIVE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".IMPSRC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>IMPSRC</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".MEMBER"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>MEMBER</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".OODATE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>OODATE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".PREFIX"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".TARGET"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>TARGET</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".SHELL"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>shellPath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Shell_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>GNode_FindVar</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>Substring</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>HashTable_FindValueBySubstringHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>VarFindSubstring</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elsewhere</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nameHash</name></decl>;</decl_stmt>


<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>CanonicalVarname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nameHash</name> <operator>=</operator> <call><name>Hash_Substring</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elsewhere</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>var</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>SCOPE_CMDLINE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>checkEnvFirst</name></name> <operator>&amp;&amp;</operator> <name>var</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>SCOPE_GLOBAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>SCOPE_INTERNAL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>SCOPE_INTERNAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>envName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envValue</name></decl>;</decl_stmt>






<expr_stmt><expr><name>envName</name> <operator>=</operator> <call><name>Substring_Str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>envValue</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name><name>envName</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>envValue</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>VarNew</name><argument_list>(<argument><expr><name>envName</name></expr></argument>, <argument><expr><name>envValue</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>envName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>checkEnvFirst</name></name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>SCOPE_GLOBAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>SCOPE_INTERNAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>GNode_FindVar</name><argument_list>(<argument><expr><name>SCOPE_INTERNAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>nameHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>VarFind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>elsewhere</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>VarFindSubstring</name><argument_list>(<argument><expr><call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>elsewhere</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarFreeEnv</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>fromEnv</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>VarAdd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>VarSetFlags</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HashEntry</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><call><name>HashTable_CreateEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>VarNew</name><argument_list>(<argument><expr><call><name>FStr_InitRefer</name><argument_list>( <argument><expr><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VAR_SET_READONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>HashEntry_Set</name><argument_list>(<argument><expr><name>he</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s\n"</literal></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Var_Delete</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HashEntry</name> <modifier>*</modifier></type><name>he</name> <init>= <expr><call><name>HashTable_FindEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>he</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s:delete %s (not found)\n"</literal></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s:delete %s\n"</literal></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>he</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>inUse</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Cannot delete variable \"%s\" while it is used"</literal></expr></argument>,
<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>MAKE_EXPORTED</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>var_exportedVars</name> <operator>=</operator> <name>VAR_EXPORTED_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>freeIt</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HashTable_DeleteEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Var_DeleteExpand</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>varname</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Var_Delete</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Var_Undef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>vpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Words</name></type> <name>varnames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"The .undef directive requires an argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vpr</name> <operator>=</operator> <call><name>Var_Subst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vpr</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Error in variable names to be undefined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>varnames</name> <operator>=</operator> <call><name>Str_Words</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>varnames</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>varnames</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>varnames</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>varnames</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name><name>varnames</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>Words_Free</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MayExport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>






<switch>switch <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<case>case <expr><literal type="char">'%'</literal></expr>:</case>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExportVarEnv</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>exported</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>inUse</name></name></expr>)</condition> <block>{<block_content>




<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>str_concat3</name><argument_list>(<argument><expr><literal type="string">"${"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExportVarPlain</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>







<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExportVarLiteral</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>exported</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExportVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VarExportMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MayExport</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>VEM_ENV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExportVarEnv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>VEM_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExportVarPlain</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>ExportVarLiteral</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Var_ReexportVars</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xvarnames</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">21</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>makelevel</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>MAKE_LEVEL_ENV</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>var_exportedVars</name> <operator>==</operator> <name>VAR_EXPORTED_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var_exportedVars</name> <operator>==</operator> <name>VAR_EXPORTED_ALL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>HashIter</name></type> <name>hi</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>HashIter_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SCOPE_GLOBAL</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HashIter_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>hi</name><operator>.</operator><name>entry</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ExportVar</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>VEM_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${"</literal> <name>MAKE_EXPORTED</name> <literal type="string">":O:u}"</literal></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>xvarnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xvarnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Words</name></type> <name>varnames</name> <init>= <expr><call><name>Str_Words</name><argument_list>(<argument><expr><name>xvarnames</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>varnames</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ExportVar</name><argument_list>(<argument><expr><name><name>varnames</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>VEM_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>Words_Free</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>xvarnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExportVars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varnames</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isExport</name></decl></parameter>, <parameter><decl><type><name>VarExportMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>
<decl_stmt><decl><type><name>Words</name></type> <name>words</name> <init>= <expr><call><name>Str_Words</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>words</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExportVar</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var_exportedVars</name> <operator>==</operator> <name>VAR_EXPORTED_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>var_exportedVars</name> <operator>=</operator> <name>VAR_EXPORTED_SOME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isExport</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <name>VEM_PLAIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKE_EXPORTED</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>Words_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExportVarsExpand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uvarnames</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isExport</name></decl></parameter>, <parameter><decl><type><name>VarExportMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xvarnames</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>uvarnames</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xvarnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ExportVars</name><argument_list>(<argument><expr><name>xvarnames</name></expr></argument>, <argument><expr><name>isExport</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>xvarnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Var_Export</name><parameter_list>(<parameter><decl><type><name>VarExportMode</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>VEM_PLAIN</name> <operator>&amp;&amp;</operator> <name><name>varnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>var_exportedVars</name> <operator>=</operator> <name>VAR_EXPORTED_ALL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ExportVarsExpand</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Var_ExportVars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varnames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ExportVarsExpand</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>VEM_PLAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ClearEnv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newenv</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>MAKE_LEVEL_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>environ</name> <operator>==</operator> <name>savedEnv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newenv</name> <operator>=</operator> <call><name>bmake_realloc</name><argument_list>(<argument><expr><name>environ</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>savedEnv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>savedEnv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>savedEnv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>newenv</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>environ</name> <operator>=</operator> <name>savedEnv</name> <operator>=</operator> <name>newenv</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newenv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newenv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>MAKE_LEVEL_ENV</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetVarnamesToUnexport</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
<parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_varnames</name></decl></parameter>, <parameter><decl><type><name>UnexportWhat</name> <modifier>*</modifier></type><name>out_what</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UnexportWhat</name></type> <name>what</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>varnames</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isEnv</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"The directive .unexport-env does not take "</literal>
<literal type="string">"arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>what</name> <operator>=</operator> <name>UNEXPORT_ENV</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>what</name> <operator>=</operator> <ternary><condition><expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><name>UNEXPORT_NAMED</name></expr> </then><else>: <expr><name>UNEXPORT_ALL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>UNEXPORT_NAMED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>varnames</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>!=</operator> <name>UNEXPORT_NAMED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${"</literal> <name>MAKE_EXPORTED</name> <literal type="string">":O:u}"</literal></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>,
<argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varnames</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>out_varnames</name> <operator>=</operator> <name>varnames</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_what</name> <operator>=</operator> <name>what</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnexportVar</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><name>UnexportWhat</name></type> <name>what</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>VarFindSubstring</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Not unexporting \"%.*s\" (not found)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Unexporting \"%.*s\"\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>!=</operator> <name>UNEXPORT_ENV</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>reexport</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>UNEXPORT_NAMED</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>str_concat3</name><argument_list>(<argument><expr><literal type="string">"${"</literal> <name>MAKE_EXPORTED</name> <literal type="string">":N"</literal></expr></argument>,
<argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKE_EXPORTED</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnexportVars</name><parameter_list>(<parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>varnames</name></decl></parameter>, <parameter><decl><type><name>UnexportWhat</name></type> <name>what</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>UNEXPORT_ENV</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ClearEnv</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Substring_Words</name><argument_list>(<argument><expr><name><name>varnames</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>UnexportVar</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>!=</operator> <name>UNEXPORT_NAMED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><name>MAKE_EXPORTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>Var_UnExport</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isEnv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UnexportWhat</name></type> <name>what</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>varnames</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetVarnamesToUnexport</name><argument_list>(<argument><expr><name>isEnv</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UnexportVars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varnames</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ExistsInCmdline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fromCmd</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s ignored!\n"</literal></expr></argument>,
<argument><expr><name><name>SCOPE_GLOBAL</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VarFreeEnv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Var_SetWithFlags</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>,
<parameter><decl><type><name>VarSetFlags</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"SetVar: variable name is empty - ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_GLOBAL</name> <operator>&amp;&amp;</operator> <call><name>ExistsInCmdline</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>






<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VAR_SET_NO_EXPORT</name><operator>)</operator></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><call><name>Var_Delete</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".SUFFIXES"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s ignored (read-only)\n"</literal></expr></argument>,
<argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarAdd</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>readOnly</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VAR_SET_READONLY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s ignored (read-only)\n"</literal></expr></argument>,
<argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_Empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s\n"</literal></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>exported</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ExportVar</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>VEM_PLAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>





<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VAR_SET_NO_EXPORT</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fromCmd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>varNoExportEnv</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEOVERRIDES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAKE_SAVE_DOLLARS</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>save_dollars</name> <operator>=</operator> <call><name>ParseBoolean</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>save_dollars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarFreeEnv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Var_SetExpandWithFlags</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>,
<parameter><decl><type><name>VarSetFlags</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unexpanded_name</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>varname</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>varname</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>,
<argument><expr><literal type="string">"Var_SetExpand: variable name \"%s\" expands "</literal>
<literal type="string">"to empty string, with value \"%s\" - ignored\n"</literal></expr></argument>,
<argument><expr><name>unexpanded_name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_SetWithFlags</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Var_Set</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_SetWithFlags</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>VAR_SET_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><name>void</name></type>
<name>Var_SetExpand</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_SetExpandWithFlags</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>VAR_SET_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Global_Set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Global_SetExpand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_SetExpand</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Global_Delete</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_Delete</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Var_Append</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>scope</name> <operator>==</operator> <name>SCOPE_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Var_SetWithFlags</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>VAR_SET_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>readOnly</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Ignoring append to %s since it is read-only\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>||</operator> <operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>fromCmd</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"%s: %s = %s\n"</literal></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fromEnv</name></name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>fromEnv</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>





<expr_stmt><expr><call><name>HashTable_Set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





















<function><type><name>void</name></type>
<name>Var_AppendExpand</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>xname</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xname</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expanded</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>,
<argument><expr><literal type="string">"Var_AppendExpand: variable name \"%s\" expands "</literal>
<literal type="string">"to empty string, with value \"%s\" - ignored\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Var_Append</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>xname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Global_Append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_Append</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>Var_Exists</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>VarFreeEnv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>Var_ExistsExpand</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>varname</name> <init>= <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>exists</name> <operator>=</operator> <call><name>Var_Exists</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>













<function><type><name>FStr</name></type>
<name>Var_Value</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>fromEnv</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GNode_ValueDirect</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarEvalMode</name></type>
<name>VarEvalMode_WithoutKeepDollar</name><parameter_list>(<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_KEEP_DOLLAR_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VARE_EVAL_KEEP_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_EVAL_KEEP_DOLLAR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VARE_WANTRES</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>emode</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarEvalMode</name></type>
<name>VarEvalMode_UndefOk</name><parameter_list>(<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name></expr> ?</condition><then> <expr><name>VARE_WANTRES</name></expr> </then><else>: <expr><name>emode</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarEvalMode_ShouldEval</name><parameter_list>(<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>emode</name> <operator>!=</operator> <name>VARE_PARSE_ONLY</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarEvalMode_ShouldKeepUndef</name><parameter_list>(<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>emode</name> <operator>==</operator> <name>VARE_EVAL_KEEP_UNDEF</name> <operator>||</operator>
<name>emode</name> <operator>==</operator> <name>VARE_KEEP_DOLLAR_UNDEF</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarEvalMode_ShouldKeepDollar</name><parameter_list>(<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>emode</name> <operator>==</operator> <name>VARE_EVAL_KEEP_DOLLAR</name> <operator>||</operator>
<name>emode</name> <operator>==</operator> <name>VARE_KEEP_DOLLAR_UNDEF</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_Init</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>needSep</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <name>sep</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_Sep</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>needSep</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_AddBytes</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>mem_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>mem_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>needSep</name></name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>sep</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>needSep</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_AddBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>mem_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_AddBytesBetween</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_AddStr</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SepBuf_AddSubstring</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Substring</name></type> <name>sub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>sub</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>sub</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SepBuf_DoneData</name><parameter_list>(<parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>ModifyWordProc</name>)<parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl></typedef>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Head</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>dummy</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>Substring_Dirname</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Tail</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>dummy</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>Substring_Basename</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Suffix</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>dummy</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lastDot</name> <init>= <expr><call><name>Substring_LastIndex</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lastDot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lastDot</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Root</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>dummy</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lastDot</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lastDot</name> <operator>=</operator> <call><name>Substring_LastIndex</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>lastDot</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>lastDot</name></expr> </then><else>: <expr><name><name>word</name><operator>.</operator><name>end</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Match</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Str_Match</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_NoMatch</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Str_Match</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYSVVARSUB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>ModifyWord_SysVSubstArgs</name> <block>{
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>lhsPrefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>lhsPercent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>lhsSuffix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rhs</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_SysVSubst</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ModifyWord_SysVSubstArgs</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>rhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rhsExp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>percent</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_IsEmpty</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Substring_HasPrefix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhsPrefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>no_match</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Substring_HasSuffix</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhsSuffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>no_match</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhsExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>rhsExp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>percent</name> <operator>=</operator> <ternary><condition><expr><name><name>args</name><operator>-&gt;</operator><name>lhsPercent</name></name></expr> ?</condition><then> <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>rhs</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>percent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>rhs</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>percent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>percent</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>args</name><operator>-&gt;</operator><name>lhsPercent</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name> <operator>+</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhsPrefix</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>word</name><operator>.</operator><name>end</name></name> <operator>-</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhsSuffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SepBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>percent</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>percent</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>rhs</name><operator>.</operator><name>str</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>

<label><name>no_match</name>:</label>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<struct>struct <name>ModifyWord_SubstArgs</name> <block>{
<decl_stmt><decl><type><name>Substring</name></type> <name>lhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>rhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PatternFlags</name></type> <name>pflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>matched</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>Substring_Find</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>haystack</name></decl></parameter>, <parameter><decl><type><name>Substring</name></type> <name>needle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>needleLen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name>haystack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needleLen</name> <operator>=</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name>needle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <name>needleLen</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>haystack</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>needle</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>needleLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>haystack</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Subst</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_SubstArgs</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wordLen</name></decl>, <decl><type ref="prev"/><name>lhsLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wordEnd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>

<expr_stmt><expr><name>wordLen</name> <operator>=</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wordEnd</name> <operator>=</operator> <name><name>word</name><operator>.</operator><name>end</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>subOnce</name></name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>matched</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lhsLen</name> <operator>=</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>anchorStart</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>wordLen</name> <operator>&lt;</operator> <name>lhsLen</name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>lhsLen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>anchorEnd</name></name> <operator>&amp;&amp;</operator> <name>wordLen</name> <operator>!=</operator> <name>lhsLen</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>start</name></name> <operator>+</operator> <name>lhsLen</name></expr></argument>, <argument><expr><name>wordEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>anchorEnd</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>wordLen</name> <operator>&lt;</operator> <name>lhsLen</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>wordEnd</name> <operator>-</operator> <name>lhsLen</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhs</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>lhsLen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>wordEnd</name> <operator>-</operator> <name>lhsLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_IsEmpty</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nosub</name>;</goto></block_content></block></if></if_stmt>


<while>while <condition>(<expr><operator>(</operator><name>match</name> <operator>=</operator> <call><name>Substring_Find</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>word</name><operator>.</operator><name>start</name></name> <operator>=</operator> <name>match</name> <operator>+</operator> <name>lhsLen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Substring_IsEmpty</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>subGlobal</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<label><name>nosub</name>:</label>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_REGEX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarREError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reerr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>errlen</name> <init>= <expr><call><name>regerror</name><argument_list>(<argument><expr><name>reerr</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name> <init>= <expr><call><name>bmake_malloc</name><argument_list>(<argument><expr><name>errlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>reerr</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>RegexReplace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>regmatch_t</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nsub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>replace</name></expr>;</init> <condition><expr><operator>*</operator><name>rp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>rp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>||</operator> <name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>wp</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></argument>,
<argument><expr><name>wp</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator> <operator>!</operator><call><name>ch_isdigit</name><argument_list>(<argument><expr><name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>rp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>nsub</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"No subexpression \\%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>m</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"No match for subexpression \\%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>wp</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></argument>,
<argument><expr><name>wp</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<struct>struct <name>ModifyWord_SubstRegexArgs</name> <block>{
<decl_stmt><decl><type><name>regex_t</name></type> <name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nsub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PatternFlags</name></type> <name>pflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>matched</name></decl>;</decl_stmt>
}</block>;</struct>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_SubstRegex</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_SubstRegexArgs</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xrv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>regmatch_t</name></type> <name><name>m</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wp</name> <operator>=</operator> <name><name>word</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>subOnce</name></name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>matched</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>no_match</name>;</goto></block_content></block></if></if_stmt>

<label><name>again</name>:</label>
<expr_stmt><expr><name>xrv</name> <operator>=</operator> <call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>nsub</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xrv</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ok</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xrv</name> <operator>!=</operator> <name>REG_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarREError</name><argument_list>(<argument><expr><name>xrv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><literal type="string">"Unexpected regex error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>no_match</name>:</label>
<expr_stmt><expr><call><name>SepBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>

<label><name>ok</name>:</label>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RegexReplace</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>replace</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>nsub</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wp</name> <operator>+=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>pflags</name><operator>.</operator><name>subGlobal</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>REG_NOTBOL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddBytes</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>wp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>again</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>wp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<struct>struct <name>ModifyWord_LoopArgs</name> <block>{
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Loop</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ModifyWord_LoopArgs</name></name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_IsEmpty</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_SetWithFlags</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>,
<argument><expr><name>VAR_SET_NO_EXPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG4</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"ModifyWord_Loop: "</literal>
<literal type="string">"in \"%s\", replace \"%s\" with \"%s\" to \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <call><name>Buf_EndsWith</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>needSep</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SepBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>VarSelectWords</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oneBigWord</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SepBuf</name></type> <name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SepBuf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oneBigWord</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>words</name></name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>freeIt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Substring_Words</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>words</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>last</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>first</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>first</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>last</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>last</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <ternary><condition><expr><name>first</name> <operator>&lt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>first</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>last</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>last</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><operator>(</operator><name>step</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>i</name> <operator>&gt;=</operator> <name>end</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SepBuf_Sep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>SepBuf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Realpath</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>rbuf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>cached_realpath</name><argument_list>(<argument><expr><name><name>word</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>rp</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <call><name>stat</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SubstringWords_JoinFree</name><parameter_list>(<parameter><decl><type><name>SubstringWords</name></type> <name>words</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Buf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_AddBytesBetween</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>,
<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>start</name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarQuote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quoteDollar</name></decl></parameter>, <parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LazyBuf_Init</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newline</name> <init>= <expr><call><name>Shell_GetNewline</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newline</name> <operator>=</operator> <literal type="string">"\\\n"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>LazyBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ch_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_shell_metachar</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>quoteDollar</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>VarHash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hexdigits</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <init>= <expr><literal type="string">"0123456789abcdef"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ustr</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>h</name> <init>= <expr><literal type="number">0x971e137bU</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c1</name> <init>= <expr><literal type="number">0x95543787U</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c2</name> <init>= <expr><literal type="number">0x2ad7eb25U</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <name>len2</name></expr>;</init> <condition><expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator>
<operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator>
<operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator>
<operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ustr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ustr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <name>c1</name> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">0x7b7d159cU</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>c2</name> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">0x6bce6396U</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>c1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>k</name> <operator>&lt;&lt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>k</name> <operator>&gt;&gt;</operator> <literal type="number">21</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>&lt;&lt;</operator> <literal type="number">13</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>h</name> <operator>&gt;&gt;</operator> <literal type="number">19</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <name>h</name> <operator>*</operator> <literal type="number">5</literal> <operator>+</operator> <literal type="number">0x52dce729U</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>len2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <literal type="number">0x85ebca6b</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">13</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <literal type="number">0xc2b2ae35</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>hexdigits</name><index>[<expr><name>h</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>VarStrftime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>zulu</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>tim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fmt</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <literal type="string">"%c"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><ternary><condition><expr><name>zulu</name></expr> ?</condition><then> <expr><call><name>gmtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tim</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tim</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><sizeof>sizeof <name>buf</name></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>































































<typedef>typedef <type><enum>enum <name>ExprDefined</name> <block>{

<decl><name>DEF_REGULAR</name></decl>,

<decl><name>DEF_UNDEF</name></decl>,





<decl><name>DEF_DEFINED</name></decl>
}</block></enum></type> <name>ExprDefined</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ExprDefined_Name</name><index>[]</index><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="string">"regular"</literal></expr>,
<expr><literal type="string">"undefined"</literal></expr>,
<expr><literal type="string">"defined"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>const_member</name></cpp:macro> <cpp:value>const</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>const_member</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><struct>struct <name>Expr</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarEvalMode</name> <name>const_member</name></type> <name>emode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier><name>const_member</name></type> <name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprDefined</name></type> <name>defined</name></decl>;</decl_stmt>
}</block></struct></type> <name>Expr</name>;</typedef>



























<typedef>typedef <type><struct>struct <name>ModChain</name> <block>{
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <name>const_member</name></type> <name>startc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <name>const_member</name></type> <name>endc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>sep</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>oneBigWord</name></decl>;</decl_stmt>
}</block></struct></type> <name>ModChain</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Expr_Define</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>=</operator> <name>DEF_DEFINED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>Expr_Str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>expr</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>str</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SubstringWords</name></type>
<name>Expr_Words</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Substring_Words</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Expr_SetValue</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>FStr</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>expr</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Expr_SetValueOwn</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Expr_SetValueRefer</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>Expr_ShouldEval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>VarEvalMode_ShouldEval</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ModChain_ShouldEval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><enum>enum <name>ApplyModifierResult</name> <block>{

<decl><name>AMR_OK</name></decl>,

<decl><name>AMR_UNKNOWN</name></decl>,

<decl><name>AMR_BAD</name></decl>,

<decl><name>AMR_CLEANUP</name></decl>
}</block></enum></type> <name>ApplyModifierResult</name>;</typedef>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsEscapedModifierPart</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ModifyWord_SubstArgs</name></name> <modifier>*</modifier></type><name>subst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>delim</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>&amp;&amp;</operator> <name>subst</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseModifierPartExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>nested_val</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>,
<argument><expr><call><name>VarEvalMode_WithoutKeepDollar</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LazyBuf_AddStr</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>nested_val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseModifierPartDollar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>startc</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>endc</name> <init>= <expr><ternary><condition><expr><name>startc</name> <operator>==</operator> <literal type="char">'('</literal></expr> ?</condition><then> <expr><literal type="char">')'</literal></expr> </then><else>: <expr><literal type="char">'}'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>startc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>endc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>LazyBuf_AddBytesBetween</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><operator>*</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VarParseResult</name></type>
<name>ParseModifierPartSubst</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>,
<parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,


<parameter><decl><type><name>PatternFlags</name> <modifier>*</modifier></type><name>out_pflags</name></decl></parameter>,


<parameter><decl><type><name><name>struct</name> <name>ModifyWord_SubstArgs</name></name> <modifier>*</modifier></type><name>subst</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LazyBuf_Init</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IsEscapedModifierPart</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>subst</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_AddSubstring</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>subst</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>out_pflags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out_pflags</name><operator>-&gt;</operator><name>anchorEnd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>VarEvalMode_ShouldEval</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseModifierPartExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ParseModifierPartDollar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>delim</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Unfinished modifier for \"%s\" ('%c' missing)"</literal></expr></argument>,
<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>Substring</name></type> <name>sub</name> <init>= <expr><call><name>LazyBuf_Get</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Modifier part: \"%.*s\"\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>sub</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><name>VPR_OK</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VarParseResult</name></type>
<name>ParseModifierPart</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,

<parameter><decl><type><name>char</name></type> <name>delim</name></decl></parameter>,

<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>,
<parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>part</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ParseModifierPartSubst</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MAKE_INLINE</name> <name>bool</name></type>
<name>IsDelimiter</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>c</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>MAKE_INLINE</name> <name>bool</name></type>
<name>ModMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>MAKE_INLINE</name> <name>bool</name></type>
<name>ModMatchEq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>mod</name><index>[<expr><name>n</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryParseIntBase0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <operator>*</operator><name>pp</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>==</operator> <name>LONG_MIN</name> <operator>||</operator> <name>n</name> <operator>==</operator> <name>LONG_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>n</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_num</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryParseSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>out_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>ULONG_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_num</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryParseChar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out_ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isalnum</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>ULONG_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_ch</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWords</name><parameter_list>(<parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>ModifyWordProc</name></type> <name>modifyWord</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>modifyWord_args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>oneBigWord</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SepBuf</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>word</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oneBigWord</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>word</name> <operator>=</operator> <call><name>Substring_InitStr</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>modifyWord</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>modifyWord_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Substring_Words</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"ModifyWords: split \"%s\" into %u %s\n"</literal></expr></argument>,
<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>words</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"words"</literal></expr> </then><else>: <expr><literal type="string">"word"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SepBuf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>modifyWord</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>modifyWord_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SepBuf_Sep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>SepBuf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Loop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_LoopArgs</name></name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>prev_sep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>tvarBuf</name></decl>, <decl><type ref="prev"/><name>strBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>tvar</name></decl>, <decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>, <argument><expr><name>VARE_PARSE_ONLY</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tvarBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tvar</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tvarBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>var</name></name> <operator>=</operator> <name><name>tvar</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"In the :@ modifier of \"%s\", the variable name \"%s\" "</literal>
<literal type="string">"must not contain a dollar"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>, <argument><expr><name>VARE_PARSE_ONLY</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>strBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>body</name></name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>emode</name></name> <operator>=</operator> <call><name>VarEvalMode_WithoutKeepDollar</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_sep</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>sep</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Loop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <name>prev_sep</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Var_Delete</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Defined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>emode</name> <init>= <expr><name>VARE_PARSE_ONLY</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'D'</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_REGULAR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>emode</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LazyBuf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>nested_val</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>nested_val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Expr_Define</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VarEvalMode_ShouldEval</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>Substring_Str</name><argument_list>(<argument><expr><call><name>LazyBuf_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Expr_Define</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TryParseTime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>out_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isdigit</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>ULONG_MAX</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_time</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Gmtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>utc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModMatchEq</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"gmtime"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>mod</name> <operator>+</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>utc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Invalid time value at \"%s\""</literal></expr></argument>, <argument><expr><name>mod</name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>utc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
<argument><expr><call><name>VarStrftime</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>utc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Localtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>utc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModMatchEq</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"localtime"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>mod</name> <operator>+</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>utc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Invalid time value at \"%s\""</literal></expr></argument>, <argument><expr><name>mod</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>utc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>expr</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
<argument><expr><call><name>VarStrftime</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>utc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModMatch</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><call><name>VarHash</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Expr_Define</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_FindNode</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_NOPATH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>searchPath</name> <init>= <expr><call><name>Suff_FindPath</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>searchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_ShellCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errfmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>cmdBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>cmd</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">'!'</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmdBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmdBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>errfmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>Cmd_Exec</name><argument_list>(<argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errfmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>errfmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_Define</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModMatchEq</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>mod</name> <operator>+</operator> <literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Invalid number \"%s\" for ':range' modifier"</literal></expr></argument>,
<argument><expr><name>mod</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name> <init>= <expr><call><name>Expr_Words</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Buf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_AddInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseModifier_Match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>copy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>needSubst</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name>int</name></type> <name>nest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name>nest</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ch</name><operator>-&gt;</operator><name>startc</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>needSubst</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>needSubst</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nest</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nest</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nest</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endpat</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>


<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>endpat</name> <operator>-</operator> <operator>(</operator><name>mod</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>src</name> <operator>&lt;</operator> <name>endpat</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr><operator>,</operator> <expr><name>dst</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>src</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>endpat</name> <operator>&amp;&amp;</operator>

<call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>dst</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>bmake_strsedup</name><argument_list>(<argument><expr><name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>endpat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>needSubst</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_pattern</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>old_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Pattern for ':%c' is \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_pattern</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>mod</name> <init>= <expr><operator>*</operator><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ParseModifier_Match</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ModifyWordProc</name></type> <name>modifyWord</name> <init>=
<expr><ternary><condition><expr><name>mod</name> <operator>==</operator> <literal type="char">'M'</literal></expr> ?</condition><then> <expr><name>ModifyWord_Match</name></expr> </then><else>: <expr><name>ModifyWord_NoMatch</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>modifyWord</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParsePatternFlags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>PatternFlags</name> <modifier>*</modifier></type><name>pflags</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>oneBigWord</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'g'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pflags</name><operator>-&gt;</operator><name>subGlobal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pflags</name><operator>-&gt;</operator><name>subOnce</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'W'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>oneBigWord</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>MAKE_INLINE</name> <name>PatternFlags</name></type>
<name>PatternFlags_None</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PatternFlags</name></type> <name>pflags</name> <init>= <expr><block>{ <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><name>pflags</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Subst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_SubstArgs</name></name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oneBigWord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>lhsBuf</name></decl>, <decl><type ref="prev"/><name>rhsBuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>delim</name> <init>= <expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>delim</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing delimiter for modifier ':S'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>pflags</name></name> <operator>=</operator> <call><name>PatternFlags_None</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>pflags</name><operator>.</operator><name>anchorStart</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPartSubst</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>pflags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>lhs</name></name> <operator>=</operator> <call><name>LazyBuf_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPartSubst</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhsBuf</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>rhs</name></name> <operator>=</operator> <call><name>LazyBuf_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oneBigWord</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParsePatternFlags</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>pflags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oneBigWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Subst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>oneBigWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_REGEX</name></expr></argument>)</argument_list></call></expr></cpp:if>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_SubstRegexArgs</name></name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>oneBigWord</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>reBuf</name></decl>, <decl><type ref="prev"/><name>replaceBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>re</name></decl>, <decl><type ref="prev"/><name>replace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>delim</name> <init>= <expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>delim</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Missing delimiter for :C modifier"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>replaceBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>replace</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replaceBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>replace</name></name> <operator>=</operator> <name><name>replace</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>pflags</name></name> <operator>=</operator> <call><name>PatternFlags_None</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oneBigWord</name> <operator>=</operator> <name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParsePatternFlags</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>pflags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oneBigWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>re</name></name></expr></argument>, <argument><expr><name><name>re</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>REG_EXTENDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>VarREError</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>re</name></name></expr></argument>, <argument><expr><literal type="string">"Regex compilation error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>nsub</name></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>re</name><operator>.</operator><name>re_nsub</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>nsub</name></name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>nsub</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_SubstRegex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>oneBigWord</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Quote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>quoteDollar</name></decl>;</decl_stmt>

<expr_stmt><expr><name>quoteDollar</name> <operator>=</operator> <operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <literal type="char">'q'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>VarQuote</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>quoteDollar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ModifyWord_Copy</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>word</name></decl></parameter>, <parameter><decl><type><name>SepBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SepBuf_AddSubstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_ToSep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><operator>*</operator><name>pp</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>









<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name> <operator>&amp;&amp;</operator> <call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>sep</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>sep</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>sep</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>


<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ch_isdigit</name><argument_list>(<argument><expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character number at \"%s\""</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block>

<label><name>ok</name>:</label>
<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Copy</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_toupper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ch_toupper</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_tolower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ch_tolower</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_To</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ApplyModifier_ToSep</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Realpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>str_toupper</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>str_tolower</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'W'</literal> <operator>||</operator> <name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name> <operator>=</operator> <name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'W'</literal></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Words</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>estr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>estrBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>festr</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>estrBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>festr</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estrBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>estr</name> <operator>=</operator> <name><name>festr</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ok</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>estr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>estr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>estr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name> <init>= <expr><call><name>Expr_Words</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ac</name> <init>= <expr><name><name>words</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SubstringWords_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddInt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>estr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>estr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>estr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name><name>estr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>p</name> <operator>=</operator> <name>estr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseIntBase0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>first</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TryParseIntBase0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></else></if_stmt>





<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>last</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>last</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
<argument><expr><call><name>VarSelectWords</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>last</name></expr></argument>,
<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>sep</name></name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>ok</name>:</label>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>festr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>

<label><name>bad_modifier</name>:</label>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>festr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NUM_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TYPE</name></cpp:macro> <cpp:value>long long</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_INT64_T_DECLARED</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TYPE</name></cpp:macro> <cpp:value>int64_t</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TYPE</name></cpp:macro> <cpp:value>long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtoll</name></cpp:macro> <cpp:value>strtol</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>NUM_TYPE</name></type>
<name>num_val</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NUM_TYPE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>start</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ep</name> <operator>!=</operator> <name><name>s</name><operator>.</operator><name>start</name></name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>ep</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'K'</literal></expr>:</case>
<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>&lt;&lt;=</operator> <literal type="number">30</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SubNumAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>NUM_TYPE</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>num_val</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Substring</name> <operator>*</operator><operator>)</operator><name>sa</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>num_val</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Substring</name> <operator>*</operator><operator>)</operator><name>sb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>b</name> <operator>&gt;</operator> <name>a</name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SubNumDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>SubNumAsc</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SubStrAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(
<argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Substring</name> <operator>*</operator><operator>)</operator><name>sa</name><operator>)</operator><operator>-&gt;</operator><name>start</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Substring</name> <operator>*</operator><operator>)</operator><name>sb</name><operator>)</operator><operator>-&gt;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>SubStrDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>SubStrAsc</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShuffleSubstrings</name><parameter_list>(<parameter><decl><type><name>Substring</name> <modifier>*</modifier></type><name>strs</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>rndidx</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>random</name><argument_list>()</argument_list></call> <operator>%</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>t</name> <init>= <expr><name><name>strs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>strs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>strs</name><index>[<expr><name>rndidx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>strs</name><index>[<expr><name>rndidx</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<if_stmt><if>if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>SubStrAsc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>mod</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>SubNumAsc</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>SubStrDesc</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>mod</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <name><name>mod</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'r'</literal> <operator>&amp;&amp;</operator> <name><name>mod</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>SubNumDesc</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>bad</name>;</goto></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<goto>goto <name>bad</name>;</goto>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Expr_Words</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ShuffleSubstrings</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><call><name>SubstringWords_JoinFree</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>

<label><name>bad</name>:</label>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_IfElse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>then_expr</name></decl>, <decl><type ref="prev"/><name>else_expr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>value</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>then_emode</name> <init>= <expr><name>VARE_PARSE_ONLY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>else_emode</name> <init>= <expr><name>VARE_PARSE_ONLY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CondEvalResult</name></type> <name>cond_rc</name> <init>= <expr><name>COND_PARSE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cond_rc</name> <operator>=</operator> <call><name>Cond_EvalCondition</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cond_rc</name> <operator>!=</operator> <name>COND_INVALID</name> <operator>&amp;&amp;</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>then_emode</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cond_rc</name> <operator>!=</operator> <name>COND_INVALID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>else_emode</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>then_emode</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>then_expr</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr></argument>, <argument><expr><name>else_emode</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>then_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>else_expr</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cond_rc</name> <operator>==</operator> <name>COND_INVALID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Bad conditional expression '%s' in '%s?%s:%s'"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>then_expr</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>else_expr</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>then_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>else_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>then_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>else_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>then_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>else_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>then_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_SetValue</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>else_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>Expr_Define</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Assign</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ok</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ok</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return>

<label><name>ok</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>AMR_BAD</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_REGULAR</name> <operator>&amp;&amp;</operator> <name><name>expr</name><operator>-&gt;</operator><name>scope</name></name> <operator>!=</operator> <name>SCOPE_GLOBAL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>gv</name> <init>= <expr><call><name>VarFind</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>gv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>SCOPE_GLOBAL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarFreeEnv</name><argument_list>(<argument><expr><name>gv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<expr_stmt><expr><call><name>Var_Append</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errfmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd_output</name> <init>= <expr><call><name>Cmd_Exec</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errfmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>errfmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><name>errfmt</name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>cmd_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmd_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_REGULAR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Remember</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModMatchEq</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>mod</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>argLen</name> <init>= <expr><call><name>strcspn</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">":)}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>arg</name> <operator>+</operator> <name>argLen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><call><name>bmake_strldup</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>argLen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>mod</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_WordFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>,
<parameter><decl><type><name>ModifyWordProc</name></type> <name>modifyWord</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>modifyWord</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_Unique</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SubstringWords</name></type> <name>words</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ModChain_ShouldEval</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Expr_Words</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>si</name></decl>, <decl><type ref="prev"/><name>di</name></decl>;</decl_stmt>

<expr_stmt><expr><name>di</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>si</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>si</name> <operator>&lt;</operator> <name><name>words</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>si</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Substring_Eq</name><argument_list>(<argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>si</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>di</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>di</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>di</name> <operator>!=</operator> <name>si</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>di</name></expr>]</index></name> <operator>=</operator> <name><name>words</name><operator>.</operator><name>words</name><index>[<expr><name>si</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>words</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>di</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><call><name>SubstringWords_JoinFree</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYSVVARSUB</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_SysV</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>lhsBuf</name></decl>, <decl><type ref="prev"/><name>rhsBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>rhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ModifyWord_SysVSubstArgs</name></name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>lhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lhsSuffix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>eqFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>mod</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eqFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name><name>ch</name><operator>-&gt;</operator><name>startc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name> <operator>||</operator> <operator>!</operator><name>eqFound</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseModifierPart</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_CLEANUP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>lhsBuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lhs</name> <operator>=</operator> <call><name>LazyBuf_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lhsSuffix</name> <operator>=</operator> <call><name>Substring_SkipFirst</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>lhsPrefix</name></name> <operator>=</operator> <call><name>Substring_Init</name><argument_list>(<argument><expr><name><name>lhs</name><operator>.</operator><name>start</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>lhsSuffix</name> <operator>!=</operator> <name><name>lhs</name><operator>.</operator><name>start</name></name></expr> ?</condition><then> <expr><name>lhsSuffix</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>lhs</name><operator>.</operator><name>start</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>lhsPercent</name></name> <operator>=</operator> <name>lhsSuffix</name> <operator>!=</operator> <name><name>lhs</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>lhsSuffix</name></name> <operator>=</operator> <call><name>Substring_Init</name><argument_list>(<argument><expr><name>lhsSuffix</name></expr></argument>, <argument><expr><name><name>lhs</name><operator>.</operator><name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>rhs</name></name> <operator>=</operator> <name><name>rhs</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ModifyWords</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_SysVSubst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>ch</name><operator>-&gt;</operator><name>oneBigWord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhsBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUNSHCMD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier_SunShell</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'h'</literal> <operator>&amp;&amp;</operator> <call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errfmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><call><name>Cmd_Exec</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>errfmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>errfmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><name>errfmt</name></expr></argument>, <argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogBeforeApply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_single_char</name> <init>= <expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>IsDelimiter</name><argument_list>(<argument><expr><name><name>mod</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Expr_ShouldEval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"Parsing modifier ${%s:%c%s}\n"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_single_char</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"..."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name> <operator>==</operator> <name>VARE_WANTRES</name> <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>emode</name></name> <operator>==</operator> <name>VARE_UNDEFERR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_REGULAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(
<argument><expr><literal type="string">"Evaluating modifier ${%s:%c%s} on value \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_single_char</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"..."</literal></expr></else></ternary></expr></argument>,
<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(
<argument><expr><literal type="string">"Evaluating modifier ${%s:%c%s} on value \"%s\" (%s, %s)\n"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>mod</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_single_char</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"..."</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>VarEvalMode_Name</name><index>[<expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ExprDefined_Name</name><index>[<expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>LogAfterApply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>quot</name> <init>= <expr><ternary><condition><expr><name>value</name> <operator>==</operator> <name>var_Error</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"\""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name> <operator>==</operator> <name>VARE_WANTRES</name> <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>emode</name></name> <operator>==</operator> <name>VARE_UNDEFERR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>expr</name><operator>-&gt;</operator><name>defined</name></name> <operator>==</operator> <name>DEF_REGULAR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"Result of ${%s:%.*s} is %s%s%s\n"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>mod</name><operator>)</operator></expr></argument>, <argument><expr><name>mod</name></expr></argument>,
<argument><expr><name>quot</name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name> <operator>==</operator> <name>var_Error</name></expr> ?</condition><then> <expr><literal type="string">"error"</literal></expr> </then><else>: <expr><name>value</name></expr></else></ternary></expr></argument>, <argument><expr><name>quot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"Result of ${%s:%.*s} is %s%s%s (%s, %s)\n"</literal></expr></argument>,
<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>mod</name><operator>)</operator></expr></argument>, <argument><expr><name>mod</name></expr></argument>,
<argument><expr><name>quot</name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name> <operator>==</operator> <name>var_Error</name></expr> ?</condition><then> <expr><literal type="string">"error"</literal></expr> </then><else>: <expr><name>value</name></expr></else></ternary></expr></argument>, <argument><expr><name>quot</name></expr></argument>,
<argument><expr><name><name>VarEvalMode_Name</name><index>[<expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>ExprDefined_Name</name><index>[<expr><name><name>expr</name><operator>-&gt;</operator><name>defined</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplyModifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_ShellCommand</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Assign</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_IfElse</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Loop</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Words</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'_'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Remember</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_REGEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Regex</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<case>case <expr><literal type="char">'U'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Defined</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'E'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_WordFunc</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Suffix</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Gmtime</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_WordFunc</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Head</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Hash</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'L'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Literal</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Localtime</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Match</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'O'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Order</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Path</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'Q'</literal></expr>:</case>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Quote</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_WordFunc</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Root</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Range</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Subst</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUNSHCMD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_SunShell</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><literal type="char">'T'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_WordFunc</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ModifyWord_Tail</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_To</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<return>return <expr><call><name>ApplyModifier_Unique</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><name>AMR_UNKNOWN</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ApplyModifiers</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name></type></decl></parameter>, <parameter><decl><type><name>char</name></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><enum>enum <name>ApplyModifiersIndirectResult</name> <block>{

<decl><name>AMIR_CONTINUE</name></decl>,

<decl><name>AMIR_SYSV</name></decl>,

<decl><name>AMIR_OUT</name></decl>
}</block></enum></type> <name>ApplyModifiersIndirectResult</name>;</typedef>














<function><type><specifier>static</specifier> <name>ApplyModifiersIndirectResult</name></type>
<name>ApplyModifiersIndirect</name><parameter_list>(<parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>mods</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>emode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>mods</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>AMIR_SYSV</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Indirect modifier \"%s\" from \"%.*s\"\n"</literal></expr></argument>,
<argument><expr><name><name>mods</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <operator>*</operator><name>pp</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mods</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modsp</name> <init>= <expr><name><name>mods</name><operator>.</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ApplyModifiers</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modsp</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>var_Error</name> <operator>||</operator> <operator>*</operator><name>modsp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>AMIR_OUT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Unclosed variable expression after indirect "</literal>
<literal type="string">"modifier, expecting '%c' for variable \"%s\""</literal></expr></argument>,
<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>AMIR_OUT</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>AMIR_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ApplyModifierResult</name></type>
<name>ApplySingleModifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>ModChain</name> <modifier>*</modifier></type><name>ch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ApplyModifierResult</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LogBeforeApply</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ApplyModifier</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYSVVARSUB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AMR_UNKNOWN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ApplyModifier_SysV</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AMR_UNKNOWN</name></expr>)</condition> <block>{<block_content>






<for>for <control>(<init><expr><name>p</name><operator>++</operator></expr>;</init> <condition><expr><operator>!</operator><call><name>IsDelimiter</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unknown modifier \"%.*s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>mod</name><operator>)</operator></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>var_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AMR_CLEANUP</name> <operator>||</operator> <name>res</name> <operator>==</operator> <name>AMR_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LogAfterApply</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(
<argument><expr><literal type="string">"Unclosed variable expression, expecting '%c' for "</literal>
<literal type="string">"modifier \"%.*s\" of variable \"%s\" with value \"%s\""</literal></expr></argument>,
<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>mod</name><operator>)</operator></expr></argument>, <argument><expr><name>mod</name></expr></argument>,
<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name><name>ch</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name><name>ch</name><operator>-&gt;</operator><name>endc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Missing delimiter ':' after modifier \"%.*s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>mod</name><operator>)</operator></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>AMR_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ModChain_Literal</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>, <parameter><type><name>startc</name></type></parameter>, <parameter><type><name>endc</name></type></parameter>, <parameter><type><name>sep</name></type></parameter>, <parameter><type><name>oneBigWord</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ModChain) { expr, startc, endc, sep, oneBigWord }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>MAKE_INLINE</name> <name>ModChain</name></type>
<name>ModChain_Literal</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>startc</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>endc</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>oneBigWord</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ModChain</name></type> <name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ch</name><operator>.</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>.</operator><name>startc</name></name> <operator>=</operator> <name>startc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>.</operator><name>endc</name></name> <operator>=</operator> <name>endc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>.</operator><name>sep</name></name> <operator>=</operator> <name>sep</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ch</name><operator>.</operator><name>oneBigWord</name></name> <operator>=</operator> <name>oneBigWord</name></expr>;</expr_stmt>
<return>return <expr><name>ch</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>ApplyModifiers</name><parameter_list>(
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>startc</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>endc</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ModChain</name></type> <name>ch</name> <init>= <expr><call><name>ModChain_Literal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><name>endc</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mod</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>startc</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <name>startc</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <name>startc</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>endc</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <name>endc</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator> <name>endc</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>endc</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(
<argument><expr><literal type="string">"Unclosed variable expression (expecting '%c') for \"%s\""</literal></expr></argument>,
<argument><expr><name><name>ch</name><operator>.</operator><name>endc</name></name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>endc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ApplyModifierResult</name></type> <name>res</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ApplyModifiersIndirectResult</name></type> <name>amir</name> <init>=
<expr><call><name>ApplyModifiersIndirect</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>amir</name> <operator>==</operator> <name>AMIR_CONTINUE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>amir</name> <operator>==</operator> <name>AMIR_OUT</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>





</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mod</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ApplySingleModifier</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AMR_CLEANUP</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>AMR_BAD</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_modifier</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>

<label><name>bad_modifier</name>:</label>

<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Bad modifier \":%.*s\" for variable \"%s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strcspn</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">":)}"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mod</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>










<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>var_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>VarnameIsDynamic</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>varname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>varname</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>Substring_Length</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'F'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<case>case <expr><literal type="char">'%'</literal></expr>:</case>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>ch_isupper</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="string">".TARGET"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>Substring_Equals</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="string">".ARCHIVE"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>Substring_Equals</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="string">".PREFIX"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>Substring_Equals</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="string">".MEMBER"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>UndefinedShortVarValue</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>||</operator> <name>scope</name> <operator>==</operator> <name>SCOPE_GLOBAL</name></expr>)</condition> <block>{<block_content>









<switch>switch <condition>(<expr><name>varname</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<return>return <expr><literal type="string">"$(.TARGET)"</literal></expr>;</return>
<case>case <expr><literal type="char">'%'</literal></expr>:</case>
<return>return <expr><literal type="string">"$(.MEMBER)"</literal></expr>;</return>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<return>return <expr><literal type="string">"$(.PREFIX)"</literal></expr>;</return>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<return>return <expr><literal type="string">"$(.ARCHIVE)"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParseVarname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>startc</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>endc</name></decl></parameter>,
<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>,
<parameter><decl><type><name>LazyBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LazyBuf_Init</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <name>endc</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>startc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>endc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>nested_val</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LazyBuf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>nested_val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>LazyBuf_Add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarParseResult</name></type>
<name>ValidShortVarname</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>!=</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name>varname</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name>varname</name> <operator>!=</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator>
<name>varname</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <name>varname</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VPR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>strict</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VPR_ERR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>varname</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"To escape a dollar, use \\$, not $$, at \"%s\""</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>varname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Dollar followed by nothing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Invalid variable name '%c', at \"%s\""</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>VPR_ERR</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseVarnameShort</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>,
<parameter><decl><type><name>VarParseResult</name> <modifier>*</modifier></type><name>out_false_res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_false_val</name></decl></parameter>,
<parameter><decl><type><name>Var</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_true_var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>vpr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vpr</name> <operator>=</operator> <call><name>ValidShortVarname</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vpr</name> <operator>!=</operator> <name>VPR_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_res</name> <operator>=</operator> <name>vpr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_val</name> <operator>=</operator> <name>var_Error</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFind</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>UndefinedShortVarValue</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name></expr>
?</condition><then> <expr><name>var_Error</name></expr> </then><else>: <expr><name>varUndefined</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name> <operator>&amp;&amp;</operator> <name>val</name> <operator>==</operator> <name>var_Error</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Variable \"%s\" is undefined"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_res</name> <operator>=</operator> <name>VPR_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>











<expr_stmt><expr><operator>*</operator><name>out_false_res</name> <operator>=</operator> <ternary><condition><expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name></expr>
?</condition><then> <expr><name>VPR_UNDEF</name></expr> </then><else>: <expr><name>VPR_OK</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>out_true_var</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>FindLocalLegacyVar</name><parameter_list>(<parameter><decl><type><name>Substring</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_extraModifiers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>||</operator> <name>scope</name> <operator>==</operator> <name>SCOPE_GLOBAL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Substring_Length</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>varname</name><operator>.</operator><name>start</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'F'</literal> <operator>&amp;&amp;</operator> <name><name>varname</name><operator>.</operator><name>start</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'D'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"@%?*!&lt;&gt;"</literal></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>start</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFindSubstring</name><argument_list>(<argument><expr><call><name>Substring_Sub</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>out_extraModifiers</name> <operator>=</operator> <ternary><condition><expr><name><name>varname</name><operator>.</operator><name>start</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'D'</literal></expr> ?</condition><then> <expr><literal type="string">"H:"</literal></expr> </then><else>: <expr><literal type="string">"T:"</literal></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarParseResult</name></type>
<name>EvalUndefined</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dynamic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name>Substring</name></type> <name>varname</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dynamic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><call><name>bmake_strsedup</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name> <operator>&amp;&amp;</operator> <name><name>opts</name><operator>.</operator><name>strict</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Variable \"%.*s\" is undefined"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>varname</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>var_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>var_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_UNDEF</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>varUndefined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_OK</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseVarnameLong</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>startc</name></decl></parameter>,
<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_false_pp</name></decl></parameter>,
<parameter><decl><type><name>VarParseResult</name> <modifier>*</modifier></type><name>out_false_res</name></decl></parameter>,
<parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_false_val</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out_true_endc</name></decl></parameter>,
<parameter><decl><type><name>Var</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_true_v</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>out_true_haveModifier</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_true_extraModifiers</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>out_true_dynamic</name></decl></parameter>,
<parameter><decl><type><name>ExprDefined</name> <modifier>*</modifier></type><name>out_true_exprDefined</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>LazyBuf</name></type> <name>varname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Substring</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>haveModifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>dynamic</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>endc</name> <init>= <expr><ternary><condition><expr><name>startc</name> <operator>==</operator> <literal type="char">'('</literal></expr> ?</condition><then> <expr><literal type="char">')'</literal></expr> </then><else>: <expr><literal type="char">'}'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ParseVarname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><name>endc</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>LazyBuf_Get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>haveModifier</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>endc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>haveModifier</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unclosed variable \"%.*s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>Substring_Length</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_val</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>var_Error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_res</name> <operator>=</operator> <name>VPR_ERR</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarFindSubstring</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>Substring_Equals</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".SUFFIXES"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarNew</name><argument_list>(<argument><expr><call><name>Substring_Str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>Suff_NamesStr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>FindLocalLegacyVar</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>,
<argument><expr><name>out_true_extraModifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>dynamic</name> <operator>=</operator> <call><name>VarnameIsDynamic</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>scope</name> <operator>==</operator> <name>SCOPE_CMDLINE</name> <operator>||</operator> <name>scope</name> <operator>==</operator> <name>SCOPE_GLOBAL</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveModifier</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_false_res</name> <operator>=</operator> <call><name>EvalUndefined</name><argument_list>(<argument><expr><name>dynamic</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><name>out_false_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>















<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>VarNew</name><argument_list>(<argument><expr><call><name>LazyBuf_DoneGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_true_exprDefined</name> <operator>=</operator> <name>DEF_UNDEF</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>LazyBuf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_true_endc</name> <operator>=</operator> <name>endc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_true_v</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_true_haveModifier</name> <operator>=</operator> <name>haveModifier</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_true_dynamic</name> <operator>=</operator> <name>dynamic</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeEnvVar</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varValue</name> <init>= <expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>varValue</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>freeIt</name></name> <operator>=</operator> <name>varValue</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Expr_Literal</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>value</name></type></parameter>, <parameter><type><name>emode</name></type></parameter>, <parameter><type><name>scope</name></type></parameter>, <parameter><type><name>defined</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ name, value, emode, scope, defined }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>MAKE_INLINE</name> <name>Expr</name></type>
<name>Expr_Literal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>FStr</name></type> <name>value</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>ExprDefined</name></type> <name>defined</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Expr</name></type> <name>expr</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>emode</name></name> <operator>=</operator> <name>emode</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>scope</name></name> <operator>=</operator> <name>scope</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>defined</name></name> <operator>=</operator> <name>defined</name></expr>;</expr_stmt>
<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><specifier>static</specifier> <name>bool</name></type>
<name>Var_Parse_FastLane</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>pp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'U'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_PARSE_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>out_value</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>out_value</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><call><name>bmake_strsedup</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>






































<function><type><name>VarParseResult</name></type>
<name>Var_Parse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>FStr</name> <modifier>*</modifier></type><name>out_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveModifier</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>startc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>endc</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>dynamic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extramodifiers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name></type> <name>expr</name> <init>= <expr><call><name>Expr_Literal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>emode</name></expr></argument>,
<argument><expr><name>scope</name></expr></argument>, <argument><expr><name>DEF_REGULAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Var_Parse_FastLane</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><name>out_val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>VPR_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>VAR</name></expr></argument>, <argument><expr><literal type="string">"Var_Parse: %s (%s)\n"</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name><name>VarEvalMode_Name</name><index>[<expr><name>emode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extramodifiers</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dynamic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>





<expr_stmt><expr><name>endc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>startc</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>startc</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name>startc</name> <operator>!=</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseVarnameShort</name><argument_list>(<argument><expr><name>startc</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>out_val</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>haveModifier</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>VarParseResult</name></type> <name>res</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseVarnameLong</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>,
<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>out_val</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>endc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>haveModifier</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extramodifiers</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dynamic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>expr</name><operator>.</operator><name>defined</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>inUse</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="string">"Variable %s is recursive."</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>










<expr_stmt><expr><name><name>expr</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>VarEvalMode_ShouldEval</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarEvalMode</name></type> <name>nested_emode</name> <init>= <expr><name>emode</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nested_emode</name> <operator>=</operator> <call><name>VarEvalMode_UndefOk</name><argument_list>(<argument><expr><name>nested_emode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>inUse</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><call><name>Expr_Str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>nested_emode</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>inUse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>, <argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>extramodifiers</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><name>extramodifiers</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ApplyModifiers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>em</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>haveModifier</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ApplyModifiers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>startc</name></expr></argument>, <argument><expr><name>endc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>fromEnv</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FreeEnvVar</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>expr</name><operator>.</operator><name>defined</name></name> <operator>!=</operator> <name>DEF_REGULAR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>.</operator><name>defined</name></name> <operator>==</operator> <name>DEF_UNDEF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>dynamic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Expr_SetValueOwn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>,
<argument><expr><call><name>bmake_strsedup</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><call><name>Expr_SetValueRefer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expr</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name></expr>
?</condition><then> <expr><name>var_Error</name></expr> </then><else>: <expr><name>varUndefined</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>.</operator><name>value</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name><name>v</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Buf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>out_val</name> <operator>=</operator> <name><name>expr</name><operator>.</operator><name>value</name></name></expr>;</expr_stmt>
<return>return <expr><name>VPR_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarSubstDollarDollar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>save_dollars</name> <operator>&amp;&amp;</operator> <call><name>VarEvalMode_ShouldKeepDollar</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarSubstExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>,
<parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>inout_errorReported</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nested_p</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_p</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>var_Error</name> <operator>||</operator> <name><name>val</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>varUndefined</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VarEvalMode_ShouldKeepUndef</name><argument_list>(<argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nested_p</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>emode</name> <operator>==</operator> <name>VARE_UNDEFERR</name> <operator>||</operator> <name><name>val</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>var_Error</name></expr>)</condition> <block>{<block_content>













<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>inout_errorReported</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Undefined variable \"%.*s\""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nested_p</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nested_p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_errorReported</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>nested_p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarSubstPlain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>Buffer</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name><operator>++</operator></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><call><name>Buf_AddBytesBetween</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><name>VarParseResult</name></type>
<name>Var_Subst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>, <parameter><decl><type><name>VarEvalMode</name></type> <name>emode</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Buffer</name></type> <name>res</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>errorReported</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Buf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errorReported</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarSubstDollarDollar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarSubstExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>emode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorReported</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>VarSubstPlain</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>out_res</name> <operator>=</operator> <call><name>Buf_DoneDataCompact</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>VPR_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Var_Init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>SCOPE_INTERNAL</name> <operator>=</operator> <call><name>GNode_New</name><argument_list>(<argument><expr><literal type="string">"Internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SCOPE_GLOBAL</name> <operator>=</operator> <call><name>GNode_New</name><argument_list>(<argument><expr><literal type="string">"Global"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SCOPE_CMDLINE</name> <operator>=</operator> <call><name>GNode_New</name><argument_list>(<argument><expr><literal type="string">"Command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Var_End</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Var_Stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Var_Stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HashTable_DebugStats</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SCOPE_GLOBAL</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><literal type="string">"Global variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>StrAsc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>sb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(
<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><name>sa</name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator><name>sb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>Var_Dump</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>scope</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Vector</name></type> <name>vec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HashIter</name></type> <name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>varnames</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Vector_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vec</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HashIter_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HashIter_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>Vector_Push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vec</name></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>hi</name><operator>.</operator><name>entry</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>varnames</name> <operator>=</operator> <name><name>vec</name><operator>.</operator><name>items</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>varnames</name></expr></argument>, <argument><expr><name><name>vec</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>varnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></argument>, <argument><expr><name>StrAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name><name>varnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>HashTable_FindValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"%-16s = %s\n"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>Vector_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
