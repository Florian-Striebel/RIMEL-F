<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bmake/suff.c">
















































































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"make.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>


<expr_stmt><expr><call><name>MAKE_RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: suff.c,v 1.357 2021/12/12 20:45:48 sjg Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <type><name>List</name></type> <name>SuffixList</name>;</typedef>
<typedef>typedef <type><name>ListNode</name></type> <name>SuffixListNode</name>;</typedef>

<typedef>typedef <type><name>List</name></type> <name>CandidateList</name>;</typedef>
<typedef>typedef <type><name>ListNode</name></type> <name>CandidateListNode</name>;</typedef>


<decl_stmt><decl><type><specifier>static</specifier> <name>SuffixList</name></type> <name>sufflist</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>SuffixList</name></type> <name>suffClean</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><specifier>static</specifier> <name>GNodeList</name></type> <name>transforms</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name>List</name></type> <name>SuffixListList</name>;</typedef>





<typedef>typedef <type><struct>struct <name>Suffix</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>nameLen</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>include</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>library</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>









<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name><range>:<expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>searchPath</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>sNum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>refCount</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SuffixList</name></type> <name>parents</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SuffixList</name></type> <name>children</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>SuffixListList</name></type> <name>ref</name></decl>;</decl_stmt>
}</block></struct></type> <name>Suffix</name>;</typedef>










<typedef>typedef <type><struct>struct <name>Candidate</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>struct</name> <name>Candidate</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>numChildren</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>CandidateList</name></type> <name>childrenList</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>Candidate</name>;</typedef>

<typedef>typedef <type><struct>struct <name>CandidateSearcher</name> <block>{

<decl_stmt><decl><type><name>CandidateList</name></type> <name>list</name></decl>;</decl_stmt>






}</block></struct></type> <name>CandidateSearcher</name>;</typedef>




<decl_stmt><decl><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>nullSuff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>emptySuff</name></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type>
<name>Suffix_Ref</name><parameter_list>(<parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>suff</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>Suffix_Reassign</name><parameter_list>(<parameter><decl><type><name>Suffix</name> <modifier>*</modifier><modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>var</name><operator>)</operator><operator>-&gt;</operator><name>refCount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>var</name> <operator>=</operator> <name>suff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>Suffix_Unassign</name><parameter_list>(<parameter><decl><type><name>Suffix</name> <modifier>*</modifier><modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>var</name><operator>)</operator><operator>-&gt;</operator><name>refCount</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>var</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>StrTrimPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pref</name> <operator>==</operator> <operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pref</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><ternary><condition><expr><operator>*</operator><name>pref</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>StrTrimSuffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>strLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>suffLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffInStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>strLen</name> <operator>&lt;</operator> <name>suffLen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>suffInStr</name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>strLen</name> <operator>-</operator> <name>suffLen</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>suffLen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>suff</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>suffInStr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>suffInStr</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>Suffix_TrimSuffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nameLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>StrTrimSuffix</name><argument_list>(<argument><expr><name>nameEnd</name> <operator>-</operator> <name>nameLen</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>nameLen</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>Suffix_IsSuffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nameLen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameEnd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Suffix_TrimSuffix</name><argument_list>(<argument><expr><name>suff</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type>
<name>FindSuffixByNameLen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nameLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>suff</name><operator>-&gt;</operator><name>nameLen</name></name> <operator>==</operator> <name>nameLen</name> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>suff</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type>
<name>FindSuffixByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>FindSuffixByNameLen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GNode</name> <modifier>*</modifier></type>
<name>FindTransformByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>transforms</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>gn</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SuffixList_Unref</name><parameter_list>(<parameter><decl><type><name>SuffixList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><call><name>Lst_FindDatum</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>Suffix_Free</name><parameter_list>(<parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>==</operator> <name>nullSuff</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nullSuff</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>==</operator> <name>emptySuff</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>emptySuff</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (suff-&gt;refCount != 0)
Punt("Internal error deleting suffix `%s' with refcount = %d",
suff-&gt;name, suff-&gt;refCount);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SuffFree</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Suffix_Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SuffixList_Remove</name><parameter_list>(<parameter><decl><type><name>SuffixList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SuffixList_Unref</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SuffixList_Unref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sufflist</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"Removing suffix \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SuffFree</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>SuffixList_Insert</name><parameter_list>(<parameter><decl><type><name>SuffixList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>listSuff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>listSuff</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>listSuff</name><operator>-&gt;</operator><name>sNum</name></name> <operator>&gt;=</operator> <name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"inserting \"%s\" (%d) at end of list\n"</literal></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>Suffix_Ref</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>listSuff</name><operator>-&gt;</operator><name>sNum</name></name> <operator>!=</operator> <name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG4</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"inserting \"%s\" (%d) before \"%s\" (%d)\n"</literal></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr></argument>, <argument><expr><name><name>listSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>listSuff</name><operator>-&gt;</operator><name>sNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_InsertBefore</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>, <argument><expr><call><name>Suffix_Ref</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" (%d) is already there\n"</literal></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Relate</name><parameter_list>(<parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>srcSuff</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>targSuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SuffixList_Insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targSuff</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>srcSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SuffixList_Insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>srcSuff</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>targSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Suffix</name> <modifier>*</modifier></type>
<name>Suffix_New</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>bmake_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>suff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>nameLen</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name> <operator>=</operator> <call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name> <operator>=</operator> <name>sNum</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>include</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>library</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>suff</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type>
<name>Suff_ClearSuffixes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_MoveAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>suffClean</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sufflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"Clearing all suffixes\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sufflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sNum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nullSuff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SuffFree</name><argument_list>(<argument><expr><name>nullSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>emptySuff</name> <operator>=</operator> <name>nullSuff</name> <operator>=</operator> <call><name>Suffix_New</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SearchPath_AddAll</name><argument_list>(<argument><expr><name><name>nullSuff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nullSuff</name><operator>-&gt;</operator><name>include</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nullSuff</name><operator>-&gt;</operator><name>library</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nullSuff</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParseTransform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_src</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_targ</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>single</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>







<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>StrTrimPrefix</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><name><name>src</name><operator>-&gt;</operator><name>nameLen</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>single</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>targ</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name><name>src</name><operator>-&gt;</operator><name>nameLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>targ</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_src</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_targ</name> <operator>=</operator> <name>targ</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>single</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>










<expr_stmt><expr><operator>*</operator><name>out_src</name> <operator>=</operator> <name>single</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_targ</name> <operator>=</operator> <name>nullSuff</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>bool</name></type>
<name>Suff_IsTransform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>src</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>targ</name></decl>;</decl_stmt>

<return>return <expr><call><name>ParseTransform</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targ</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













<function><type><name>GNode</name> <modifier>*</modifier></type>
<name>Suff_AddTransform</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>srcSuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>targSuff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>FindTransformByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>gn</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>GNode_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>transforms</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>







<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OP_TRANSFORM</name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>ok</name> <init>= <expr><call><name>ParseTransform</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSuff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targSuff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ok</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"defining transformation from `%s' to `%s'\n"</literal></expr></argument>,
<argument><expr><name><name>srcSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>targSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Relate</name><argument_list>(<argument><expr><name>srcSuff</name></expr></argument>, <argument><expr><name>targSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>gn</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>void</name></type>
<name>Suff_EndTransform</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>srcSuff</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>targSuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SuffixList</name> <modifier>*</modifier></type><name>srcSuffParents</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_DOUBLEDEP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>cohorts</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>cohorts</name><operator>.</operator><name>last</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_TRANSFORM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"transformation %s complete\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseTransform</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSuff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targSuff</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"deleting incomplete transformation from `%s' to `%s'\n"</literal></expr></argument>,
<argument><expr><name><name>srcSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>targSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>srcSuffParents</name> <operator>=</operator> <operator>&amp;</operator><name><name>srcSuff</name><operator>-&gt;</operator><name>parents</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SuffixList_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targSuff</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>srcSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SuffixList_Remove</name><argument_list>(<argument><expr><name>srcSuffParents</name></expr></argument>, <argument><expr><name>targSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>void</name></type>
<name>RebuildGraph</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>transform</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>transform</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nameLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toName</name></decl>;</decl_stmt>


<expr_stmt><expr><name>toName</name> <operator>=</operator> <call><name>StrTrimPrefix</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>toName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>toName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>to</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Relate</name><argument_list>(<argument><expr><name>suff</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>toName</name> <operator>=</operator> <call><name>Suffix_TrimSuffix</name><argument_list>(<argument><expr><name>suff</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>nameLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>toName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>FindSuffixByNameLen</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>toName</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Relate</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>bool</name></type>
<name>UpdateTarget</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_main</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>inout_removedMain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>srcSuff</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>targSuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_main</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>inout_removedMain</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_NOTARGET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>MAKE</name></expr></argument>, <argument><expr><literal type="string">"Setting main node to \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_main</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_SetMain</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_TRANSFORM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>






<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ParseTransform</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcSuff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targSuff</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>inout_main</name> <operator>==</operator> <name>target</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>MAKE</name></expr></argument>,
<argument><expr><literal type="string">"Setting main node from \"%s\" back to null\n"</literal></expr></argument>,
<argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_removedMain</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>inout_main</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_SetMain</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>target</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>OP_TRANSFORM</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"defining transformation from `%s' to `%s'\n"</literal></expr></argument>,
<argument><expr><name><name>srcSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>targSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Relate</name><argument_list>(<argument><expr><name>srcSuff</name></expr></argument>, <argument><expr><name>targSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateTargets</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_main</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>removedMain</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <call><name>Targ_List</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>first</name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>UpdateTarget</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>inout_main</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>removedMain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>














<function><type><name>void</name></type>
<name>Suff_AddSuffix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>inout_main</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>suff</name> <operator>=</operator> <call><name>Suffix_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sufflist</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"Adding suffix \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UpdateTargets</name><argument_list>(<argument><expr><name>inout_main</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>transforms</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RebuildGraph</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<function><type><name>SearchPath</name> <modifier>*</modifier></type>
<name>Suff_GetPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>














<function><type><name>void</name></type>
<name>Suff_ExtendPaths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>includesPath</name> <init>= <expr><call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>libsPath</name> <init>= <expr><call><name>SearchPath_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>suff</name><operator>-&gt;</operator><name>include</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SearchPath_AddAll</name><argument_list>(<argument><expr><name>includesPath</name></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LIBRARIES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>suff</name><operator>-&gt;</operator><name>library</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SearchPath_AddAll</name><argument_list>(<argument><expr><name>libsPath</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>SearchPath_AddAll</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name> <operator>=</operator> <call><name>Dir_CopyDirSearchPath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>SearchPath_ToFlags</name><argument_list>(<argument><expr><name>includesPath</name></expr></argument>, <argument><expr><literal type="string">"-I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".INCLUDES"</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>SearchPath_ToFlags</name><argument_list>(<argument><expr><name>libsPath</name></expr></argument>, <argument><expr><literal type="string">"-L"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".LIBS"</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>includesPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Free</name><argument_list>(<argument><expr><name>libsPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Suff_AddInclude</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>suffName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>include</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Suff_AddLib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>suffName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>library</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_Init</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_Done</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_Add</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>cand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_AddIfNew</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>Lst_FindDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>cand</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>cand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_MoveAll</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>, <parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>Lst_MoveAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateList_PrintAddrs</name><parameter_list>(<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CandidateListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">" %p:%s"</literal></expr></argument>, <argument><expr><name>cand</name></expr></argument>, <argument><expr><name><name>cand</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Candidate</name> <modifier>*</modifier></type>
<name>Candidate_New</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name> <init>= <expr><call><name>bmake_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>cand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>suff</name></name> <operator>=</operator> <call><name>Suffix_Ref</name><argument_list>(<argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cand</name><operator>-&gt;</operator><name>numChildren</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cand</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cand</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateList_Add</name><parameter_list>(<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcName</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl></parameter>,
<parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>debug_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name> <init>= <expr><call><name>Candidate_New</name><argument_list>(<argument><expr><name>srcName</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>targ</name><operator>-&gt;</operator><name>numChildren</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>, <argument><expr><name>cand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"%s add suff %p:%s candidate %p:%s to list %p:"</literal></expr></argument>,
<argument><expr><name>debug_tag</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>cand</name></expr></argument>, <argument><expr><name><name>cand</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CandidateList_PrintAddrs</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateList_AddCandidatesFor</name><parameter_list>(<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>cand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>cand</name><operator>-&gt;</operator><name>suff</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>suff</name><operator>-&gt;</operator><name>isNull</name></name> <operator>&amp;&amp;</operator> <name><name>suff</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>CandidateList_Add</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>cand</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>cand</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CandidateList_Add</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>str_concat2</name><argument_list>(<argument><expr><name><name>cand</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>cand</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RemoveCandidate</name><parameter_list>(<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>srcs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CandidateListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"cleaning list %p:"</literal></expr></argument>, <argument><expr><name>srcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CandidateList_PrintAddrs</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>srcs</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>numChildren</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>CandidateListNode</name> <modifier>*</modifier></type><name>ln2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ln2</name> <operator>=</operator> <call><name>Lst_FindDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>,
<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ln2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>,
<argument><expr><name>ln2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>numChildren</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"free: list %p src %p:%s children %d\n"</literal></expr></argument>,
<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>numChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"keep: list %p src %p:%s children %d:"</literal></expr></argument>,
<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>numChildren</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CandidateList_PrintAddrs</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Candidate</name> <modifier>*</modifier></type>
<name>FindThem</name><parameter_list>(<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>srcs</name></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HashSet</name></type> <name>seen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>HashSet_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>Lst_Dequeue</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"remove from list %p src %p:%s\n"</literal></expr></argument>,
<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\ttrying %s..."</literal></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>Targ_FindNode</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<label><name>found</name>:</label>
<expr_stmt><expr><call><name>HashSet_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"got it\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>src</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>Dir_FindFile</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
<argument><expr><name><name>src</name><operator>-&gt;</operator><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>found</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"not there\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>HashSet_Add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seen</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CandidateList_AddCandidatesFor</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"FindThem: skipping duplicate \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>src</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CandidateSearcher_Add</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>HashSet_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>Candidate</name> <modifier>*</modifier></type>
<name>FindCmds</name><parameter_list>(<parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>gln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>tgn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>sgn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prefLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tgn</name> <operator>=</operator> <name><name>targ</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prefLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>gln</name> <operator>=</operator> <name><name>tgn</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>gln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>gln</name> <operator>=</operator> <name><name>gln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sgn</name> <operator>=</operator> <name><name>gln</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sgn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_OPTIONAL</name> <operator>&amp;&amp;</operator> <call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tgn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>







<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>str_basename</name><argument_list>(<argument><expr><name><name>sgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>prefLen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>suff</name> <operator>=</operator> <call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>base</name> <operator>+</operator> <name>prefLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><call><name>Lst_FindDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gln</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>Candidate_New</name><argument_list>(<argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>sgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>,
<argument><expr><name>sgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>targ</name><operator>-&gt;</operator><name>numChildren</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"3 add targ %p:%s ret %p:%s\n"</literal></expr></argument>,
<argument><expr><name>targ</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>targ</name><operator>-&gt;</operator><name>childrenList</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>CandidateSearcher_Add</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\tusing existing source %s\n"</literal></expr></argument>, <argument><expr><name><name>sgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandWildcards</name><parameter_list>(<parameter><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>cln</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>pgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>cgn</name> <init>= <expr><name><name>cln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringList</name></type> <name>expansions</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Dir_HasWildcards</name><argument_list>(<argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Expand</name><argument_list>(<argument><expr><call><name>Suff_FindPath</name><argument_list>(<argument><expr><name>cgn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expansions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>Lst_Dequeue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"%s..."</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Lst_InsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>cln</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>expansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name><name>pgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>cln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><call><name>Lst_FindDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandChildrenRegular</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>pgn</name></decl></parameter>, <parameter><decl><type><name>GNodeList</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pp_skip_hspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>




<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>members</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pp_skip_hspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nested_p</name> <init>= <expr><name>cp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>junk</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nested_p</name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>, <argument><expr><name>VARE_PARSE_ONLY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>junk</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>var_Error</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_FATAL</name></expr></argument>,
<argument><expr><literal type="string">"Malformed variable expression at \"%s\""</literal></expr></argument>,
<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <name>nested_p</name> <operator>-</operator> <name>cp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>cp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name>cp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>start</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>members</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandChildren</name><parameter_list>(<parameter><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>cln</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>pgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>cgn</name> <init>= <expr><name><name>cln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>order_pred</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>order_succ</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cgn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_WAIT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ExpandWildcards</name><argument_list>(<argument><expr><name>cln</name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"Expanding \"%s\"..."</literal></expr></argument>, <argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>cgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>, <argument><expr><name>VARE_UNDEFERR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>GNodeList</name></type> <name>members</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cgn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_ARCHV</name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>cp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Arch_ParseArchive</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ExpandChildrenRegular</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<while>while <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>Lst_Dequeue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"%s..."</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>Lst_InsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>cln</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ExpandWildcards</name><argument_list>(<argument><expr><name><name>cln</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name><name>pgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>cln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><call><name>Lst_FindDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>pgn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandAllChildren</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name>nln</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ExpandChildren</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>













<function><type><name>SearchPath</name> <modifier>*</modifier></type>
<name>Suff_FindPath</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nameLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>Suffix_IsSuffix</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>nameLen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"Wildcard expanding \"%s\"..."</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>suff</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>




</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"suffix is \"%s\"...\n"</literal></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><name>dirSearchPath</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ApplyTransform</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>tgn</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>sgn</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>tsuff</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>ssuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tgn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>sgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sgn</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>tgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tgn</name><operator>-&gt;</operator><name>unmade</name></name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>tname</name> <operator>=</operator> <call><name>str_concat2</name><argument_list>(<argument><expr><name><name>ssuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tsuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>gn</name> <operator>=</operator> <call><name>FindTransformByName</name><argument_list>(<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>gn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG3</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\tapplying %s -&gt; %s to \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>ssuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tsuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>tgn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>tgn</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>last</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Make_HandleUse</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>tgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ln</name> <operator>=</operator> <ternary><condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>nln</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ExpandChildren</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><name>tgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name>nln</name></expr>;</expr_stmt>
</block_content>}</block></while>





<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sgn</name><operator>-&gt;</operator><name>implicitParents</name></name></expr></argument>, <argument><expr><name>tgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExpandMember</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eoarch</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>memSuff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nameLen</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>eoarch</name> <operator>-</operator> <name><name>gn</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>memSuff</name><operator>-&gt;</operator><name>parents</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>Suffix_IsSuffix</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>eoarch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ApplyTransform</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><name>memSuff</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\tNo transformation from %s -&gt; %s\n"</literal></expr></argument>,
<argument><expr><name><name>memSuff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FindDeps</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsArchive</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eoarch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eoname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>memSuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>





<expr_stmt><expr><name>eoarch</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eoname</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>eoarch</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eoarch</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eoname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>eoname</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eoarch</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>eoarch</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>








<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FindDeps</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>, <argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mem</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>unmade</name></name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><call><name>GNode_VarPrefix</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><call><name>GNode_VarTarget</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>memSuff</name> <operator>=</operator> <name><name>mem</name><operator>-&gt;</operator><name>suffix</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>memSuff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"using null suffix\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>memSuff</name> <operator>=</operator> <name>nullSuff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>MEMBER</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>ARCHIVE</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>ExpandAllChildren</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>memSuff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ExpandMember</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>eoarch</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>memSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><operator>*</operator><name>eoarch</name> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eoname</name> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GNode_IsTarget</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_DEPENDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>






<expr_stmt><expr><name><name>mem</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_MEMBER</name> <operator>|</operator> <name>OP_JOIN</name> <operator>|</operator> <name>OP_MADE</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsLib</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>LIBSUFF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Suffix_Reassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name>suff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Arch_FindLib</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>Suffix_Unassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsRegularKnown</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nameLen</name></decl></parameter>, <parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>,
<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>srcs</name></decl></parameter>, <parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>targs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pref</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Suffix_IsSuffix</name><argument_list>(<argument><expr><name>suff</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>nameLen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pref</name> <operator>=</operator> <call><name>bmake_strldup</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nameLen</name> <operator>-</operator> <name><name>suff</name><operator>-&gt;</operator><name>nameLen</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>targ</name> <operator>=</operator> <call><name>Candidate_New</name><argument_list>(<argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pref</name></expr></argument>, <argument><expr><name>suff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CandidateList_AddCandidatesFor</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsRegularUnknown</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sopref</name></decl></parameter>,
<parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>srcs</name></decl></parameter>, <parameter><decl><type><name>CandidateList</name> <modifier>*</modifier></type><name>targs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><name>targs</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>nullSuff</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\tNo known suffix on %s. Using .NULL suffix\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>targ</name> <operator>=</operator> <call><name>Candidate_New</name><argument_list>(<argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>sopref</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>nullSuff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>commands</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CandidateList_AddCandidatesFor</name><argument_list>(<argument><expr><name>srcs</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"not "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>DEBUG0</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"adding suffix rules\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsRegularPath</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <operator>(</operator><name>OP_PHONY</name> <operator>|</operator> <name>OP_NOPATH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>targ</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>dirSearchPath</name></expr> </then><else>:
<expr><name><name>targ</name><operator>-&gt;</operator><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>targ</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name>size_t</name></type> <name>savep</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>targ</name><operator>-&gt;</operator><name>suff</name><operator>-&gt;</operator><name>nameLen</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>savec</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Suffix_Reassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>savec</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>path</name><index>[<expr><name>savep</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name><index>[<expr><name>savep</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><call><name>str_basename</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name><index>[<expr><name>savep</name></expr>]</index></name> <operator>=</operator> <name>savec</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>Suffix_Unassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><call><name>str_basename</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDepsRegular</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>CandidateList</name></type> <name>srcs</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>CandidateList</name></type> <name>targs</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>bottom</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Candidate</name> <modifier>*</modifier></type><name>targ</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nameLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_SRC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"FindDepsRegular \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




















<expr_stmt><expr><name>bottom</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>targ</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_PHONY</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FindDepsRegularKnown</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>FindDepsRegularUnknown</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>bottom</name> <operator>=</operator> <call><name>FindThem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcs</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bottom</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>targs</name><operator>.</operator><name>first</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>targ</name> <operator>=</operator> <name><name>targs</name><operator>.</operator><name>first</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>targ</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<for>for <control>(<init><expr><name>targ</name> <operator>=</operator> <name>bottom</name></expr>;</init>
<condition><expr><name><name>targ</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>targ</name> <operator>=</operator> <name><name>targ</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><call><name>GNode_Path</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><ternary><condition><expr><name>targ</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr> </then><else>: <expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>children</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name>nln</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ExpandChildren</name><argument_list>(<argument><expr><name>ln</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>targ</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"\tNo valid suffix on %s\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>sfnd_abort</name>:</label>
<expr_stmt><expr><call><name>FindDepsRegularPath</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>sfnd_return</name>;</goto>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>targ</name><operator>-&gt;</operator><name>suff</name><operator>-&gt;</operator><name>library</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_LIB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>FindCmds</name><argument_list>(<argument><expr><name>targ</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>src</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<while>while <condition>(<expr><name>bottom</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>bottom</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CandidateSearcher_AddIfNew</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bottom</name> <operator>=</operator> <name><name>bottom</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>bottom</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bottom</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>sfnd_abort</name>;</goto>
</block_content>}</block></if></if_stmt>













<if_stmt><if>if <condition>(<expr><name><name>bottom</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>bottom</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name><name>bottom</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>src</name> <operator>=</operator> <name>bottom</name></expr>;</init> <condition><expr><name><name>src</name><operator>-&gt;</operator><name>parent</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>src</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>targ</name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Suffix_Reassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>Targ_GetNode</name><argument_list>(<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ApplyTransform</name><argument_list>(<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name> <operator>!=</operator> <name>gn</name></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_DEPS_FOUND</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><name><name>targ</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>Suffix_Reassign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gn</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<label><name>sfnd_return</name>:</label>
<if_stmt><if>if <condition>(<expr><name>bottom</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CandidateSearcher_AddIfNew</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><name>bottom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><call><name>RemoveCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcs</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RemoveCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></while>

<expr_stmt><expr><call><name>CandidateSearcher_MoveAll</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CandidateSearcher_MoveAll</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CandidateSearcher_CleanUp</name><parameter_list>(<parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><call><name>RemoveCandidate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></while>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cs</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

















<function><type><name>void</name></type>
<name>Suff_FindDeps</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CandidateSearcher</name></type> <name>cs</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CandidateSearcher_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FindDeps</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CandidateSearcher_CleanUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CandidateSearcher_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FindDeps</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>CandidateSearcher</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_DEPS_FOUND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_DEPS_FOUND</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>TARGET</name></expr></argument>, <argument><expr><call><name>GNode_Path</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>SUFF</name></expr></argument>, <argument><expr><literal type="string">"SuffFindDeps \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_ARCHV</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FindDepsArchive</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_LIB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FindDepsLib</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FindDepsRegular</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>










<function><type><name>void</name></type>
<name>Suff_SetNull</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><call><name>FindSuffixByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>suff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Error</name><argument_list>(<argument><expr><name>PARSE_WARNING</name></expr></argument>,
<argument><expr><literal type="string">"Desired null suffix %s not defined"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nullSuff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nullSuff</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>suff</name><operator>-&gt;</operator><name>isNull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nullSuff</name> <operator>=</operator> <name>suff</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>Suff_Init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>





<expr_stmt><expr><call><name>Suff_ClearSuffixes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>Suff_End</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_DoneCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sufflist</name></expr></argument>, <argument><expr><name>SuffFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_DoneCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name>suffClean</name></expr></argument>, <argument><expr><name>SuffFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nullSuff</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SuffFree</name><argument_list>(<argument><expr><name>nullSuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>transforms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintSuffNames</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SuffixList</name> <modifier>*</modifier></type><name>suffs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#\t%s: "</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>suffs</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>suff</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>Suffix_Print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>include</name></name></expr></argument>, <argument><expr><literal type="string">"SUFF_INCLUDE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>library</name></name></expr></argument>, <argument><expr><literal type="string">"SUFF_LIBRARY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddFlag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>isNull</name></name></expr></argument>, <argument><expr><literal type="string">"SUFF_NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#\"%s\" (num %d, ref %d)"</literal></expr></argument>,
<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>sNum</name></name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>refCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">" (%s)"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Buf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PrintSuffNames</name><argument_list>(<argument><expr><literal type="string">"To"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>parents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PrintSuffNames</name><argument_list>(<argument><expr><literal type="string">"From"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>suff</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#\tSearch Path: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SearchPath_Print</name><argument_list>(<argument><expr><name><name>suff</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintTransformation</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"%-16s:"</literal></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintType</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_PrintCmds</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Suff_PrintAll</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#*** Suffixes:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Suffix_Print</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block>

<expr_stmt><expr><call><name>debug_printf</name><argument_list>(<argument><expr><literal type="string">"#*** Transformations:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>transforms</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PrintTransformation</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>Suff_NamesStr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SuffixListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suffix</name> <modifier>*</modifier></type><name>suff</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Buf_InitSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>suff</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>!=</operator> <name><name>sufflist</name><operator>.</operator><name>first</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Buf_AddByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>suff</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
