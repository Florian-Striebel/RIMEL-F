<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bmake/main.c">

























































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_NATIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utsname.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wait.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"make.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"job.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pathnames.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trace.h"</cpp:file></cpp:include>


<expr_stmt><expr><call><name>MAKE_RCSID</name><argument_list>(<argument><expr><literal type="string">"$NetBSD: main.c,v 1.541 2021/08/14 13:32:12 rillig Exp $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_NATIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>__COPYRIGHT</name><argument_list>(<argument><expr><literal type="string">"@(#) Copyright (c) 1988, 1989, 1990, 1993 "</literal>
<literal type="string">"The Regents of the University of California. "</literal>
<literal type="string">"All rights reserved."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__arraycount</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__arraycount</name><parameter_list>(<parameter><type><name>__x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(__x) / sizeof(__x[0]))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>CmdOpts</name></type> <name>opts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GNode</name> <modifier>*</modifier></type><name>defaultNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>allPrecious</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>deleteOnError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>maxJobTokens</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enterFlagObj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>jp_0</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>jp_1</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>doing_depend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>jobsRunning</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tracefile</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReadMakefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>purge_relative_cached_realpaths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ignorePWD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>objdir</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>curdir</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>makeDependfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>myPid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>makelevel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>forceJobs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>main_errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HashTable</name></type> <name>cached_realpaths</name></decl>;</decl_stmt>





<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>explode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <name>flags</name></expr>;</init> <condition><expr><operator>*</operator><name>f</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ch_isalpha</name><argument_list>(<argument><expr><operator>*</operator><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>f</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>st</name> <operator>=</operator> <name>nf</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>flags</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nf</name><operator>++</operator> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nf</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>flags</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nf</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>nf</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>st</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>MAKE_ATTR_DEAD</name> <specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>prognameLen</name> <init>= <expr><call><name>strcspn</name><argument_list>(<argument><expr><name>progname</name></expr></argument>, <argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"usage: %.*s [-BeikNnqrSstWwX]\n"</literal>
<literal type="string">" [-C directory] [-D variable] [-d flags] [-f makefile]\n"</literal>
<literal type="string">" [-I directory] [-J private] [-j max_jobs] [-m directory] [-T file]\n"</literal>
<literal type="string">" [-V variable] [-v variable] [variable=value] [target ...]\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>prognameLen</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgDebugFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stdout</name> <operator>&amp;&amp;</operator> <name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stderr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"a"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="string">"w"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>bmake_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Cannot open debug file %s\n"</literal></expr></argument>,
<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgDebug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DebugFlags</name></type> <name>debug</name> <init>= <expr><name><name>opts</name><operator>.</operator><name>debug</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>modules</name> <operator>=</operator> <name>argvalue</name></expr>;</init> <condition><expr><operator>*</operator><name>modules</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>modules</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>modules</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>=</operator> <name>DEBUG_NONE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'A'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>=</operator> <name>DEBUG_ALL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_ARCH</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_CWD</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_COND</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_DIR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_ERROR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_FOR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>modules</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_GRAPH1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>modules</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>modules</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'2'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_GRAPH2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>modules</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>modules</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'3'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_GRAPH3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>modules</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_HASH</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_JOB</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'L'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>strict</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_LOUD</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'M'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_META</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_MAKE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_SCRIPT</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_PARSE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_SUFF</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_TARG</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debugVflag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_VAR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name>debug</name> <operator>|=</operator> <name>DEBUG_SHELL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'F'</literal></expr>:</case>
<expr_stmt><expr><call><name>MainParseArgDebugFile</name><argument_list>(<argument><expr><name>modules</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>debug_setbuf</name>;</goto>
<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: illegal argument to d option -- %c\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>*</operator><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>

<label><name>debug_setbuf</name>:</label>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug</name></name> <operator>=</operator> <name>debug</name></expr>;</expr_stmt>





<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsRelativePath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"/."</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgChdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sa</name></decl>, <decl><type ref="prev"/><name>sb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: chdir %s: %s\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getcwd</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s.\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRelativePath</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>stat</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>stat</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>sa</name><operator>.</operator><name>st_ino</name></name> <operator>==</operator> <name><name>sb</name><operator>.</operator><name>st_ino</name></name> <operator>&amp;&amp;</operator>
<name><name>sa</name><operator>.</operator><name>st_dev</name></name> <operator>==</operator> <name><name>sb</name><operator>.</operator><name>st_dev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ignorePWD</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgJobsInternal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>end</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>, <argument><expr><literal type="string">"%d,%d%c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jp_0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jp_1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: internal error -- J option malformed (%s)\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>fcntl</name><argument_list>(<argument><expr><name>jp_0</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>fcntl</name><argument_list>(<argument><expr><name>jp_1</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
(void)fprintf(stderr,
"%s: ######warning -- J descriptors were closed!\n",
progname);
exit(2);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>jp_0</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>jp_1</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-J"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgJobs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>forceJobs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>maxJobs</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>opts</name><operator>.</operator><name>maxJobs</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: illegal argument to -j -- must be positive integer!\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-j"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.JOBS"</literal></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxJobTokens</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>maxJobs</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgSysInc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">".../"</literal></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>found_path</name> <init>= <expr><call><name>Dir_FindHereOrAbove</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>argvalue</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>found_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name>sysIncPath</name></expr></argument>, <argument><expr><name>found_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>found_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name>sysIncPath</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MainParseArg</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<break>break;</break>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-B"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKE_MODE</name></expr></argument>, <argument><expr><literal type="string">"compat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'C'</literal></expr>:</case>
<expr_stmt><expr><call><name>MainParseArgChdir</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Global_SetExpand</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-D"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<expr_stmt><expr><call><name>Parse_AddIncludeDir</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-I"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'J'</literal></expr>:</case>
<expr_stmt><expr><call><name>MainParseArgJobsInternal</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noExecute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noRecursiveExecute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-N"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>keepgoing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-S"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'T'</literal></expr>:</case>
<expr_stmt><expr><name>tracefile</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-T"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>=</operator> <ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'v'</literal></expr> ?</condition><then> <expr><name>PVM_EXPANDED</name></expr> </then><else>: <expr><name>PVM_UNEXPANDED</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>variables</name></name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>parseWarnFatal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><literal type="char">'X'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>varNoExportEnv</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-X"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvalue</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argvalue</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>MainParseArgDebug</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>checkEnvFirst</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'i'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>ignoreErrors</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-i"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><call><name>MainParseArgJobs</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>keepgoing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-k"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><call><name>MainParseArgSysInc</name><argument_list>(<argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noExecute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>queryFlag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noBuiltins</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>beSilent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>touchFlag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>enterFlag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>MainParseArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>arginc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argvalue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>optscan</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>inOption</name></decl>, <decl><type ref="prev"/><name>dashDash</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optspecs</name> <init>= <expr><literal type="string">"BC:D:I:J:NST:V:WXd:ef:ij:km:nqrstv:w"</literal></expr></init></decl>;</decl_stmt>


<label><name>rearg</name>:</label>
<expr_stmt><expr><name>inOption</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>optscan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optspec</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inOption</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>optscan</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>optscan</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>arginc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>inOption</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>inOption</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>dashDash</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>inOption</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>optscan</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>optspec</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optspecs</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>optspec</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>optspec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inOption</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>arginc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>argvalue</name> <operator>=</operator> <name>optscan</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argvalue</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>noarg</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>argvalue</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>arginc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>argvalue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><name>arginc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>inOption</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name>dashDash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MainParseArg</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>argvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>noarg</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>arginc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>arginc</name></expr>;</expr_stmt>
</block_content>}</block></while>






<for>for <control>(<init>;</init> <condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>argv</name><operator>++</operator></expr><operator>,</operator> <expr><name>argc</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VarAssign</name></type> <name>var</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Parse_IsVar</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_Var</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Punt</name><argument_list>(<argument><expr><literal type="string">"illegal (null) argument."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>dashDash</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>rearg</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return;</return>
<label><name>noarg</name>:</label>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: option requires an argument -- %c\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Main_ParseArgLine</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Words</name></type> <name>words</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>line</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>



<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cp</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"make"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"make"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>argv0</name> <init>= <expr><call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><literal type="string">".MAKE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>str_concat3</name><argument_list>(<argument><expr><name><name>argv0</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><name>words</name> <operator>=</operator> <call><name>Str_Words</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>words</name><operator>.</operator><name>words</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Error</name><argument_list>(<argument><expr><literal type="string">"Unterminated quoted string [%s]"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MainParseArgs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>words</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>words</name><operator>.</operator><name>words</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Words_Free</name><argument_list>(<argument><expr><name>words</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>Main_SetObjdir</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>writable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf2</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>rc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>path</name> <operator>=</operator> <name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name>buf2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>writable</name> <operator>&amp;&amp;</operator> <call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>W_OK</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>chdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s warning: %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>objdir</name></expr></argument>, <argument><expr><sizeof>sizeof <name>objdir</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".OBJDIR"</literal></expr></argument>, <argument><expr><name>objdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"PWD"</literal></expr></argument>, <argument><expr><name>objdir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Dir_InitDot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>purge_relative_cached_realpaths</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>enterFlag</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>objdir</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>enterFlagObj</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SetVarObjdir</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>writable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>path</name> <init>= <expr><call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>xpath</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>path</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>xpath</name> <operator>=</operator> <call><name>FStr_InitRefer</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expanded</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>xpath</name> <operator>=</operator> <call><name>FStr_InitOwn</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>xpath</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>str2Lst_Append</name><parameter_list>(<parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">" \t"</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>cp</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cp</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>Lst_Append</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>siginfo</name><parameter_list>(<parameter><decl><type><name>int</name> <name>signo</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getcwd</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><sizeof>sizeof <name>dir</name></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <name>str</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%s: Working in: %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>write</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>MakeMode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${"</literal> <name>MAKE_MODE</name> <literal type="string">":tl}"</literal></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"compat"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>forceJobs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_META</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"meta"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>meta_mode_init</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>PrintVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expandVars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>evalue</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bmake_free</name><argument_list>(<argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>expandVars</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>str_concat3</name><argument_list>(<argument><expr><literal type="string">"${"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>evalue</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bmake_free</name><argument_list>(<argument><expr><name>evalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>value</name> <init>= <expr><call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>value</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>value</name><operator>.</operator><name>str</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>








<function><type><name>bool</name></type>
<name>GetBooleanExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ParseBoolean</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doPrintVars</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>expandVars</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>==</operator> <name>PVM_EXPANDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expandVars</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>opts</name><operator>.</operator><name>debugVflag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>expandVars</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>expandVars</name> <operator>=</operator> <call><name>GetBooleanExpr</name><argument_list>(<argument><expr><literal type="string">"${.MAKE.EXPAND_VARIABLES}"</literal></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>variables</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PrintVar</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>expandVars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>runTargets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GNodeList</name></type> <name>targs</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>outOfDate</name></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Parse_MainName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Targ_FindList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>compatMake</name></name></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>queryFlag</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Job_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>jobsRunning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>outOfDate</name> <operator>=</operator> <call><name>Make_Run</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>Compat_Run</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outOfDate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>outOfDate</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitVarTargets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".TARGETS"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>create</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><literal type="string">".TARGETS"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitRandom</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>InitVarMachine</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>utsname</name></name> <modifier>*</modifier><name>utsname</name></type> <name>MAKE_ATTR_UNUSED</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORCE_MACHINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>FORCE_MACHINE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>machine</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"MACHINE"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>machine</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>machine</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_NATIVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name><name>utsname</name><operator>-&gt;</operator><name>machine</name></name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_MACHINE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><name>MAKE_MACHINE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>InitVarMachineArch</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FORCE_MACHINE_ARCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>FORCE_MACHINE_ARCH</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"MACHINE_ARCH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>env</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_NATIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CTL_HW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>utsname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>machine_arch_buf</name><index>[<expr><sizeof>sizeof <name><name>utsname</name><operator>.</operator><name>machine</name></name></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>mib</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>CTL_HW</name></expr>, <expr><name>HW_MACHINE_ARCH</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof <name>machine_arch_buf</name></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sysctl</name><argument_list>(<argument><expr><name>mib</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>__arraycount</name><argument_list>(<argument><expr><name>mib</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>machine_arch_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: sysctl failed (%s).\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>machine_arch_buf</name></expr>;</return>
</block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACHINE_ARCH</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><name>MACHINE_ARCH</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_MACHINE_ARCH</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><name>MAKE_MACHINE_ARCH</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_PWD_OVERRIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
















<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandlePWD</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>curdir_st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pwd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FStr</name></type> <name>prefix</name></decl>, <decl><type ref="prev"/><name>makeobjdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>pwd_st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ignorePWD</name> <operator>||</operator> <operator>(</operator><name>pwd</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PWD"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><literal type="string">"MAKEOBJDIRPREFIX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>makeobjdir</name> <operator>=</operator> <call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><literal type="string">"MAKEOBJDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>makeobjdir</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name><name>makeobjdir</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>ignore_pwd</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pwd_st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>curdir_st</name><operator>-&gt;</operator><name>st_ino</name></name> <operator>==</operator> <name><name>pwd_st</name><operator>.</operator><name>st_ino</name></name> <operator>&amp;&amp;</operator>
<name><name>curdir_st</name><operator>-&gt;</operator><name>st_dev</name></name> <operator>==</operator> <name><name>pwd_st</name><operator>.</operator><name>st_dev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strncpy</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>ignore_pwd</name>:</label>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>makeobjdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitObjdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>machine</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>machine_arch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>writable</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Dir_InitCur</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>writable</name> <operator>=</operator> <call><name>GetBooleanExpr</name><argument_list>(<argument><expr><literal type="string">"${MAKE_OBJDIR_CHECK_WRITABLE}"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetVarObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"MAKEOBJDIRPREFIX"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>SetVarObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"MAKEOBJDIR"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"%s.%s-%s"</literal></expr></argument>, <argument><expr><name>_PATH_OBJDIR</name></expr></argument>, <argument><expr><name>machine</name></expr></argument>, <argument><expr><name>machine_arch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>_PATH_OBJDIR</name></expr></argument>, <argument><expr><name>machine</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>_PATH_OBJDIR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Main_SetObjdir</name><argument_list>(<argument><expr><name>writable</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>_PATH_OBJDIRPREFIX</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>UnlimitFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>rl</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<name><name>rl</name><operator>.</operator><name>rlim_cur</name></name> <operator>!=</operator> <name><name>rl</name><operator>.</operator><name>rlim_max</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rl</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <name><name>rl</name><operator>.</operator><name>rlim_max</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_NOFILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CmdOpts_Init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug</name></name> <operator>=</operator> <name>DEBUG_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>strict</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debugVflag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>checkEnvFirst</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>ignoreErrors</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>maxJobs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>keepgoing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noRecursiveExecute</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noExecute</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>queryFlag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>noBuiltins</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>beSilent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>touchFlag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>=</operator> <name>PVM_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>variables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>parseWarnFatal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>enterFlag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>varNoExportEnv</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitVarMake</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argv0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>make</name> <init>= <expr><name>argv0</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argv0</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>pathbuf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abspath</name> <init>= <expr><call><name>cached_realpath</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>, <argument><expr><name>pathbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>abspath</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>abspath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<call><name>stat</name><argument_list>(<argument><expr><name>make</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>make</name> <operator>=</operator> <name>abspath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"MAKE"</literal></expr></argument>, <argument><expr><name>make</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE"</literal></expr></argument>, <argument><expr><name>make</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitDefSysIncPath</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>syspath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>defsyspath</name><index>[]</index></name> <init>= <expr><name>_PATH_DEFSYSPATH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name>syspath</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>syspath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>syspath</name> <operator>=</operator> <name>defsyspath</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>syspath</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>syspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>start</name> <operator>=</operator> <name>syspath</name></expr>;</init> <condition><expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>start</name> <operator>=</operator> <name>cp</name></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="string">".../"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>Dir_FindHereOrAbove</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name>defSysIncPath</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><name>defSysIncPath</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>syspath</name> <operator>!=</operator> <name>defsyspath</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadBuiltinRules</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringList</name></type> <name>sysMkFiles</name> <init>= <expr><name>LST_INIT</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SearchPath_Expand</name><argument_list>(
<argument><expr><ternary><condition><expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sysIncPath</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>defSysIncPath</name></expr> </then><else>: <expr><name>sysIncPath</name></expr></else></ternary></expr></argument>,
<argument><expr><name>_PATH_DEFSYSMK</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>sysMkFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysMkFiles</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="string">"%s: no system rules (%s)."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>_PATH_DEFSYSMK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>sysMkFiles</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>ReadMakefile</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>ln</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="string">"%s: cannot open %s."</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>sysMkFiles</name><operator>.</operator><name>first</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysMkFiles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitMaxJobs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>forceJobs</name> <operator>||</operator> <name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>||</operator>
<operator>!</operator><call><name>Var_Exists</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><literal type="string">".MAKE.JOBS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${.MAKE.JOBS}"</literal></expr></argument>, <argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: illegal value for .MAKE.JOBS "</literal>
<literal type="string">"-- must be positive integer!\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name><name>opts</name><operator>.</operator><name>maxJobs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">"-j"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>maxJobs</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maxJobTokens</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>maxJobs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>forceJobs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitVpath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vpath</name></decl>, <decl><type ref="prev"/><name>savec</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Var_Exists</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><literal type="string">"VPATH"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${VPATH}"</literal></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>vpath</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>path</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>

<expr_stmt><expr><name>savec</name> <operator>=</operator> <operator>*</operator><name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>SearchPath_Add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dirSearchPath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>savec</name></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name>cp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>savec</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>;</do>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>vpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadAllMakefiles</name><parameter_list>(<parameter><decl><type><name>StringList</name> <modifier>*</modifier></type><name>makefiles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>makefiles</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ReadMakefile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="string">"%s: cannot open %s."</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadFirstDefaultMakefile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prefs</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${"</literal> <name>MAKE_MAKEFILE_PREFERENCE</name> <literal type="string">"}"</literal></expr></argument>,
<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>str2Lst_Append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>, <argument><expr><name>prefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>makefiles</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>ReadMakefile</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>prefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>main_Init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>machine</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>machine_arch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>syspath</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"MAKESYSPATH"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>utsname</name></name></type> <name>utsname</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>debug_file</name></name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HashTable_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_realpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>bmake_signal</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>, <argument><expr><name>siginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>InitRandom</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>str_basename</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UnlimitFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>uname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>utsname</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: uname failed (%s).\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>









<expr_stmt><expr><name>machine</name> <operator>=</operator> <call><name>InitVarMachine</name><argument_list>(<argument><expr><operator>&amp;</operator><name>utsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>machine_arch</name> <operator>=</operator> <call><name>InitVarMachineArch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>myPid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>Targ_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.OS"</literal></expr></argument>, <argument><expr><name><name>utsname</name><operator>.</operator><name>sysname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"MACHINE"</literal></expr></argument>, <argument><expr><name>machine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"MACHINE_ARCH"</literal></expr></argument>, <argument><expr><name>machine_arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAKE_VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"MAKE_VERSION"</literal></expr></argument>, <argument><expr><name>MAKE_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".newline"</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAKEFILE_PREFERENCE_LIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAKEFILE_PREFERENCE_LIST</name></cpp:macro> <cpp:value>"makefile Makefile"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKE_MAKEFILE_PREFERENCE</name></expr></argument>, <argument><expr><name>MAKEFILE_PREFERENCE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKE_DEPENDFILE</name></expr></argument>, <argument><expr><literal type="string">".depend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CmdOpts_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>allPrecious</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOnError</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>jobsRunning</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxJobTokens</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>maxJobs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ignorePWD</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>













<expr_stmt><expr><call><name>Parse_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>InitVarMake</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKEFLAGS</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKEOVERRIDES</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">"MFLAGS"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".ALLTARGETS"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>MAKE_LEVEL</name> <literal type="string">".ENV"</literal></expr></argument>, <argument><expr><name>MAKE_LEVEL_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>MAKE_LEVEL_ENV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>makelevel</name> <operator>=</operator> <ternary><condition><expr><name>ep</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><call><name>atoi</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>makelevel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>makelevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>makelevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><name>MAKE_LEVEL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>myPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.PID"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>getppid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.PPID"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>getuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.UID"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <name>tmp</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>getgid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".MAKE.GID"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>makelevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>pn</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pn</name></expr></argument>, <argument><expr><sizeof>sizeof <name>pn</name></sizeof></expr></argument>, <argument><expr><literal type="string">"%s[%d]"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>makelevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>progname</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>pn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_META</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>meta_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Dir_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>explode</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"MAKEFLAGS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Main_ParseArgLine</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Main_ParseArgLine</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"MAKE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<if_stmt><if>if <condition>(<expr><call><name>getcwd</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: getcwd: %s.\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MainParseArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>enterFlag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: Entering directory `%s'\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_PWD_OVERRIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>HandlePWD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".CURDIR"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>InitObjdir</name><argument_list>(<argument><expr><name>machine</name></expr></argument>, <argument><expr><name>machine_arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>Arch_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Suff_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Trace_Init</name><argument_list>(<argument><expr><name>tracefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>defaultNode</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Trace_Log</name><argument_list>(<argument><expr><name>MAKESTART</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>InitVarTargets</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>InitDefSysIncPath</name><argument_list>(<argument><expr><name>syspath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>main_ReadFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>noBuiltins</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ReadBuiltinRules</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ReadAllMakefiles</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ReadFirstDefaultMakefile</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>main_PrepareMaking</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>noBuiltins</name></name> <operator>||</operator> <name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>==</operator> <name>PVM_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${.MAKE.DEPENDFILE}"</literal></expr></argument>,
<argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>makeDependfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>makeDependfile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>doing_depend</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ReadMakefile</name><argument_list>(<argument><expr><name>makeDependfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>doing_depend</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enterFlagObj</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: Entering directory `%s'\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>objdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MakeMode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>FStr</name></type> <name>makeflags</name> <init>= <expr><call><name>Var_Value</name><argument_list>(<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>MAKEFLAGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><literal type="string">"MFLAGS"</literal></expr></argument>, <argument><expr><name><name>makeflags</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FStr_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>makeflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>InitMaxJobs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceJobs</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>opts</name><operator>.</operator><name>compatMake</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Job_ServerStart</name><argument_list>(<argument><expr><name>maxJobTokens</name></expr></argument>, <argument><expr><name>jp_0</name></expr></argument>, <argument><expr><name>jp_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>DEBUG5</name><argument_list>(<argument><expr><name>JOB</name></expr></argument>, <argument><expr><literal type="string">"job_pipe %d %d, maxjobs %d, tokens %d, compat %d\n"</literal></expr></argument>,
<argument><expr><name>jp_0</name></expr></argument>, <argument><expr><name>jp_1</name></expr></argument>, <argument><expr><name><name>opts</name><operator>.</operator><name>maxJobs</name></name></expr></argument>, <argument><expr><name>maxJobTokens</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>opts</name><operator>.</operator><name>compatMake</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>==</operator> <name>PVM_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Main_ExportMAKEFLAGS</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>InitVpath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>Suff_ExtendPaths</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>Targ_Propagate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>GRAPH1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Targ_PrintGraph</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>bool</name></type>
<name>main_Run</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>printVars</name></name> <operator>!=</operator> <name>PVM_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>doPrintVars</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>runTargets</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>main_CleanUp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLEANUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Lst_DoneCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>variables</name></name></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>Lst_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>makefiles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Lst_DoneCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opts</name><operator>.</operator><name>create</name></name></expr></argument>, <argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>GRAPH2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Targ_PrintGraph</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Trace_Log</name><argument_list>(<argument><expr><name>MAKEEND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enterFlagObj</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: Leaving directory `%s'\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>objdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>enterFlag</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s: Leaving directory `%s'\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_META</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>meta_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Suff_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Targ_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Arch_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Parse_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Dir_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Job_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Trace_End</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>main_Exit</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>outOfDate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>opts</name><operator>.</operator><name>strict</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>main_errors</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>Parse_NumErrors</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>outOfDate</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>outOfDate</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>main_Init</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>main_ReadFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>main_PrepareMaking</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outOfDate</name> <operator>=</operator> <call><name>main_Run</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>main_CleanUp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>main_Exit</name><argument_list>(<argument><expr><name>outOfDate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>ReadMakefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Parse_File</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> , <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>SCOPE_INTERNAL</name></expr></argument>, <argument><expr><literal type="string">"MAKEFILE"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>objdir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>fname</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>str_concat3</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<goto>goto <name>found</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>str_concat3</name><argument_list>(<argument><expr><name>objdir</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<goto>goto <name>found</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>parseIncPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SearchPath</name> <modifier>*</modifier></type><name>sysInc</name> <init>= <expr><ternary><condition><expr><call><name>Lst_IsEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sysIncPath</name><operator>-&gt;</operator><name>dirs</name></name></expr></argument>)</argument_list></call></expr>
?</condition><then> <expr><name>defSysIncPath</name></expr> </then><else>: <expr><name>sysIncPath</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>Dir_FindFile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>sysInc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>





<label><name>found</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>doing_depend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Var_Set</name><argument_list>(<argument><expr><name>SCOPE_INTERNAL</name></expr></argument>, <argument><expr><literal type="string">"MAKEFILE"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Parse_File</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>














<function><type><name>char</name> <modifier>*</modifier></type>
<name>Cmd_Exec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>errfmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>pipefds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cpid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>res_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>savederr</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shellName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Shell_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>shellName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"-c"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>pipefds</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <literal type="string">"Couldn't create pipe for \"%s\""</literal></expr>;</expr_stmt>
<goto>goto <name>bad</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Var_ReexportVars</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<switch>switch <condition>(<expr><name>cpid</name> <operator>=</operator> <call><name>vfork</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dup2</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>execv</name><argument_list>(<argument><expr><name>shellPath</name></expr></argument>, <argument><expr><call><name>UNCONST</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <literal type="string">"Couldn't exec \"%s\""</literal></expr>;</expr_stmt>
<goto>goto <name>bad</name>;</goto>

<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>savederr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>result</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>bytes_read</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof <name>result</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Buf_AddBytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>bytes_read</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name>bytes_read</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>savederr</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name><name>pipefds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>cpid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>cpid</name> <operator>&amp;&amp;</operator> <name>pid</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>JobReapChild</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>res_len</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>Buf_DoneData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>savederr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <literal type="string">"Couldn't read shell's output for \"%s\""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <literal type="string">"\"%s\" exited on a signal"</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>errfmt</name> <operator>=</operator> <literal type="string">"\"%s\" returned non-zero status"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>res_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>res</name><index>[<expr><name>res_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>res_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>res</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>res</name></expr>;</return>
<label><name>bad</name>:</label>
<return>return <expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>Error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>err_file</name></decl>;</decl_stmt>

<expr_stmt><expr><name>err_file</name> <operator>=</operator> <name><name>opts</name><operator>.</operator><name>debug_file</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err_file</name> <operator>==</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>err_file</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>err_file</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vfprintf</name><argument_list>(<argument><expr><name>err_file</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>err_file</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>err_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err_file</name> <operator>==</operator> <name>stderr</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>err_file</name> <operator>=</operator> <name>stderr</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>main_errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type>
<name>Fatal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>jobsRunning</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Job_Wait</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PrintOnError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>GRAPH2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>DEBUG</name><argument_list>(<argument><expr><name>GRAPH3</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Targ_PrintGraph</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Trace_Log</name><argument_list>(<argument><expr><name>MAKEERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>Punt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PrintOnError</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DieHorribly</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>DieHorribly</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>jobsRunning</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Job_AbortAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>GRAPH2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Targ_PrintGraph</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Trace_Log</name><argument_list>(<argument><expr><name>MAKEERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>Finish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>shouldDieQuietly</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Fatal</name><argument_list>(<argument><expr><literal type="string">"%d error%s"</literal></expr></argument>, <argument><expr><name>errs</name></expr></argument>, <argument><expr><ternary><condition><expr><name>errs</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>eunlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EISDIR</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>unlink</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_all</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>written</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>written</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>written</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mem</name> <operator>+=</operator> <name>written</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>written</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<function><type><name>void</name> <name>MAKE_ATTR_DEAD</name></type>
<name>execDie</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>af</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>av</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Buffer</name></type> <name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Buf_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">") failed ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Buf_AddStr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_all</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Buf_Done</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>purge_relative_cached_realpaths</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HashEntry</name> <modifier>*</modifier></type><name>he</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nhe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HashIter</name></type> <name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>HashIter_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cached_realpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>he</name> <operator>=</operator> <call><name>HashIter_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>he</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nhe</name> <operator>=</operator> <call><name>HashIter_Next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>he</name><operator>-&gt;</operator><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUG1</name><argument_list>(<argument><expr><name>DIR</name></expr></argument>, <argument><expr><literal type="string">"cached_realpath: purging %s\n"</literal></expr></argument>, <argument><expr><name><name>he</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HashTable_DeleteEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_realpaths</name></expr></argument>, <argument><expr><name>he</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>he</name> <operator>=</operator> <name>nhe</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>cached_realpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resolved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pathname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pathname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>HashTable_FindValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_realpaths</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resolved</name><index>[<expr><name>MAXPATHLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><name>resolved</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HashTable_Set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cached_realpaths</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><call><name>bmake_strdup</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUG2</name><argument_list>(<argument><expr><name>DIR</name></expr></argument>, <argument><expr><literal type="string">"cached_realpath: %s -&gt; %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>resolved</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>bool</name></type>
<name>shouldDieQuietly</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>quietly</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>quietly</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>JOB</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>GetBooleanExpr</name><argument_list>(<argument><expr><literal type="string">"${.MAKE.DIE_QUIETLY}"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>quietly</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>bf</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>quietly</name> <operator>=</operator> <name>bf</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>quietly</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>gn</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>&amp;</operator> <name>OP_MAKE</name><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>quietly</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetErrorVars</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>StringListNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>Global_Set</name><argument_list>(<argument><expr><literal type="string">".ERROR_TARGET"</literal></expr></argument>, <argument><expr><name><name>gn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Global_Delete</name><argument_list>(<argument><expr><literal type="string">".ERROR_CMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>ln</name> <operator>=</operator> <name><name>gn</name><operator>-&gt;</operator><name>commands</name><operator>.</operator><name>first</name></name></expr>;</init> <condition><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>datum</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Global_Append</name><argument_list>(<argument><expr><literal type="string">".ERROR_CMD"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>PrintOnError</name><parameter_list>(<parameter><decl><type><name>GNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>GNode</name> <modifier>*</modifier></type><name>errorNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DEBUG</name><argument_list>(<argument><expr><name>HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Targ_Stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Var_Stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errorNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s: stopped in %s\n"</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>shouldDieQuietly</name><argument_list>(<argument><expr><name>gn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>gn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SetErrorVars</name><argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errorVarsValues</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${MAKE_PRINT_VAR_ON_ERROR:@v@$v='${$v}'\n@}"</literal></expr></argument>,
<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorVarsValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errorVarsValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>errorVarsValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>errorNode</name> <operator>=</operator> <call><name>Targ_FindNode</name><argument_list>(<argument><expr><literal type="string">".ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errorNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>errorNode</name><operator>-&gt;</operator><name>type</name></name> <operator>|=</operator> <name>OP_SPECIAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Compat_Make</name><argument_list>(<argument><expr><name>errorNode</name></expr></argument>, <argument><expr><name>errorNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Main_ExportMAKEFLAGS</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>once</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>once</name> <operator>!=</operator> <name>first</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>once</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>expr</name> <operator>=</operator> <literal type="string">"${.MAKEFLAGS} ${.MAKEOVERRIDES:O:u:@v@$v=${$v:Q}@}"</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>SCOPE_CMDLINE</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"MAKEFLAGS"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"MAKE"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>getTmpdir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpdir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>tmpdir</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Var_Subst</name><argument_list>(<argument><expr><literal type="string">"${TMPDIR:tA:U"</literal> <name>_PATH_TMP</name> <literal type="string">":S,/$,,W}/"</literal></expr></argument>,
<argument><expr><name>SCOPE_GLOBAL</name></expr></argument>, <argument><expr><name>VARE_WANTRES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <call><name>bmake_strdup</name><argument_list>(<argument><expr><name>_PATH_TMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>tmpdir</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>mkTempFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tfile</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tfile_sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tbuf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <name>TMPPAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpdir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <call><name>getTmpdir</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tfile</name> <operator>=</operator> <name>tbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tfile_sz</name> <operator>=</operator> <sizeof>sizeof <name>tbuf</name></sizeof></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>tfile_sz</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>tfile_sz</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>mkstemp</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Punt</name><argument_list>(<argument><expr><literal type="string">"Could not create temporary file %s: %s"</literal></expr></argument>, <argument><expr><name>tfile</name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tfile</name> <operator>==</operator> <name>tbuf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>bool</name></type>
<name>ParseBoolean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name>ch_tolower</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>fallback</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ch_tolower</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'f'</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
