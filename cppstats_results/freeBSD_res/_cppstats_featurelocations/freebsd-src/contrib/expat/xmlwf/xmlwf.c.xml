<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/expat/xmlwf/xmlwf.c">































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"codepage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmlfile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltchar.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crtdbg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <type><struct>struct <name>NotationList</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>NotationList</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl>;</decl_stmt>
}</block></struct></type> <name>NotationList</name>;</typedef>

<typedef>typedef <type><struct>struct <name>xmlwfUserData</name> <block>{
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier></type><name>notationListHead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>currentDoctypeName</name></decl>;</decl_stmt>
}</block></struct></type> <name>XmlwfUserData</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSSEP</name></cpp:macro> <cpp:value>T('\001')</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>characterData</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>W3C14N</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">13</literal></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#xD;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">9</literal></expr>:</case>
<case>case <expr><literal type="number">10</literal></expr>:</case>
<case>case <expr><literal type="number">13</literal></expr>:</case>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#%d;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>attributeValue</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<case>case <expr><name>NSSEP</name></expr>:</case>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&amp;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;amp;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;lt;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;quot;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>W3C14N</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">9</literal></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#x9;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">10</literal></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#xA;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">13</literal></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#xD;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;gt;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">9</literal></expr>:</case>
<case>case <expr><literal type="number">10</literal></expr>:</case>
<case>case <expr><literal type="number">13</literal></expr>:</case>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&amp;#%d;"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>attcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>att1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>att2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>tcscmp</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>att1</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>att2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>startElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>atts</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>nAtts</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>atts</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>atts</name></expr></argument>, <argument><expr><name>nAtts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>attcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><name>atts</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><operator>*</operator><name>atts</name><operator>++</operator></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>attributeValue</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>*</operator><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>atts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>endElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>nsattcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>att1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>att2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sep1</name> <init>= <expr><operator>(</operator><call><name>tcsrchr</name><argument_list>(<argument><expr><name>att1</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sep2</name> <init>= <expr><operator>(</operator><call><name>tcsrchr</name><argument_list>(<argument><expr><name>att1</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>sep1</name> <operator>!=</operator> <name>sep2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>sep1</name> <operator>-</operator> <name>sep2</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>tcscmp</name><argument_list>(<argument><expr><name>att1</name></expr></argument>, <argument><expr><name>att2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>startElementNS</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nsi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>tcsrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"n1:"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" xmlns:n1"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>attributeValue</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsi</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsi</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>atts</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>nAtts</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>atts</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>atts</name></expr></argument>, <argument><expr><name>nAtts</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>nsattcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><name>atts</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>*</operator><name>atts</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>tcsrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"n%d:"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>attributeValue</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>*</operator><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" xmlns:n%d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsi</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>attributeValue</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>atts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>endElementNS</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>tcsrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"n1:"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>sep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>W3C14N</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>processingInstruction</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>xcsdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numBytes</name></decl>;</decl_stmt>


<while>while <condition>(<expr><name><name>s</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>
<expr_stmt><expr><name>numBytes</name> <operator>=</operator> <name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>numBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>numBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>startDoctypeDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>doctypeName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sysid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_internal_subset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>has_internal_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name> <operator>=</operator> <call><name>xcsdup</name><argument_list>(<argument><expr><name>doctypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeNotations</name><parameter_list>(<parameter><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier></type><name>notationListHead</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>notationListHead</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>notationListHead</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>notationListHead</name><operator>-&gt;</operator><name>notationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>notationListHead</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>notationListHead</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>notationListHead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>notationListHead</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xcscmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>xt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>xs</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>xt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>&lt;</operator> <operator>*</operator><name>xt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>&gt;</operator> <operator>*</operator><name>xt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>xs</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>xt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>&lt;</operator> <operator>*</operator><name>xt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>&gt;</operator> <operator>*</operator><name>xt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>notationCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>NotationList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>n1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>NotationList</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>NotationList</name> <modifier>*</modifier><specifier>const</specifier></type> <name>n2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>NotationList</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>xcscmp</name><argument_list>(<argument><expr><name><name>n1</name><operator>-&gt;</operator><name>notationName</name></name></expr></argument>, <argument><expr><name><name>n2</name><operator>-&gt;</operator><name>notationName</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>endDoctypeDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier><modifier>*</modifier></type><name>notations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>notationCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>notationCount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>notationCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>notations</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>notationCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NotationList</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>notations</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unable to sort notations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeNotations</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>notationCount</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>notations</name></expr></argument>, <argument><expr><name>notationCount</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NotationList</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>notationCmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;!DOCTYPE "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" [\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>notationCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;!NOTATION "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>notationName</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>publicId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" PUBLIC '"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>publicId</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>systemId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>systemId</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>systemId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" SYSTEM '"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><name><name>notations</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>systemId</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"]&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>notations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeNotations</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>currentDoctypeName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>notationDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NotationList</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NotationList</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorMessage</name> <init>= <expr><literal type="string">"Unable to store NOTATION for output\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>notationName</name></name> <operator>=</operator> <call><name>xcsdup</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>notationName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>systemId</name></name> <operator>=</operator> <call><name>xcsdup</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>systemId</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>notationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>systemId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>publicId</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <call><name>xcsdup</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>publicId</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>errorMessage</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>notationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>notationListHead</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>defaultCharacterData</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_DefaultCurrent</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>defaultStartElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_DefaultCurrent</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>defaultEndElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_DefaultCurrent</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>defaultProcessingInstruction</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_DefaultCurrent</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>nopCharacterData</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>nopStartElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>nopEndElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>nopProcessingInstruction</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>markup</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>++</operator><name>s</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>metaLocation</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name> <init>= <expr><call><name>XML_GetBase</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>uri</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" uri=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><macro><name>T</name><argument_list>(<argument><literal type="string">" byte=\"%"</literal></argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument>XML_FMT_INT_MOD</argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument><literal type="string">"d\""</literal></argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument><literal type="string">" nbytes=\"%d\""</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" line=\"%"</literal></argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument>XML_FMT_INT_MOD</argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument><literal type="string">"u\""</literal></argument>)</argument_list></macro> <macro><name>T</name><argument_list>(<argument><literal type="string">" col=\"%"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument>XML_FMT_INT_MOD</argument>)</argument_list></macro> <call><name>T</name><argument_list>(<argument><expr><literal type="string">"u\""</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>metaStartDocument</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;document&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>metaEndDocument</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;/document&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaStartElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>specifiedAttsEnd</name>
<init>= <expr><name>atts</name> <operator>+</operator> <call><name>XML_GetSpecifiedAttributeCount</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>idAttPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idAttIndex</name> <init>= <expr><call><name>XML_GetIdAttributeIndex</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idAttIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idAttPtr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>idAttPtr</name> <operator>=</operator> <name>atts</name> <operator>+</operator> <name>idAttIndex</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;starttag name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>atts</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;attribute name=\"%s\" value=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name><name>atts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>atts</name> <operator>&gt;=</operator> <name>specifiedAttsEnd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\" defaulted=\"yes\"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>atts</name> <operator>==</operator> <name>idAttPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\" id=\"yes\"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>(</operator><name>atts</name> <operator>+=</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>;</do>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;/starttag&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaEndElement</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;endtag name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaProcessingInstruction</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>usrData</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>usrData</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;pi target=\"%s\" data=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>usrData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaComment</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>usrData</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>usrData</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;comment data=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>usrData</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaStartCdataSection</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;startcdata"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaEndCdataSection</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;endcdata"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaCharacterData</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;chars str=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaStartDoctypeDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>doctypeName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sysid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>pubid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_internal_subset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>has_internal_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;startdoctype name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>doctypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaEndDoctypeDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;enddoctype"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaNotationDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;notation name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>publicId</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" public=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" system=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>systemId</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaEntityDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_param</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>is_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;entity name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;/entity/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>notationName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;entity name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>publicId</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" public=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" system=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>systemId</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" notation=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;entity name=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>publicId</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" public=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" system=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>systemId</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaLocation</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaStartNamespaceDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;startns"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" prefix=\"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>uri</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">" ns=\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterData</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>metaEndNamespaceDecl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>XmlwfUserData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>fp</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputts</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;endns/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"&lt;endns prefix=\"%s\"/&gt;\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>unknownEncodingConvert</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>codepageConvert</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>unknownEncoding</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>prefixL</name><index>[]</index></name> <init>= <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"windows-"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>prefixU</name><index>[]</index></name> <init>= <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"WINDOWS-"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>prefixU</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>prefixU</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>prefixL</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>digits</name><index>[]</index></name> <init>= <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"0123456789"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>tcschr</name><argument_list>(<argument><expr><name>digits</name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>s</name> <operator>-</operator> <name>digits</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>&gt;=</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>codepageMap</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>unknownEncodingConvert</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>info</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>notStandalone</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>showVersion</name><parameter_list>(<parameter><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>prog</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>prog</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Feature</name> <modifier>*</modifier></type><name>features</name> <init>= <expr><call><name>XML_GetFeatureList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'/'</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <name>ch</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prog</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"%s using %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><call><name>XML_ExpatVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>features</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>features</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>feature</name> <operator>!=</operator> <name>XML_FEATURE_END</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>features</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>features</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"=%ld"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>features</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>feature</name> <operator>!=</operator> <name>XML_FEATURE_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">", %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"=%ld"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>features</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prog</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ftprintf</name><argument_list>(
<argument><expr><name>stderr</name></expr></argument>,




<argument><expr><macro><name>T</name><argument_list>(<argument><literal type="string">"usage: %s [-s] [-n] [-p] [-x] [-e ENCODING] [-w] [-r] [-d DIRECTORY]\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" [-c | -m | -t] [-N]\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" [FILE [FILE ...]]\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"xmlwf - Determines if an XML document is well-formed\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"positional arguments:\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" FILE files to process (default: STDIN)\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"input control arguments:\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -s print an error if the document is not [s]tandalone\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -n enable [n]amespace processing\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -p enable processing external DTDs and [p]arameter entities\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -x enable processing of e[x]ternal entities\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -e ENCODING override any in-document [e]ncoding declaration\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -w enable support for [W]indows code pages\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -r disable memory-mapping and use normal file [r]ead IO calls instead\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"output control arguments:\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -d DIRECTORY output [d]estination directory\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -c write a [c]opy of input XML, not canonical XML\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -m write [m]eta XML, not canonical XML\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -t write no XML output for [t]iming of plain parsing\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -N enable adding doctype and [n]otation declarations\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"info arguments:\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -h show this [h]elp message and exit\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">" -v show program's [v]ersion number and exit\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"\n"</literal></argument>)</argument_list></macro>
<macro><name>T</name><argument_list>(<argument><literal type="string">"libexpat is software libre, licensed under the MIT license.\n"</literal></argument>)</argument_list></macro>
<call><name>T</name><argument_list>(<argument><expr><literal type="string">"Please report bugs at https://github.com/libexpat/libexpat/issues. Thank you!\n"</literal></expr></argument>)</argument_list></call></expr></argument>
,
<argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><name>int</name></type> <name>wmain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>tmain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>outputDir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>processFlags</name> <init>= <expr><name>XML_MAP_FILE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>windowsCodePages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>outputType</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>useNamespaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>requireStandalone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>requiresNotations</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_ParamEntityParsing</name></name></type> <name>paramEntityParsing</name>
<init>= <expr><name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>useStdin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XmlwfUserData</name></type> <name>userData</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_CrtSetDbgFlag</name><argument_list>(<argument><expr><name>_CRTDBG_ALLOC_MEM_DF</name> <operator>|</operator> <name>_CRTDBG_LEAK_CHECK_DF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <call><name>T</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>T</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <call><name>T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>processFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>XML_MAP_FILE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>requireStandalone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>useNamespaces</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'p'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>paramEntityParsing</name> <operator>=</operator> <name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr>;</expr_stmt>

<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'x'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>processFlags</name> <operator>|=</operator> <name>XML_EXTERNAL_ENTITIES</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>windowsCodePages</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'m'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>outputType</name> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>outputType</name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>useNamespaces</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>outputType</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><name>requiresNotations</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>)</argument_list></call></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>==</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>outputDir</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>outputDir</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'e'</literal></expr></argument>)</argument_list></call></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>==</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'h'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call></expr>:</case>
<expr_stmt><expr><call><name>showVersion</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><call><name>T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>useStdin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>processFlags</name> <operator>&amp;=</operator> <operator>~</operator><name>XML_MAP_FILE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>outName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>useNamespaces</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>XML_ParserCreateNS</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>NSSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>parser</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tperror</name><argument_list>(<argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"Could not instantiate parser"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>requireStandalone</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>notStandalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>paramEntityParsing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>outputType</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>outputDir</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>nopStartElement</name></expr></argument>, <argument><expr><name>nopEndElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>nopCharacterData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>nopProcessingInstruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>outputDir</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>delim</name> <init>= <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><ternary><condition><expr><name>useStdin</name></expr> ?</condition><then> <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"STDIN"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>useStdin</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>lastDelim</name> <init>= <expr><call><name>tcsrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>delim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lastDelim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>lastDelim</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>winDelim</name> <init>= <expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"\\"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lastDelim</name> <operator>=</operator> <call><name>tcsrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>winDelim</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lastDelim</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name>lastDelim</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>delim</name> <operator>=</operator> <name>winDelim</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>outName</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><call><name>tcslen</name><argument_list>(<argument><expr><name>outputDir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>tcslen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal><operator>)</operator>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcscpy</name><argument_list>(<argument><expr><name>outName</name></expr></argument>, <argument><expr><name>outputDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcscat</name><argument_list>(<argument><expr><name>outName</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcscat</name><argument_list>(<argument><expr><name>outName</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>userData</name><operator>.</operator><name>fp</name></name> <operator>=</operator> <call><name>tfopen</name><argument_list>(<argument><expr><name>outName</name></expr></argument>, <argument><expr><call><name>T</name><argument_list>(<argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>userData</name><operator>.</operator><name>fp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tperror</name><argument_list>(<argument><expr><name>outName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>userData</name><operator>.</operator><name>fp</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>_IOFBF</name></expr></argument>, <argument><expr><literal type="number">16384</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>puttc</name><argument_list>(<argument><expr><literal type="number">0xFEFF</literal></expr></argument>, <argument><expr><name><name>userData</name><operator>.</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>outputType</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><call><name>XML_UseParserAsHandlerArg</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaStartElement</name></expr></argument>, <argument><expr><name>metaEndElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaProcessingInstruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaComment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCdataSectionHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaStartCdataSection</name></expr></argument>,
<argument><expr><name>metaEndCdataSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaCharacterData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaStartDoctypeDecl</name></expr></argument>,
<argument><expr><name>metaEndDoctypeDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaEntityDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaNotationDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNamespaceDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>metaStartNamespaceDecl</name></expr></argument>,
<argument><expr><name>metaEndNamespaceDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>metaStartDocument</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><call><name>XML_UseParserAsHandlerArg</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>markup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>defaultStartElement</name></expr></argument>, <argument><expr><name>defaultEndElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>defaultCharacterData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>,
<argument><expr><name>defaultProcessingInstruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>useNamespaces</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>startElementNS</name></expr></argument>, <argument><expr><name>endElementNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>startElement</name></expr></argument>, <argument><expr><name>endElement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>characterData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>W3C14N</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>processingInstruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>requiresNotations</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>startDoctypeDecl</name></expr></argument>, <argument><expr><name>endDoctypeDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>notationDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>windowsCodePages</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>unknownEncoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>XML_ProcessFile</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><ternary><condition><expr><name>useStdin</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></argument>, <argument><expr><name>processFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>outputDir</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>outputType</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>metaEndDocument</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>userData</name><operator>.</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tremove</name><argument_list>(<argument><expr><name>outName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>outName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
