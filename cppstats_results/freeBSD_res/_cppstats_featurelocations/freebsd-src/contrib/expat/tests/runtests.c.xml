<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/expat/tests/runtests.c">































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NDEBUG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXPAT_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat_config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1600</literal><operator>)</operator></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>__int64</name></type> <name>intptr_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>__int32</name></type> <name>intptr_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name>unsigned</name> <name>__int64</name></type> <name>uint64_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;=</operator> <literal type="number">1700</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bool</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>false</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>true</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"chardata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structdata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"minicheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"siphash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ascii.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_LARGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_INT_MOD</name></cpp:macro> <cpp:value>"ll"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_INT_MOD</name></cpp:macro> <cpp:value>"l"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_CHAR</name></cpp:macro> <cpp:value>"lc"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_STR</name></cpp:macro> <cpp:value>"ls"</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrlen</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>wcslen(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrcmp</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>wcscmp((s), (t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrncmp</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>t</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>wcsncmp((s), (t), (n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XCS</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_XCS(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XCS</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>L##s</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"No support for UTF-16 character without wchar_t in tests"</cpp:literal></cpp:error>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_CHAR</name></cpp:macro> <cpp:value>"c"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_FMT_STR</name></cpp:macro> <cpp:value>"s"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrlen</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlen(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrcmp</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strcmp((s), (t))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcstrncmp</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>t</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strncmp((s), (t), (n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XCS</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>XML_Parser</name></type> <name>g_parser</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>basic_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>basic_teardown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>_xml_failure</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>err</name> <init>= <expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><literal type="string">" %d: %"</literal> <name>XML_FMT_STR</name> <literal type="string">" (line %"</literal> <name>XML_FMT_INT_MOD</name>
<literal type="string">"u, offset %"</literal> <name>XML_FMT_INT_MOD</name> <literal type="string">"u)\n reported from %s, line %d\n"</literal></expr></argument>,
<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_fail_unless</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Status</name></name></type>
<name>_XML_Parse_SINGLE_BYTES</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>isFinal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>res</name> <init>= <expr><name>XML_STATUS_ERROR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>isFinal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>offset</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>offset</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>innerIsFinal</name> <init>= <expr><operator>(</operator><name>offset</name> <operator>==</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>isFinal</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name> <init>= <expr><name><name>s</name><index>[<expr><name>offset</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>innerIsFinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xml_failure</name><parameter_list>(<parameter><type><name>parser</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_xml_failure((parser), __FILE__, __LINE__)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_expect_failure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>errorCode</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorMessage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>_fail_unless</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>errorMessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>errorCode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>_xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expect_failure</name><parameter_list>(<parameter><type><name>text</name></type></parameter>, <parameter><type><name>errorCode</name></type></parameter>, <parameter><type><name>errorMessage</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_expect_failure((text), (errorCode), (errorMessage), __FILE__, __LINE__)</cpp:value></cpp:define>





<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>dummy_handler_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_START_DOCTYPE_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_END_DOCTYPE_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_ENTITY_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_ATTLIST_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_COMMENT_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_PI_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_START_ELEMENT_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_START_CDATA_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_END_CDATA_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_START_NS_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 12)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_END_NS_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 14)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 15)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_SKIP_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_DEFAULT_HANDLER_FLAG</name></cpp:macro> <cpp:value>(1UL &lt;&lt; 17)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_xdecl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_start_doctype_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>doctypeName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sysid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>pubid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_internal_subset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>doctypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>has_internal_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_START_DOCTYPE_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_end_doctype_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_END_DOCTYPE_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_entity_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>value_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>is_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>value_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_ENTITY_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_notation_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_element_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>model</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>XML_FreeContentModel</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_attlist_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>elname</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>att_type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>dflt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isrequired</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>elname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>att_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>dflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>isrequired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_ATTLIST_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_comment_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_COMMENT_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_pi_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_PI_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_start_element</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_START_ELEMENT_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_end_element</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_start_cdata_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_START_CDATA_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_end_cdata_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_END_CDATA_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_cdata_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_start_namespace_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_START_NS_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_end_namespace_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_END_NS_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_unparsed_entity_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_default_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_start_doctype_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>doctypeName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>sysid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>pubid</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_internal_subset</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>doctypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>pubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>has_internal_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_end_doctype_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>dummy_skip_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>is_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>|=</operator> <name>DUMMY_SKIP_HANDLER_FLAG</name></expr>;</expr_stmt>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <name>ExtOption</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>system_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtOption</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_optioner</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtOption</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><operator>(</operator><name>ExtOption</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>parse_text</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>system_id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>options</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"No suitable option found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTITY_MATCH_FAIL</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTITY_MATCH_NOT_FOUND</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENTITY_MATCH_SUCCESS</name></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entity_name_to_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entity_value_to_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>entity_match_flag</name> <init>= <expr><name>ENTITY_MATCH_NOT_FOUND</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>param_entity_match_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>value_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>is_parameter_entity</name> <operator>||</operator> <name>entity_name_to_match</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name>entity_value_to_match</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>, <argument><expr><name>entity_name_to_match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>value_length</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>xcstrlen</name><argument_list>(<argument><expr><name>entity_value_to_match</name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>xcstrncmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>entity_value_to_match</name></expr></argument>, <argument><expr><name>value_length</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entity_match_flag</name> <operator>=</operator> <name>ENTITY_MATCH_FAIL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>entity_match_flag</name> <operator>=</operator> <name>ENTITY_MATCH_SUCCESS</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></function>





<macro><name>START_TEST</name><argument_list>(<argument>test_nul_byte</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;doc&gt;\0&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser did not report error on NUL-byte."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_u0000_char</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"&lt;doc&gt;&amp;#0;&lt;/doc&gt;"</literal></expr></argument>, <argument><expr><name>XML_ERROR_BAD_CHAR_REF</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report error on NUL-byte."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_siphash_self</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>sip24_valid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"SipHash self-test failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_siphash_spec</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>message</name><index>[]</index></name> <init>= <expr><literal type="string">"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09"</literal>
<literal type="string">"\x0a\x0b\x0c\x0d\x0e"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>expected</name> <init>= <expr><call><name>_SIP_ULL</name><argument_list>(<argument><expr><literal type="number">0xa129ca61U</literal></expr></argument>, <argument><expr><literal type="number">0x49be45e5U</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>siphash</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sipkey</name></name></type> <name>key</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sip_tokey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="string">"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09"</literal>
<literal type="string">"\x0a\x0b\x0c\x0d\x0e\x0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sip24_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>message</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sip24_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"sip24_final failed spec test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>siphash24</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>expected</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"siphash24 failed spec test\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bom_utf8</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"\357\273\277&lt;e/&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bom_utf16_be</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\376\377\0&lt;\0e\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bom_utf16_le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\377\376&lt;\0e\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nobom_utf16_le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">" \0&lt;\0e\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>accumulate_characters</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>accumulate_attribute</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>atts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>storage</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>atts</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_run_character_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>_xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>run_character_check</name><parameter_list>(<parameter><type><name>text</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_run_character_check(text, expected, __FILE__, __LINE__)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_run_attribute_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>_xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>run_attribute_check</name><parameter_list>(<parameter><type><name>text</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_run_attribute_check(text, expected, __FILE__, __LINE__)</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>ExtTest</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtTest</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>ext_accumulate_characters</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtTest</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtTest</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>accumulate_characters</name><argument_list>(<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_run_ext_character_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>ExtTest</name> <modifier>*</modifier></type><name>test_data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier><specifier>const</specifier></type> <name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CharData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>_xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>run_ext_character_check</name><parameter_list>(<parameter><type><name>text</name></type></parameter>, <parameter><type><name>test_data</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_run_ext_character_check(text, test_data, expected, __FILE__, __LINE__)</cpp:value></cpp:define>



<macro><name>START_TEST</name><argument_list>(<argument>test_danish_latin1</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;e&gt;J\xF8rgen \xE6\xF8\xE5\xC6\xD8\xC5&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"J\x00f8rgen \x00e6\x00f8\x00e5\x00c6\x00d8\x00c5"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"J\xC3\xB8rgen \xC3\xA6\xC3\xB8\xC3\xA5\xC3\x86\xC3\x98\xC3\x85"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_french_charref_hexidecimal</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;#xE9;&amp;#xE8;&amp;#xE0;&amp;#xE7;&amp;#xEA;&amp;#xC8;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9\x00e8\x00e0\x00e7\x00ea\x00c8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_french_charref_decimal</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;#233;&amp;#232;&amp;#224;&amp;#231;&amp;#234;&amp;#200;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9\x00e8\x00e0\x00e7\x00ea\x00c8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_french_latin1</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\xE9\xE8\xE0\xE7\xEa\xC8&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9\x00e8\x00e0\x00e7\x00ea\x00c8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xC3\xA9\xC3\xA8\xC3\xA0\xC3\xA7\xC3\xAA\xC3\x88"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_french_utf8</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\xC3\xA9&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xC3\xA9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>






<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf8_false_rejection</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;\xEF\xBA\xBF&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xfebf"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xEF\xBA\xBF"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>






<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_illegal_utf8</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">255</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="string">"&lt;e&gt;%ccd&lt;/e&gt;"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><literal type="string">"expected token error for '%c' (ordinal %d) in UTF-8 text"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_LEAD_1</name></cpp:macro> <cpp:value>"\x7f"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_LEAD_2</name></cpp:macro> <cpp:value>"\xdf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_LEAD_3</name></cpp:macro> <cpp:value>"\xef"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_LEAD_4</name></cpp:macro> <cpp:value>"\xf7"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_FOLLOW</name></cpp:macro> <cpp:value>"\xbf"</cpp:value></cpp:define>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf8_auto_align</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<struct>struct <name>TestCase</name> <block>{
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>expectedMovementInChars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>TestCase</name></name></type> <name><name>cases</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">00</literal></expr>, <expr><literal type="string">""</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">00</literal></expr>, <expr><name>UTF8_LEAD_1</name></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>UTF8_LEAD_2</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">00</literal></expr>, <expr><name>UTF8_LEAD_2</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>UTF8_LEAD_3</name></expr>}</block></expr>,
<expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><name>UTF8_LEAD_3</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">00</literal></expr>, <expr><name>UTF8_LEAD_3</name> <name>UTF8_FOLLOW</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,

<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>UTF8_LEAD_4</name></expr>}</block></expr>,
<expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><name>UTF8_LEAD_4</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,
<expr><block>{<expr><operator>-</operator><literal type="number">3</literal></expr>, <expr><name>UTF8_LEAD_4</name> <name>UTF8_FOLLOW</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">00</literal></expr>, <expr><name>UTF8_LEAD_4</name> <name>UTF8_FOLLOW</name> <name>UTF8_FOLLOW</name> <name>UTF8_FOLLOW</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cases</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cases</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name> <init>= <expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>input</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fromLimInitially</name> <init>= <expr><name>fromLim</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>actualMovementInChars</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>_INTERNAL_trim_to_complete_utf8_characters</name><argument_list>(<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fromLim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>actualMovementInChars</name> <operator>=</operator> <operator>(</operator><name>fromLim</name> <operator>-</operator> <name>fromLimInitially</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>actualMovementInChars</name> <operator>!=</operator> <name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expectedMovementInChars</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[-] UTF-8 case %2u: Expected movement by %2d chars"</literal>
<literal type="string">", actually moved by %2d chars: \""</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expectedMovementInChars</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>actualMovementInChars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>input</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>input</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>success</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"UTF-8 auto-alignment is not bullet-proof\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>





<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name>
<init>= <expr><literal type="string">"\000&lt;\000?\000x\000m\000\154\000 \000v\000e\000r\000s\000i\000o"</literal>
<literal type="string">"\000n\000=\000'\0001\000.\000\060\000'\000 \000e\000n\000c\000o"</literal>
<literal type="string">"\000d\000i\000n\000g\000=\000'\000U\000T\000F\000-\0001\000\066"</literal>
<literal type="string">"\000'\000?\000&gt;\000\n"</literal>
<literal type="string">"\000&lt;\000d\000o\000c\000 \000a\000=\000'\0001\0002\0003\000'\000&gt;"</literal>
<literal type="string">"\000s\000o\000m\000e\000 \xff\x21\000 \000t\000e\000x\000t\000"</literal>
<literal type="string">"&lt;\000/\000d\000o\000c\000&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"some \xff21 text"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"some \357\274\241 text"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_le_epilog_newline</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>first_chunk_bytes</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\xFF\xFE"</literal>
<literal type="string">"&lt;\000e\000/\000&gt;\000"</literal>
<literal type="string">"\r\000\n\000\r\000\n\000"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>first_chunk_bytes</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"bad value of first_chunk_bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>first_chunk_bytes</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name> <operator>+</operator> <name>first_chunk_bytes</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>first_chunk_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_not_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-16'?&gt;"</literal>
<literal type="string">"&lt;doc&gt;Hi&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INCORRECT_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"UTF-16 declared in UTF-8 not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_encoding</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;Hi&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"unknown-encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_SetEncoding failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_latin1_umlauts</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;e a='\xE4 \xF6 \xFC &amp;#228; &amp;#246; &amp;#252; &amp;#x00E4; &amp;#x0F6; &amp;#xFC; &gt;'\n"</literal>
<literal type="string">" &gt;\xE4 \xF6 \xFC &amp;#228; &amp;#246; &amp;#252; &amp;#x00E4; &amp;#x0F6; &amp;#xFC; &gt;&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <macro><name>XCS</name><argument_list>(<argument><literal type="string">"\x00e4 \x00f6 \x00fc "</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"\x00e4 \x00f6 \x00fc "</literal></argument>)</argument_list></macro> <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e4 \x00f6 \x00fc &gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <macro><name>XCS</name><argument_list>(<argument><literal type="string">"\xC3\xA4 \xC3\xB6 \xC3\xBC "</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"\xC3\xA4 \xC3\xB6 \xC3\xBC "</literal></argument>)</argument_list></macro> <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xC3\xA4 \xC3\xB6 \xC3\xBC &gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_attribute_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_attribute_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_long_utf8_character</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>

<literal type="string">"&lt;do\xf0\x90\x80\x80/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"4-byte UTF-8 character in element name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_long_latin1_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;\n"</literal>
<literal type="string">"&lt;doc att='"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>

<literal type="string">"\xe4'&gt;\n&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>=


<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal></argument>)</argument_list></macro>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>run_attribute_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_long_ascii_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;doc att='"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"01234'&gt;\n&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>=


<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"01234"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>run_attribute_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_line_number_after_parse</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;tag&gt;\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"\n&lt;/tag&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>lineno</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lineno</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"expected 4 lines, saw %"</literal> <name>XML_FMT_INT_MOD</name> <literal type="string">"u"</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_column_number_after_parse</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;tag&gt;&lt;/tag&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>colno</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>colno</name> <operator>=</operator> <call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>!=</operator> <literal type="number">11</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"expected 11 columns, saw %"</literal> <name>XML_FMT_INT_MOD</name> <literal type="string">"u"</literal></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_START_TAG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRUCT_END_TAG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>start_element_event_handler2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>StructData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>StructData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>StructData_AddItem</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STRUCT_START_TAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>end_element_event_handler2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>StructData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>StructData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>StructData_AddItem</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STRUCT_END_TAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_line_and_column_numbers_inside_handlers</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;\n"</literal>
<literal type="string">" &lt;b&gt;\r\n"</literal>
<literal type="string">" &lt;c/&gt;\r"</literal>
<literal type="string">" &lt;/b&gt;\n"</literal>
<literal type="string">" &lt;d&gt;\n"</literal>
<literal type="string">" &lt;f/&gt;\n"</literal>
<literal type="string">" &lt;/d&gt;\n"</literal>
<literal type="string">"&lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>StructDataEntry</name></type> <name><name>expected</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>STRUCT_START_TAG</name></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>STRUCT_START_TAG</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>STRUCT_START_TAG</name></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>STRUCT_END_TAG</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>STRUCT_END_TAG</name></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>STRUCT_START_TAG</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><name>STRUCT_START_TAG</name></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"f"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><name>STRUCT_END_TAG</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"d"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><name>STRUCT_END_TAG</name></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><name>STRUCT_END_TAG</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>expected_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>StructDataEntry</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StructData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StructData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_event_handler2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>end_element_event_handler2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>StructData_CheckItems</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name>expected_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>StructData_Dispose</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_line_number_after_error</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;\n"</literal>
<literal type="string">" &lt;b&gt;\n"</literal>
<literal type="string">" &lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>lineno</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Expected a parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lineno</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"expected 3 lines, saw %"</literal> <name>XML_FMT_INT_MOD</name> <literal type="string">"u"</literal></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_column_number_after_error</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;\n"</literal>
<literal type="string">" &lt;b&gt;\n"</literal>
<literal type="string">" &lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>colno</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Expected a parse error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>colno</name> <operator>=</operator> <call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>colno</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"expected 4 columns, saw %"</literal> <name>XML_FMT_INT_MOD</name> <literal type="string">"u"</literal></expr></argument>, <argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_really_long_lines</name></type></decl></parameter>)</parameter_list> <block>{<block_content>





<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;e&gt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_really_long_encoded_lines</name></type></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;"</literal>
<literal type="string">"&lt;e&gt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-+"</literal>
<literal type="string">"&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not allocate parse buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>





<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>start_element_event_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>end_element_event_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_end_element_events</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;d&gt;&lt;f/&gt;&lt;/d&gt;&lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"/c/b/f/d/a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>end_element_event_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>














<specifier>static</specifier> <name>int</name></type>
<name>is_whitespace_normalized</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_cdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>blanks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>at_start</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>blanks</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>at_start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>at_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>blanks</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>is_cdata</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>blanks</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator> <name>is_cdata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>blanks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>blanks</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name>is_cdata</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>testhelper_is_whitespace_normalized</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc def ghi "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\t"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abc\t def"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>check_attr_contains_normalized_whitespace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attrname</name> <init>= <expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name><name>atts</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"attr"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"ents"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"refs"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_whitespace_normalized</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><literal type="string">"attribute value not normalized: %"</literal> <name>XML_FMT_STR</name>
<literal type="string">"='%"</literal> <name>XML_FMT_STR</name> <literal type="string">"'"</literal></expr></argument>,
<argument><expr><name>attrname</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_attr_whitespace_normalization</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ATTLIST doc\n"</literal>
<literal type="string">" attr NMTOKENS #REQUIRED\n"</literal>
<literal type="string">" ents ENTITIES #REQUIRED\n"</literal>
<literal type="string">" refs IDREFS #REQUIRED&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc attr=' a b c\t\td\te\t' refs=' id-1 \t id-2\t\t' \n"</literal>
<literal type="string">" ents=' ent-1 \t\r\n"</literal>
<literal type="string">" ent-2 ' &gt;\n"</literal>
<literal type="string">" &lt;e id='id-1'/&gt;\n"</literal>
<literal type="string">" &lt;e id='id-2'/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>check_attr_contains_normalized_whitespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_xmldecl_misplaced</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"\n"</literal>
<literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;a/&gt;"</literal></expr></argument>,
<argument><expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr></argument>,
<argument><expr><literal type="string">"failed to report misplaced XML declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_xmldecl_invalid</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"&lt;?xml version='1.0' \xc3\xa7?&gt;\n&lt;doc/&gt;"</literal></expr></argument>, <argument><expr><name>XML_ERROR_XML_DECL</name></expr></argument>,
<argument><expr><literal type="string">"Failed to report invalid XML declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_xmldecl_missing_attr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"&lt;?xml ='1.0'?&gt;\n&lt;doc/&gt;\n"</literal></expr></argument>, <argument><expr><name>XML_ERROR_XML_DECL</name></expr></argument>,
<argument><expr><literal type="string">"Failed to report missing XML declaration attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_xmldecl_missing_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii' standalone?&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></argument>,
<argument><expr><name>XML_ERROR_XML_DECL</name></expr></argument>,
<argument><expr><literal type="string">"Failed to report missing attribute value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>UnknownEncodingHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>,
<parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"unsupported-encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_unknown_encoding_internal_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='unsupported-encoding'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE test [&lt;!ENTITY foo 'bar'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;test a='&amp;foo;'/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>UnknownEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name></type>
<name>dummy_release</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>UnrecognisedEncodingHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>,
<parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>dummy_release</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_unrecognised_encoding_internal_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='unsupported-encoding'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE test [&lt;!ENTITY foo 'bar'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;test a='&amp;foo;'/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>UnrecognisedEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unrecognised encoding not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_loader</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtTest</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtTest</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>extparser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extparser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>extparser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_SetEncoding() ignored for external entity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_set_encoding</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name>
<init>= <expr><block>{


<expr><literal type="string">"&lt;?xml encoding='iso-8859-3'?&gt;\xC3\xA9"</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-8"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ext_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_no_handler</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_set_bom</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"\xEF\xBB\xBF"</literal>
<literal type="string">"&lt;?xml encoding='iso-8859-3'?&gt;"</literal>
<literal type="string">"\xC3\xA9"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-8"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa9"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ext_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>


<typedef>typedef <type><struct>struct <name>ext_faults</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fail_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>error</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtFaults</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_faulter</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name> <init>= <expr><operator>(</operator><name>ExtFaults</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fault</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>fault</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_SetEncoding failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>fail_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>fault</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_bad_encoding</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>fault</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;?xml encoding='iso-8859-3'?&gt;u"</literal></expr>, <expr><literal type="string">"Unsupported encoding not faulted"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Bad encoding should not have been accepted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_bad_encoding_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>fault</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><literal type="string">"Unknown encoding not faulted"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"unknown-encoding"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Bad encoding not faulted in external entity handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_undeclared_entity_unread_external_subset</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_undeclared_entity_no_external_subset</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report undefined entity w/out a DTD."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_undeclared_entity_standalone</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii' standalone='yes'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report undefined entity (standalone)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_undeclared_entity_with_external_subset_standalone</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii' standalone='yes'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report undefined entity (external DTD)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_entity_with_external_subset_unless_standalone</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii' standalone='yes'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY entity 'bar'&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report undefined entity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_undeclared_entity_with_external_subset</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ext_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>reject_not_standalone_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_not_standalone_handler_reject</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>reject_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_NOT_STANDALONE</name></expr></argument>,
<argument><expr><literal type="string">"NotStandalone handler failed to reject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>reject_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_NOT_STANDALONE</name></expr></argument>,
<argument><expr><literal type="string">"NotStandalone handler failed to reject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>accept_not_standalone_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_not_standalone_handler_accept</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accept_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ext_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accept_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_wfc_no_recursive_entity_refs</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity '&amp;#38;entity;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report recursive entity reference."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_invalid_parse</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExtFaults</name></type> <name><name>faults</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><literal type="string">"&lt;"</literal></expr>, <expr><literal type="string">"Incomplete element declaration not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;\xe2\x82"</literal></expr>,
<expr><literal type="string">"Incomplete character not faulted"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;tag&gt;\xe2\x82"</literal></expr>, <expr><literal type="string">"Incomplete character in CDATA not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name> <init>= <expr><name>faults</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fault</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report external entity error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_dtd_default_handling</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY e SYSTEM 'http://example.org/e'&gt;\n"</literal>
<literal type="string">"&lt;!NOTATION n SYSTEM 'http://example.org/n'&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc a CDATA #IMPLIED&gt;\n"</literal>
<literal type="string">"&lt;?pi in dtd?&gt;\n"</literal>
<literal type="string">"&lt;!--comment in dtd--&gt;\n"</literal>
<literal type="string">"]&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartCdataSectionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndCdataSectionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n\n\n\n\n\n\n&lt;doc/&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>


<typedef>typedef <type><struct>struct <name>AttTest</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>definition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>element_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attr_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attr_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>default_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_required</name></decl>;</decl_stmt>
}</block></struct></type> <name>AttTest</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>verify_attlist_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>element_name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attr_name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attr_type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>default_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_required</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>AttTest</name> <modifier>*</modifier></type><name>at</name> <init>= <expr><operator>(</operator><name>AttTest</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>element_name</name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>element_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected element name in attribute declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>attr_name</name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>attr_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected attribute name in attribute declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>attr_type</name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>attr_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected attribute type in attribute declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>default_value</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>at</name><operator>-&gt;</operator><name>default_value</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>default_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>at</name><operator>-&gt;</operator><name>default_value</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>default_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>default_value</name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>default_value</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected default value in attribute declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_required</name> <operator>!=</operator> <name><name>at</name><operator>-&gt;</operator><name>is_required</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Requirement mismatch in attribute declaration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_dtd_attr_handling</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prolog</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttTest</name></type> <name><name>attr_data</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><literal type="string">"&lt;!ATTLIST doc a ( one | two | three ) #REQUIRED&gt;\n"</literal>
<literal type="string">"]&gt;"</literal>
<literal type="string">"&lt;doc a='two'/&gt;"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"(one|two|three)"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>NULL</name></expr>, <expr><name>XML_TRUE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;!NOTATION foo SYSTEM 'http://example.org/foo'&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc a NOTATION (foo) #IMPLIED&gt;\n"</literal>
<literal type="string">"]&gt;"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"NOTATION(foo)"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;!ATTLIST doc a NOTATION (foo) 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"NOTATION(foo)"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;!ATTLIST doc a CDATA '\xdb\xb2'&gt;\n"</literal>
<literal type="string">"]&gt;"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr>,
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"CDATA"</literal></expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x06f2"</literal></expr></argument>)</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xdb\xb2"</literal></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>XML_FALSE</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttTest</name> <modifier>*</modifier></type><name>test</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>test</name> <operator>=</operator> <name>attr_data</name></expr>;</init> <condition><expr><name><name>test</name><operator>-&gt;</operator><name>definition</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>test</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>verify_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>prolog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>prolog</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>definition</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<function><type><name>END_TEST</name></type>







<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_empty_ns_without_namespaces</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns:prefix='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns:prefix=''/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_in_attribute_default_without_namespaces</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE e:element [\n"</literal>
<literal type="string">" &lt;!ATTLIST e:element\n"</literal>
<literal type="string">" xmlns:e CDATA 'http://example.org/'&gt;\n"</literal>
<literal type="string">" ]&gt;\n"</literal>
<literal type="string">"&lt;e:element/&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>END_TEST</name>

<specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_character_data_text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;&lt;s&gt;"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"&lt;/s&gt;"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>XML_Bool</name></type> <name>resumable</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>clearing_aborting_character_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>resumable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<macro><name>START_TEST</name><argument_list>(<argument>test_stop_parser_between_char_data_calls</argument>)</argument_list></macro> <block>{<block_content>






<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_character_data_text</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>



<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_suspend_parser_between_char_data_calls</name></type></decl></parameter>)</parameter_list> <block>{<block_content>






<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_character_data_text</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Attempt to continue parse while suspended not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspended parse not faulted with correct error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>END_TEST</name>

<specifier>static</specifier> <name>XML_Bool</name></type> <name>abortable</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parser_stop_character_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>resumable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>resumable</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Aborting aborted parser not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>abortable</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspending suspended parser not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_repeated_stop_parser_between_char_data_calls</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_character_data_text</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>parser_stop_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>abortable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to double-stop parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>parser_stop_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>abortable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to double-suspend parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>parser_stop_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>abortable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to suspend-abort parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_good_cdata_ascii</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;&lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;greeting&gt;Hello, world!&lt;/greeting&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetStartCdataSectionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndCdataSectionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_good_cdata_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name>
<init>= <expr><literal type="string">"\0&lt;\0?\0x\0m\0l\0"</literal>
<literal type="string">" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"</literal>
<literal type="string">" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"</literal>
<literal type="string">"1\0"</literal>
<literal type="string">"6\0'"</literal>
<literal type="string">"\0?\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0a\0&gt;\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0h\0e\0l\0l\0o\0]\0]\0&gt;\0&lt;\0/\0a\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_good_cdata_utf16_le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;\0?\0x\0m\0l\0"</literal>
<literal type="string">" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"</literal>
<literal type="string">" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"</literal>
<literal type="string">"1\0"</literal>
<literal type="string">"6\0'"</literal>
<literal type="string">"\0?\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0a\0&gt;\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0h\0e\0l\0l\0o\0]\0]\0&gt;\0&lt;\0/\0a\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>A_TO_P_IN_UTF16</name></cpp:macro> <cpp:value>"\0A\0B\0C\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0N\0O\0P"</cpp:value></cpp:define>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_long_cdata_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>






<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name>
<init>= <expr><literal type="string">"\0&lt;\0?\0x\0m\0l\0 "</literal>
<literal type="string">"\0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0 "</literal>
<literal type="string">"\0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0\x31\0\x36\0'\0?\0&gt;"</literal>
<literal type="string">"\0&lt;\0a\0&gt;\0&lt;\0!\0[\0C\0D\0A\0T\0A\0["</literal>


<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name> <name>A_TO_P_IN_UTF16</name>
<name>A_TO_P_IN_UTF16</name>

<literal type="string">"\0]\0]\0&gt;\0&lt;\0/\0a\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>=

<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"ABCDEFGHIJKLMNOP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not allocate parse buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_multichar_cdata_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>











<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\0&lt;\0?\0x\0m\0l\0"</literal>
<literal type="string">" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"</literal>
<literal type="string">" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"</literal>
<literal type="string">"1\0"</literal>
<literal type="string">"6\0'"</literal>
<literal type="string">"\0?\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0a\0&gt;\0&lt;\0!\0[\0C\0D\0A\0T\0A\0["</literal>
<literal type="string">"\xd8\x34\xdd\x5e\xd8\x34\xdd\x5f"</literal>
<literal type="string">"\0]\0]\0&gt;\0&lt;\0/\0a\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xd834\xdd5e\xd834\xdd5f"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xf0\x9d\x85\x9e\xf0\x9d\x85\x9f"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_bad_surrogate_pair</name></type></decl></parameter>)</parameter_list> <block>{<block_content>








<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\0&lt;\0?\0x\0m\0l\0"</literal>
<literal type="string">" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"</literal>
<literal type="string">" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"</literal>
<literal type="string">"1\0"</literal>
<literal type="string">"6\0'"</literal>
<literal type="string">"\0?\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0a\0&gt;\0&lt;\0!\0[\0C\0D\0A\0T\0A\0["</literal>
<literal type="string">"\xdc\x00\xd8\x00"</literal>
<literal type="string">"\0]\0]\0&gt;\0&lt;\0/\0a\0&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Reversed UTF-16 surrogate pair not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_cdata</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<struct>struct <name>CaseData</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>expectedError</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>CaseData</name></name></type> <name><name>cases</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;!"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;!["</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![C"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CD"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDA"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDAT"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA["</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA[]"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA[]]"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;!&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![C&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CD&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDA&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDAT&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA[&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA[]&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;a&gt;&lt;![CDATA[]]&lt;a/&gt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cases</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>CaseData</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Status</name></name></type> <name>actualStatus</name> <init>= <expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(
<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>actualError</name> <init>= <expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>actualStatus</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>actualError</name> <operator>!=</operator> <name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expectedError</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
<argument><expr><literal type="string">"Expected error %d but got error %d for case %u: \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expectedError</name></expr></argument>, <argument><expr><name>actualError</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_cdata_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<struct>struct <name>CaseData</name> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>text_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>expected_error</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>prolog</name><index>[]</index></name> <init>= <expr><literal type="string">"\0&lt;\0?\0x\0m\0l\0"</literal>
<literal type="string">" \0v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0"</literal>
<literal type="string">" \0e\0n\0c\0o\0d\0i\0n\0g\0=\0'\0u\0t\0f\0-\0"</literal>
<literal type="string">"1\0"</literal>
<literal type="string">"6\0'"</literal>
<literal type="string">"\0?\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0a\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>CaseData</name></name></type> <name><name>cases</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="string">"\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="string">"\0&lt;"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="string">"\0&lt;\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="string">"\0&lt;\0!"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0["</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">13</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">17</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">18</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0["</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">19</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">20</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0Z"</literal></expr>, <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">21</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0Z\xd8"</literal></expr>,
<expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">22</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0Z\xd8\x34"</literal></expr>, <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">23</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0Z\xd8\x34\xdd"</literal></expr>,
<expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">24</literal></expr>, <expr><literal type="string">"\0&lt;\0!\0[\0C\0D\0A\0T\0A\0[\0Z\xd8\x34\xdd\x5e"</literal></expr>,
<expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>cases</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>CaseData</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>actual_status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>actual_error</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>prolog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>prolog</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>actual_status</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>text</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>text_bytes</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>actual_status</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>actual_error</name> <operator>=</operator> <call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>actual_error</name> <operator>!=</operator> <name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected_error</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>,
<argument><expr><literal type="string">"Expected error %d (%"</literal> <name>XML_FMT_STR</name> <literal type="string">"), got %d (%"</literal> <name>XML_FMT_STR</name>
<literal type="string">") for case %lu\n"</literal></expr></argument>,
<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected_error</name></expr></argument>, <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><name><name>cases</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected_error</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>actual_error</name></expr></argument>, <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><name>actual_error</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>unsigned</name><operator>)</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<decl_stmt><decl><type><name>END_TEST</name>

<specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_cdata_text</name>
<init>= <expr><literal type="string">"&lt;s&gt;&lt;![CDATA["</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"012345678901234567890123456789012345678901234567890123456789"</literal>
<literal type="string">"]]&gt;&lt;/s&gt;"</literal></expr></init></decl>;</decl_stmt>


<macro><name>START_TEST</name><argument_list>(<argument>test_stop_parser_between_cdata_calls</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_cdata_text</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_ABORTED</name></expr></argument>, <argument><expr><literal type="string">"Parse not aborted in CDATA handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_suspend_parser_between_cdata_calls</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_cdata_text</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse not suspended in CDATA handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_memory_allocation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>XML_MemMalloc</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"TEST"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Memory not writable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>XML_MemRealloc</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Reallocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'V'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"VEST"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Reallocated memory not writable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>XML_MemFree</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_default_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"D"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_cdata_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_DefaultCurrent</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_cdata_nodefault_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_skip_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>is_parameter_entity</name></expr> ?</condition><then> <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"E"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"e"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_default_current</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;hell]&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>entity_text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY entity '&amp;#37;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DCDCDCDCDCDD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_nodefault_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DcccccD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DDDDDDDDDDDDDDDDDDD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetSkippedEntityHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_skip_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DDDDDDDDDDDDDDDDDeD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandlerExpand</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DDDDDDDDDDDDDDDDDCDD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandlerExpand</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_cdata_nodefault_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"DDDDDDDDDDDDDDDDDcD"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_dtd_elements</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc (chapter)&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT chapter (#PCDATA)&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;chapter&gt;Wombats are go&lt;/chapter&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_set_foreign_dtd</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0x12345678</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not set foreign DTD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to reject late foreign DTD setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0x23456789</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to reject late hash salt change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_foreign_dtd_not_standalone</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>reject_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not set foreign DTD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_NOT_STANDALONE</name></expr></argument>,
<argument><expr><literal type="string">"NotStandalonehandler failed to reject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_foreign_dtd</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"$"</literal></expr>, <expr><literal type="string">"Dollar not faulted"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Bad DTD should not have been accepted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_foreign_dtd_with_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc [&lt;!ENTITY entity 'hello world'&gt;]&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0x12345678</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not set foreign DTD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to reject late foreign DTD setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0x23456789</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to reject late hash salt change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_null_loader</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_foreign_dtd_without_external_subset</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [&lt;!ENTITY foo 'bar'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;foo;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_null_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_empty_foreign_dtd</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_null_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Undefined entity not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_set_base</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>old_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>new_base</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"/local/file/name.xml"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>old_base</name> <operator>=</operator> <call><name>XML_GetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_SetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>new_base</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unable to set base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><call><name>XML_GetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_base</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Base setting not correct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_SetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unable to NULL base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Base setting not nulled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>old_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>


<typedef>typedef <type><struct>struct <name>attrInfo</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>AttrInfo</name>;</typedef>

<typedef>typedef <type><struct>struct <name>elementInfo</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>attr_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>id_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttrInfo</name> <modifier>*</modifier></type><name>attributes</name></decl>;</decl_stmt>
}</block></struct></type> <name>ElementInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>counting_start_element_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ElementInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>ElementInfo</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttrInfo</name> <modifier>*</modifier></type><name>attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>id</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>info</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element not recognised"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>XML_GetSpecifiedAttributeCount</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>attr_count</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>!=</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Not got expected attribute count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>XML_GetIdAttributeIndex</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>info</name><operator>-&gt;</operator><name>id_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"ID not present"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>atts</name><index>[<expr><name>id</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>id_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"ID does not have the correct name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info</name><operator>-&gt;</operator><name>attr_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>attributes</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>attr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Attribute not recognised"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>atts</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Attribute has wrong value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>atts</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_attributes</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc (tag)&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc id ID #REQUIRED&gt;\n"</literal>
<literal type="string">"]&gt;"</literal>
<literal type="string">"&lt;doc a='1' id='one' b='2'&gt;"</literal>
<literal type="string">"&lt;tag c='3'/&gt;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttrInfo</name></type> <name><name>doc_info</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>XCS</name><argument_list>(<argument><literal type="string">"1"</literal></argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"b"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>XCS</name><argument_list>(<argument><literal type="string">"2"</literal></argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>XCS</name><argument_list>(<argument><literal type="string">"one"</literal></argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttrInfo</name></type> <name><name>tag_info</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"c"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>XCS</name><argument_list>(<argument><literal type="string">"3"</literal></argument>)</argument_list></macro>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ElementInfo</name></type> <name><name>info</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">3</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"tag"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>attributes</name> <operator>=</operator> <name>doc_info</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>attributes</name> <operator>=</operator> <name>tag_info</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>counting_start_element_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_reset_in_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY wombat 'wom'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY entity 'hi &amp;wom; there'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing status not SUSPENDED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing status doesn't reset to INITIALIZED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_resume_invalid_parse</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;Hello&lt;/doc"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Resumed invalid parse not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_UNCLOSED_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid parse not correctly faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_resume_resuspended</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;Hello&lt;meep/&gt;world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Resumption not suspended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_cdata_default</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;![CDATA[Hello\nworld]]&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;doc&gt;&lt;![CDATA[Hello\nworld]]&gt;&lt;/doc&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_resetter</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_INITIALIZED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing status is not INITIALIZED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing status is not FINISHED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing when finished not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing when finished faulted with wrong code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing status not still FINISHED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_subordinate_reset</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_resetter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>



<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>entity_suspending_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>model</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Attempting to suspend a subordinate parser not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SUSPEND_PE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspending subordinate parser get wrong code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_FreeContentModel</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_suspender</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>entity_suspending_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_subordinate_suspend</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_suspender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>



<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>entity_suspending_xdecl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name> <init>= <expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>resumable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_suspend_xmldecl</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>rc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>entity_suspending_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>resumable</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Ext Parsing status not SUSPENDED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Ext parsing not aborted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Ext Parsing status not FINISHED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_subordinate_xdecl_suspend</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_suspend_xmldecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_subordinate_xdecl_abort</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_suspend_xmldecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_suspending_faulter</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name> <init>= <expr><operator>(</operator><name>ExtFaults</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>entity_suspending_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not allocate parse buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>parse_len</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML declaration did not suspend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>fail_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>fault</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_invalid_suspended_parse</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name><name>faults</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;&lt;"</literal></expr>,
<expr><literal type="string">"Incomplete element declaration not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{
<expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\xe2\x82"</literal></expr>,
<expr><literal type="string">"Incomplete character not faulted"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>fault</name> <operator>=</operator> <operator>&amp;</operator><name><name>faults</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fault</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>external_entity_suspending_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Parser did not report external entity error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_explicit_encoding</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;doc&gt;Hello "</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">" World&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to initialise encoding to NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-8"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to set explicit encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"us-ascii"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Allowed encoding change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to unset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>cr_cdata_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pfound</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pfound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_trailing_cr</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;\r"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found_cr</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>cr_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_cr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to fault unclosed doc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_cr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Did not catch the carriage return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>cr_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_cr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to fault unclosed doc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_cr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Did not catch default carriage return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_cr_catcher</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"\r"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>cr_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_bad_cr_catcher</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;tag&gt;\r"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>cr_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Async entity error not caught"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ASYNC_ENTITY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_trailing_cr</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found_cr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_cr_catcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_cr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_cr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"No carriage return found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_bad_cr_catcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_cr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_cr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"No carriage return found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>rsqb_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pfound</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <call><name>XCS</name><argument_list>(<argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pfound</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_trailing_rsqb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text8</name> <init>= <expr><literal type="string">"&lt;doc&gt;]"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text16</name><index>[]</index></name> <init>= <expr><literal type="string">"\xFF\xFE&lt;\000d\000o\000c\000&gt;\000]\000"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found_rsqb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>text8_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text8</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>rsqb_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_rsqb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text8</name></expr></argument>, <argument><expr><name>text8_len</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to fault unclosed doc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_rsqb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Did not catch the right square bracket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>rsqb_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_rsqb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text16</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text16</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to fault unclosed doc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_rsqb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Did not catch the right square bracket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>rsqb_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_rsqb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text16</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text16</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to fault unclosed doc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_rsqb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Did not catch the right square bracket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_rsqb_catcher</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;tag&gt;]"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>rsqb_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Async entity error not caught"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ASYNC_ENTITY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_trailing_rsqb</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found_rsqb</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_rsqb_catcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_rsqb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>found_rsqb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"No right square bracket found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_good_cdata_ascii</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a&gt;&lt;![CDATA[&lt;greeting&gt;Hello, world!&lt;/greeting&gt;]]&gt;&lt;/a&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;greeting&gt;Hello, world!&lt;/greeting&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_good_cdata</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_good_cdata_ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<decl_stmt><decl><type><name>END_TEST</name>



<specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>handler_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>comment_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>skip_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>xdecl_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>xml_decl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>userData</name> <operator>!=</operator> <name>handler_data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"User data (xml decl) not correctly set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>standalone</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Standalone not flagged as not present in XML decl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>xdecl_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>param_check_skip_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>entityName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>is_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>userData</name> <operator>!=</operator> <name>handler_data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"User data (skip) not correctly set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>skip_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>data_check_comment_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>userData</name> <operator>!=</operator> <name>handler_data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"User data (parser) not correctly set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"User data in parser not correctly set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>comment_count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_param_checker</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!-- Subordinate parser --&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>handler_data</name> <operator>=</operator> <name>ext_parser</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>handler_data</name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_user_parameters</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!-- Primary parse --&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>epilog</name> <init>= <expr><literal type="string">"&lt;!-- Back to primary parser --&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>comment_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>skip_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>xdecl_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>xml_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_param_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>data_check_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetSkippedEntityHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>param_check_skip_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_UseParserAsHandlerArg</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handler_data</name> <operator>=</operator> <name>g_parser</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>comment_count</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Comment handler not invoked enough times"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Changed param entity parsing policy while parsing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>epilog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>epilog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>comment_count</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Comment handler not invoked enough times"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>skip_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Skip handler not invoked enough times"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xdecl_count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML declaration handler not invoked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>










<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_ref_param_checker</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parameter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>parameter</name> <operator>!=</operator> <name>handler_data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"External entity ref handler parameter not correct"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_ref_parameter</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_ref_param_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandlerArg</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handler_data</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>text</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_ref_param_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandlerArg</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handler_data</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>g_parser</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_empty_parse</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>partial</name> <init>= <expr><literal type="string">"&lt;doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing empty string faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing final empty string not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NO_ELEMENTS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing final empty string faulted for wrong reason"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing final empty string faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>partial</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing final incomplete empty string not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name><name>enum</name> <name>XML_Status</name></name></type>
<name>get_feature</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>XML_FeatureEnum</name></name></type> <name>feature_id</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>presult</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Feature</name> <modifier>*</modifier></type><name>feature</name> <init>= <expr><call><name>XML_GetFeatureList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>feature</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>feature</name><operator>-&gt;</operator><name>feature</name></name> <operator>!=</operator> <name>XML_FEATURE_END</name></expr>;</condition> <incr><expr><name>feature</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>feature</name><operator>-&gt;</operator><name>feature</name></name> <operator>==</operator> <name>feature_id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>presult</name> <operator>=</operator> <name><name>feature</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_buffer_test_text</name>
<init>= <expr><literal type="string">"&lt;documentwitharidiculouslylongelementnametotease"</literal>
<literal type="string">"aparticularcorneroftheallocationinXML_GetBuffers"</literal>
<literal type="string">"othatwecanimprovethecoverageyetagain012345678901"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789abcdef0"</literal>
<literal type="string">"123456789abcdef0123456789abcdef0123456789&gt;\n&lt;ef0"</literal></expr></init></decl>;</decl_stmt>


<macro><name>START_TEST</name><argument_list>(<argument>test_get_buffer_1</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>get_buffer_test_text</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>context_bytes</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">12</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Negative length buffer not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">1536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"1.5K buffer failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"INT_MAX buffer not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>











<if_stmt><if>if <condition>(<expr><call><name>get_feature</name><argument_list>(<argument><expr><name>XML_FEATURE_CONTEXT_BYTES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context_bytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>context_bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>-</operator> <operator>(</operator><name>context_bytes</name> <operator>+</operator> <literal type="number">1025</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"INT_MAX- buffer not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"1000 buffer failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_get_buffer_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>get_buffer_test_text</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>


<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">1536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"1.5K buffer failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"1024 buffer failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_byte_info_at_end</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal>
<operator>||</operator> <call><name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Byte index/count incorrect at start of parse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Terminal byte count incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>XML_Index</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Terminal byte index incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRE_ERROR_STR</name></cpp:macro> <cpp:value>"&lt;doc&gt;&lt;/"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POST_ERROR_STR</name></cpp:macro> <cpp:value>"wombat&gt;&lt;/doc&gt;"</cpp:value></cpp:define>
<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_byte_info_at_error</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>PRE_ERROR_STR</name> <name>POST_ERROR_STR</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Syntax error not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Error byte count incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PRE_ERROR_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Error byte index incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PRE_ERROR_STR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>POST_ERROR_STR</name></cpp:undef>


<typedef>typedef <type><struct>struct <name>ByteTestData</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>start_element_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cdata_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>total_string_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>ByteTestData</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>byte_character_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ByteTestData</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ByteTestData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetInputContext</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to get context buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name><name>data</name><operator>-&gt;</operator><name>start_element_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Context offset in unexpected position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>data</name><operator>-&gt;</operator><name>cdata_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"CDATA length reported incorrectly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name><name>data</name><operator>-&gt;</operator><name>total_string_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Context size is not full buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Character byte index incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Character byte count incorrect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>START_ELEMENT</name></cpp:macro> <cpp:value>"&lt;e&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CDATA_TEXT</name></cpp:macro> <cpp:value>"Hello"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_ELEMENT</name></cpp:macro> <cpp:value>"&lt;/e&gt;"</cpp:value></cpp:define>
<macro><name>START_TEST</name><argument_list>(<argument>test_byte_info_at_cdata</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>START_ELEMENT</name> <name>CDATA_TEXT</name> <name>END_ELEMENT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ByteTestData</name></type> <name>data</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_GetInputContext</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected context at start of parse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>start_element_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>START_ELEMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>cdata_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>CDATA_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>total_string_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>byte_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>START_ELEMENT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CDATA_TEXT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>END_ELEMENT</name></cpp:undef>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_predefined_entities</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&amp;lt;&amp;gt;&amp;amp;&amp;quot;&amp;apos;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;doc&gt;&amp;lt;&amp;gt;&amp;amp;&amp;quot;&amp;apos;&lt;/doc&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;&gt;&amp;\"'"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>









<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_param</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 SYSTEM '004-2.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e2 '%e1;'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;!ELEMENT el EMPTY&gt;\n"</literal>
<literal type="string">"&lt;el/&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-1.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Inner DTD with invalid tag not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-2.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid tag in external param not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unknown system ID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_invalid_tag_in_dtd</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM '004-1.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid tag IN DTD external param not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_not_predefined_entities</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>text</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"&lt;doc&gt;&amp;pt;&lt;/doc&gt;"</literal></expr>, <expr><literal type="string">"&lt;doc&gt;&amp;amo;&lt;/doc&gt;"</literal></expr>,
<expr><literal type="string">"&lt;doc&gt;&amp;quid;&lt;/doc&gt;"</literal></expr>, <expr><literal type="string">"&lt;doc&gt;&amp;apod;&lt;/doc&gt;"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr></argument>,
<argument><expr><literal type="string">"Undefined entity not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_load_ignore</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;![IGNORE[&lt;!ELEMENT e (#PCDATA)*&gt;]]&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ignore_section</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;e&gt;&amp;entity;&lt;/e&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;![IGNORE[&lt;!ELEMENT e (#PCDATA)*&gt;]]&gt;\n&amp;entity;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_load_ignore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_load_ignore_utf16</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0!\0[\0I\0G\0N\0O\0R\0E\0[\0"</literal>
<literal type="string">"&lt;\0!\0E\0L\0E\0M\0E\0N\0T\0 \0e\0 \0"</literal>
<literal type="string">"(\0#\0P\0C\0D\0A\0T\0A\0)\0*\0&gt;\0]\0]\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ignore_section_utf16</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0 "</literal>
<literal type="string">"\0S\0Y\0S\0T\0E\0M\0 \0'\0s\0'\0&gt;\0\n\0"</literal>

<literal type="string">"&lt;\0d\0&gt;\0&lt;\0e\0&gt;\0&amp;\0e\0n\0;\0&lt;\0/\0e\0&gt;\0&lt;\0/\0d\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;![IGNORE[&lt;!ELEMENT e (#PCDATA)*&gt;]]&gt;\n&amp;en;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_load_ignore_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_load_ignore_utf16_be</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0!\0[\0I\0G\0N\0O\0R\0E\0["</literal>
<literal type="string">"\0&lt;\0!\0E\0L\0E\0M\0E\0N\0T\0 \0e\0 "</literal>
<literal type="string">"\0(\0#\0P\0C\0D\0A\0T\0A\0)\0*\0&gt;\0]\0]\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ignore_section_utf16_be</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0 "</literal>
<literal type="string">"\0S\0Y\0S\0T\0E\0M\0 \0'\0s\0'\0&gt;\0\n"</literal>

<literal type="string">"\0&lt;\0d\0&gt;\0&lt;\0e\0&gt;\0&amp;\0e\0n\0;\0&lt;\0/\0e\0&gt;\0&lt;\0/\0d\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;![IGNORE[&lt;!ELEMENT e (#PCDATA)*&gt;]]&gt;\n&amp;en;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>external_entity_load_ignore_utf16_be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_ignore_section</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;e&gt;&amp;entity;&lt;/e&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name><name>faults</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><literal type="string">"&lt;![IGNORE[&lt;!ELEM"</literal></expr>, <expr><literal type="string">"Broken-off declaration not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_SYNTAX</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;![IGNORE[\x01]]&gt;"</literal></expr>, <expr><literal type="string">"Invalid XML character not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{
<expr><literal type="string">"&lt;![IGNORE[\xe2\x82"</literal></expr>, <expr><literal type="string">"Partial XML character not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>fault</name> <operator>=</operator> <operator>&amp;</operator><name><name>faults</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fault</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete IGNORE section not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_valuer</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 SYSTEM '004-2.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e2 '%e1;'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-1.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-2.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExtFaults</name> <modifier>*</modifier></type><name>fault</name> <init>= <expr><operator>(</operator><name>ExtFaults</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>error</name></decl>;</decl_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fault</name><operator>-&gt;</operator><name>error</name></name> <operator>==</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name><name>fault</name><operator>-&gt;</operator><name>fail_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name><name>fault</name><operator>-&gt;</operator><name>error</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>fault</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <name>XML_ERROR_XML_DECL</name>
<operator>||</operator> <name>error</name> <operator>!=</operator> <name>XML_ERROR_TEXT_DECL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_external_entity_values</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM '004-1.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name><name>data_004_2</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"&lt;!ATTLIST doc a1 CDATA 'value'&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;!ATTLIST $doc a1 CDATA 'value'&gt;"</literal></expr>, <expr><literal type="string">"Invalid token not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"'wombat"</literal></expr>, <expr><literal type="string">"Unterminated string not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"\xe2\x82"</literal></expr>, <expr><literal type="string">"Partial UTF-8 character not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;?xml?&gt;"</literal></expr>, <expr><literal type="string">"Malformed XML declaration not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_XML_DECL</name></expr>}</block></expr>,
<expr><block>{
<expr><literal type="string">"\xEF\xBB\xBF&lt;!ATTLIST doc a1 CDATA 'value'&gt;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_NONE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n$"</literal></expr>,
<expr><literal type="string">"Invalid token after text declaration not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n'wombat"</literal></expr>,
<expr><literal type="string">"Unterminated string after text decl not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n\xe2\x82"</literal></expr>,
<expr><literal type="string">"Partial UTF-8 character after text decl not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"%e1;"</literal></expr>, <expr><literal type="string">"Recursive parameter entity not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NONE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>data_004_2</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parse_text</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_valuer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data_004_2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_not_standalone</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;!ATTLIST doc a1 CDATA 'value'&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>reject_not_standalone_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Expected not standalone rejection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NOT_STANDALONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_SetNotStandaloneHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_not_standalone</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_not_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Standalone rejection not caught"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_value_aborter</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 SYSTEM '004-2.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e2 '%e1;'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-1.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"004-2.ent"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>entity_suspending_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Aborted parse not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_value_abort</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM '004-1.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_value_aborter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_public_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc PUBLIC '{BadName}' 'test'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>,
<argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_PUBLICID</name></expr></argument>, <argument><expr><literal type="string">"Bad Public ID not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_attribute_enum_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' standalone='no'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE animal SYSTEM 'test.dtd'&gt;\n"</literal>
<literal type="string">"&lt;animal&gt;This is a \n &lt;a/&gt; \n\nyellow tiger&lt;/animal&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>dtd_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT animal (#PCDATA|a)*&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT a EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST animal xml:space (default|preserve) 'preserve'&gt;"</literal></expr>,
<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"This is a \n \n\nyellow tiger"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ext_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd_data</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>






<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_predefined_entity_redefinition</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY apos 'foo'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;apos;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_dtd_stop_processing</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"%foo;\n"</literal>
<literal type="string">"&lt;!ENTITY bar 'bas'&gt;\n"</literal>
<literal type="string">"]&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"DTD processing still going after undefined PE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_public_notation_no_sysid</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!NOTATION note PUBLIC 'foo'&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"]&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Notation declaration handler not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_element_start_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>xcstrlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_nested_groups</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc "</literal>

<literal type="string">"(e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,"</literal>
<literal type="string">"(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?"</literal>
<literal type="string">"))))))))))))))))))))))))))))))))&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;e/&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doce"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler not fired"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_group_choice</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc (a|b|c)+&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT a EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT b (#PCDATA)&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT c ANY&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\n"</literal>
<literal type="string">"&lt;a/&gt;\n"</literal>
<literal type="string">"&lt;b attr='foo'&gt;This is a foo&lt;/b&gt;\n"</literal>
<literal type="string">"&lt;c&gt;&lt;/c&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler flag not raised"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_public</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name> <init>= <expr><literal type="string">"&lt;!ATTLIST doc a CDATA 'value'&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_res</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"http://example.org/"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>text</name> <operator>=</operator> <name>text1</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>publicId</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>text</name> <operator>=</operator> <name>text2</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected parameters to external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>text</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parse_res</name>
<operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>parse_res</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_standalone_parameter_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' standalone='yes'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/' [\n"</literal>
<literal type="string">"&lt;!ENTITY % entity '&lt;!ELEMENT doc (#PCDATA)&gt;'&gt;\n"</literal>
<literal type="string">"%entity;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_data</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;!ENTITY % e1 'foo'&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_public</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>



<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_skipped_parameter_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE root SYSTEM 'http://example.org/dtd.ent' [\n"</literal>
<literal type="string">"&lt;!ELEMENT root (#PCDATA|a)* &gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;root&gt;&lt;/root&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>dtd_data</name> <init>= <expr><block>{<expr><literal type="string">"%pe2;"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetSkippedEntityHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_skip_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_SKIP_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Skip handler not executed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_recursive_external_parameter_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE root SYSTEM 'http://example.org/dtd.ent' [\n"</literal>
<literal type="string">"&lt;!ELEMENT root (#PCDATA|a)* &gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;root&gt;&lt;/root&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>dtd_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY % pe2 '&amp;#37;pe2;'&gt;\n%pe2;"</literal></expr>,
<expr><literal type="string">"Recursive external parameter entity not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtd_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Recursive external parameter not spotted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_devaluer</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>clear_handler</name> <init>= <expr><operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>systemId</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unexpected system ID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could note create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>clear_handler</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_undefined_ext_entity_in_external_dtd</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_devaluer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_devaluer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>aborting_xdecl_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>version</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>standalone</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>resumable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_suspend_xdecl</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>long_character_data_text</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>aborting_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Attempt to parse while suspended not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspended parse not faulted with correct error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>selective_aborting_default_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><call><name>xcstrlen</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>xcstrncmp</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>resumable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_abort_epilog</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n\r\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>match</name><index>[]</index></name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>selective_aborting_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Abort not triggered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_ABORTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_abort_epilog_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>match</name><index>[]</index></name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>selective_aborting_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_ABORTED</name></expr></argument>, <argument><expr><literal type="string">"Abort not triggered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_suspend_epilog</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>match</name><index>[]</index></name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>selective_aborting_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>suspending_end_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_suspend_in_sole_empty_tag</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>rc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>suspending_end_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspend not triggered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Resume failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unfinished_epilog</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;&lt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete epilog entry not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_partial_char_in_epilog</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\xe2\x82"</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Partial character in epilog not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_PARTIAL_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_hash_collision</name></type></decl></parameter>)</parameter_list> <block>{<block_content>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLLIDING_HASH_SALT</name></cpp:macro> <cpp:value>(unsigned long)_SIP_ULL(0xffffffffU, 0xff99fc90U)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;doc&gt;\n"</literal>
<literal type="string">"&lt;a1/&gt;&lt;a2/&gt;&lt;a3/&gt;&lt;a4/&gt;&lt;a5/&gt;&lt;a6/&gt;&lt;a7/&gt;&lt;a8/&gt;\n"</literal>
<literal type="string">"&lt;b1&gt;&lt;/b1&gt;&lt;b2 attr='foo'&gt;This is a foo&lt;/b2&gt;&lt;b3&gt;&lt;/b3&gt;&lt;b4&gt;&lt;/b4&gt;\n"</literal>
<literal type="string">"&lt;b5&gt;&lt;/b5&gt;&lt;b6&gt;&lt;/b6&gt;&lt;b7&gt;&lt;/b7&gt;&lt;b8&gt;&lt;/b8&gt;\n"</literal>
<literal type="string">"&lt;c1/&gt;&lt;c2/&gt;&lt;c3/&gt;&lt;c4/&gt;&lt;c5/&gt;&lt;c6/&gt;&lt;c7/&gt;&lt;c8/&gt;\n"</literal>
<literal type="string">"&lt;d1/&gt;&lt;d2/&gt;&lt;d3/&gt;&lt;d4/&gt;&lt;d5/&gt;&lt;d6/&gt;&lt;d7/&gt;\n"</literal>
<literal type="string">"&lt;d8&gt;This triggers the table growth and collides with b2&lt;/d8&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>COLLIDING_HASH_SALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COLLIDING_HASH_SALT</name></cpp:undef>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>start_element_suspender</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"suspend"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abort"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_suspend_resume_internal_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY foo '&lt;suspend&gt;Hi&lt;suspend&gt;Ho&lt;/suspend&gt;&lt;/suspend&gt;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;foo;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected1</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hi"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected2</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"HiHo"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_suspender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_resume_entity_with_syntax_error</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY foo '&lt;suspend&gt;Hi&lt;/wombat&gt;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;foo;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_suspender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Syntax error in entity not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_TAG_MISMATCH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>element_decl_suspender</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>model</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_FreeContentModel</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_suspend_resume_parameter_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY % foo '&lt;!ELEMENT doc (#PCDATA)*&gt;'&gt;\n"</literal>
<literal type="string">"%foo;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hello, world"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>element_decl_suspender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_restart_on_error</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;$doc&gt;&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid tag name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Restarting invalid parse not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_reject_lt_in_attribute_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [&lt;!ATTLIST doc a CDATA '&lt;bar&gt;'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Bad attribute default not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_reject_unfinished_param_in_att_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [&lt;!ATTLIST doc a CDATA '&amp;foo'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Bad attribute default not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_trailing_cr_in_att_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc a='value\r'/&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_standalone_internal_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' standalone='yes' ?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ELEMENT doc (#PCDATA)&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY % pe '&lt;!ATTLIST doc att2 CDATA \"&amp;ge;\"&gt;'&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY ge 'AttDefaultValue'&gt;\n"</literal>
<literal type="string">" %pe;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc att2='any'/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_skipped_external_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name> <init>= <expr><block>{<expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e2 '%e1;'&gt;\n"</literal></expr>,
<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>


<typedef>typedef <type><struct>struct <name>ext_hdlr_data</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>handler</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtHdlrData</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_oneshot_loader</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtHdlrData</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtHdlrData</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_skipped_null_loaded_ext_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/one.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtHdlrData</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY % pe1 SYSTEM 'http://example.org/two.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % pe2 '%pe1;'&gt;\n"</literal>
<literal type="string">"%pe2;\n"</literal></expr>,
<expr><name>external_entity_null_loader</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_oneshot_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_skipped_unloaded_ext_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/one.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtHdlrData</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY % pe1 SYSTEM 'http://example.org/two.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % pe2 '%pe1;'&gt;\n"</literal>
<literal type="string">"%pe2;\n"</literal></expr>,
<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_oneshot_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_param_entity_with_trailing_cr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAM_ENTITY_NAME</name></cpp:macro> <cpp:value>"pe"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAM_ENTITY_CORE_VALUE</name></cpp:macro> <cpp:value>"&lt;!ATTLIST doc att CDATA \"default\"&gt;"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY % "</literal> <name>PARAM_ENTITY_NAME</name> <literal type="string">" '"</literal> <name>PARAM_ENTITY_CORE_VALUE</name> <literal type="string">"\r'&gt;\n"</literal>
<literal type="string">"%"</literal> <name>PARAM_ENTITY_NAME</name> <literal type="string">";\n"</literal></expr>,
<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>param_entity_match_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entity_name_to_match</name> <operator>=</operator> <call><name>XCS</name><argument_list>(<argument><expr><name>PARAM_ENTITY_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entity_value_to_match</name> <operator>=</operator> <macro><name>XCS</name><argument_list>(<argument>PARAM_ENTITY_CORE_VALUE</argument>)</argument_list></macro> <call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entity_match_flag</name> <operator>=</operator> <name>ENTITY_MATCH_NOT_FOUND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>entity_match_flag</name> <operator>==</operator> <name>ENTITY_MATCH_FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parameter entity CR-&gt;NEWLINE conversion failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>entity_match_flag</name> <operator>==</operator> <name>ENTITY_MATCH_NOT_FOUND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parameter entity not parsed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PARAM_ENTITY_NAME</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PARAM_ENTITY_CORE_VALUE</name></cpp:undef>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_character_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity '&amp;#x110000;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_BAD_CHAR_REF</name></expr></argument>,
<argument><expr><literal type="string">"Out of range character reference not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_character_entity_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity '&amp;#xg0;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Out of range character reference not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_character_entity_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0o\0c\0 \0[\0\n"</literal>



<literal type="string">"\0&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0e\0n\0t\0i\0t\0y\0 "</literal>
<literal type="string">"\0'\0&amp;\x0e\x04\x0e\x08\0;\0'\0&gt;\0\n"</literal>

<literal type="string">"\0]\0&gt;\0\n"</literal>

<literal type="string">"\0&lt;\0d\0o\0c\0&gt;\0&amp;\0e\0n\0t\0i\0t\0y\0;\0&lt;\0/\0d\0o\0c\0&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid start of entity name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_UNDEFINED_ENTITY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_character_entity_4</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY entity '&amp;#1114112;'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_BAD_CHAR_REF</name></expr></argument>,
<argument><expr><literal type="string">"Out of range character reference not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_pi_handled_in_default</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?test processing instruction?&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;?test processing instruction?&gt;\n&lt;doc/&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_comment_handled_in_default</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!-- This is a comment --&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"&lt;!-- This is a comment --&gt;\n&lt;doc/&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>accumulate_pi_characters</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_pi_yml</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?yml something like data?&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"yml: something like data\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_pi_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_pi_xnl</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xnl nothing like data?&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"xnl: nothing like data\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_pi_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_pi_xmm</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xmm everything like data?&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"xmm: everything like data\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_pi_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_pi</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=




<expr><literal type="string">"&lt;\0?\0\x04\x0e\x08\x0e?\0&gt;\0"</literal>

<literal type="string">"&lt;\0q\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x0e04\x0e08: \n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xe0\xb8\x84\xe0\xb8\x88: \n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_pi_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_be_pi</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=




<expr><literal type="string">"\0&lt;\0?\x0e\x04\x0e\x08\0?\0&gt;"</literal>

<literal type="string">"\0&lt;\0q\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x0e04\x0e08: \n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xe0\xb8\x84\xe0\xb8\x88: \n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_pi_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>accumulate_comment</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_utf16_be_comment</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0!\0-\0-\0 \0C\0o\0m\0m\0e\0n\0t\0 \0A\0 \0-\0-\0&gt;\0\n"</literal>

<literal type="string">"\0&lt;\0d\0o\0c\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" Comment A "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_le_comment</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0!\0-\0-\0 \0C\0o\0m\0m\0e\0n\0t\0 \0B\0 \0-\0-\0&gt;\0\n\0"</literal>

<literal type="string">"&lt;\0d\0o\0c\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" Comment B "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>




<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>failing_converter</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>prefix_converter</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x01ff</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>MiscEncodingHandler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>high_map</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-9"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"ascii-like"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-len"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-surrogate"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-high"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>high_map</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>high_map</name></expr>;</expr_stmt></block_content></block></for>


<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-9"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-len"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0x81</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-a"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0x82</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-surrogate"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0x83</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xd801</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"invalid-high"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><literal type="number">0x84</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x010101</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"failing-conv"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>failing_converter</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"prefix-conv"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>prefix_converter</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_missing_encoding_conversion_fn</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='no-conv'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\x81&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Encoding with missing convert() not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_failing_encoding_conversion_fn</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='failing-conv'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\x81&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Encoding with failing convert() not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_success</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>

<literal type="string">"&lt;\x81\x64\x80oc&gt;Hello, world&lt;/\x81\x64\x80oc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hello, world"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_bad_name</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;\xff\x64oc&gt;Hello, world&lt;/\xff\x64oc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Bad name start in unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_bad_name_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;d\xffoc&gt;Hello, world&lt;/d\xffoc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Bad name in unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_long_name_1</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;abcdefghabcdefghabcdefghijkl\x80m\x80n\x80o\x80p&gt;"</literal>
<literal type="string">"Hi"</literal>
<literal type="string">"&lt;/abcdefghabcdefghabcdefghijkl\x80m\x80n\x80o\x80p&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abcdefghabcdefghabcdefghijklmnop"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_long_name_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;abcdefghabcdefghabcdefghijklmnop&gt;"</literal>
<literal type="string">"Hi"</literal>
<literal type="string">"&lt;/abcdefghabcdefghabcdefghijklmnop&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"abcdefghabcdefghabcdefghijklmnop"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_invalid_unknown_encoding</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='invalid-9'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_ascii_encoding_ok</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='ascii-like'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hello, world"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_ascii_encoding_fail</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='ascii-like'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, \x80 world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_invalid_length</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='invalid-len'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_invalid_topbit</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='invalid-a'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_invalid_surrogate</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='invalid-surrogate'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, \x82 world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_invalid_high</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='invalid-high'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid unknown encoding not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_invalid_attr_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;doc attr='\xff\x30'/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid attribute valid not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>END_TEST</name>




<name><name>enum</name> <name>ee_parse_flags</name></name></type> <block>{<block_content> <expr_stmt><expr><name>EE_PARSE_NONE</name> <operator>=</operator> <literal type="number">0x00</literal></expr><operator>,</operator> <expr><name>EE_PARSE_FULL_BUFFER</name> <operator>=</operator> <literal type="number">0x01</literal></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <type><struct>struct <name>ExtTest2</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ee_parse_flags</name></name></type> <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtTest2</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_loader2</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtTest2</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtTest2</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>extparser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extparser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>extparser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Coulr not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_SetEncoding() ignored for external entity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>test_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EE_PARSE_FULL_BUFFER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_len</name></name></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>,
<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_len</name></name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>ext2_accumulate_characters</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtTest2</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtTest2</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>accumulate_characters</name><argument_list>(<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>storage</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_latin1_utf16le_bom</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{



<expr><literal type="string">"\xff\xfe\x4c\x20"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"iso-8859-1"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00ff\x00feL "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xbf\xc3\xbeL "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_latin1_utf16be_bom</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{



<expr><literal type="string">"\xfe\xff\x20\x4c"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"iso-8859-1"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00fe\x00ff L"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xbe\xc3\xbf L"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_latin1_utf16le_bom2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{



<expr><literal type="string">"\xff\xfe\x4c\x20"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"iso-8859-1"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_FULL_BUFFER</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00ff\x00feL "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xbf\xc3\xbeL "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_latin1_utf16be_bom2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{



<expr><literal type="string">"\xfe\xff\x20\x4c"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"iso-8859-1"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_FULL_BUFFER</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00fe\x00ff L"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><literal type="string">"\xc3\xbe\xc3\xbf L"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_utf16_be</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;\0e\0/\0&gt;\0"</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-16be"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x3c00\x6500\x2f00\x3e00"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xe3\xb0\x80"</literal>
<literal type="string">"\xe6\x94\x80"</literal>
<literal type="string">"\xe2\xbc\x80"</literal>
<literal type="string">"\xe3\xb8\x80"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_utf16_le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"\0&lt;\0e\0/\0&gt;"</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-16le"</literal></expr></argument>)</argument_list></call></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x3c00\x6500\x2f00\x3e00"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xe3\xb0\x80"</literal>
<literal type="string">"\xe6\x94\x80"</literal>
<literal type="string">"\xe2\xbc\x80"</literal>
<literal type="string">"\xe3\xb8\x80"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>








<typedef>typedef <type><struct>struct <name>ExtFaults2</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>parse_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fail_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>error</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExtFaults2</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_faulter2</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtFaults2</name> <modifier>*</modifier></type><name>test_data</name> <init>= <expr><operator>(</operator><name>ExtFaults2</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>extparser</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extparser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>extparser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_SetEncoding() ignored for external entity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_Parse</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_text</name></name></expr></argument>, <argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>parse_len</name></name></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name><name>test_data</name><operator>-&gt;</operator><name>fail_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>test_data</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>extparser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_ext_entity_utf16_unknown</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults2</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"a\0b\0c\0"</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="string">"Invalid character in entity not faulted"</literal></expr>, <expr><name>NULL</name></expr>,
<expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character should not have been accepted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ext_entity_utf8_non_bom</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"\xef\xbb\x80"</literal></expr>,
<expr><literal type="number">3</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xfec0"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xef\xbb\x80"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf8_in_cdata_section</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;![CDATA[one \xc3\xa9 two]]&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"one \x00e9 two"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"one \xc3\xa9 two"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf8_in_cdata_section_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;![CDATA[\xc3\xa9]\xc3\xa9two]]&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e9]\x00e9two"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa9]\xc3\xa9two"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>record_element_end_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_trailing_spaces_in_elements</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc &gt;Hi&lt;/doc &gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doc/doc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>,
<argument><expr><name>record_element_end_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=




<expr><literal type="string">"&lt;\0d\0 \0\x04\x0e\x08\x0e=\0'\0a\0'\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_utf16_second_attr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;\0d\0 \0a\0=\0'\0\x31\0'\0 \0"</literal>
<literal type="string">"\x04\x0e\x08\x0e=\0'\0\x32\0'\0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_attr_after_solidus</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc attr1='a' / attr2='b'&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>, <argument><expr><literal type="string">"Misplaced / not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>accumulate_entity_decl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>entityName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>is_parameter_entity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>value_length</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notationName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>is_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>notationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>entityName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_utf16_pe</argument>)</argument_list></macro> <block>{<block_content>









<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>= <expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0o\0c\0 \0[\0\n"</literal>
<literal type="string">"\0&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0%\0 \x0e\x04\x0e\x08\0 "</literal>
<literal type="string">"\0'\0&lt;\0!\0E\0L\0E\0M\0E\0N\0T\0 "</literal>
<literal type="string">"\0d\0o\0c\0 \0(\0#\0P\0C\0D\0A\0T\0A\0)\0&gt;\0'\0&gt;\0\n"</literal>
<literal type="string">"\0%\x0e\x04\x0e\x08\0;\0\n"</literal>
<literal type="string">"\0]\0&gt;\0\n"</literal>
<literal type="string">"\0&lt;\0d\0o\0c\0&gt;\0&lt;\0/\0d\0o\0c\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x0e04\x0e08=&lt;!ELEMENT doc (#PCDATA)&gt;\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name>
<init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xe0\xb8\x84\xe0\xb8\x88=&lt;!ELEMENT doc (#PCDATA)&gt;\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_entity_decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_attr_desc_keyword</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ATTLIST doc attr CDATA #!IMPLIED&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Bad keyword !IMPLIED not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_attr_desc_keyword_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>







<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name>
<init>= <expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0 \0[\0\n"</literal>
<literal type="string">"\0&lt;\0!\0A\0T\0T\0L\0I\0S\0T\0 \0d\0 \0a\0 \0C\0D\0A\0T\0A\0 "</literal>
<literal type="string">"\0#\x0e\x04\x0e\x08\0&gt;\0\n"</literal>
<literal type="string">"\0]\0&gt;\0&lt;\0d\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid UTF16 attribute keyword not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc [ \x80\x44 ]&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"Invalid bytes in DOCTYPE not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_doctype_utf16</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=





<expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0o\0c\0 \0[\0 "</literal>
<literal type="string">"\x06\xf2"</literal>
<literal type="string">"\0 \0]\0&gt;\0&lt;\0d\0o\0c\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Invalid bytes in DOCTYPE not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_doctype_plus</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE 1+ [ &lt;!ENTITY foo 'bar'&gt; ]&gt;\n"</literal>
<literal type="string">"&lt;1+&gt;&amp;foo;&lt;/1+&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"'+' in document name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_doctype_star</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE 1* [ &lt;!ENTITY foo 'bar'&gt; ]&gt;\n"</literal>
<literal type="string">"&lt;1*&gt;&amp;foo;&lt;/1*&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"'*' in document name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_doctype_query</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE 1? [ &lt;!ENTITY foo 'bar'&gt; ]&gt;\n"</literal>
<literal type="string">"&lt;1?&gt;&amp;foo;&lt;/1?&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"'?' in document name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_unknown_encoding_bad_ignore</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;"</literal>
<literal type="string">"&lt;doc&gt;&lt;e&gt;&amp;entity;&lt;/e&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>fault</name> <init>= <expr><block>{<expr><literal type="string">"&lt;![IGNORE[&lt;!ELEMENT \xffG (#PCDATA)*&gt;]]&gt;"</literal></expr>,
<expr><literal type="string">"Invalid character not faulted"</literal></expr>, <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"prefix-conv"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>XML_ERROR_INVALID_TOKEN</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Bad IGNORE section with unknown encoding not failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_entity_in_utf16_be_attr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0e\0 \0a\0=\0'\0&amp;\0#\0\x32\0\x32\0\x38\0;\0 "</literal>
<literal type="string">"\0&amp;\0#\0x\0\x30\0\x30\0E\0\x34\0;\0'\0&gt;\0&lt;\0/\0e\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e4 \x00e4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa4 \xc3\xa4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_entity_in_utf16_le_attr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0e\0 \0a\0=\0'\0&amp;\0#\0\x32\0\x32\0\x38\0;\0 \0"</literal>
<literal type="string">"&amp;\0#\0x\0\x30\0\x30\0E\0\x34\0;\0'\0&gt;\0&lt;\0/\0e\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\x00e4 \x00e4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\xc3\xa4 \xc3\xa4"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_entity_public_utf16_be</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0 \0[\0\n"</literal>

<literal type="string">"\0&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0%\0 \0e\0 \0P\0U\0B\0L\0I\0C\0 "</literal>
<literal type="string">"\0'\0f\0o\0o\0'\0 \0'\0b\0a\0r\0.\0e\0n\0t\0'\0&gt;\0\n"</literal>

<literal type="string">"\0%\0e\0;\0\n"</literal>

<literal type="string">"\0]\0&gt;\0\n"</literal>

<literal type="string">"\0&lt;\0d\0&gt;\0&amp;\0j\0;\0&lt;\0/\0d\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name> <init>= <expr><block>{
<expr><literal type="string">"\0&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0j\0 \0'\0b\0a\0z\0'\0&gt;"</literal></expr>,
<expr><literal type="number">34</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"baz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_entity_public_utf16_le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0d\0 \0[\0\n\0"</literal>

<literal type="string">"&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0%\0 \0e\0 \0P\0U\0B\0L\0I\0C\0 \0"</literal>
<literal type="string">"'\0f\0o\0o\0'\0 \0'\0b\0a\0r\0.\0e\0n\0t\0'\0&gt;\0\n\0"</literal>

<literal type="string">"%\0e\0;\0\n\0"</literal>

<literal type="string">"]\0&gt;\0\n\0"</literal>

<literal type="string">"&lt;\0d\0&gt;\0&amp;\0j\0;\0&lt;\0/\0d\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtTest2</name></type> <name>test_data</name> <init>= <expr><block>{
<expr><literal type="string">"&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0j\0 \0'\0b\0a\0z\0'\0&gt;\0"</literal></expr>,
<expr><literal type="number">34</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>EE_PARSE_NONE</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"baz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>test_data</name><operator>.</operator><name>storage</name></name> <operator>=</operator> <operator>&amp;</operator><name>storage</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_loader2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>ext2_accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_short_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"DOCTYPE without subset not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_short_doctype_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc PUBLIC&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"DOCTYPE without Public ID not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_short_doctype_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"DOCTYPE without System ID not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_long_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc PUBLIC 'foo' 'bar' 'baz'&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>, <argument><expr><literal type="string">"DOCTYPE with extra ID not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY foo PUBLIC&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"ENTITY without Public ID is not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_entity_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY % foo bar&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"ENTITY without Public ID is not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_entity_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY % foo PUBLIC&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"Parameter ENTITY without Public ID is not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_entity_4</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY % foo SYSTEM&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"Parameter ENTITY without Public ID is not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_bad_notation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!NOTATION n SYSTEM&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"Notation without System ID is not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>


<typedef>typedef <type><struct>struct <name>default_check</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>expectedLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>seen</name></decl>;</decl_stmt>
}</block></struct></type> <name>DefaultCheck</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>checking_default_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DefaultCheck</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>DefaultCheck</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expectedLen</name> <operator>==</operator> <name>len</name>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>seen</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_default_doctype_handler</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc PUBLIC 'pubname' 'test.dtd' [\n"</literal>
<literal type="string">" &lt;!ENTITY foo 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;foo;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DefaultCheck</name></type> <name><name>test_data</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"'pubname'"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">9</literal></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>,
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"'test.dtd'"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>XML_FALSE</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>checking_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expected</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>seen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Default handler not run for public !DOCTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_empty_element_abort</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;abort/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_suspender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Expected to error on abort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>





<specifier>static</specifier> <name>void</name></type>
<name>namespace_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreateNS</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>namespace_teardown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>basic_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>triplet_start_flag</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>triplet_end_flag</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>triplet_start_checker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>elemstr</name> <init>= <expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>elemstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"unexpected start string: '%"</literal> <name>XML_FMT_STR</name> <literal type="string">"'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>elemstr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"unexpected attribute string: '%"</literal> <name>XML_FMT_STR</name> <literal type="string">"'"</literal></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>triplet_start_flag</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>triplet_end_checker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>elemstr</name> <init>= <expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name><name>elemstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"unexpected end string: '%"</literal> <name>XML_FMT_STR</name> <literal type="string">"'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>triplet_end_flag</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_return_ns_triplet</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' bar:a='12'\n"</literal>
<literal type="string">" xmlns:bar='http://example.org/'&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>epilog</name> <init>= <expr><literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name><name>elemstr</name><index>[]</index></name>
<init>= <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"http://example.org/ e foo"</literal></expr></argument>)</argument_list></call></expr>, <macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/ a bar"</literal></argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>elemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>triplet_start_checker</name></expr></argument>, <argument><expr><name>triplet_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNamespaceDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_namespace_decl_handler</name></expr></argument>,
<argument><expr><name>dummy_end_namespace_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>triplet_start_flag</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>triplet_end_flag</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>triplet_start_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"triplet_start_checker not invoked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>epilog</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>epilog</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>triplet_end_flag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"triplet_end_checker not invoked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name>
<operator>!=</operator> <operator>(</operator><name>DUMMY_START_NS_DECL_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_END_NS_DECL_HANDLER_FLAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Namespace handlers not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>overwrite_start_checker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"start "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>atts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\nattribute "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><operator>*</operator><name>atts</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>atts</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>overwrite_end_checker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name> <modifier>*</modifier></type><name>storage</name> <init>= <expr><operator>(</operator><name>CharData</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"end "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_AppendXMLChars</name><argument_list>(<argument><expr><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>run_ns_tagname_overwrite_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>overwrite_start_checker</name></expr></argument>,
<argument><expr><name>overwrite_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_ns_tagname_overwrite</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;n:e xmlns:n='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;n:f n:attr='foo'/&gt;\n"</literal>
<literal type="string">" &lt;n:g n:attr2='bar'/&gt;\n"</literal>
<literal type="string">"&lt;/n:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>result</name> <init>= <macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ e\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ f\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"attribute http://example.org/ attr\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"end http://example.org/ f\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ g\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"attribute http://example.org/ attr2\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"end http://example.org/ g\n"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"end http://example.org/ e\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>run_ns_tagname_overwrite_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_tagname_overwrite_triplet</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;n:e xmlns:n='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;n:f n:attr='foo'/&gt;\n"</literal>
<literal type="string">" &lt;n:g n:attr2='bar'/&gt;\n"</literal>
<literal type="string">"&lt;/n:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>result</name> <init>= <macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ e n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ f n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"attribute http://example.org/ attr n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"end http://example.org/ f n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"start http://example.org/ g n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"attribute http://example.org/ attr2 n\n"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"end http://example.org/ g n\n"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"end http://example.org/ e n\n"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_ns_tagname_overwrite_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>start_element_fail</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"should never reach start_element_fail()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>XMLCALL</name></type>
<name>start_ns_clearing_start_element</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><operator>(</operator><name>XML_Parser</name><operator>)</operator><name>userData</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_start_ns_clears_start_element</argument>)</argument_list></macro> <block>{<block_content>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;e xmlns='http://example.org/'&gt;&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartNamespaceDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_ns_clearing_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndNamespaceDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_namespace_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_UseParserAsHandlerArg</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_handler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>callno</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>p2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>callno</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;!ELEMENT doc (e+)&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc xmlns CDATA #IMPLIED&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;\n"</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;"</literal>
<literal type="string">"&lt;e/&gt;"</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>callno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_default_ns_from_ext_subset_and_ext_ge</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/doc.dtd' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/entity.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/ns1'&gt;\n"</literal>
<literal type="string">"&amp;en;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_prefix_with_empty_uri_1</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns:prefix='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns:prefix=''/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr></argument>,
<argument><expr><literal type="string">"Did not report re-setting namespace"</literal>
<literal type="string">" URI with prefix to ''."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_prefix_with_empty_uri_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;docelem xmlns:pre=''/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr></argument>,
<argument><expr><literal type="string">"Did not report setting namespace URI with prefix to ''."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_prefix_with_empty_uri_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">" &lt;!ATTLIST doc\n"</literal>
<literal type="string">" xmlns:prefix CDATA ''&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr></argument>,
<argument><expr><literal type="string">"Didn't report attr default setting NS w/ prefix to ''."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_prefix_with_empty_uri_4</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ELEMENT prefix:doc EMPTY&gt;\n"</literal>
<literal type="string">" &lt;!ATTLIST prefix:doc\n"</literal>
<literal type="string">" xmlns:prefix CDATA 'http://example.org/'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;prefix:doc/&gt;"</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name><name>elemstr</name><index>[]</index></name> <init>= <expr><block>{<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/ doc prefix"</literal></argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>elemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>triplet_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_unbound_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ELEMENT prefix:doc EMPTY&gt;\n"</literal>
<literal type="string">" &lt;!ATTLIST prefix:doc\n"</literal>
<literal type="string">" notxmlns:prefix CDATA 'http://example.org/'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;prefix:doc/&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unbound prefix incorrectly passed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_UNBOUND_PREFIX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_default_with_empty_uri</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns=''/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetStartNamespaceDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>dummy_start_namespace_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEndNamespaceDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_end_namespace_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_duplicate_attrs_diff_prefixes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns:a='http://example.org/a'\n"</literal>
<literal type="string">" xmlns:b='http://example.org/a'\n"</literal>
<literal type="string">" a:a='v' b:a='v' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr></argument>,
<argument><expr><literal type="string">"did not report multiple attributes with same URI+name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_duplicate_hashes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
















<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns:a='http://example.org/a'\n"</literal>
<literal type="string">" a:a='v' a:i='w' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_unbound_prefix_on_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc a:attr=''/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr></argument>,
<argument><expr><literal type="string">"did not report unbound prefix on attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_unbound_prefix_on_element</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;a:doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr></argument>,
<argument><expr><literal type="string">"did not report unbound prefix on element"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_parser_reset</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"parsing status doesn't start INITIALIZED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>test_return_ns_triplet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"parsing status doesn't end FINISHED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_GetParsingStatus</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>status</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_INITIALIZED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"parsing status doesn't reset to INITIALIZED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_long_element</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;foo:thisisalongenoughelementnametotriggerareallocation\n"</literal>
<literal type="string">" xmlns:foo='http://example.org/' bar:a='12'\n"</literal>
<literal type="string">" xmlns:bar='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/foo:thisisalongenoughelementnametotriggerareallocation&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name><name>elemstr</name><index>[]</index></name>
<init>= <expr><block>{<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" thisisalongenoughelementnametotriggerareallocation foo"</literal></expr></argument>)</argument_list></call></expr>,
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/ a bar"</literal></argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>elemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>triplet_start_checker</name></expr></argument>, <argument><expr><name>triplet_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_mixed_prefix_atts</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;e a='12' bar:b='13'\n"</literal>
<literal type="string">" xmlns:bar='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/e&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_extend_uri_buffer</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/'&gt;"</literal>
<literal type="string">" &lt;foo:thisisalongenoughnametotriggerallocationaction"</literal>
<literal type="string">" foo:a='12' /&gt;"</literal>
<literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_reserved_attributes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' xmlns:xmlns='12' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' foo:xmlns='12' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text1</name></expr></argument>, <argument><expr><name>XML_ERROR_RESERVED_PREFIX_XMLNS</name></expr></argument>,
<argument><expr><literal type="string">"xmlns not rejected as an attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_reserved_attributes_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/'"</literal>
<literal type="string">" xmlns:xml='http://example.org/' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://www.w3.org/XML/1998/namespace' /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text3</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://www.w3.org/2000/xmlns/' /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text1</name></expr></argument>, <argument><expr><name>XML_ERROR_RESERVED_PREFIX_XML</name></expr></argument>,
<argument><expr><literal type="string">"xml not rejected as an attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text2</name></expr></argument>, <argument><expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr></argument>,
<argument><expr><literal type="string">"Use of w3.org URL not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text3</name></expr></argument>, <argument><expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr></argument>,
<argument><expr><literal type="string">"Use of w3.org xmlns URL not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>



<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_extremely_long_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name>
<init>= <expr><literal type="string">"&lt;doc "</literal>


<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">":a='12'"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name>
<init>= <expr><literal type="string">" xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"='foo'\n&gt;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_unknown_encoding_success</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='prefix-conv'?&gt;\n"</literal>
<literal type="string">"&lt;foo:e xmlns:foo='http://example.org/'&gt;Hi&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>run_character_check</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hi"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_double_colon</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' foo:a:b='bar' /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Double colon in attribute name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_double_colon_element</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:bar:e xmlns:foo='http://example.org/' /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Double colon in element name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_bad_attr_leafname</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' foo:?ar='baz' /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character in leafname not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_bad_element_leafname</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:?oc xmlns:foo='http://example.org/' /&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character in element leafname not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_utf16_leafname</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=



<expr><literal type="string">"&lt;\0n\0:\0e\0 \0x\0m\0l\0n\0s\0:\0n\0=\0'\0U\0R\0I\0'\0 \0"</literal>
<literal type="string">"n\0:\0\x04\x0e=\0'\0a\0'\0 \0/\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_utf16_element_leafname</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=



<expr><literal type="string">"\0&lt;\0n\0:\x0e\x04\0 \0x\0m\0l\0n\0s\0:\0n\0=\0'\0U\0R\0I\0'\0/\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"URI \x0e04"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"URI \xe0\xb8\x84"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_event_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_utf16_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=



<expr><literal type="string">"\0&lt;\0!\0D\0O\0C\0T\0Y\0P\0E\0 \0f\0o\0o\0:\x0e\x04\0 "</literal>
<literal type="string">"\0[\0 \0&lt;\0!\0E\0N\0T\0I\0T\0Y\0 \0b\0a\0r\0 \0'\0b\0a\0z\0'\0&gt;\0 "</literal>
<literal type="string">"\0]\0&gt;\0\n"</literal>

<literal type="string">"\0&lt;\0f\0o\0o\0:\x0e\x04\0 "</literal>
<literal type="string">"\0x\0m\0l\0n\0s\0:\0f\0o\0o\0=\0'\0U\0R\0I\0'\0&gt;"</literal>
<literal type="string">"\0&amp;\0b\0a\0r\0;"</literal>
<literal type="string">"\0&lt;\0/\0f\0o\0o\0:\x0e\x04\0&gt;"</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"URI \x0e04"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"URI \xe0\xb8\x84"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>start_element_event_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>MiscEncodingHandler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_invalid_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE foo:!bad [ &lt;!ENTITY bar 'baz' ]&gt;\n"</literal>
<literal type="string">"&lt;foo:!bad&gt;&amp;bar;&lt;/foo:!bad&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_INVALID_TOKEN</name></expr></argument>,
<argument><expr><literal type="string">"Invalid character in document local name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_ns_double_colon_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE foo:a:doc [ &lt;!ENTITY bar 'baz' ]&gt;\n"</literal>
<literal type="string">"&lt;foo:a:doc&gt;&amp;bar;&lt;/foo:a:doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_SYNTAX</name></expr></argument>,
<argument><expr><literal type="string">"Double colon in document name not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>END_TEST</name>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOC_ALWAYS_SUCCEED</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALLOC_ALWAYS_SUCCEED</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<specifier>static</specifier> <name>intptr_t</name></type> <name>allocation_count</name> <init>= <expr><name>ALLOC_ALWAYS_SUCCEED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>intptr_t</name></type> <name>reallocation_count</name> <init>= <expr><name>REALLOC_ALWAYS_SUCCEED</name></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>duff_allocator</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>allocation_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>allocation_count</name> <operator>!=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>allocation_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>duff_reallocator</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reallocation_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reallocation_count</name> <operator>!=</operator> <name>REALLOC_ALWAYS_SUCCEED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>reallocation_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_misc_alloc_create_parser</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name></type> <name>memsuite</name> <init>= <expr><block>{<expr><name>duff_allocator</name></expr>, <expr><name>realloc</name></expr>, <expr><name>free</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memsuite</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser unexpectedly ignored failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created with max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_alloc_create_parser_with_encoding</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name></type> <name>memsuite</name> <init>= <expr><block>{<expr><name>duff_allocator</name></expr>, <expr><name>realloc</name></expr>, <expr><name>free</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"us-ascii"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>memsuite</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser ignored failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created with max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_null_parser</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_error_string</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><operator>(</operator>enum <name>XML_Error</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Negative error code not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><operator>(</operator>enum <name>XML_Error</name><operator>)</operator><literal type="number">100</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Large error code not rejected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>







<specifier>static</specifier> <name>int</name></type>
<name>parse_version</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_LChar</name> <modifier>*</modifier></type><name>version_text</name></decl></parameter>,
<parameter><decl><type><name>XML_Expat_Version</name> <modifier>*</modifier></type><name>version_struct</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>version_text</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>version_text</name> <operator>!=</operator> <literal type="number">0x00</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>version_text</name> <operator>&gt;=</operator> <name>ASCII_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>version_text</name> <operator>&lt;=</operator> <name>ASCII_9</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>version_text</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>version_text</name> <operator>==</operator> <literal type="number">0x00</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>version_text</name> <operator>&gt;=</operator> <name>ASCII_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>version_text</name> <operator>&lt;=</operator> <name>ASCII_9</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>major</name></name>
<operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name><name>version_struct</name><operator>-&gt;</operator><name>major</name></name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>version_text</name><operator>++</operator> <operator>-</operator> <name>ASCII_0</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>version_text</name><operator>++</operator> <operator>!=</operator> <name>ASCII_PERIOD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>version_text</name> <operator>&gt;=</operator> <name>ASCII_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>version_text</name> <operator>&lt;=</operator> <name>ASCII_9</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>minor</name></name>
<operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name><name>version_struct</name><operator>-&gt;</operator><name>minor</name></name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>version_text</name><operator>++</operator> <operator>-</operator> <name>ASCII_0</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>version_text</name><operator>++</operator> <operator>!=</operator> <name>ASCII_PERIOD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>micro</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>version_text</name> <operator>&gt;=</operator> <name>ASCII_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>version_text</name> <operator>&lt;=</operator> <name>ASCII_9</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>version_struct</name><operator>-&gt;</operator><name>micro</name></name>
<operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name><name>version_struct</name><operator>-&gt;</operator><name>micro</name></name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>version_text</name><operator>++</operator> <operator>-</operator> <name>ASCII_0</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>version_text</name> <operator>!=</operator> <literal type="number">0x00</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>versions_equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Expat_Version</name> <modifier>*</modifier></type><name>first</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Expat_Version</name> <modifier>*</modifier></type><name>second</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>first</name><operator>-&gt;</operator><name>major</name></name> <operator>==</operator> <name><name>second</name><operator>-&gt;</operator><name>major</name></name> <operator>&amp;&amp;</operator> <name><name>first</name><operator>-&gt;</operator><name>minor</name></name> <operator>==</operator> <name><name>second</name><operator>-&gt;</operator><name>minor</name></name>
<operator>&amp;&amp;</operator> <name><name>first</name><operator>-&gt;</operator><name>micro</name></name> <operator>==</operator> <name><name>second</name><operator>-&gt;</operator><name>micro</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_misc_version</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Expat_Version</name></type> <name>read_version</name> <init>= <expr><call><name>XML_ExpatVersionInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>XML_Expat_Version</name></type> <name>parsed_version</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_LChar</name> <modifier>*</modifier></type><name>version_text</name> <init>= <expr><call><name>XML_ExpatVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>version_text</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not obtain version text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>version_text</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>parse_version</name><argument_list>(<argument><expr><name>version_text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_version</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unable to parse version text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>versions_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>read_version</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_version</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Version mismatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>xcstrcmp</name><argument_list>(<argument><expr><name>version_text</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"expat_2.2.9"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_*_VERSION in expat.h out of sync?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>



<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>version_text</name></expr></argument>, <argument><expr><literal type="string">"expat_2.2.5"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_*_VERSION in expat.h out of sync?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_features</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Feature</name> <modifier>*</modifier></type><name>features</name> <init>= <expr><call><name>XML_GetFeatureList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>features</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to get feature information"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<while>while <condition>(<expr><name><name>features</name><operator>-&gt;</operator><name>feature</name></name> <operator>!=</operator> <name>XML_FEATURE_END</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>features</name><operator>-&gt;</operator><name>feature</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_FEATURE_SIZEOF_XML_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>features</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Incorrect size of XML_Char"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_FEATURE_SIZEOF_XML_LCHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>features</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_LChar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Incorrect size of XML_LChar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>features</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_attribute_leak</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;D xmlns:L=\"D\" l:a='' L:a=''/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name></type> <name>memsuite</name>
<init>= <expr><block>{<expr><name>tracking_malloc</name></expr>, <expr><name>tracking_realloc</name></expr>, <expr><name>tracking_free</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>memsuite</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr></argument>, <argument><expr><literal type="string">"Unbound prefixes not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>tracking_report</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Memory leak found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_utf16le</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>text</name><index>[]</index></name> <init>=

<expr><literal type="string">"&lt;\0?\0x\0m\0l\0 \0"</literal>
<literal type="string">"v\0e\0r\0s\0i\0o\0n\0=\0'\0\x31\0.\0\x30\0'\0?\0&gt;\0"</literal>
<literal type="string">"&lt;\0q\0&gt;\0H\0i\0&lt;\0/\0q\0&gt;\0"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"Hi"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>

<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"UTF-16LE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<macro><name>END_TEST</name></macro>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deep</name></decl>;</decl_stmt>
}</block></struct></type> <name>DataIssue240</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_element_issue_240</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DataIssue240</name> <modifier>*</modifier></type><name>mydata</name> <init>= <expr><operator>(</operator><name>DataIssue240</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>deep</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_element_issue_240</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DataIssue240</name> <modifier>*</modifier></type><name>mydata</name> <init>= <expr><operator>(</operator><name>DataIssue240</name> <operator>*</operator><operator>)</operator><name>userData</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>deep</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mydata</name><operator>-&gt;</operator><name>deep</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_StopParser</name><argument_list>(<argument><expr><name><name>mydata</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_misc_stop_during_end_handler_issue_240_1</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DataIssue240</name> <modifier>*</modifier></type><name>mydata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>doc1</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;e1/&gt;&lt;e&gt;&lt;foo/&gt;&lt;/e&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start_element_issue_240</name></expr></argument>, <argument><expr><name>end_element_issue_240</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mydata</name> <operator>=</operator> <operator>(</operator><name>DataIssue240</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataIssue240</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>deep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>mydata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>doc1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>doc1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mydata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Stopping the parser did not work as expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_stop_during_end_handler_issue_240_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DataIssue240</name> <modifier>*</modifier></type><name>mydata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>doc2</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;elem/&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start_element_issue_240</name></expr></argument>, <argument><expr><name>end_element_issue_240</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mydata</name> <operator>=</operator> <operator>(</operator><name>DataIssue240</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataIssue240</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>parser</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mydata</name><operator>-&gt;</operator><name>deep</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>mydata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>doc2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>doc2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mydata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Stopping the parser did not work as expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_misc_deny_internal_entity_closing_doctype_issue_317</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>inputOne</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE d [\n"</literal>
<literal type="string">"&lt;!ENTITY % e ']&gt;&lt;d/&gt;'&gt;\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"%e;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>inputTwo</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE d [\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 ']&gt;&lt;d/&gt;'&gt;&lt;!ENTITY % e2 '&amp;e1;'&gt;\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"%e2;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>inputThree</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE d [\n"</literal>
<literal type="string">"&lt;!ENTITY % e ']&gt;&lt;d'&gt;\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">"%e;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>inputIssue317</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY % foo ']&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hell&lt;oc (#PCDATA)*&gt;'&gt;\n"</literal>
<literal type="string">"%foo;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/dVc&gt;"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>inputs</name><index>[]</index></name> <init>= <expr><block>{<expr><name>inputOne</name></expr>, <expr><name>inputTwo</name></expr>, <expr><name>inputThree</name></expr>, <expr><name>inputIssue317</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>inputIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>inputIndex</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>inputs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>inputs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>inputIndex</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>parseResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>setParamEntityResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>lineNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Size</name></type> <name>columnNumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>input</name> <init>= <expr><name><name>inputs</name><index>[<expr><name>inputIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>setParamEntityResult</name>
<operator>=</operator> <call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>setParamEntityResult</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed to set XML_PARAM_ENTITY_PARSING_ALWAYS."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>parseResult</name> <operator>=</operator> <call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>parseResult</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>parseResult</name> <operator>=</operator> <call><name>XML_Parse</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>parseResult</name> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing was expected to fail but succeeded."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Error code does not match XML_ERROR_INVALID_TOKEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lineNumber</name> <operator>=</operator> <call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lineNumber</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_GetCurrentLineNumber does not work as expected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>columnNumber</name> <operator>=</operator> <call><name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>columnNumber</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"XML_GetCurrentColumnNumber does not work as expected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>END_TEST</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<specifier>static</specifier> <name>void</name></type>
<name>alloc_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name></type> <name>memsuite</name> <init>= <expr><block>{<expr><name>duff_allocator</name></expr>, <expr><name>duff_reallocator</name></expr>, <expr><name>free</name></expr>}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>REALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memsuite</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>alloc_teardown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>basic_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_parse_xdecl</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>




<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>long_encoding_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>,
<parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_parse_xdecl_2</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='"</literal>

<literal type="string">"ThisIsAStupidlyLongEncodingNameIntendedToTriggerPoolGrowth123456"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN"</literal>
<literal type="string">"'?&gt;"</literal>
<literal type="string">"&lt;doc&gt;Hello, world&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetXmlDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_xdecl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>long_encoding_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_pi</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;?pi unknown?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;"</literal>
<literal type="string">"Hello, world"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_pi_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;"</literal>
<literal type="string">"Hello, world"</literal>
<literal type="string">"&lt;?pi unknown?&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_pi_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?"</literal>

<literal type="string">"This processing instruction should be long enough to ensure that"</literal>
<literal type="string">"it triggers the growth of an internal string pool when the "</literal>
<literal type="string">"allocator fails at a cruicial moment FGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"Q?&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_comment</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;!-- Test parsing this comment --&gt;"</literal>
<literal type="string">"&lt;doc&gt;Hi&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_comment_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;"</literal>
<literal type="string">"Hello, world"</literal>
<literal type="string">"&lt;!-- Parse this comment too --&gt;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_duff_loader</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>new_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"External parser creation ignored failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Extern parser not created with max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>


<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>




<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_create_external_parser</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>foo_text</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>foo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_duff_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"External parser allocator returned success incorrectly"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_run_external_parser</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>foo_text</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>foo_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_null_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing ignored failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed with allocation count 10"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_dbl_handler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>callno</name> <init>= <expr><operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>new_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>callno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;!ELEMENT doc (e+)&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc xmlns CDATA #IMPLIED&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;\n"</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>new_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Unable to allocate first external parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><operator>(</operator><literal type="number">10000</literal> <operator>-</operator> <name>allocation_count</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;"</literal>
<literal type="string">"&lt;e/&gt;"</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>callno</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Second external parser unexpectedly created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Second external parser not created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>




<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_dtd_copy_default_atts</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/doc.dtd' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/entity.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/ns1'&gt;\n"</literal>
<literal type="string">"&amp;en;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_dbl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_dbl_handler_2</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>callno</name> <init>= <expr><operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>new_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>rv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>callno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;!ELEMENT doc (e+)&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc xmlns CDATA #IMPLIED&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;\n"</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>text</name> <operator>=</operator> <operator>(</operator><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;"</literal>
<literal type="string">"&lt;e/&gt;"</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>new_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>new_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_external_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/doc.dtd' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/entity.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/ns1'&gt;\n"</literal>
<literal type="string">"&amp;en;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>alloc_test_max_repeats</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>alloc_test_max_repeats</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_dbl_handler_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"External entity parsed despite duff allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>alloc_test_max_repeats</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"External entity not parsed at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_alloc_set_encoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml encoding='iso-8859-3'?&gt;"</literal>
<literal type="string">"\xC3\xA9"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"utf-8"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>status</name>
<operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_ext_entity_set_encoding</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_allocation_count</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_allocation_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>external_entity_alloc_set_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Encoding check succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_allocation_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Encoding failed at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>unknown_released_encoding_handler</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>,
<parameter><decl><type><name>XML_Encoding</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>xcstrcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"unsupported-encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>release</name></name> <operator>=</operator> <name>dummy_release</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></function>




<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_internal_entity</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='unsupported-encoding'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE test [&lt;!ENTITY foo 'bar'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;test a='&amp;foo;'/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnknownEncodingHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>unknown_released_encoding_handler</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Internal entity worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Internal entity failed at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_dtd_default_handling</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ENTITY e SYSTEM 'http://example.org/e'&gt;\n"</literal>
<literal type="string">"&lt;!NOTATION n SYSTEM 'http://example.org/n'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY e1 SYSTEM 'http://example.org/e' NDATA n&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc (#PCDATA)&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc a CDATA #IMPLIED&gt;\n"</literal>
<literal type="string">"&lt;?pi in dtd?&gt;\n"</literal>
<literal type="string">"&lt;!--comment in dtd--&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;![CDATA[text in doc]]&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"\n\n\n\n\n\n\n\n\n&lt;doc&gt;text in doc&lt;/doc&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_handler</name></expr></argument>,
<argument><expr><name>dummy_end_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCdataSectionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_cdata_handler</name></expr></argument>,
<argument><expr><name>dummy_end_cdata_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUnparsedEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>,
<argument><expr><name>dummy_unparsed_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>accumulate_characters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Default DTD parsed despite allocation failures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Default DTD not parsed with maximum alloc count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name>
<operator>!=</operator> <operator>(</operator><name>DUMMY_START_DOCTYPE_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_END_DOCTYPE_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_ENTITY_DECL_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_ATTLIST_DECL_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_COMMENT_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_PI_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_START_CDATA_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_END_CDATA_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_UNPARSED_ENTITY_DECL_HANDLER_FLAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Not all handlers were called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_explicit_encoding</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_SetEncoding</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"us-ascii"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Encoding set despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Encoding not set at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_set_base</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>new_base</name> <init>= <expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"/local/file/name.xml"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_SetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>new_base</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Base set despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Base not set with max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_buffer</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>get_buffer_test_text</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">1536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"1.5K buffer reallocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded with no reallocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed with max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>


<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_reallocator</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><name>get_buffer_test_text</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not create external entity parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><literal type="number">1536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Buffer allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>status</name> <operator>==</operator> <name>XML_STATUS_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>XML_STATUS_OK</name></expr> </then><else>: <expr><name>XML_STATUS_ERROR</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_ext_entity_realloc_buffer</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'http://example.org/dummy.ent'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_reallocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Succeeded with no reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed with max reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_many_attributes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ATTLIST doc za CDATA 'default'&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc zb CDATA 'def2'&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc zc CDATA 'def3'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc a='1'"</literal>
<literal type="string">" b='2'"</literal>
<literal type="string">" c='3'"</literal>
<literal type="string">" d='4'"</literal>
<literal type="string">" e='5'"</literal>
<literal type="string">" f='6'"</literal>
<literal type="string">" g='7'"</literal>
<literal type="string">" h='8'"</literal>
<literal type="string">" i='9'"</literal>
<literal type="string">" j='10'"</literal>
<literal type="string">" k='11'"</literal>
<literal type="string">" l='12'"</literal>
<literal type="string">" m='13'"</literal>
<literal type="string">" n='14'"</literal>
<literal type="string">" p='15'"</literal>
<literal type="string">" q='16'"</literal>
<literal type="string">" r='17'"</literal>
<literal type="string">" s='18'&gt;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite no reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at max reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_public_entity_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % e1 PUBLIC 'foo' 'bar.ent'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % "</literal>

<literal type="string">"ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">" '%e1;'&gt;\n"</literal>
<literal type="string">"%e1;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_public</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ENTITY_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Entity declaration handler not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_subst_public_entity_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % "</literal>

<literal type="string">"ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">" PUBLIC 'foo' 'bar.ent'&gt;\n"</literal>
<literal type="string">"%ThisIsAStupidlyLongParameterNameIntendedToTriggerPoolGrowth12345"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_public</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_public_doctype</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc PUBLIC '"</literal>

<literal type="string">"http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"' 'test'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_decl_handler</name></expr></argument>,
<argument><expr><name>dummy_end_doctype_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name>
<operator>!=</operator> <operator>(</operator><name>DUMMY_START_DOCTYPE_DECL_HANDLER_FLAG</name>
<operator>|</operator> <name>DUMMY_END_DOCTYPE_DECL_HANDLER_FLAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Doctype handler functions not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_parse_public_doctype_long_name</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='utf-8'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE doc PUBLIC 'http://example.com/foo' '"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetDoctypeDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_start_doctype_decl_handler</name></expr></argument>,
<argument><expr><name>dummy_end_doctype_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>int</name> <name>XMLCALL</name></type>
<name>external_entity_alloc</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>XML_GetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>ext_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parse_res</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>systemId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>publicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext_parser</name> <operator>=</operator> <call><name>XML_ExternalEntityParserCreate</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>parse_res</name>
<operator>=</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>ext_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>parse_res</name></expr>;</return>
</block_content>}</block></function>


<macro><name>START_TEST</name><argument_list>(<argument>test_alloc_set_foreign_dtd</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' encoding='us-ascii'?&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;entity;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>text2</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;!ELEMENT doc (#PCDATA)*&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>text2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_UseForeignDTD</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not set foreign DTD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_attribute_enum_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' standalone='no'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE animal SYSTEM 'test.dtd'&gt;\n"</literal>
<literal type="string">"&lt;animal&gt;This is a \n &lt;a/&gt; \n\nyellow tiger&lt;/animal&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name> <init>= <expr><literal type="string">"&lt;!ELEMENT animal (#PCDATA|a)*&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT a EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST animal xml:space (default|preserve) 'preserve'&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_attribute_enum_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;?xml version='1.0' standalone='no'?&gt;\n"</literal>
<literal type="string">"&lt;!DOCTYPE animal SYSTEM 'test.dtd'&gt;\n"</literal>
<literal type="string">"&lt;animal&gt;This is a yellow tiger&lt;/animal&gt;"</literal></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;!ELEMENT animal (#PCDATA)*&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST animal thing "</literal>
<literal type="string">"(default"</literal>

<literal type="string">"|ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO)"</literal>
<literal type="string">" 'default'&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_implied_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>





<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc a "</literal>

<literal type="string">"(ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN)"</literal>
<literal type="string">" #IMPLIED&gt;\n"</literal>
<literal type="string">"]&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_default_attribute</name></type></decl></parameter>)</parameter_list> <block>{<block_content>





<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"&lt;!ATTLIST doc a "</literal>

<literal type="string">"(ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|BBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|CBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|DBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|EBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|FBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|GBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|HBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|IBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|JBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|KBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|LBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|MBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|NBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|OBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO"</literal>
<literal type="string">"|PBCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMN)"</literal>
<literal type="string">" 'ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNO'"</literal>
<literal type="string">"&gt;\n]&gt;&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetAttlistDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_attlist_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_notation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!NOTATION "</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">" SYSTEM 'http://example.org/n'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY e SYSTEM 'http://example.org/e' NDATA "</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"]&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetEntityDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_entity_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite allocation failures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name>
<operator>!=</operator> <operator>(</operator><name>DUMMY_ENTITY_DECL_HANDLER_FLAG</name> <operator>|</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Entity declaration handler not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_public_notation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!NOTATION note PUBLIC '"</literal>

<literal type="string">"http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"' 'foo'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY e SYSTEM 'http://example.com/e' NDATA note&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"]&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite allocation failures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Notation handler not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_system_notation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!NOTATION note SYSTEM '"</literal>

<literal type="string">"http://example.com/a/long/enough/name/to/trigger/pool/growth/zz/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY e SYSTEM 'http://example.com/e' NDATA note&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT doc EMPTY&gt;\n"</literal>
<literal type="string">"]&gt;\n&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetNotationDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_notation_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite allocation failures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_NOTATION_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Notation handler not called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_nested_groups</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc "</literal>

<literal type="string">"(e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,"</literal>
<literal type="string">"(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?"</literal>
<literal type="string">"))))))))))))))))))))))))))))))))&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;e/&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doce"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler not fired"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_nested_groups</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc "</literal>

<literal type="string">"(e,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,"</literal>
<literal type="string">"(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?,(e?"</literal>
<literal type="string">"))))))))))))))))))))))))))))))))&gt;\n"</literal>
<literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&lt;e/&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharData</name></type> <name>storage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CharData_Init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetStartElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>record_element_start_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>CharData_CheckXMLChars</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage</name></expr></argument>, <argument><expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"doce"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler not fired"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_large_group</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc ("</literal>
<literal type="string">"a1|a2|a3|a4|a5|a6|a7|a8|"</literal>
<literal type="string">"b1|b2|b3|b4|b5|b6|b7|b8|"</literal>
<literal type="string">"c1|c2|c3|c4|c5|c6|c7|c8|"</literal>
<literal type="string">"d1|d2|d3|d4|d5|d6|d7|d8|"</literal>
<literal type="string">"e1"</literal>
<literal type="string">")+&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\n"</literal>
<literal type="string">"&lt;a1/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler flag not raised"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_group_choice</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">"&lt;!ELEMENT doc ("</literal>
<literal type="string">"a1|a2|a3|a4|a5|a6|a7|a8|"</literal>
<literal type="string">"b1|b2|b3|b4|b5|b6|b7|b8|"</literal>
<literal type="string">"c1|c2|c3|c4|c5|c6|c7|c8|"</literal>
<literal type="string">"d1|d2|d3|d4|d5|d6|d7|d8|"</literal>
<literal type="string">"e1"</literal>
<literal type="string">")+&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;\n"</literal>
<literal type="string">"&lt;a1/&gt;\n"</literal>
<literal type="string">"&lt;b2 attr='foo'&gt;This is a foo&lt;/b2&gt;\n"</literal>
<literal type="string">"&lt;c3&gt;&lt;/c3&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementDeclHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_element_decl_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_ELEMENT_DECL_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Element handler flag not raised"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_pi_in_epilog</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal>
<literal type="string">"&lt;?pi in epilog?&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetProcessingInstructionHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_pi_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse completed despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_PI_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Processing instruction handler not invoked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_comment_in_epilog</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;&lt;/doc&gt;\n"</literal>
<literal type="string">"&lt;!-- comment in epilog --&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetCommentHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_comment_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dummy_handler_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse completed despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dummy_handler_flags</name> <operator>!=</operator> <name>DUMMY_COMMENT_HANDLER_FLAG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Processing instruction handler not invoked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_long_attribute_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [&lt;!ENTITY foo '"</literal>

<literal type="string">"This entity will be substituted as an attribute value, and is "</literal>
<literal type="string">"calculated to be exactly long enough that the terminating NUL "</literal>
<literal type="string">"that the library adds internally will trigger the string pool to"</literal>
<literal type="string">"grow. GHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc a='&amp;foo;'&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_attribute_whitespace</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc a=' '&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_attribute_predefined_entity</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc a='&amp;amp;'&gt;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>





<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_attr_default_with_char_ref</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [&lt;!ATTLIST doc a CDATA '"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHI"</literal>
<literal type="string">"&amp;#x31;'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_attr_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE test [&lt;!ENTITY foo '\n"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;]&gt;\n"</literal>
<literal type="string">"&lt;test a='&amp;foo;'/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>






<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_nested_entities</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/one.ent'&gt;\n"</literal>
<literal type="string">"&lt;doc /&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtFaults</name></type> <name>test_data</name>
<init>= <expr><block>{<expr><literal type="string">"&lt;!ENTITY % pe1 '"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&lt;!ENTITY % pe2 '%pe1;'&gt;\n"</literal>
<literal type="string">"%pe2;"</literal></expr>,
<expr><literal type="string">"Memory Fail not faulted"</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>XML_ERROR_NO_MEMORY</name></expr>}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>test_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_faulter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expect_failure</name><argument_list>(<argument><expr><name>text</name></expr></argument>, <argument><expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr></argument>,
<argument><expr><literal type="string">"Entity allocation failure not noted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_param_entity_newline</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;!ENTITY % pe '&lt;!ATTLIST doc att CDATA \""</literal>

<literal type="string">"This default value is carefully crafted so that the carriage "</literal>
<literal type="string">"return right at the end of the entity string causes an internal "</literal>
<literal type="string">"string pool to have to grow. This allows us to test the alloc "</literal>
<literal type="string">"failure path from that point. OPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDE"</literal>
<literal type="string">"\"&gt;\n'&gt;"</literal>
<literal type="string">"%pe;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_ce_extends_pe</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;doc/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dtd_text</name><index>[]</index></name>
<init>= <expr><literal type="string">"&lt;!ENTITY % pe '&lt;!ATTLIST doc att CDATA \""</literal>

<literal type="string">"This default value is carefully crafted so that the character "</literal>
<literal type="string">"entity at the end causes an internal string pool to have to "</literal>
<literal type="string">"grow. This allows us to test the allocation failure path from "</literal>
<literal type="string">"that point onwards. EFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFG&amp;#x51;"</literal>
<literal type="string">"\"&gt;\n'&gt;"</literal>
<literal type="string">"%pe;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dtd_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_realloc_attributes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ATTLIST doc\n"</literal>
<literal type="string">" a1 (a|b|c) 'a'\n"</literal>
<literal type="string">" a2 (foo|bar) #IMPLIED\n"</literal>
<literal type="string">" a3 NMTOKEN #IMPLIED\n"</literal>
<literal type="string">" a4 NMTOKENS #IMPLIED\n"</literal>
<literal type="string">" a5 ID #IMPLIED\n"</literal>
<literal type="string">" a6 IDREF #IMPLIED\n"</literal>
<literal type="string">" a7 IDREFS #IMPLIED\n"</literal>
<literal type="string">" a8 ENTITY #IMPLIED\n"</literal>
<literal type="string">" a9 ENTITIES #IMPLIED\n"</literal>
<literal type="string">" a10 CDATA #IMPLIED\n"</literal>
<literal type="string">" &gt;]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;wombat&lt;/doc&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse succeeded despite failing reallocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parse failed at maximum reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_doc_name</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>=

<expr><literal type="string">"&lt;LongRootElementNameThatWillCauseTheNextAllocationToExpandTheStr"</literal>
<literal type="string">"ingPoolForTheDTDQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">" a='1'/&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_base</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY e SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;e;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>entity_text</name><index>[]</index></name> <init>= <expr><literal type="string">"Hello world"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name> <init>=


<macro><name>XCS</name><argument_list>(<argument><literal type="string">"LongBaseURI/that/will/overflow/an/internal/buffer/and/cause/it/t"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"o/have/to/grow/PQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_SetBase</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_public_id</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY e PUBLIC '"</literal>

<literal type="string">"LongPublicIDThatShouldResultInAnInternalStringPoolGrowingAtASpec"</literal>
<literal type="string">"ificMomentKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"' 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;e;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>entity_text</name><index>[]</index></name> <init>= <expr><literal type="string">"Hello world"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_entity_value</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ENTITY e1 '"</literal>

<literal type="string">"Long entity value that should provoke a string pool to grow whil"</literal>
<literal type="string">"e setting up to parse the external entity below. xyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY e2 SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;e2;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>entity_text</name><index>[]</index></name> <init>= <expr><literal type="string">"Hello world"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>entity_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_alloc_long_notation</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!NOTATION note SYSTEM '"</literal>

<literal type="string">"ALongNotationNameThatShouldProvokeStringPoolGrowthWhileCallingAn"</literal>
<literal type="string">"ExternalEntityParserUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY e1 SYSTEM 'foo' NDATA "</literal>

<literal type="string">"ALongNotationNameThatShouldProvokeStringPoolGrowthWhileCallingAn"</literal>
<literal type="string">"ExternalEntityParserUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AB"</literal>
<literal type="string">"&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY e2 SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;e2;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"Entity Foo"</literal></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"Entity Bar"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>alloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>void</name></type>
<name>nsalloc_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name></type> <name>memsuite</name> <init>= <expr><block>{<expr><name>duff_allocator</name></expr>, <expr><name>duff_reallocator</name></expr>, <expr><name>free</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>ns_sep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">' '</literal></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>REALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>g_parser</name> <operator>=</operator> <call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memsuite</name></expr></argument>, <argument><expr><name>ns_sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>g_parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parser not created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>nsalloc_teardown</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>basic_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<macro><name>START_TEST</name><argument_list>(<argument>test_nsalloc_xmlns</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc xmlns='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns=''/&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>XML_SetDefaultHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>dummy_default_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>





<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at maximum allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_parse_buffer</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;doc&gt;Hello&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>



<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Pre-init XML_ParseBuffer not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Pre-init XML_ParseBuffer faulted for wrong reason"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>ALLOC_ALWAYS_SUCCEED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Resuming unsuspended parser not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NOT_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>clearing_aborting_character_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resumable</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Could not acquire parse buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspended XML_ParseBuffer not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Suspended XML_GetBuffer not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ResumeParser</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Post-finishing XML_ParseBuffer not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>XML_ERROR_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Post-finishing XML_GetBuffer not faulted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":foo xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":foo&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_uri</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"' bar:a='12'\n"</literal>
<literal type="string">"xmlns:bar='http://example.org/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789A/"</literal>
<literal type="string">"'&gt;"</literal>
<literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_attr</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' bar:"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"='12'\n"</literal>
<literal type="string">"xmlns:bar='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_attr_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' "</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":a='12'\n"</literal>
<literal type="string">"xmlns:"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name><name>elemstr</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"http://example.org/ e foo"</literal></expr></argument>)</argument_list></call></expr>,
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/ a "</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal></argument>)</argument_list></macro>

}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>elemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>triplet_start_checker</name></expr></argument>, <argument><expr><name>triplet_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_attributes</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;foo:e xmlns:foo='http://example.org/' bar:a='12'\n"</literal>
<literal type="string">" xmlns:bar='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/foo:e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_element</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;foo:thisisalongenoughelementnametotriggerareallocation\n"</literal>
<literal type="string">" xmlns:foo='http://example.org/' bar:a='12'\n"</literal>
<literal type="string">" xmlns:bar='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/foo:thisisalongenoughelementnametotriggerareallocation&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name><name>elemstr</name><index>[]</index></name>
<init>= <expr><block>{<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">" thisisalongenoughelementnametotriggerareallocation foo"</literal></expr></argument>)</argument_list></call></expr>,
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"http://example.org/ a bar"</literal></argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetReturnNSTriplet</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>elemstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>triplet_start_checker</name></expr></argument>, <argument><expr><name>triplet_end_checker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>











<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_binding_uri</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><literal type="string">"&lt;doc xmlns='http://example.org/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns='' /&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>second</name>
<init>= <expr><literal type="string">"&lt;doc xmlns='http://example.org/long/enough/URI/to/reallocate/'&gt;\n"</literal>
<literal type="string">" &lt;e xmlns='' /&gt;\n"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xml_failure</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserReset</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>second</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>second</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":foo xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":foo&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>


<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_longer_prefix</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"Q:foo xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"Q='http://example.org/'&gt;"</literal>
<literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"Q:foo&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_namespace</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name>
<init>= <expr><literal type="string">"&lt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":e xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"='http://example.org/'&gt;\n"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name>
<init>= <expr><literal type="string">"&lt;"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":f "</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":attr='foo'/&gt;\n"</literal>
<literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">":e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name>
<operator>&amp;&amp;</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_less_long_namespace</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"</literal>
<literal type="string">":e xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"</literal>
<literal type="string">"='http://example.org/'&gt;\n"</literal>
<literal type="string">"&lt;"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"</literal>
<literal type="string">":f "</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"</literal>
<literal type="string">":att='foo'/&gt;\n"</literal>
<literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789AZ"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678"</literal>
<literal type="string">":e&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_context</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ATTLIST doc baz ID #REQUIRED&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKL"</literal>
<literal type="string">"' baz='2'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;e/&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">70</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>




<specifier>static</specifier> <name>void</name></type>
<name>context_realloc_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;e/&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<macro><name>START_TEST</name><argument_list>(<argument>test_nsalloc_realloc_long_context</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKL"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_2</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJK"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_3</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGH"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_4</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_5</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABC"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_6</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_7</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLM"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>context_realloc_test</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_ge_name</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY "</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">" SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc xmlns='http://example.org/baz'&gt;\n"</literal>
<literal type="string">"&amp;"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">";"</literal>
<literal type="string">"&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;!ELEMENT el EMPTY&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;el/&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>






<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_realloc_long_context_in_dtd</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text1</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE "</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">":doc [\n"</literal>
<literal type="string">" &lt;!ENTITY First SYSTEM 'foo/First'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">":doc xmlns:"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"='foo/Second'&gt;&amp;First;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text2</name>
<init>= <expr><literal type="string">"&lt;/"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">":doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo/First"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"Hello world"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_realloc_count</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_realloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>reallocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text1</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name>
<operator>&amp;&amp;</operator> <call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text2</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing reallocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_realloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max reallocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_default_in_ext</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc [\n"</literal>
<literal type="string">" &lt;!ATTLIST e a1 CDATA '"</literal>

<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY x SYSTEM 'foo'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;x;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;e/&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>

<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_long_systemid_in_ext</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name>
<init>= <expr><literal type="string">"&lt;!DOCTYPE doc SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM '"</literal>

<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal>
<literal type="string">"'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;doc&gt;&amp;en;&lt;/doc&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal></expr>}</block></expr>,
<expr><block>{
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<macro><name>XCS</name><argument_list>(<argument><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></argument>)</argument_list></macro>
<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/ABCDEFGHIJKLMNO/"</literal></expr></argument>)</argument_list></call></expr>,

<expr><literal type="string">"&lt;e/&gt;"</literal></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">55</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing worked despite failing allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Parsing failed even at max allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name></type>




<name>START_TEST</name><parameter_list>(<parameter><decl><type><name>test_nsalloc_prefixed_element</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><literal type="string">"&lt;!DOCTYPE pfx:element SYSTEM 'foo' [\n"</literal>
<literal type="string">" &lt;!ATTLIST pfx:element baz ID #REQUIRED&gt;\n"</literal>
<literal type="string">" &lt;!ENTITY en SYSTEM 'bar'&gt;\n"</literal>
<literal type="string">"]&gt;\n"</literal>
<literal type="string">"&lt;pfx:element xmlns:pfx='http://example.org/' baz='2'&gt;\n"</literal>
<literal type="string">"&amp;en;"</literal>
<literal type="string">"&lt;/pfx:element&gt;"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExtOption</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;!ELEMENT e EMPTY&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><call><name>XCS</name><argument_list>(<argument><expr><literal type="string">"bar"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="string">"&lt;e/&gt;"</literal></expr>}</block></expr>, <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_alloc_count</name> <init>= <expr><literal type="number">70</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_alloc_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>allocation_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>XML_PARAM_ENTITY_PARSING_ALWAYS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XML_SetExternalEntityRefHandler</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>external_entity_optioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_XML_Parse_SINGLE_BYTES</name><argument_list>(<argument><expr><name>g_parser</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_STATUS_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>nsalloc_teardown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nsalloc_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Success despite failing allocator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>max_alloc_count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fail</name><argument_list>(<argument><expr><literal type="string">"Failed even at full allocation count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>END_TEST</name>

<specifier>static</specifier> <name>Suite</name> <modifier>*</modifier></type>
<name>make_suite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Suite</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>suite_create</name><argument_list>(<argument><expr><literal type="string">"basic"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCase</name> <modifier>*</modifier></type><name>tc_basic</name> <init>= <expr><call><name>tcase_create</name><argument_list>(<argument><expr><literal type="string">"basic tests"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCase</name> <modifier>*</modifier></type><name>tc_namespace</name> <init>= <expr><call><name>tcase_create</name><argument_list>(<argument><expr><literal type="string">"XML namespaces"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCase</name> <modifier>*</modifier></type><name>tc_misc</name> <init>= <expr><call><name>tcase_create</name><argument_list>(<argument><expr><literal type="string">"miscellaneous tests"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCase</name> <modifier>*</modifier></type><name>tc_alloc</name> <init>= <expr><call><name>tcase_create</name><argument_list>(<argument><expr><literal type="string">"allocation tests"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TCase</name> <modifier>*</modifier></type><name>tc_nsalloc</name> <init>= <expr><call><name>tcase_create</name><argument_list>(<argument><expr><literal type="string">"namespace allocation tests"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>suite_add_tcase</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tc_basic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_checked_fixture</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>basic_setup</name></expr></argument>, <argument><expr><name>basic_teardown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_nul_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_u0000_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_siphash_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_siphash_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bom_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bom_utf16_be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bom_utf16_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_nobom_utf16_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_illegal_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf8_auto_align</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_le_epilog_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_not_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_latin1_umlauts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_long_utf8_character</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_long_latin1_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_long_ascii_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_danish_latin1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_french_charref_hexidecimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_french_charref_decimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_french_latin1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_french_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf8_false_rejection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_line_number_after_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_column_number_after_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_line_and_column_numbers_inside_handlers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_line_number_after_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_column_number_after_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_really_long_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_really_long_encoded_lines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_end_element_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_attr_whitespace_normalization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_xmldecl_misplaced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_xmldecl_invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_xmldecl_missing_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_xmldecl_missing_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_internal_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unrecognised_encoding_internal_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_wfc_undeclared_entity_unread_external_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_wfc_undeclared_entity_no_external_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_wfc_undeclared_entity_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_wfc_undeclared_entity_with_external_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_not_standalone_handler_reject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_not_standalone_handler_accept</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>,
<argument><expr><name>test_wfc_undeclared_entity_with_external_subset_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_entity_with_external_subset_unless_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_wfc_no_recursive_entity_refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_set_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_no_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_set_bom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_bad_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_bad_encoding_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_invalid_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_invalid_suspended_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_dtd_default_handling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_dtd_attr_handling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_empty_ns_without_namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ns_in_attribute_default_without_namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_stop_parser_between_char_data_calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_parser_between_char_data_calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_repeated_stop_parser_between_char_data_calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_good_cdata_ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_good_cdata_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_good_cdata_utf16_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_long_cdata_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_multichar_cdata_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_bad_surrogate_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_cdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_cdata_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_stop_parser_between_cdata_calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_parser_between_cdata_calls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_memory_allocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_default_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_dtd_elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_set_foreign_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_foreign_dtd_not_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_foreign_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_foreign_dtd_with_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_foreign_dtd_without_external_subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_empty_foreign_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_set_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_reset_in_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_resume_invalid_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_resume_resuspended</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_cdata_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_subordinate_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_subordinate_suspend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_subordinate_xdecl_suspend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_subordinate_xdecl_abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_explicit_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_trailing_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_trailing_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_trailing_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_trailing_rsqb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_good_cdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_user_parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_ref_parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_empty_parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_get_buffer_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_get_buffer_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_byte_info_at_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_byte_info_at_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_byte_info_at_cdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_predefined_entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_tag_in_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_not_predefined_entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ignore_section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ignore_section_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ignore_section_utf16_be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_ignore_section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_external_entity_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_not_standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_value_abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_public_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_attribute_enum_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_predefined_entity_redefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_dtd_stop_processing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_public_notation_no_sysid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_nested_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_group_choice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_standalone_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_skipped_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_recursive_external_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_undefined_ext_entity_in_external_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_xdecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_abort_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_abort_epilog_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_in_sole_empty_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unfinished_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_partial_char_in_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_hash_collision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_resume_internal_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_resume_entity_with_syntax_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_suspend_resume_parameter_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_restart_on_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_reject_lt_in_attribute_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_reject_unfinished_param_in_att_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_trailing_cr_in_att_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_standalone_internal_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_skipped_external_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_skipped_null_loaded_ext_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_skipped_unloaded_ext_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_param_entity_with_trailing_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_character_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_character_entity_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_character_entity_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_character_entity_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_pi_handled_in_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_comment_handled_in_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_pi_yml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_pi_xnl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_pi_xmm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_be_pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_be_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_le_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_missing_encoding_conversion_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_failing_encoding_conversion_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_bad_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_bad_name_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_long_name_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_long_name_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_invalid_unknown_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_ascii_encoding_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_ascii_encoding_fail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_invalid_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_invalid_topbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_invalid_surrogate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_invalid_high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_invalid_attr_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_latin1_utf16le_bom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_latin1_utf16be_bom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_latin1_utf16le_bom2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_latin1_utf16be_bom2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_utf16_be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_utf16_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_utf16_unknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_ext_entity_utf8_non_bom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf8_in_cdata_section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf8_in_cdata_section_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_trailing_spaces_in_elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_second_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_attr_after_solidus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_utf16_pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_attr_desc_keyword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_attr_desc_keyword_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_doctype_utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_doctype_plus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_doctype_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_doctype_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_unknown_encoding_bad_ignore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_entity_in_utf16_be_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_entity_in_utf16_le_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_entity_public_utf16_be</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_entity_public_utf16_le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_short_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_short_doctype_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_short_doctype_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_long_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_entity_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_entity_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_entity_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_bad_notation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_default_doctype_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_basic</name></expr></argument>, <argument><expr><name>test_empty_element_abort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>suite_add_tcase</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tc_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_checked_fixture</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>namespace_setup</name></expr></argument>, <argument><expr><name>namespace_teardown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_return_ns_triplet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_tagname_overwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_tagname_overwrite_triplet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_start_ns_clears_start_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_default_ns_from_ext_subset_and_ext_ge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_prefix_with_empty_uri_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_prefix_with_empty_uri_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_prefix_with_empty_uri_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_prefix_with_empty_uri_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_unbound_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_default_with_empty_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_duplicate_attrs_diff_prefixes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_duplicate_hashes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_unbound_prefix_on_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_unbound_prefix_on_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_parser_reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_long_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_mixed_prefix_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_extend_uri_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_reserved_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_reserved_attributes_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_extremely_long_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_unknown_encoding_success</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_double_colon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_double_colon_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_bad_attr_leafname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_bad_element_leafname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_utf16_leafname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_utf16_element_leafname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_utf16_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_invalid_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_namespace</name></expr></argument>, <argument><expr><name>test_ns_double_colon_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>suite_add_tcase</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tc_misc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_checked_fixture</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>basic_teardown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_alloc_create_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_alloc_create_parser_with_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_null_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_error_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_features</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_attribute_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_utf16le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_stop_during_end_handler_issue_240_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>, <argument><expr><name>test_misc_stop_during_end_handler_issue_240_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_misc</name></expr></argument>,
<argument><expr><name>test_misc_deny_internal_entity_closing_doctype_issue_317</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>suite_add_tcase</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tc_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_checked_fixture</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>alloc_setup</name></expr></argument>, <argument><expr><name>alloc_teardown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_xdecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_xdecl_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_pi_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_pi_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_comment_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_create_external_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_run_external_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_dtd_copy_default_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_external_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_ext_entity_set_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_internal_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_dtd_default_handling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_explicit_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_set_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_ext_entity_realloc_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_many_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_public_entity_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_subst_public_entity_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_public_doctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_parse_public_doctype_long_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_set_foreign_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_attribute_enum_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_attribute_enum_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_implied_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_default_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_notation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_public_notation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_system_notation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_nested_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_nested_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_large_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_group_choice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_pi_in_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_comment_in_epilog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_long_attribute_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_attribute_whitespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_attribute_predefined_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_attr_default_with_char_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_attr_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_nested_entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_param_entity_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_ce_extends_pe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_realloc_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_doc_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_public_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_entity_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_alloc</name></expr></argument>, <argument><expr><name>test_alloc_long_notation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>suite_add_tcase</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tc_nsalloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_checked_fixture</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>nsalloc_setup</name></expr></argument>, <argument><expr><name>nsalloc_teardown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_xmlns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_parse_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_attr_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_attributes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_binding_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_longer_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_less_long_namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_ge_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_realloc_long_context_in_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_default_in_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_long_systemid_in_ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tcase_add_test</name><argument_list>(<argument><expr><name>tc_nsalloc</name></expr></argument>, <argument><expr><name>test_nsalloc_prefixed_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>verbosity</name> <init>= <expr><name>CK_NORMAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Suite</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>make_suite</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SRunner</name> <modifier>*</modifier></type><name>sr</name> <init>= <expr><call><name>srunner_create</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>testhelper_is_whitespace_normalized</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"-v"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--verbose"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>verbosity</name> <operator>=</operator> <name>CK_VERBOSE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"-q"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--quiet"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>verbosity</name> <operator>=</operator> <name>CK_SILENT</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"runtests: unknown option '%s'\n"</literal></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>!=</operator> <name>CK_SILENT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Expat version: %"</literal> <name>XML_FMT_STR</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><call><name>XML_ExpatVersion</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>srunner_run_all</name><argument_list>(<argument><expr><name>sr</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nf</name> <operator>=</operator> <call><name>srunner_ntests_failed</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>srunner_free</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>nf</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
</unit>
