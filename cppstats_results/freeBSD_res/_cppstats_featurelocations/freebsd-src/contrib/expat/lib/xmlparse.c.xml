<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/expat/lib/xmlparse.c">































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_GNU_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_CRT_RAND_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_RAND_S</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getpid</name></cpp:macro> <cpp:value>GetCurrentProcessId</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_BUILDING_EXPAT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXPAT_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat_config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ascii.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"siphash.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_GETRANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/random.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/syscall.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>GRND_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRND_NONBLOCK</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBBSD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bsd/stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LOAD_LIBRARY_SEARCH_SYSTEM32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOAD_LIBRARY_SEARCH_SYSTEM32</name></cpp:macro> <cpp:value>0x00000800</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_GETRANDOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_DEV_URANDOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_POOR_ENTROPY</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:error>#<cpp:directive>error</cpp:directive> You do not have support for any sources of high quality entropy enabled. For end user security, that is probably not what you want. Your options include: * Linux + glibc &gt;=2.25 (getrandom): HAVE_GETRANDOM, * Linux + glibc &lt;2.25 (syscall SYS_getrandom): HAVE_SYSCALL_GETRANDOM, * BSD / macOS &gt;=10.7 (arc4random_buf): HAVE_ARC4RANDOM_BUF, * BSD / macOS &lt;10.7 (arc4random): HAVE_ARC4RANDOM, * libbsd (arc4random_buf): HAVE_ARC4RANDOM_BUF + HAVE_LIBBSD, * libbsd (arc4random): HAVE_ARC4RANDOM + HAVE_LIBBSD, * Linux / BSD / macOS (/dev/urandom): XML_DEV_URANDOM * Windows (rand_s): _WIN32. If insist on not using any of these, bypass this error by defining XML_POOR_ENTROPY; you have been warned. If you have reasons to patch this detection code away or need changes to the build system, please open a bug. Thank you!</cpp:error>

















<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ENCODE_MAX</name></cpp:macro> <cpp:value>XML_UTF16_ENCODE_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlConvert</name></cpp:macro> <cpp:value>XmlUtf16Convert</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncoding</name></cpp:macro> <cpp:value>XmlGetUtf16InternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetUtf16InternalEncodingNS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlEncode</name></cpp:macro> <cpp:value>XmlUtf16Encode</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_CONVERT</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(! (enc)-&gt;isUtf16 || (((char *)(s) - (char *)NULL) &amp; 1))</cpp:value></cpp:define>

<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>ICHAR</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ENCODE_MAX</name></cpp:macro> <cpp:value>XML_UTF8_ENCODE_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlConvert</name></cpp:macro> <cpp:value>XmlUtf8Convert</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncoding</name></cpp:macro> <cpp:value>XmlGetUtf8InternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetUtf8InternalEncodingNS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlEncode</name></cpp:macro> <cpp:value>XmlUtf8Encode</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_CONVERT</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(! (enc)-&gt;isUtf8)</cpp:value></cpp:define>
<typedef>typedef <type><name>char</name></type> <name>ICHAR</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlInitEncodingNS</name></cpp:macro> <cpp:value>XmlInitEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlInitUnknownEncodingNS</name></cpp:macro> <cpp:value>XmlInitUnknownEncoding</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XmlGetInternalEncodingNS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetInternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlParseXmlDeclNS</name></cpp:macro> <cpp:value>XmlParseXmlDecl</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(const wchar_t) x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>L##x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(const unsigned short)x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND_UP</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n) + ((sz)-1)) &amp; ~((sz)-1))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAT_SAFE_PTR_DIFF</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>q</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((p) &amp;&amp; (q)) ? ((p) - (q)) : 0)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmlrole.h"</cpp:file></cpp:include>

<typedef>typedef <type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>KEY</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>KEY</name></type> <name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>NAMED</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NAMED</name> <modifier>*</modifier><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>power</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>
}</block></struct></type> <name>HASH_TABLE</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>keylen</name><parameter_list>(<parameter><decl><type><name>KEY</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_salt_to_sipkey</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sipkey</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECOND_HASH</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>, <parameter><type><name>power</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((hash) &amp; ~(mask)) &gt;&gt; ((power)-1)) &amp; ((mask) &gt;&gt; 2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROBE_STEP</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>, <parameter><type><name>power</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NAMED</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NAMED</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
}</block></struct></type> <name>HASH_TABLE_ITER</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_TAG_BUF_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_DATA_BUF_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ATTS_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ATTS_VERSION</name></cpp:macro> <cpp:value>0xFFFFFFFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_BLOCK_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_BUFFER_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_SPARE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>binding</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>prefix</name></name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>binding</name></name> <modifier>*</modifier></type><name>nextTagBinding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>binding</name></name> <modifier>*</modifier></type><name>prevPrefixBinding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>attribute_id</name></name> <modifier>*</modifier></type><name>attId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriAlloc</name></decl>;</decl_stmt>
}</block></struct></type> <name>BINDING</name>;</typedef>

<typedef>typedef <type><struct>struct <name>prefix</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>binding</name></decl>;</decl_stmt>
}</block></struct></type> <name>PREFIX</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>localPart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefixLen</name></decl>;</decl_stmt>
}</block></struct></type> <name>TAG_NAME</name>;</typedef>














<typedef>typedef <type><struct>struct <name>tag</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>tag</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rawNameLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG_NAME</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bufEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name></decl>;</decl_stmt>
}</block></struct></type> <name>TAG</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>textPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>textLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>processed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>notation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>open</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>is_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>is_internal</name></decl>;</decl_stmt>
}</block></struct></type> <name>ENTITY</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Content_Type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Content_Quant</name></name></type> <name>quant</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstchild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lastchild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>childcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextsib</name></decl>;</decl_stmt>
}</block></struct></type> <name>CONTENT_SCAFFOLD</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SCAFFOLD_ELEMENTS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>block</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BLOCK</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>freeBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>
}</block></struct></type> <name>STRING_POOL</name>;</typedef>



<typedef>typedef <type><struct>struct <name>attribute_id</name> <block>{
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>maybeTokenized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>xmlns</name></decl>;</decl_stmt>
}</block></struct></type> <name>ATTRIBUTE_ID</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>DEFAULT_ATTRIBUTE</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uriName</name></decl>;</decl_stmt>
}</block></struct></type> <name>NS_ATT</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>idAtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allocDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> <modifier>*</modifier></type><name>defaultAtts</name></decl>;</decl_stmt>
}</block></struct></type> <name>ELEMENT_TYPE</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>generalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>elementTypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>attributeIds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>prefixes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>entityValuePool</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>XML_Bool</name></type> <name>keepProcessing</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hasParamEntityRefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>standalone</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>XML_Bool</name></type> <name>paramEntityRead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>paramEntities</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PREFIX</name></type> <name>defaultPrefix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>XML_Bool</name></type> <name>in_eldecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> <modifier>*</modifier></type><name>scaffold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>contentStringLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>scaffSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>scaffCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scaffLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>scaffIndex</name></decl>;</decl_stmt>
}</block></struct></type> <name>DTD</name>;</typedef>

<typedef>typedef <type><struct>struct <name>open_internal_entity</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>internalEventPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>internalEventEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>open_internal_entity</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startTagLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name></decl>;</decl_stmt>
}</block></struct></type> <name>OPEN_INTERNAL_ENTITY</name>;</typedef>

<typedef>typedef <function_decl><type><name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type> <name>Processor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>prologProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>prologInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>contentProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>cdataSectionProcessor</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>ignoreSectionProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalParEntProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalParEntInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>entityValueProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>entityValueInitProcessor</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>epilogProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>errorProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityContentProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>internalEntityProcessor</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>handleUnknownEncoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>processXmlDecl</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>initializeEncoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>doProlog</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>allowClosingDoctype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>processInternalEntity</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>doContent</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startTagLevel</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>doCdataSection</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>startPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>doIgnoreSection</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>startPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freeBindings</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>storeAtts</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>TAG_NAME</name> <modifier>*</modifier></type><name>tagNamePtr</name></decl></parameter>,
<parameter><decl><type><name>BINDING</name> <modifier>*</modifier><modifier>*</modifier></type><name>bindingsPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>addBinding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>attId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>,
<parameter><decl><type><name>BINDING</name> <modifier>*</modifier><modifier>*</modifier></type><name>bindingsPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>defineAttribute</name><parameter_list>(<parameter><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>isId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>dfltValue</name></decl></parameter>,
<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>storeAttributeValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>appendAttributeValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>getAttributeId</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>setElementTypePrefix</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type> <name>storeEntityValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>reportProcessingInstruction</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>reportComment</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reportDefault</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>getContext</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Bool</name></type> <name>setContext</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>normalizePublicId</name><parameter_list>(<parameter><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DTD</name> <modifier>*</modifier></type><name>dtdCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dtdReset</name><parameter_list>(<parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dtdDestroy</name><parameter_list>(<parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isDocEntity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>dtdCopy</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></parameter>, <parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>newDtd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DTD</name> <modifier>*</modifier></type><name>oldDtd</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>copyEntityTable</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></parameter>, <parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NAMED</name> <modifier>*</modifier></type><name>lookup</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>KEY</name></type> <name>name</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>createSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableInit</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableClear</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableDestroy</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableIterInit</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE_ITER</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HASH_TABLE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NAMED</name> <modifier>*</modifier><name>FASTCALL</name></type> <name>hashTableIterNext</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE_ITER</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>poolInit</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>poolClear</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>poolDestroy</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>poolAppend</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>poolStoreString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Bool</name> <name>FASTCALL</name></type> <name>poolGrow</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><name>FASTCALL</name></type> <name>poolCopyString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>poolCopyStringN</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><name>FASTCALL</name></type> <name>poolAppendString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type> <name>nextScaffoldPart</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Content</name> <modifier>*</modifier></type><name>build_model</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>getElementType</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>copyString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>memsuite</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>generate_hash_secret_salt</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Bool</name></type> <name>startParsing</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>XML_Parser</name></type> <name>parserCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>memsuite</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>nameSep</name></decl></parameter>, <parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>dtd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parserInit</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolStart</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolEnd</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolLength</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr - (pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolChop</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)--(pool-&gt;ptr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolLastChar</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((pool)-&gt;ptr)[-1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolDiscard</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr = (pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolFinish</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;start = (pool)-&gt;ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolAppendChar</name><parameter_list>(<parameter><type><name>pool</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((pool)-&gt;ptr == (pool)-&gt;end &amp;&amp; ! poolGrow(pool)) ? 0 : ((*((pool)-&gt;ptr)++ = c), 1))</cpp:value></cpp:define>




<struct>struct <name>XML_ParserStruct</name> <block>{


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_userData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_handlerArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>m_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name></type> <name>m_mem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_bufferPtr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>m_bufferEnd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_bufferLim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Index</name></type> <name>m_parseEndByteIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_parseEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>m_dataBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>m_dataBufEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartElementHandler</name></type> <name>m_startElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndElementHandler</name></type> <name>m_endElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>m_characterDataHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>m_processingInstructionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CommentHandler</name></type> <name>m_commentHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>m_startCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>m_endCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_DefaultHandler</name></type> <name>m_defaultHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>m_startDoctypeDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>m_endDoctypeDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>m_unparsedEntityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotationDeclHandler</name></type> <name>m_notationDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>m_startNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>m_endNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotStandaloneHandler</name></type> <name>m_notStandaloneHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>m_externalEntityRefHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>m_externalEntityRefHandlerArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_SkippedEntityHandler</name></type> <name>m_skippedEntityHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>m_unknownEncodingHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ElementDeclHandler</name></type> <name>m_elementDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_AttlistDeclHandler</name></type> <name>m_attlistDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EntityDeclHandler</name></type> <name>m_entityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_XmlDeclHandler</name></type> <name>m_xmlDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>m_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>INIT_ENCODING</name></type> <name>m_initEncoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>m_internalEncoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_protocolEncodingName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_ns_triplets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_unknownEncodingMem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_unknownEncodingData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_unknownEncodingHandlerData</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type>(<name>XMLCALL</name> <modifier>*</modifier><name>m_unknownEncodingRelease</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PROLOG_STATE</name></type> <name>m_prologState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Processor</name> <modifier>*</modifier></type><name>m_processor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>m_errorCode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_eventPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_eventEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m_positionPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>m_openInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>m_freeInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_defaultExpandInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_tagLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>m_declEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_doctypeName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_doctypeSysid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_doctypePubid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_declAttributeType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_declNotationName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_declNotationPublicId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>m_declElementType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>m_declAttributeId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_declAttributeIsCdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_declAttributeIsId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier></type><name>m_dtd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>m_curBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>m_tagStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>m_freeTagList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>m_inheritedBindings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>m_freeBindingList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_attsSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_nSpecifiedAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_idAttIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE</name> <modifier>*</modifier></type><name>m_atts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NS_ATT</name> <modifier>*</modifier></type><name>m_nsAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>m_nsAttsVersion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>m_nsAttsPower</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_AttrInfo</name> <modifier>*</modifier></type><name>m_attInfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>POSITION</name></type> <name>m_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>m_tempPool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>m_temp2Pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>m_groupConnector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m_groupSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>m_namespaceSeparator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>m_parentParser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>m_parsingStatus</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_isParamEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_useForeignDTD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_ParamEntityParsing</name></name></type> <name>m_paramEntityParsing</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>m_hash_secret_salt</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC</name><parameter_list>(<parameter><type><name>parser</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.malloc_fcn((s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALLOC</name><parameter_list>(<parameter><type><name>parser</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.realloc_fcn((p), (s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE</name><parameter_list>(<parameter><type><name>parser</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.free_fcn((p)))</cpp:value></cpp:define>

<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreateNS</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>, <parameter><decl><type><name>XML_Char</name></type> <name>nsSep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <name>nsSep</name></expr>;</expr_stmt>
<return>return <expr><call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>implicitContext</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_x</name></expr>, <expr><name>ASCII_m</name></expr>, <expr><name>ASCII_l</name></expr>, <expr><name>ASCII_EQUALS</name></expr>, <expr><name>ASCII_h</name></expr>,
<expr><name>ASCII_t</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_p</name></expr>, <expr><name>ASCII_COLON</name></expr>, <expr><name>ASCII_SLASH</name></expr>,
<expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_PERIOD</name></expr>,
<expr><name>ASCII_w</name></expr>, <expr><name>ASCII_3</name></expr>, <expr><name>ASCII_PERIOD</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_r</name></expr>,
<expr><name>ASCII_g</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_X</name></expr>, <expr><name>ASCII_M</name></expr>, <expr><name>ASCII_L</name></expr>,
<expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_9</name></expr>, <expr><name>ASCII_9</name></expr>, <expr><name>ASCII_8</name></expr>,
<expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_m</name></expr>, <expr><name>ASCII_e</name></expr>,
<expr><name>ASCII_s</name></expr>, <expr><name>ASCII_p</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_c</name></expr>, <expr><name>ASCII_e</name></expr>,
<expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_GETRANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>writeRandomBytes_getrandom_nonblock</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWrittenTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>getrandomFlags</name> <init>= <expr><name>GRND_NONBLOCK</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>currentTarget</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>target</name> <operator>+</operator> <name>bytesWrittenTotal</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bytesToWrite</name> <init>= <expr><name>count</name> <operator>-</operator> <name>bytesWrittenTotal</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bytesWrittenMore</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>getrandom</name><argument_list>(<argument><expr><name>currentTarget</name></expr></argument>, <argument><expr><name>bytesToWrite</name></expr></argument>, <argument><expr><name>getrandomFlags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>syscall</name><argument_list>(<argument><expr><name>SYS_getrandom</name></expr></argument>, <argument><expr><name>currentTarget</name></expr></argument>, <argument><expr><name>bytesToWrite</name></expr></argument>, <argument><expr><name>getrandomFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>bytesWrittenMore</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bytesWrittenTotal</name> <operator>+=</operator> <name>bytesWrittenMore</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesWrittenTotal</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>!</operator> <name>success</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>;</do>

<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_DEV_URANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>writeRandomBytes_dev_urandom</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWrittenTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>currentTarget</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>target</name> <operator>+</operator> <name>bytesWrittenTotal</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>bytesToWrite</name> <init>= <expr><name>count</name> <operator>-</operator> <name>bytesWrittenTotal</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ssize_t</name></type> <name>bytesWrittenMore</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>currentTarget</name></expr></argument>, <argument><expr><name>bytesToWrite</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytesWrittenMore</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bytesWrittenTotal</name> <operator>+=</operator> <name>bytesWrittenMore</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesWrittenTotal</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>!</operator> <name>success</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>;</do>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>success</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writeRandomBytes_arc4random</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWrittenTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bytesWrittenTotal</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>random32</name> <init>= <expr><call><name>arc4random</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>random32</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>bytesWrittenTotal</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>bytesWrittenTotal</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>random8</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>random32</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>target</name><operator>)</operator><index>[<expr><name>bytesWrittenTotal</name></expr>]</index> <operator>=</operator> <name>random8</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>writeRandomBytes_rand_s</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesWrittenTotal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bytesWrittenTotal</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>random32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rand_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>random32</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>random32</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>bytesWrittenTotal</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>bytesWrittenTotal</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>random8</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><name>random32</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>target</name><operator>)</operator><index>[<expr><name>bytesWrittenTotal</name></expr>]</index> <operator>=</operator> <name>random8</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>gather_time_entropy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>FILETIME</name></type> <name>ft</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetSystemTimeAsFileTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ft</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>^</operator> <name><name>ft</name><operator>.</operator><name>dwLowDateTime</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gettimeofday_res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>gettimeofday_res</name> <operator>=</operator> <call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>gettimeofday_res</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>gettimeofday_res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<return>return <expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>ENTROPY_DEBUG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>entropy</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>EXPAT_ENTROPY_DEBUG</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"EXPAT_ENTROPY_DEBUG"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>EXPAT_ENTROPY_DEBUG</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>EXPAT_ENTROPY_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Entropy: %s --&gt; 0x%0*lx (%lu bytes)\n"</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>entropy</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>generate_hash_secret_salt</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>entropy</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>parser</name></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>arc4random_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entropy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"arc4random_buf"</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ARC4RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>writeRandomBytes_arc4random</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>entropy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"arc4random"</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>writeRandomBytes_rand_s</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>entropy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"rand_s"</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRANDOM</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_GETRANDOM</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><call><name>writeRandomBytes_getrandom_nonblock</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>entropy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"getrandom"</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XML_DEV_URANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>writeRandomBytes_dev_urandom</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>entropy</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>entropy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"/dev/urandom"</literal></expr></argument>, <argument><expr><name>entropy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr_stmt><expr><name>entropy</name> <operator>=</operator> <call><name>gather_time_entropy</name><argument_list>()</argument_list></call> <operator>^</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr>sizeof<operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"fallback(4)"</literal></expr></argument>, <argument><expr><name>entropy</name> <operator>*</operator> <literal type="number">2147483647</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>ENTROPY_DEBUG</name><argument_list>(<argument><expr><literal type="string">"fallback(8)"</literal></expr></argument>,
<argument><expr><name>entropy</name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><literal type="number">2305843009213693951ULL</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>get_hash_secret_salt</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get_hash_secret_salt</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Bool</name></type>
<name>startParsing</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name> <operator>=</operator> <call><name>generate_hash_secret_salt</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr>)</condition> <block>{<block_content>



<return>return <expr><call><name>setContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>implicitContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreate_MM</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>memsuite</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>nameSep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>memsuite</name></expr></argument>, <argument><expr><name>nameSep</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Parser</name></type>
<name>parserCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>memsuite</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>nameSep</name></decl></parameter>,
<parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>dtd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>memsuite</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>mtemp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <operator>(</operator><name>XML_Parser</name><operator>)</operator><call><name><name>memsuite</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>XML_ParserStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mtemp</name> <operator>=</operator> <operator>(</operator><name>XML_Memory_Handling_Suite</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>malloc_fcn</name></name> <operator>=</operator> <name><name>memsuite</name><operator>-&gt;</operator><name>malloc_fcn</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>realloc_fcn</name></name> <operator>=</operator> <name><name>memsuite</name><operator>-&gt;</operator><name>realloc_fcn</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>free_fcn</name></name> <operator>=</operator> <name><name>memsuite</name><operator>-&gt;</operator><name>free_fcn</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>mtemp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <operator>(</operator><name>XML_Parser</name><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>XML_ParserStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mtemp</name> <operator>=</operator> <operator>(</operator><name>XML_Memory_Handling_Suite</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>malloc_fcn</name></name> <operator>=</operator> <name>malloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>realloc_fcn</name></name> <operator>=</operator> <name>realloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name><operator>-&gt;</operator><name>free_fcn</name></name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>parser</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>parser</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>=</operator> <name>INIT_ATTS_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name>
<operator>=</operator> <operator>(</operator><name>ATTRIBUTE</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name> <operator>=</operator> <operator>(</operator><name>XML_AttrInfo</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_AttrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name>
<operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>INIT_DATA_BUF_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBufEnd</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name> <operator>+</operator> <name>INIT_DATA_BUF_SIZE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dtd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name> <operator>=</operator> <name>dtd</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name> <operator>=</operator> <call><name>dtdCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandlerData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name> <operator>=</operator> <name>ASCII_EXCL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parserInit</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encodingName</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nameSep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name> <operator>=</operator> <call><name>XmlGetInternalEncodingNS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name> <operator>=</operator> <operator>*</operator><name>nameSep</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name> <operator>=</operator> <call><name>XmlGetInternalEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>parser</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parserInit</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>prologInitProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlPrologStateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>encodingName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>=</operator> <call><name>copyString</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlInitEncoding</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_initEncoding</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endDoctypeDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypePubid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsId</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>POSITION</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_inheritedBindings</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nSpecifiedAtts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingData</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_INITIALIZED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name> <operator>=</operator> <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>moveToFreeBindingList</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name>bindings</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bindings</name> <operator>=</operator> <name><name>bindings</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>XML_Bool</name> <name>XMLCALL</name></type>
<name>XML_ParserReset</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tStk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>openEntityList</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tStk</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>tStk</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><name>tStk</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tStk</name> <operator>=</operator> <name><name>tStk</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>moveToFreeBindingList</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>openEntityList</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>openEntityList</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>openEntity</name> <init>= <expr><name>openEntityList</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>openEntityList</name> <operator>=</operator> <name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name>openEntity</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>moveToFreeBindingList</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_inheritedBindings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parserInit</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dtdReset</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_SetEncoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_PARSING</name>
<operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encodingName</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>=</operator> <call><name>copyString</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ExternalEntityParserCreate</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><name>oldParser</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier></type><name>newDtd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier></type><name>oldDtd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartElementHandler</name></type> <name>oldStartElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndElementHandler</name></type> <name>oldEndElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>oldCharacterDataHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>oldProcessingInstructionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CommentHandler</name></type> <name>oldCommentHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>oldStartCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>oldEndCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_DefaultHandler</name></type> <name>oldDefaultHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>oldUnparsedEntityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotationDeclHandler</name></type> <name>oldNotationDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>oldStartNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>oldEndNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotStandaloneHandler</name></type> <name>oldNotStandaloneHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>oldExternalEntityRefHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_SkippedEntityHandler</name></type> <name>oldSkippedEntityHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>oldUnknownEncodingHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ElementDeclHandler</name></type> <name>oldElementDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_AttlistDeclHandler</name></type> <name>oldAttlistDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EntityDeclHandler</name></type> <name>oldEntityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_XmlDeclHandler</name></type> <name>oldXmlDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>oldDeclElementType</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>oldUserData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>oldHandlerArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>oldDefaultExpandInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>oldExternalEntityRefHandlerArg</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_ParamEntityParsing</name></name></type> <name>oldParamEntityParsing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldInEntityValue</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>oldns_triplets</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>oldhash_secret_salt</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>oldParser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>oldDtd</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldStartElementHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldEndElementHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldCharacterDataHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldProcessingInstructionHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldCommentHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldStartCdataSectionHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldEndCdataSectionHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldDefaultHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldUnparsedEntityDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldNotationDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldStartNamespaceDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldEndNamespaceDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldNotStandaloneHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldExternalEntityRefHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldSkippedEntityHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldUnknownEncodingHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldElementDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldAttlistDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldEntityDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldXmlDeclHandler</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldDeclElementType</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>oldUserData</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldHandlerArg</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldDefaultExpandInternalEntities</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldExternalEntityRefHandlerArg</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>oldParamEntityParsing</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldInEntityValue</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>oldns_triplets</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name></expr>;</expr_stmt>





<expr_stmt><expr><name>oldhash_secret_salt</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>context</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newDtd</name> <operator>=</operator> <name>oldDtd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>newDtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newDtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>parser</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name> <operator>=</operator> <name>oldStartElementHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name> <operator>=</operator> <name>oldEndElementHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name> <operator>=</operator> <name>oldCharacterDataHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name> <operator>=</operator> <name>oldProcessingInstructionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name> <operator>=</operator> <name>oldCommentHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name> <operator>=</operator> <name>oldStartCdataSectionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name> <operator>=</operator> <name>oldEndCdataSectionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name> <operator>=</operator> <name>oldDefaultHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name> <operator>=</operator> <name>oldUnparsedEntityDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name> <operator>=</operator> <name>oldNotationDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name> <operator>=</operator> <name>oldStartNamespaceDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name> <operator>=</operator> <name>oldEndNamespaceDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name> <operator>=</operator> <name>oldNotStandaloneHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name> <operator>=</operator> <name>oldExternalEntityRefHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name> <operator>=</operator> <name>oldSkippedEntityHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name> <operator>=</operator> <name>oldUnknownEncodingHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name> <operator>=</operator> <name>oldElementDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name> <operator>=</operator> <name>oldAttlistDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name> <operator>=</operator> <name>oldEntityDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name> <operator>=</operator> <name>oldXmlDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name> <operator>=</operator> <name>oldDeclElementType</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name> <operator>=</operator> <name>oldUserData</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldUserData</name> <operator>==</operator> <name>oldHandlerArg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>oldExternalEntityRefHandlerArg</name> <operator>!=</operator> <name>oldParser</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name> <operator>=</operator> <name>oldExternalEntityRefHandlerArg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name> <operator>=</operator> <name>oldDefaultExpandInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name> <operator>=</operator> <name>oldns_triplets</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name> <operator>=</operator> <name>oldhash_secret_salt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>=</operator> <name>oldParser</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name> <operator>=</operator> <name>oldParamEntityParsing</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name> <operator>=</operator> <name>oldInEntityValue</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>context</name></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>dtdCopy</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></argument>, <argument><expr><name>oldDtd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>setContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalEntityInitProcessor</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></if> <else>else <block>{<block_content>







<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlPrologStateInitExternalEntity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalParEntInitProcessor</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>parser</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>destroyBindings</name><parameter_list>(<parameter><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name></decl></parameter>, <parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bindings</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_ParserFree</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tagList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>entityList</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tagList</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tagList</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tagList</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tagList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagList</name> <operator>=</operator> <name><name>tagList</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bindings</name></name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>entityList</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>openEntity</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>entityList</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>entityList</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>openEntity</name> <operator>=</operator> <name>entityList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entityList</name> <operator>=</operator> <name><name>entityList</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>openEntity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_inheritedBindings</name></name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>dtdDestroy</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingData</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_UseParserAsHandlerArg</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Error</name></name> <name>XMLCALL</name></type>
<name>XML_UseForeignDTD</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>useDTD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_INVALID_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_PARSING</name>
<operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name> <operator>=</operator> <name>useDTD</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>XML_ERROR_FEATURE_REQUIRES_XML_DTD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetReturnNSTriplet</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_nst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_PARSING</name>
<operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name> <operator>=</operator> <ternary><condition><expr><name>do_nst</name></expr> ?</condition><then> <expr><name>XML_TRUE</name></expr> </then><else>: <expr><name>XML_FALSE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUserData</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_userData</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_SetBase</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_GetBase</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_GetSpecifiedAttributeCount</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_nSpecifiedAtts</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_GetIdAttributeIndex</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_idAttIndex</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>const</specifier> <name>XML_AttrInfo</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_GetAttributeInfo</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetElementHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_StartElementHandler</name></type> <name>start</name></decl></parameter>,
<parameter><decl><type><name>XML_EndElementHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartElementHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_StartElementHandler</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndElementHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_EndElementHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCharacterDataHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_CharacterDataHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetProcessingInstructionHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCommentHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_CommentHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCdataSectionHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>start</name></decl></parameter>,
<parameter><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartCdataSectionHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndCdataSectionHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDefaultHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_DefaultHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDefaultHandlerExpand</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_DefaultHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDoctypeDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>start</name></decl></parameter>,
<parameter><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endDoctypeDeclHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartDoctypeDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndDoctypeDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endDoctypeDeclHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUnparsedEntityDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNotationDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_NotationDeclHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNamespaceDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>start</name></decl></parameter>,
<parameter><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartNamespaceDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>start</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndNamespaceDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNotStandaloneHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_NotStandaloneHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetExternalEntityRefHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetExternalEntityRefHandlerArg</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name> <operator>=</operator> <operator>(</operator><name>XML_Parser</name><operator>)</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name> <operator>=</operator> <name>parser</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetSkippedEntityHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_SkippedEntityHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUnknownEncodingHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>handler</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandlerData</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetElementDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_ElementDeclHandler</name></type> <name>eldecl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name> <operator>=</operator> <name>eldecl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetAttlistDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_AttlistDeclHandler</name></type> <name>attdecl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name> <operator>=</operator> <name>attdecl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEntityDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_EntityDeclHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetXmlDeclHandler</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_XmlDeclHandler</name></type> <name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_SetParamEntityParsing</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>XML_ParamEntityParsing</name></name></type> <name>peParsing</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_PARSING</name>
<operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name> <operator>=</operator> <name>peParsing</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>peParsing</name> <operator>==</operator> <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_SetHashSalt</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>hash_salt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>XML_SetHashSalt</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr></argument>, <argument><expr><name>hash_salt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_PARSING</name>
<operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_hash_secret_salt</name></name> <operator>=</operator> <name>hash_salt</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_Parse</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isFinal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>parser</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>(</operator><name>s</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_INVALID_ARGUMENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>startParsing</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_PARSING</name></expr>;</expr_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>=</operator> <operator>(</operator><name>XML_Bool</name><operator>)</operator><name>isFinal</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isFinal</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr>;</expr_stmt>





<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name>
<operator>=</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>==</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>












<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_SUSPENDED</name></expr>;</return>

<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<case>case <expr><name>XML_PARSING</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt>

<default>default:</default>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nLeftOver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>XML_Size</name><operator>)</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>=</operator> <operator>(</operator><name>XML_Bool</name><operator>)</operator><name>isFinal</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name>
<operator>=</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<case>case <expr><name>XML_PARSING</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>isFinal</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_STATUS_OK</name></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nLeftOver</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>end</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nLeftOver</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name>nLeftOver</name> <operator>&gt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bytesToAllocate</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name> <operator>*</operator> <literal type="number">2U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesToAllocate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>, <argument><expr><name>bytesToAllocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>+</operator> <name>bytesToAllocate</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nLeftOver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>+</operator> <name>nLeftOver</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buff</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>isFinal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_ParseBuffer</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isFinal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name> <init>= <expr><name>XML_STATUS_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>startParsing</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_PARSING</name></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>=</operator> <operator>(</operator><name>XML_Bool</name><operator>)</operator><name>isFinal</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<case>case <expr><name>XML_PARSING</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>isFinal</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_GetBuffer</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>keep</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>neededSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name>
<operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>neededSize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>keep</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keep</name> <operator>&gt;</operator> <name>XML_CONTEXT_BYTES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>keep</name> <operator>=</operator> <name>XML_CONTEXT_BYTES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>neededSize</name> <operator>+=</operator> <name>keep</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>neededSize</name>
<operator>&lt;=</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>keep</name> <operator>&lt;</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name>
<init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call>
<operator>-</operator> <name>keep</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>+</operator> <name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>,
<argument><expr><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name>
<operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name>
<operator>+</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufferSize</name>
<init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bufferSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bufferSize</name> <operator>=</operator> <name>INIT_BUFFER_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<do>do <block>{<block_content>

<expr_stmt><expr><name>bufferSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">2U</literal> <operator>*</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>bufferSize</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>bufferSize</name> <argument_list type="generic">&lt; <argument><expr><name>neededSize</name> <operator>&amp;&amp;</operator> <name>bufferSize</name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>bufferSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>newBuf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newBuf</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferLim</name></name> <operator>=</operator> <name>newBuf</name> <operator>+</operator> <name>bufferSize</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name><index>[<expr><operator>-</operator><name>keep</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>=</operator> <name>newBuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name>
<operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name>
<operator>+</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call>
<operator>+</operator> <name>keep</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>+</operator> <name>keep</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>=</operator> <name>newBuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>=</operator> <name>newBuf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>,
<argument><expr><call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name>
<operator>=</operator> <name>newBuf</name>
<operator>+</operator> <call><name>EXPAT_SAFE_PTR_DIFF</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>=</operator> <name>newBuf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name> <operator>=</operator> <name>newBuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_StopParser</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>resumable</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>resumable</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>resumable</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_SUSPEND_PE</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_SUSPENDED</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></switch>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Status</name></name> <name>XMLCALL</name></type>
<name>XML_ResumeParser</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Status</name></name></type> <name>result</name> <init>= <expr><name>XML_STATUS_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_SUSPENDED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <name>XML_ERROR_NOT_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_PARSING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>=</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_INITIALIZED</name></expr>:</case>
<case>case <expr><name>XML_PARSING</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>=</operator> <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_bufferPtr</name></name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_GetParsingStatus</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_ParsingStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>status</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>enum</name> <name>XML_Error</name></name> <name>XMLCALL</name></type>
<name>XML_GetErrorCode</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_INVALID_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Index</name> <name>XMLCALL</name></type>
<name>XML_GetCurrentByteIndex</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>XML_Index</name><operator>)</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name>
<operator>-</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_GetCurrentByteCount</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_GetInputContext</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_bufferEnd</name></name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_buffer</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>size</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Size</name> <name>XMLCALL</name></type>
<name>XML_GetCurrentLineNumber</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>&gt;=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_position</name><operator>.</operator><name>lineNumber</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>XML_Size</name> <name>XMLCALL</name></type>
<name>XML_GetCurrentColumnNumber</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>&gt;=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_positionPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_position</name><operator>.</operator><name>columnNumber</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_FreeContentModel</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>model</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_MemMalloc</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_MemRealloc</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_MemFree</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_DefaultCurrent</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>XML_LChar</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_ErrorString</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>code</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_ERROR_NONE</name></expr>:</case>
<return>return <expr><name>NULL</name></expr>;</return>
<case>case <expr><name>XML_ERROR_NO_MEMORY</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_SYNTAX</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"no element found"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"not well-formed (invalid token)"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"unclosed token"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"partial character"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_TAG_MISMATCH</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"mismatched tag"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"duplicate attribute"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"junk after document element"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_PARAM_ENTITY_REF</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"illegal parameter entity reference"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"undefined entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"recursive entity reference"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"asynchronous entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"reference to invalid character number"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"reference to binary entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"reference to external entity in attribute"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML or text declaration not at start of entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"unknown encoding"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_INCORRECT_ENCODING</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"encoding specified in XML declaration is incorrect"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"unclosed CDATA section"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"error in processing external entity reference"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"document is not standalone"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"unexpected parser state - please send a bug report"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"entity declared in parameter entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_FEATURE_REQUIRES_XML_DTD</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"requested feature requires XML_DTD support in Expat"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"cannot change setting once parsing has begun"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"unbound prefix"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"must not undeclare prefix"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_INCOMPLETE_PE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"incomplete markup in parameter entity"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_XML_DECL</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML declaration not well-formed"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_TEXT_DECL</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"text declaration not well-formed"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_PUBLICID</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"illegal character(s) in public id"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_SUSPENDED</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"parser suspended"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_NOT_SUSPENDED</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"parser not suspended"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_ABORTED</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"parsing aborted"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_FINISHED</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"parsing finished"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_SUSPEND_PE</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"cannot suspend in external parameter entity"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>XML_ERROR_RESERVED_PREFIX_XML</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(
<argument><expr><literal type="string">"reserved prefix (xml) must not be undeclared or bound to another namespace name"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_RESERVED_PREFIX_XMLNS</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"reserved prefix (xmlns) must not be declared or undeclared"</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(
<argument><expr><literal type="string">"prefix must not be bound to one of the reserved namespace names"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>XML_ERROR_INVALID_ARGUMENT</name></expr>:</case>
<return>return <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"invalid argument"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>XML_LChar</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_ExpatVersion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>XML_L(#a) XML_L(".") XML_L(#b) XML_L(".") XML_L(#c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>XML_L("expat_") V1(a, b, c)</cpp:value></cpp:define>

<return>return <expr><call><name>V2</name><argument_list>(<argument><expr><name>XML_MAJOR_VERSION</name></expr></argument>, <argument><expr><name>XML_MINOR_VERSION</name></expr></argument>, <argument><expr><name>XML_MICRO_VERSION</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V2</name></cpp:undef>
</block_content>}</block></function>

<function><type><name>XML_Expat_Version</name> <name>XMLCALL</name></type>
<name>XML_ExpatVersionInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Expat_Version</name></type> <name>version</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>version</name><operator>.</operator><name>major</name></name> <operator>=</operator> <name>XML_MAJOR_VERSION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>version</name><operator>.</operator><name>minor</name></name> <operator>=</operator> <name>XML_MINOR_VERSION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>version</name><operator>.</operator><name>micro</name></name> <operator>=</operator> <name>XML_MICRO_VERSION</name></expr>;</expr_stmt>

<return>return <expr><name>version</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>XML_Feature</name> <modifier>*</modifier><name>XMLCALL</name></type>
<name>XML_GetFeatureList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Feature</name></type> <name><name>features</name><index>[]</index></name>
<init>= <expr><block>{<expr><block>{<expr><name>XML_FEATURE_SIZEOF_XML_CHAR</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"sizeof(XML_Char)"</literal></expr></argument>)</argument_list></call></expr>,
<expr>sizeof<operator>(</operator><name>XML_Char</name><operator>)</operator></expr>}</block></expr>,
<expr><block>{<expr><name>XML_FEATURE_SIZEOF_XML_LCHAR</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"sizeof(XML_LChar)"</literal></expr></argument>)</argument_list></call></expr>,
<expr>sizeof<operator>(</operator><name>XML_LChar</name><operator>)</operator></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_UNICODE</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_UNICODE"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_UNICODE_WCHAR_T</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_UNICODE_WCHAR_T"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_DTD</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_DTD"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_CONTEXT_BYTES</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_CONTEXT_BYTES"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>XML_CONTEXT_BYTES</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_MIN_SIZE</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_MIN_SIZE"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_NS</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_NS"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_LARGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_LARGE_SIZE</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_LARGE_SIZE"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_ATTR_INFO</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr><literal type="string">"XML_ATTR_INFO"</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>XML_FEATURE_END</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><name>features</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>XML_Bool</name></type>
<name>storeRawNames</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>tag</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bufSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nameLen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>strLen</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rawNameBuf</name> <init>= <expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>nameLen</name></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name> <operator>==</operator> <name>rawNameBuf</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>



<expr_stmt><expr><name>bufSize</name> <operator>=</operator> <name>nameLen</name> <operator>+</operator> <call><name>ROUND_UP</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rawNameLength</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bufSize</name> <operator>&gt;</operator> <name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>-</operator> <name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>==</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>temp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>localPart</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>localPart</name></name>
<operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>temp</name> <operator>+</operator> <operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>localPart</name></name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>=</operator> <name>temp</name> <operator>+</operator> <name>bufSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rawNameBuf</name> <operator>=</operator> <name>temp</name> <operator>+</operator> <name>nameLen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rawNameBuf</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rawNameLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name> <operator>=</operator> <name>rawNameBuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>contentProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name>
<init>= <expr><call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>storeRawNames</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalEntityInitProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalEntityInitProcessor2</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityInitProcessor2</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalEntityInitProcessor2</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlContentTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_BOM</name></expr>:</case>





<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalEntityInitProcessor3</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityInitProcessor3</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalEntityInitProcessor3</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlContentTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_XML_DECL</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>endPtr</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalEntityContentProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityContentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalEntityContentProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name>
<init>= <expr><call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>storeRawNames</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>doContent</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startTagLevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventEndPP</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlContentTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr><literal type="number">0xA</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>startTagLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>!=</operator> <name>startTagLevel</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>startTagLevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>!=</operator> <name>startTagLevel</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>ch</name> <init>= <expr><operator>(</operator><name>XML_Char</name><operator>)</operator><call><name>XmlPredefinedEntityName</name><argument_list>(
<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>entity</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>generalEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>||</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>entity</name><operator>-&gt;</operator><name>is_internal</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>notation</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_defaultExpandInternalEntities</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>processInternalEntity</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>context</name> <operator>=</operator> <call><name>getContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>context</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>XML_TOK_START_TAG_NO_ATTS</name></expr>:</case>

<case>case <expr><name>XML_TOK_START_TAG_WITH_ATTS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>toPtr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>(</operator><name>TAG</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tag</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>INIT_TAG_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name>INIT_TAG_BUF_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>localPart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>rawNameLength</name></name> <operator>=</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawNameEnd</name> <init>= <expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name> <operator>+</operator> <name><name>tag</name><operator>-&gt;</operator><name>rawNameLength</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromPtr</name> <init>= <expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>toPtr</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bufSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>convLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>convert_res</name>
<init>= <expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fromPtr</name></expr></argument>, <argument><expr><name>rawNameEnd</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>toPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>convLen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>toPtr</name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fromPtr</name> <operator>&gt;=</operator> <name>rawNameEnd</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>strLen</name></name> <operator>=</operator> <name>convLen</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bufSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>-</operator> <name><name>tag</name><operator>-&gt;</operator><name>buf</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bufEnd</name></name> <operator>=</operator> <name>temp</name> <operator>+</operator> <name>bufSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>toPtr</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>temp</name> <operator>+</operator> <name>convLen</name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></for>
</block_content>}</block>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>toPtr</name> <operator>=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storeAtts</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>XML_TOK_EMPTY_ELEMENT_NO_ATTS</name></expr>:</case>

<case>case <expr><name>XML_TOK_EMPTY_ELEMENT_WITH_ATTS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawName</name> <init>= <expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>noElmHandlers</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG_NAME</name></type> <name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>name</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>,
<argument><expr><name>rawName</name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>name</name><operator>.</operator><name>str</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storeAtts</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bindings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>freeBindings</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bindings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>str</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>noElmHandlers</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startElementHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <operator>*</operator><name>eventEndPP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>noElmHandlers</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>noElmHandlers</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeBindings</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bindings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>epilogProcessor</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>epilogProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_END_TAG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>==</operator> <name>startTagLevel</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rawName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeTagList</name></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rawName</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>tag</name><operator>-&gt;</operator><name>rawNameLength</name></name>
<operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>tag</name><operator>-&gt;</operator><name>rawName</name></name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>rawName</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_TAG_MISMATCH</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>localPart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl>;</decl_stmt>
<expr_stmt><expr><name>localPart</name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>localPart</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name> <operator>&amp;&amp;</operator> <name>localPart</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>uri</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>+</operator> <name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>uriLen</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>localPart</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>uri</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>localPart</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>prefix</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name> <operator>&amp;&amp;</operator> <name>prefix</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>uri</name><operator>++</operator> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>uri</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>prefix</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>uri</name> <operator>=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endElementHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>tag</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>,
<argument><expr><name><name>b</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tag</name><operator>-&gt;</operator><name>bindings</name></name> <operator>=</operator> <name><name>tag</name><operator>-&gt;</operator><name>bindings</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>binding</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>prevPrefixBinding</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>!=</operator> <name>XML_FINISHED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>epilogProcessor</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>epilogProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_CHAR_REF</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr><call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_XML_DECL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr>;</return>
<case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr><literal type="number">0xA</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_CDATA_SECT_OPEN</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startCdataSectionHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>













<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doCdataSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>, <argument><expr><name>haveMore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>cdataSectionProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_TRAILING_RSQB</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ICHAR</name> <modifier>*</modifier></type><name>dataPtr</name> <init>= <expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBufEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dataPtr</name> <operator>-</operator> <operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>end</name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>startTagLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name> <operator>!=</operator> <name>startTagLevel</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>charDataHandler</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>charDataHandler</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ICHAR</name> <modifier>*</modifier></type><name>dataPtr</name> <init>= <expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>convert_res</name> <init>= <expr><call><name>XmlConvert</name><argument_list>(
<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBufEnd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>charDataHandler</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dataPtr</name> <operator>-</operator> <operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_COMPLETED</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>charDataHandler</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>next</name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_PI</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_COMMENT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>







<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

</block_content>}</block></switch>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>

</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeBindings</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>bindings</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name>bindings</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endNamespaceDeclHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bindings</name> <operator>=</operator> <name><name>bindings</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>binding</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>prevPrefixBinding</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>storeAtts</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attStr</name></decl></parameter>,
<parameter><decl><type><name>TAG_NAME</name> <modifier>*</modifier></type><name>tagNamePtr</name></decl></parameter>, <parameter><decl><type><name>BINDING</name> <modifier>*</modifier><modifier>*</modifier></type><name>bindingsPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>elementType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>appAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>attIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefixLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPrefixes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>binding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>localPart</name></decl>;</decl_stmt>


<expr_stmt><expr><name>elementType</name>
<operator>=</operator> <operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>elementTypes</name></name></expr></argument>, <argument><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>elementType</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>elementType</name> <operator>=</operator> <operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>elementTypes</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>elementType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>setElementTypePrefix</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nDefaultAtts</name> <operator>=</operator> <name><name>elementType</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>XmlGetAttributes</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>attStr</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>+</operator> <name>nDefaultAtts</name> <operator>&gt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldAttsSize</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_AttrInfo</name> <modifier>*</modifier></type><name>temp2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>nDefaultAtts</name> <operator>+</operator> <name>INIT_ATTS_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>=</operator> <name>oldAttsSize</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>temp2</name> <operator>=</operator> <operator>(</operator><name>XML_AttrInfo</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_AttrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attsSize</name></name> <operator>=</operator> <name>oldAttsSize</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name></name> <operator>=</operator> <name>temp2</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>oldAttsSize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>XmlGetAttributes</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>attStr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>appAtts</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>XML_Char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ATTRIBUTE</name> <modifier>*</modifier></type><name>currAtt</name> <init>= <expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_AttrInfo</name> <modifier>*</modifier></type><name>currAttInfo</name> <init>= <expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_attInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>attId</name>
<init>= <expr><call><name>getAttributeId</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>currAtt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>currAtt</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>currAtt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>attId</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_ATTR_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>currAttInfo</name><operator>-&gt;</operator><name>nameStart</name></name>
<operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name> <operator>-</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>-</operator> <name><name>currAtt</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>currAttInfo</name><operator>-&gt;</operator><name>nameEnd</name></name>
<operator>=</operator> <name><name>currAttInfo</name><operator>-&gt;</operator><name>nameStart</name></name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>currAtt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>currAttInfo</name><operator>-&gt;</operator><name>valueStart</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name>
<operator>-</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>-</operator> <name><name>currAtt</name><operator>-&gt;</operator><name>valuePtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>currAttInfo</name><operator>-&gt;</operator><name>valueEnd</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parseEndByteIndex</name></name>
<operator>-</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parseEndPtr</name></name> <operator>-</operator> <name><name>currAtt</name><operator>-&gt;</operator><name>valueEnd</name></name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>attId</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name><name>attId</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>attId</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>normalized</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isCdata</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>attId</name><operator>-&gt;</operator><name>maybeTokenized</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nDefaultAtts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>attId</name> <operator>==</operator> <name><name>elementType</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>isCdata</name> <operator>=</operator> <name><name>elementType</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>isCdata</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storeAttributeValue</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>isCdata</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valuePtr</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>=</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valuePtr</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_atts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>valueEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>attId</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>attId</name><operator>-&gt;</operator><name>xmlns</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>attId</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>attId</name></expr></argument>,
<argument><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>bindingsPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name>attIndex</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>attIndex</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nPrefixes</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name><name>attId</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>attIndex</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nSpecifiedAtts</name></name> <operator>=</operator> <name>attIndex</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>elementType</name><operator>-&gt;</operator><name>idAtt</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>elementType</name><operator>-&gt;</operator><name>idAtt</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>elementType</name><operator>-&gt;</operator><name>idAtt</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_idAttIndex</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_idAttIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nDefaultAtts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>DEFAULT_ATTRIBUTE</name> <modifier>*</modifier></type><name>da</name> <init>= <expr><name><name>elementType</name><operator>-&gt;</operator><name>defaultAtts</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>&amp;&amp;</operator> <name><name>da</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>xmlns</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>da</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
<argument><expr><name><name>da</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>bindingsPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nPrefixes</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>da</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>da</name><operator>-&gt;</operator><name>id</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>da</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nPrefixes</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>version</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsVersion</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nsAttsSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>oldNsAttsPower</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nPrefixes</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator>
<operator>&gt;&gt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NS_ATT</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>nPrefixes</name> <operator>&gt;&gt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nsAttsSize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>NS_ATT</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name></name></expr></argument>,
<argument><expr><name>nsAttsSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NS_ATT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>temp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name> <operator>=</operator> <name>oldNsAttsPower</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>version</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>version</name> <operator>=</operator> <name>INIT_ATTS_VERSION</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>nsAttsSize</name></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><operator>--</operator><name>j</name></expr>]</index></name><operator>.</operator><name>version</name> <operator>=</operator> <name>version</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsVersion</name></name> <operator>=</operator> <operator>--</operator><name>version</name></expr>;</expr_stmt>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>BINDING</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uriHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>siphash</name></name></type> <name>sip_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sipkey</name></name></type> <name>sip_key</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>copy_salt_to_sipkey</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sip_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sip24_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sip_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sip_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>attributeIds</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>id</name> <operator>||</operator> <operator>!</operator> <name><name>id</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>














<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>binding</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>uriLen</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name></type> <name>c</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>uri</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sip_state</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>uriLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_COLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>

<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sip_state</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>keylen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator></expr>)</condition>;</do>

<expr_stmt><expr><name>uriHash</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>sip24_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sip_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name> <init>= <expr><name>nsAttsSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>uriHash</name> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>version</name> <operator>==</operator> <name>version</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>uriHash</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hash</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uriName</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s1</name> <operator>==</operator> <operator>*</operator><name>s2</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s1</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>s1</name><operator>++</operator></expr><operator>,</operator> <expr><name>s2</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>step</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>uriHash</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAttsPower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><ternary><condition><expr><name>j</name> <operator>&lt;</operator> <name>step</name></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>+=</operator> <name>nsAttsSize</name> <operator>-</operator> <name>step</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>j</name> <operator>-=</operator> <name>step</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name><operator>.</operator><name>ptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>version</name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>hash</name> <operator>=</operator> <name>uriHash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_nsAtts</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>uriName</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>--</operator><name>nPrefixes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>)</operator><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>binding</name> <operator>=</operator> <operator>*</operator><name>bindingsPtr</name></expr>;</init> <condition><expr><name>binding</name></expr>;</condition> <incr><expr><name>binding</name> <operator>=</operator> <name><name>binding</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>binding</name><operator>-&gt;</operator><name>attId</name><operator>-&gt;</operator><name>name</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>elementType</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>binding</name> <operator>=</operator> <name><name>elementType</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>binding</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>binding</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>localPart</name> <operator>=</operator> <name><name>tagNamePtr</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>localPart</name><operator>++</operator> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_COLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>binding</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>localPart</name> <operator>=</operator> <name><name>tagNamePtr</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></block_content></block></else></if_stmt>
<expr_stmt><expr><name>prefixLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns_triplets</name></name> <operator>&amp;&amp;</operator> <name><name>binding</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name><name>binding</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>prefixLen</name><operator>++</operator></expr>]</index></name></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>localPart</name></name> <operator>=</operator> <name>localPart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>uriLen</name></name> <operator>=</operator> <name><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name><name>binding</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>prefixLen</name></name> <operator>=</operator> <name>prefixLen</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>localPart</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name> <operator>+</operator> <name>prefixLen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>binding</name><operator>-&gt;</operator><name>uriAlloc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TAG</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>uri</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>(</operator><name>n</name> <operator>+</operator> <name>EXPAND_SPARE</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>uri</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>binding</name><operator>-&gt;</operator><name>uriAlloc</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>EXPAND_SPARE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>binding</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tagStack</name></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>parent</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>==</operator> <name><name>binding</name><operator>-&gt;</operator><name>uri</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>uri</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>binding</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>binding</name><operator>-&gt;</operator><name>uri</name></name> <operator>=</operator> <name>uri</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>uri</name> <operator>=</operator> <name><name>binding</name><operator>-&gt;</operator><name>uri</name></name> <operator>+</operator> <name><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>localPart</name></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefixLen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uri</name> <operator>+=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>uri</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>binding</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>prefixLen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <name><name>binding</name><operator>-&gt;</operator><name>uri</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>addBinding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>attId</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>uri</name></decl></parameter>, <parameter><decl><type><name>BINDING</name> <modifier>*</modifier><modifier>*</modifier></type><name>bindingsPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>xmlNamespace</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_h</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_p</name></expr>, <expr><name>ASCII_COLON</name></expr>,
<expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>,
<expr><name>ASCII_PERIOD</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_3</name></expr>, <expr><name>ASCII_PERIOD</name></expr>, <expr><name>ASCII_o</name></expr>,
<expr><name>ASCII_r</name></expr>, <expr><name>ASCII_g</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_X</name></expr>, <expr><name>ASCII_M</name></expr>,
<expr><name>ASCII_L</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_9</name></expr>, <expr><name>ASCII_9</name></expr>,
<expr><name>ASCII_8</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_m</name></expr>,
<expr><name>ASCII_e</name></expr>, <expr><name>ASCII_s</name></expr>, <expr><name>ASCII_p</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_c</name></expr>,
<expr><name>ASCII_e</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>xmlLen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>xmlNamespace</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>xmlnsNamespace</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_h</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_p</name></expr>, <expr><name>ASCII_COLON</name></expr>, <expr><name>ASCII_SLASH</name></expr>,
<expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_w</name></expr>, <expr><name>ASCII_PERIOD</name></expr>, <expr><name>ASCII_w</name></expr>,
<expr><name>ASCII_3</name></expr>, <expr><name>ASCII_PERIOD</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_r</name></expr>, <expr><name>ASCII_g</name></expr>, <expr><name>ASCII_SLASH</name></expr>,
<expr><name>ASCII_2</name></expr>, <expr><name>ASCII_0</name></expr>, <expr><name>ASCII_0</name></expr>, <expr><name>ASCII_0</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><name>ASCII_x</name></expr>,
<expr><name>ASCII_m</name></expr>, <expr><name>ASCII_l</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_s</name></expr>, <expr><name>ASCII_SLASH</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>xmlnsLen</name>
<init>= <expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>xmlnsNamespace</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>XML_Bool</name></type> <name>mustBeXML</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isXML</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isXMLNS</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BINDING</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>uri</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_m</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_s</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_RESERVED_PREFIX_XMLNS</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mustBeXML</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>isXML</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <name>xmlLen</name> <operator>||</operator> <name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <name><name>xmlNamespace</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>isXML</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>mustBeXML</name> <operator>&amp;&amp;</operator> <name>isXMLNS</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <name>xmlnsLen</name> <operator>||</operator> <name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <name><name>xmlnsNamespace</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>isXMLNS</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>isXML</name> <operator>=</operator> <name>isXML</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>==</operator> <name>xmlLen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>isXMLNS</name> <operator>=</operator> <name>isXMLNS</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>==</operator> <name>xmlnsLen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mustBeXML</name> <operator>!=</operator> <name>isXML</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>mustBeXML</name></expr> ?</condition><then> <expr><name>XML_ERROR_RESERVED_PREFIX_XML</name></expr>
</then><else>: <expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isXMLNS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>uriAlloc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <name>EXPAND_SPARE</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uriAlloc</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>EXPAND_SPARE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeBindingList</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>BINDING</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BINDING</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name>
<operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <name>EXPAND_SPARE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>b</name><operator>-&gt;</operator><name>uri</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uriAlloc</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>EXPAND_SPARE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uriLen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>uri</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>attId</name></name> <operator>=</operator> <name>attId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prevPrefixBinding</name></name> <operator>=</operator> <name><name>prefix</name><operator>-&gt;</operator><name>binding</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>uri</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>prefix</name> <operator>==</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name><operator>-&gt;</operator><name>defaultPrefix</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>prefix</name><operator>-&gt;</operator><name>binding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>prefix</name><operator>-&gt;</operator><name>binding</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>nextTagBinding</name></name> <operator>=</operator> <operator>*</operator><name>bindingsPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bindingsPtr</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>attId</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startNamespaceDeclHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>prefix</name><operator>-&gt;</operator><name>binding</name></name></expr> ?</condition><then> <expr><name>uri</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>cdataSectionProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name>
<init>= <expr><call><name>doCdataSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalEntityContentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityContentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>contentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>contentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>doCdataSection</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>startPtr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>startPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventEndPP</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>startPtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlCdataSectionTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_CDATA_SECT_CLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endCdataSectionHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>


<if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>startPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></block_content></block></else></if_stmt>
<case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr><literal type="number">0xA</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>charDataHandler</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_characterDataHandler</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>charDataHandler</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ICHAR</name> <modifier>*</modifier></type><name>dataPtr</name> <init>= <expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>convert_res</name> <init>= <expr><call><name>XmlConvert</name><argument_list>(
<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBufEnd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>charDataHandler</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dataPtr</name> <operator>-</operator> <operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_COMPLETED</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>charDataHandler</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>next</name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>;</return>
<default>default:</default>







<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>ignoreSectionProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name>
<init>= <expr><call><name>doIgnoreSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>prologProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>doIgnoreSection</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>startPtr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>startPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventEndPP</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>











<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>startPtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlIgnoreSectionTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_IGNORE_SECT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>startPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></block_content></block></else></if_stmt>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>haveMore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return>
<default>default:</default>







<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>initializeEncoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>encodingBuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>encodingBuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal>
<operator>||</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x7f</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>encodingBuf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr> ?</condition><then> <expr><name>XmlInitEncodingNS</name></expr> </then><else>: <expr><name>XmlInitEncoding</name></expr></else></ternary><operator>)</operator><operator>(</operator>
<operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_initEncoding</name></name><operator>,</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name><operator>,</operator> <name>s</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>handleUnknownEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>processXmlDecl</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encodingName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>storedEncName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>newEncoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>versionend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>storedversion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>standalone</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><ternary><condition><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr> ?</condition><then> <expr><name>XmlParseXmlDeclNS</name></expr> </then><else>: <expr><name>XmlParseXmlDecl</name></expr></else></ternary><operator>)</operator><operator>(</operator>
<name>isGeneralTextEntity</name><operator>,</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name><operator>,</operator> <name>s</name><operator>,</operator> <name>next</name><operator>,</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name><operator>,</operator>
<operator>&amp;</operator><name>version</name><operator>,</operator> <operator>&amp;</operator><name>versionend</name><operator>,</operator> <operator>&amp;</operator><name>encodingName</name><operator>,</operator> <operator>&amp;</operator><name>newEncoding</name><operator>,</operator> <operator>&amp;</operator><name>standalone</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>isGeneralTextEntity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_TEXT_DECL</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_XML_DECL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isGeneralTextEntity</name> <operator>&amp;&amp;</operator> <name>standalone</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name><operator>-&gt;</operator><name>standalone</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name>
<operator>==</operator> <name>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name> <operator>=</operator> <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>encodingName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>storedEncName</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>,
<argument><expr><name>encodingName</name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>storedEncName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>version</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>storedversion</name>
<operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>version</name></expr></argument>,
<argument><expr><name>versionend</name> <operator>-</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>storedversion</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_xmlDeclHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>storedversion</name></expr></argument>, <argument><expr><name>storedEncName</name></expr></argument>,
<argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_protocolEncodingName</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>newEncoding</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name><name>newEncoding</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>!=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name><operator>-&gt;</operator><name>minBytesPerChar</name></name>
<operator>||</operator> <operator>(</operator><name><name>newEncoding</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>==</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <name>newEncoding</name> <operator>!=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>encodingName</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INCORRECT_ENCODING</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name> <operator>=</operator> <name>newEncoding</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encodingName</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>storedEncName</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>storedEncName</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>,
<argument><expr><name>encodingName</name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>storedEncName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>handleUnknownEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>storedEncName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>XML_ERROR_UNKNOWN_ENCODING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>encodingName</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>storedEncName</name> <operator>||</operator> <name>storedversion</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>handleUnknownEncoding</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>encodingName</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Encoding</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>convert</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>release</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingHandlerData</name></name></expr></argument>,
<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name> <operator>=</operator> <call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><call><name>XmlSizeOfUnknownEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>release</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>release</name></name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr> ?</condition><then> <expr><name>XmlInitUnknownEncodingNS</name></expr> </then><else>: <expr><name>XmlInitUnknownEncoding</name></expr></else></ternary><operator>)</operator><operator>(</operator>
<name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingMem</name></name><operator>,</operator> <name><name>info</name><operator>.</operator><name>map</name></name><operator>,</operator> <name><name>info</name><operator>.</operator><name>convert</name></name><operator>,</operator> <name><name>info</name><operator>.</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingData</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_unknownEncodingRelease</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>release</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>release</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>release</name></name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>prologInitProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>prologProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalParEntInitProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>entityValueInitProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>entityValueInitProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>externalParEntProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalParEntProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>entityValueInitProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>&amp;&amp;</operator> <name>tok</name> <operator>!=</operator> <name>XML_TOK_INVALID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_XML_DECL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>entityValueProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>entityValueProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>







<if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_BOM</name> <operator>&amp;&amp;</operator> <name>next</name> <operator>==</operator> <name>end</name>
<operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if>




<if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_INSTANCE_START</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>externalParEntProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>&amp;&amp;</operator> <name>tok</name> <operator>!=</operator> <name>XML_TOK_INVALID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>




<if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_BOM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>entityValueProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name> <operator>&amp;&amp;</operator> <name>tok</name> <operator>!=</operator> <name>XML_TOK_INVALID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>prologProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>doProlog</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>haveMore</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>allowClosingDoctype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>externalSubsetName</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_HASH</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeCDATA</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_C</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeID</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeIDREF</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><name>ASCII_R</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeIDREFS</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><name>ASCII_R</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeENTITY</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_E</name></expr>, <expr><name>ASCII_N</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_I</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_Y</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeENTITIES</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_E</name></expr>, <expr><name>ASCII_N</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_I</name></expr>, <expr><name>ASCII_T</name></expr>,
<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeNMTOKEN</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_N</name></expr>, <expr><name>ASCII_M</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_K</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><name>ASCII_N</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeNMTOKENS</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_N</name></expr>, <expr><name>ASCII_M</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_K</name></expr>,
<expr><name>ASCII_E</name></expr>, <expr><name>ASCII_N</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>notationPrefix</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_N</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_T</name></expr>,
<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_N</name></expr>, <expr><name>ASCII_LPAREN</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>enumValueSep</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_PIPE</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>enumValueStart</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_LPAREN</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventEndPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Content_Quant</name></name></type> <name>quant</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>role</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>handleDefault</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>haveMore</name> <operator>&amp;&amp;</operator> <name>tok</name> <operator>!=</operator> <name>XML_TOK_INVALID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<case>case <expr><operator>-</operator><name>XML_TOK_PROLOG_S</name></expr>:</case>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <operator>-</operator><name>tok</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>betweenDecl</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name> <operator>||</operator> <name>enc</name> <operator>!=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>XmlTokenRole</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name></name></expr></argument>, <argument><expr><name>XML_TOK_NONE</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call>
<operator>==</operator> <name>XML_ROLE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_INCOMPLETE_PE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <operator>-</operator><name>tok</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>role</name> <operator>=</operator> <call><name>XmlTokenRole</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>role</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_ROLE_XML_DECL</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_ROLE_DOCTYPE_NAME</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name>
<operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypePubid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_DOCTYPE_INTERNAL_SUBSET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypePubid</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>XML_ROLE_TEXT_DECL</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>XML_ROLE_DOCTYPE_PUBLIC_ID</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>, <argument><expr><name>externalSubsetName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>pubId</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pubId</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>pubId</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr><name>pubId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypePubid</name></name> <operator>=</operator> <name>pubId</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<goto>goto <name>alreadyChecked</name>;</goto>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>XML_ROLE_ENTITY_PUBLIC_ID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></block_content></block></if></if_stmt>
<label><name>alreadyChecked</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>tem</name>
<init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name> <operator>&amp;&amp;</operator> <name>role</name> <operator>==</operator> <name>XML_ROLE_ENTITY_PUBLIC_ID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_DOCTYPE_CLOSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>allowClosingDoctype</name> <operator>!=</operator> <name>XML_TRUE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeName</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypePubid</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hadParamEntityRefs</name> <init>= <expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition> <block>{<block_content>





<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>



<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>hadParamEntityRefs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_endDoctypeDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_endDoctypeDeclHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_INSTANCE_START</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hadParamEntityRefs</name> <init>= <expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>



<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>hadParamEntityRefs</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>contentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>contentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>XML_ROLE_ATTLIST_ELEMENT_NAME</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name> <operator>=</operator> <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_NAME</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name></name> <operator>=</operator> <call><name>getAttributeId</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsId</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_CDATA</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeCDATA</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ID</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsId</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeID</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_IDREF</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeIDREF</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_IDREFS</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeIDREFS</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ENTITY</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeENTITY</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ENTITIES</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeENTITIES</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeNMTOKEN</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name>atypeNMTOKENS</name></expr>;</expr_stmt>
<label><name>checkAttListDeclHandler</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_ENUM_VALUE</name></expr>:</case>
<case>case <expr><name>XML_ROLE_ATTRIBUTE_NOTATION_VALUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>enumValueSep</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>role</name> <operator>==</operator> <name>XML_ROLE_ATTRIBUTE_NOTATION_VALUE</name></expr> ?</condition><then> <expr><name>notationPrefix</name></expr>
</then><else>: <expr><name>enumValueStart</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_IMPLIED_ATTRIBUTE_VALUE</name></expr>:</case>
<case>case <expr><name>XML_ROLE_REQUIRED_ATTRIBUTE_VALUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>defineAttribute</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_LPAREN</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>(</operator><operator>*</operator><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_N</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_O</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_RPAREN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>role</name> <operator>==</operator> <name>XML_ROLE_REQUIRED_ATTRIBUTE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_DEFAULT_ATTRIBUTE_VALUE</name></expr>:</case>
<case>case <expr><name>XML_ROLE_FIXED_ATTRIBUTE_VALUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>attVal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>storeAttributeValue</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name></expr></argument>,
<argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>attVal</name> <operator>=</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>defineAttribute</name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeIsCdata</name></name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>, <argument><expr><name>attVal</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_LPAREN</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>(</operator><operator>*</operator><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_N</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_O</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_RPAREN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name><operator>.</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeId</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declAttributeType</name></name></expr></argument>,
<argument><expr><name>attVal</name></expr></argument>, <argument><expr><name>role</name> <operator>==</operator> <name>XML_ROLE_FIXED_ATTRIBUTE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ENTITY_VALUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><call><name>storeEntityValue</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>=</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>textLen</name></name>
<operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>poolLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>entityValuePool</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_param</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>textPtr</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>textLen</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_DOCTYPE_SYSTEM_ID</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_useForeignDTD</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content>


<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_doctypeSysid</name></name> <operator>=</operator> <name>externalSubsetName</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>, <argument><expr><name>externalSubsetName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>XML_ROLE_ENTITY_SYSTEM_ID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>systemId</name></name>
<operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>systemId</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name> <operator>&amp;&amp;</operator> <name>role</name> <operator>==</operator> <name>XML_ROLE_ENTITY_SYSTEM_ID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ENTITY_COMPLETE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_param</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ENTITY_NOTATION_NAME</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>notation</name></name>
<operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>notation</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_unparsedEntityDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>notation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>notation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_GENERAL_ENTITY_NAME</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>XmlPredefinedEntityName</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>generalEntities</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_param</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_internal</name></name>
<operator>=</operator> <operator>!</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_ROLE_PARAM_ENTITY_NAME</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_param</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name><operator>-&gt;</operator><name>is_internal</name></name>
<operator>=</operator> <operator>!</operator> <operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declEntity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NOTATION_NAME</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name>
<operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NOTATION_PUBLIC_ID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name>
<operator>-&gt;</operator><name>m_declNotationName</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NOTATION_SYSTEM_ID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>systemId</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>systemId</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr></argument>,
<argument><expr><name>systemId</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NOTATION_NO_SYSTEM_ID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationName</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_curBase</name></name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declNotationPublicId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ERROR</name></expr>:</case>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>:</case>


<return>return <expr><name>XML_ERROR_PARAM_ENTITY_REF</name></expr>;</return>
<case>case <expr><name>XML_TOK_XML_DECL</name></expr>:</case>
<return>return <expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>XML_ROLE_IGNORE_SECT</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doIgnoreSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>, <argument><expr><name>haveMore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <name>next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>ignoreSectionProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>XML_ROLE_GROUP_OPEN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name> <operator>&gt;=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name></expr>)</condition> <block>{<block_content>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>new_connector</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>*=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_connector</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name> <operator>=</operator> <name>new_connector</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier><specifier>const</specifier></type> <name>new_scaff_index</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_scaff_index</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>=</operator> <name>new_scaff_index</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name>
<operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>=</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>myindex</name> <init>= <expr><call><name>nextScaffoldPart</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>myindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name></expr>]</index></name> <operator>=</operator> <name>myindex</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>XML_CTYPE_SEQ</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_GROUP_SEQUENCE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name> <operator>==</operator> <name>ASCII_PIPE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name> <operator>=</operator> <name>ASCII_COMMA</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_GROUP_CHOICE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name> <operator>==</operator> <name>ASCII_COMMA</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>type</name>
<operator>!=</operator> <name>XML_CTYPE_MIXED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>type</name>
<operator>=</operator> <name>XML_CTYPE_CHOICE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupConnector</name><index>[<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>level</name></name></expr>]</index></name> <operator>=</operator> <name>ASCII_PIPE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_PARAM_ENTITY_REF</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>XML_ROLE_INNER_PARAM_ENTITY_REF</name></expr>:</case>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_paramEntityParsing</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>entity</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>documentEntity</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr> ?</condition><then> <expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>
</then><else>: <expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>entity</name><operator>-&gt;</operator><name>is_internal</name></name></expr>)</condition> <block>{<block_content>




















<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>role</name> <operator>==</operator> <name>XML_ROLE_PARAM_ENTITY_REF</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_skippedEntityHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name>
<init>= <expr><operator>(</operator><ternary><condition><expr><name>role</name> <operator>==</operator> <name>XML_ROLE_PARAM_ENTITY_REF</name></expr> ?</condition><then> <expr><name>XML_TRUE</name></expr> </then><else>: <expr><name>XML_FALSE</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>processInternalEntity</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>betweenDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_notStandaloneHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>



<case>case <expr><name>XML_ROLE_ELEMENT_NAME</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name> <operator>=</operator> <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>XML_ROLE_CONTENT_ANY</name></expr>:</case>
<case>case <expr><name>XML_ROLE_CONTENT_EMPTY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>content</name>
<init>= <expr><operator>(</operator><name>XML_Content</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Content</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>content</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>quant</name></name> <operator>=</operator> <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>numchildren</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>role</name> <operator>==</operator> <name>XML_ROLE_CONTENT_ANY</name><operator>)</operator></expr> ?</condition><then> <expr><name>XML_CTYPE_ANY</name></expr>
</then><else>: <expr><name>XML_CTYPE_EMPTY</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>XML_ROLE_CONTENT_PCDATA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>type</name>
<operator>=</operator> <name>XML_CTYPE_MIXED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>XML_ROLE_CONTENT_ELEMENT</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
<case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_OPT</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_OPT</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
<case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_REP</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_REP</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
<case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_PLUS</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_PLUS</name></expr>;</expr_stmt>
<label><name>elementContent</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>el</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nameLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nxt</name>
<init>= <expr><operator>(</operator><ternary><condition><expr><name>quant</name> <operator>==</operator> <name>XML_CQUANT_NONE</name></expr> ?</condition><then> <expr><name>next</name></expr> </then><else>: <expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>myindex</name> <init>= <expr><call><name>nextScaffoldPart</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>myindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>XML_CTYPE_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name><operator>.</operator><name>quant</name> <operator>=</operator> <name>quant</name></expr>;</expr_stmt>
<expr_stmt><expr><name>el</name> <operator>=</operator> <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>nxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>el</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>el</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nameLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name><name>name</name><index>[<expr><name>nameLen</name><operator>++</operator></expr>]</index></name></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>+=</operator> <name>nameLen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>XML_ROLE_GROUP_CLOSE</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
<case>case <expr><name>XML_ROLE_GROUP_CLOSE_OPT</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_OPT</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
<case>case <expr><name>XML_ROLE_GROUP_CLOSE_REP</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_REP</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
<case>case <expr><name>XML_ROLE_GROUP_CLOSE_PLUS</name></expr>:</case>
<expr_stmt><expr><name>quant</name> <operator>=</operator> <name>XML_CQUANT_PLUS</name></expr>;</expr_stmt>
<label><name>closeGroup</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>quant</name> <operator>=</operator> <name>quant</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>handleDefault</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>model</name> <init>= <expr><call><name>build_model</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>model</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_declElementType</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>


<case>case <expr><name>XML_ROLE_PI</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_COMMENT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NONE</name></expr>:</case>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_BOM</name></expr>:</case>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>XML_ROLE_DOCTYPE_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_startDoctypeDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ENTITY_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_entityDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_NOTATION_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_notationDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ATTLIST_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_attlistDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_ROLE_ELEMENT_NONE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_elementDeclHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handleDefault</name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>handleDefault</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>epilogProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>epilogProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><name>XML_TOK_PROLOG_S</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_TOK_PROLOG_S</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_PI</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_COMMENT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>s</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_SUSPENDED</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_FINISHED</name></expr>:</case>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
<default>default:</default><empty_stmt>;</empty_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>processInternalEntity</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>textStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>textEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>openEntity</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>openEntity</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>openEntity</name>
<operator>=</operator> <operator>(</operator><name>OPEN_INTERNAL_ENTITY</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OPEN_INTERNAL_ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>openEntity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name> <operator>=</operator> <name>openEntity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>entity</name></name> <operator>=</operator> <name>entity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>startTagLevel</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>betweenDecl</name></name> <operator>=</operator> <name>betweenDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>internalEventPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>textStart</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textEnd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>+</operator> <name><name>entity</name><operator>-&gt;</operator><name>textLen</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>textStart</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>is_param</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name>
<init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>,
<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_tagLevel</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>,
<argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>XML_ERROR_NONE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>textEnd</name> <operator>!=</operator> <name>next</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>next</name> <operator>-</operator> <name>textStart</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>internalEntityProcessor</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name> <operator>=</operator> <name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name>openEntity</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>internalEntityProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>textStart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>textEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> <modifier>*</modifier></type><name>openEntity</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>openEntity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entity</name> <operator>=</operator> <name><name>openEntity</name><operator>-&gt;</operator><name>entity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textStart</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name><operator>)</operator> <operator>+</operator> <name><name>entity</name><operator>-&gt;</operator><name>processed</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textEnd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>+</operator> <name><name>entity</name><operator>-&gt;</operator><name>textLen</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>textStart</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>is_param</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name>
<init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>,
<argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>openEntity</name><operator>-&gt;</operator><name>startTagLevel</name></name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>,
<argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>textEnd</name> <operator>!=</operator> <name>next</name>
<operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>parsing</name></name> <operator>==</operator> <name>XML_SUSPENDED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>next</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name> <operator>=</operator> <name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>openEntity</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_freeInternalEntities</name></name> <operator>=</operator> <name>openEntity</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>is_param</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>prologProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>, <argument><expr><name>XML_TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_processor</name></name> <operator>=</operator> <name>contentProcessor</name></expr>;</expr_stmt>

<return>return <expr><call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>parser</name><operator>-&gt;</operator><name>m_parentParser</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr></argument>,
<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>,
<argument><expr><operator>(</operator><name>XML_Bool</name><operator>)</operator><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_parsingStatus</name><operator>.</operator><name>finalBuffer</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name> <name>PTRCALL</name></type>
<name>errorProcessor</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_errorCode</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>storeAttributeValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name>
<init>= <expr><call><name>appendAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>isCdata</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isCdata</name> <operator>&amp;&amp;</operator> <call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolChop</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>appendAttributeValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlAttributeValueTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
<case>case <expr><name>XML_TOK_CHAR_REF</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isCdata</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0x20</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:</case>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>

<case>case <expr><name>XML_TOK_ATTRIBUTE_VALUE_S</name></expr>:</case>
<case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isCdata</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0x20</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>checkEntityDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>ch</name> <init>= <expr><operator>(</operator><name>XML_Char</name><operator>)</operator><call><name>XmlPredefinedEntityName</name><argument_list>(
<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>ptr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>entity</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>generalEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_temp2Pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>pool</name> <operator>==</operator> <operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>checkEntityDecl</name> <operator>=</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>documentEntity</name></name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>(</operator><ternary><condition><expr><name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr> ?</condition><then> <expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name></name></expr>
</then><else>: <expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>checkEntityDecl</name> <operator>=</operator> <operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>||</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>checkEntityDecl</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <name><name>entity</name><operator>-&gt;</operator><name>is_internal</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition> <block>{<block_content>










<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>

















<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>notation</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>textEnd</name> <init>= <expr><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>+</operator> <name><name>entity</name><operator>-&gt;</operator><name>textLen</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>appendAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>,
<argument><expr><name>isCdata</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>textEnd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> <break>break;</break>
<default>default:</default>











<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>

</block_content>}</block></switch>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Error</name></name></type>
<name>storeEntityValue</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>entityTextPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>entityTextEnd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>entityValuePool</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Error</name></name></type> <name>result</name> <init>= <expr><name>XML_ERROR_NONE</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>oldInEntityValue</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlEntityValueTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>, <argument><expr><name>entityTextEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_isParamEntity</name></name> <operator>||</operator> <name>enc</name> <operator>!=</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>entityTextPtr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>entity</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>paramEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>entity</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>entityTextPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandler</name></name><argument_list>(
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_externalEntityRefHandlerArg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>storeEntityValue</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_internalEncoding</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>entity</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>+</operator> <name><name>entity</name><operator>-&gt;</operator><name>textLen</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endEntityValue</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>entityTextPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_PARAM_ENTITY_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
<case>case <expr><name>XML_TOK_NONE</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_NONE</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
<case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>:</case>
<case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:</case>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>entityTextPtr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>

<case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>==</operator> <name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>++</operator> <operator>=</operator> <literal type="number">0xA</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>XML_TOK_CHAR_REF</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>entityTextPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_BAD_CHAR_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>==</operator> <name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>++</operator> <operator>=</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block> <break>break;</break>
<case>case <expr><name>XML_TOK_PARTIAL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>entityTextPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
<case>case <expr><name>XML_TOK_INVALID</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_INVALID_TOKEN</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
<default>default:</default>







<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name> <operator>=</operator> <name>entityTextPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>

</block_content>}</block></switch>
<expr_stmt><expr><name>entityTextPtr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></for>
<label><name>endEntityValue</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>m_prologState</name><operator>.</operator><name>inEntityValue</name></name> <operator>=</operator> <name>oldInEntityValue</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>normalizeLines</name><parameter_list>(<parameter><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="number">0xD</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="number">0xD</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0xA</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="number">0xA</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>;</do>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>reportProcessingInstruction</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tem</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tem</name> <operator>=</operator> <name>start</name> <operator>+</operator> <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><call><name>XmlSkipS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>end</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>normalizeLines</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_processingInstructionHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>reportComment</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>start</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>*</operator> <literal type="number">4</literal></expr></argument>,
<argument><expr><name>end</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>data</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>normalizeLines</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_commentHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reportDefault</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>convert_res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eventEndPP</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_encoding</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_eventEndPtr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
















<expr_stmt><expr><name>eventPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventPtr</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>parser</name><operator>-&gt;</operator><name>m_openInternalEntities</name><operator>-&gt;</operator><name>internalEventEndPtr</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>ICHAR</name> <modifier>*</modifier></type><name>dataPtr</name> <init>= <expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>convert_res</name>
<operator>=</operator> <call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dataPtr</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBufEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventEndPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>dataPtr</name> <operator>-</operator> <operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>parser</name><operator>-&gt;</operator><name>m_dataBuf</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eventPP</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>convert_res</name> <operator>!=</operator> <name>XML_CONVERT_COMPLETED</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>convert_res</name> <operator>!=</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name><operator>)</operator></expr>)</condition>;</do>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>m_defaultHandler</name></name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_handlerArg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>end</name> <operator>-</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>defineAttribute</name><parameter_list>(<parameter><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>attId</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></parameter>,
<parameter><decl><type><name>XML_Bool</name></type> <name>isId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>||</operator> <name>isId</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>type</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>attId</name> <operator>==</operator> <name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>isId</name> <operator>&amp;&amp;</operator> <operator>!</operator> <name><name>type</name><operator>-&gt;</operator><name>idAtt</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <name><name>attId</name><operator>-&gt;</operator><name>xmlns</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>idAtt</name></name> <operator>=</operator> <name>attId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>nDefaultAtts</name></name> <operator>==</operator> <name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name></name> <operator>=</operator> <operator>(</operator><name>DEFAULT_ATTRIBUTE</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>DEFAULT_ATTRIBUTE</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>type</name><operator>-&gt;</operator><name>defaultAtts</name></name> <operator>+</operator> <name><name>type</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>attId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name><operator>-&gt;</operator><name>isCdata</name></name> <operator>=</operator> <name>isCdata</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isCdata</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>attId</name><operator>-&gt;</operator><name>maybeTokenized</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>nDefaultAtts</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>setElementTypePrefix</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>elementType</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>name</name> <operator>=</operator> <name><name>elementType</name><operator>-&gt;</operator><name>name</name></name></expr>;</init> <condition><expr><operator>*</operator><name>name</name></expr>;</condition> <incr><expr><name>name</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_COLON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>elementType</name><operator>-&gt;</operator><name>name</name></name></expr>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>name</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>prefixes</name></name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>elementType</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type>
<name>getAttributeId</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>attributeIds</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE_ID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parser</name><operator>-&gt;</operator><name>m_ns</name></name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_m</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_n</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_s</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>name</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_COLON</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>prefixes</name></name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>xmlns</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_COLON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>prefixes</name></name></expr></argument>,
<argument><expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>id</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTEXT_SEP</name></cpp:macro> <cpp:value>XML_T(ASCII_FF)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>getContext</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>needSep</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_EQUALS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>,
<argument><expr><name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name><operator>-&gt;</operator><name>uri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



















<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>needSep</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>prefix</name><operator>-&gt;</operator><name>binding</name></name></expr>)</condition> <block>{<block_content>






<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>needSep</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>CONTEXT_SEP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_EQUALS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>prefix</name><operator>-&gt;</operator><name>binding</name><operator>-&gt;</operator><name>uriLen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>m_namespaceSeparator</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>binding</name><operator>-&gt;</operator><name>uri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>needSep</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>e</name><operator>-&gt;</operator><name>open</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>needSep</name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><name>CONTEXT_SEP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>name</name></name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>needSep</name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name><operator>.</operator><name>start</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Bool</name></type>
<name>setContext</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>context</name> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>CONTEXT_SEP</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>generalEntities</name></name></expr></argument>,
<argument><expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>open</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>context</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <call><name>XML_T</name><argument_list>(<argument><expr><name>ASCII_EQUALS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PREFIX</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>poolLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>defaultPrefix</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prefix</name>
<operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>prefixes</name></name></expr></argument>,
<argument><expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>prefix</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>context</name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>context</name> <operator>!=</operator> <name>CONTEXT_SEP</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>context</name> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>context</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_inheritedBindings</name></name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>XML_ERROR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>context</name> <operator>!=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>context</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>m_tempPool</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>normalizePublicId</name><parameter_list>(<parameter><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>publicId</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>publicId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>publicId</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x20</literal></expr>:</case>
<case>case <expr><literal type="number">0xD</literal></expr>:</case>
<case>case <expr><literal type="number">0xA</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>publicId</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x20</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0x20</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>publicId</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x20</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DTD</name> <modifier>*</modifier></type>
<name>dtdCreate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>DTD</name> <operator>*</operator><operator>)</operator><call><name><name>ms</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DTD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>entityValuePool</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>paramEntities</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffold</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>standalone</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dtdReset</name><parameter_list>(<parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>defaultAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>paramEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>entityValuePool</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>defaultPrefix</name><operator>.</operator><name>binding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>scaffold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffold</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>scaffCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>standalone</name></name> <operator>=</operator> <name>XML_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dtdDestroy</name><parameter_list>(<parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>XML_Bool</name></type> <name>isDocEntity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>defaultAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>paramEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>entityValuePool</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isDocEntity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>scaffold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>ms</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>dtdCopy</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></parameter>, <parameter><decl><type><name>DTD</name> <modifier>*</modifier></type><name>newDtd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DTD</name> <modifier>*</modifier></type><name>oldDtd</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>



<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PREFIX</name> <modifier>*</modifier></type><name>oldP</name> <init>= <expr><operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>oldP</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>oldP</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>newA</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> <modifier>*</modifier></type><name>oldA</name> <init>= <expr><operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>oldA</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>oldA</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newA</name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE_ID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>newA</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newA</name><operator>-&gt;</operator><name>maybeTokenized</name></name> <operator>=</operator> <name><name>oldA</name><operator>-&gt;</operator><name>maybeTokenized</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldA</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>newA</name><operator>-&gt;</operator><name>xmlns</name></name> <operator>=</operator> <name><name>oldA</name><operator>-&gt;</operator><name>xmlns</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldA</name><operator>-&gt;</operator><name>prefix</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>defaultPrefix</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newA</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>newDtd</name><operator>-&gt;</operator><name>defaultPrefix</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newA</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>,
<argument><expr><name><name>oldA</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>newE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>oldE</name> <init>= <expr><operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>oldE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newE</name> <operator>=</operator> <operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>elementTypes</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>newE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name></name> <operator>=</operator> <operator>(</operator><name>DEFAULT_ATTRIBUTE</name> <operator>*</operator><operator>)</operator><call><name><name>ms</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(
<argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>nDefaultAtts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>idAtt</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>idAtt</name></name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>,
<argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>idAtt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>allocDefaultAtts</name></name> <operator>=</operator> <name><name>newE</name><operator>-&gt;</operator><name>nDefaultAtts</name></name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>prefix</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>(</operator><name>PREFIX</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>prefixes</name></name><operator>)</operator></expr></argument>,
<argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>prefix</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newE</name><operator>-&gt;</operator><name>nDefaultAtts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <operator>(</operator><name>ATTRIBUTE_ID</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(
<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>attributeIds</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>id</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isCdata</name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isCdata</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name>
<operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>copyEntityTable</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>,
<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>generalEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>copyEntityTable</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>paramEntities</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>newDtd</name><operator>-&gt;</operator><name>pool</name></name><operator>)</operator></expr></argument>,
<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>oldDtd</name><operator>-&gt;</operator><name>paramEntities</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>paramEntityRead</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>keepProcessing</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>keepProcessing</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>hasParamEntityRefs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>standalone</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>standalone</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>in_eldecl</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>in_eldecl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>scaffold</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>scaffold</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>contentStringLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>scaffSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>scaffLevel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>=</operator> <name><name>oldDtd</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>copyEntityTable</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></parameter>, <parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>newTable</name></decl></parameter>,
<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>newPool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HASH_TABLE</name> <modifier>*</modifier></type><name>oldTable</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>cachedOldBase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>cachedNewBase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>oldTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ENTITY</name> <modifier>*</modifier></type><name>newE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENTITY</name> <modifier>*</modifier></type><name>oldE</name> <init>= <expr><operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>hashTableIterNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>oldE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newE</name> <operator>=</operator> <operator>(</operator><name>ENTITY</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>oldParser</name></expr></argument>, <argument><expr><name>newTable</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>newE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>systemId</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>systemId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>systemId</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>cachedOldBase</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>cachedNewBase</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cachedOldBase</name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tem</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name>cachedOldBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cachedNewBase</name> <operator>=</operator> <name><name>newE</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>publicId</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tem</name> <operator>=</operator> <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>publicId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>publicId</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>tem</name>
<init>= <expr><call><name>poolCopyStringN</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>textPtr</name></name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>textLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>textPtr</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>textLen</name></name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>textLen</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oldE</name><operator>-&gt;</operator><name>notation</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name><operator>-&gt;</operator><name>notation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>notation</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>is_param</name></name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>is_param</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name><operator>-&gt;</operator><name>is_internal</name></name> <operator>=</operator> <name><name>oldE</name><operator>-&gt;</operator><name>is_internal</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_POWER</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>XML_Bool</name> <name>FASTCALL</name></type>
<name>keyeq</name><parameter_list>(<parameter><decl><type><name>KEY</name></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>KEY</name></type> <name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s1</name> <operator>==</operator> <operator>*</operator><name>s2</name></expr>;</condition> <incr><expr><name>s1</name><operator>++</operator></expr><operator>,</operator> <expr><name>s2</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TRUE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>XML_FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>keylen</name><parameter_list>(<parameter><decl><type><name>KEY</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>len</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_salt_to_sipkey</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sipkey</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>k</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>k</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>get_hash_secret_salt</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>FASTCALL</name></type>
<name>hash</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>KEY</name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>siphash</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sipkey</name></name></type> <name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>sip24_valid</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copy_salt_to_sipkey</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sip24_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sip24_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>keylen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>sip24_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NAMED</name> <modifier>*</modifier></type>
<name>lookup</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>KEY</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>createSize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>createSize</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>power</name></name> <operator>=</operator> <name>INIT_POWER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>INIT_POWER</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NAMED</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <operator>(</operator><name>NAMED</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>table</name><operator>-&gt;</operator><name>v</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>hash</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>h</name> <init>= <expr><call><name>hash</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>h</name> <operator>&amp;</operator> <name>mask</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>keyeq</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>step</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>power</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>step</name></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+=</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>step</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>i</name> <operator>-=</operator> <name>step</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>createSize</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>used</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><name><name>table</name><operator>-&gt;</operator><name>power</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>newPower</name> <init>= <expr><name><name>table</name><operator>-&gt;</operator><name>power</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>newSize</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>newPower</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newMask</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>newSize</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name>newSize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NAMED</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NAMED</name> <modifier>*</modifier><modifier>*</modifier></type><name>newV</name> <init>= <expr><operator>(</operator><name>NAMED</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>newV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newHash</name> <init>= <expr><call><name>hash</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><name>newHash</name> <operator>&amp;</operator> <name>newMask</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>newV</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>step</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>newHash</name></expr></argument>, <argument><expr><name>newMask</name></expr></argument>, <argument><expr><name>newPower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><ternary><condition><expr><name>j</name> <operator>&lt;</operator> <name>step</name></expr> ?</condition><then> <expr><operator>(</operator><name>j</name> <operator>+=</operator> <name>newSize</name> <operator>-</operator> <name>step</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>j</name> <operator>-=</operator> <name>step</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>newV</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>newV</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>power</name></name> <operator>=</operator> <name>newPower</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>newSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>h</name> <operator>&amp;</operator> <name>newMask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>step</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>newMask</name></expr></argument>, <argument><expr><name>newPower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name>step</name></expr> ?</condition><then> <expr><operator>(</operator><name>i</name> <operator>+=</operator> <name>newSize</name> <operator>-</operator> <name>step</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>i</name> <operator>-=</operator> <name>step</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>NAMED</name> <operator>*</operator><operator>)</operator><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><name>createSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>createSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name><name>table</name><operator>-&gt;</operator><name>used</name></name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableClear</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableDestroy</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>table</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableInit</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>power</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>mem</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableIterInit</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE_ITER</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HASH_TABLE</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>v</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NAMED</name> <modifier>*</modifier><name>FASTCALL</name></type>
<name>hashTableIterNext</name><parameter_list>(<parameter><decl><type><name>HASH_TABLE_ITER</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>p</name></name> <operator>!=</operator> <name><name>iter</name><operator>-&gt;</operator><name>end</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NAMED</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><operator>*</operator><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>p</name></name><operator>)</operator><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>tem</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>poolInit</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>ms</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>mem</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>poolClear</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>poolDestroy</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>pool</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>pool</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>poolAppend</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>convert_res</name> <init>= <expr><call><name>XmlConvert</name><argument_list>(
<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>ICHAR</name> <operator>*</operator><operator>)</operator><name><name>pool</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_COMPLETED</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name>convert_res</name> <operator>==</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><name>FASTCALL</name></type>
<name>poolCopyString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator></expr>)</condition>;</do>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>poolCopyStringN</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>











<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>n</name></expr><operator>,</operator> <expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier><name>FASTCALL</name></type>
<name>poolAppendString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>poolStoreString</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>&amp;&amp;</operator> <operator>!</operator> <call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>poolBytesToAllocateFor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>blockSize</name></decl></parameter>)</parameter_list> <block>{<block_content>







<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>stretch</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <name>stretch</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stretchedBlockSize</name> <init>= <expr><name>blockSize</name> <operator>*</operator> <operator>(</operator><name>int</name><operator>)</operator><name>stretch</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bytesToAllocate</name>
<init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>BLOCK</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>stretchedBlockSize</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesToAllocate</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bytesToAllocate</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Bool</name> <name>FASTCALL</name></type>
<name>poolGrow</name><parameter_list>(<parameter><decl><type><name>STRING_POOL</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>tem</name> <init>= <expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,
<argument><expr><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>&amp;&amp;</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>==</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesToAllocate</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>offsetInsideBlock</name> <init>= <expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<return>return <expr><name>XML_FALSE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bytesToAllocate</name> <operator>=</operator> <call><name>poolBytesToAllocateFor</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesToAllocate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>BLOCK</name> <operator>*</operator><operator>)</operator><call><name><name>pool</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>realloc_fcn</name></name><argument_list>(<argument><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>bytesToAllocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>blockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name>offsetInsideBlock</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>+</operator> <name>blockSize</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>BLOCK</name> <modifier>*</modifier></type><name>tem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesToAllocate</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>









<return>return <expr><name>XML_FALSE</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>blockSize</name> <operator>&lt;</operator> <name>INIT_BLOCK_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>blockSize</name> <operator>=</operator> <name>INIT_BLOCK_SIZE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>blockSize</name> <operator>*</operator> <literal type="number">2U</literal><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>blockSize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>bytesToAllocate</name> <operator>=</operator> <call><name>poolBytesToAllocateFor</name><argument_list>(<argument><expr><name>blockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesToAllocate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tem</name> <operator>=</operator> <operator>(</operator><name>BLOCK</name> <operator>*</operator><operator>)</operator><call><name><name>pool</name><operator>-&gt;</operator><name>mem</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><name>bytesToAllocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>tem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tem</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>blockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tem</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>blocks</name></name> <operator>=</operator> <name>tem</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>!=</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tem</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name></expr></argument>, <argument><expr><operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>tem</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <operator>(</operator><name><name>pool</name><operator>-&gt;</operator><name>ptr</name></name> <operator>-</operator> <name><name>pool</name><operator>-&gt;</operator><name>start</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>start</name></name> <operator>=</operator> <name><name>tem</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <name><name>tem</name><operator>-&gt;</operator><name>s</name></name> <operator>+</operator> <name>blockSize</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>nextScaffoldPart</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>m_groupSize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffCount</name></name> <operator>&gt;=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffSize</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>CONTENT_SCAFFOLD</name> <operator>*</operator><operator>)</operator><call><name>REALLOC</name><argument_list>(
<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name></name></expr></argument>, <argument><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CONTENT_SCAFFOLD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>CONTENT_SCAFFOLD</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>INIT_SCAFFOLD_ELEMENTS</name>
<operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CONTENT_SCAFFOLD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffSize</name></name> <operator>=</operator> <name>INIT_SCAFFOLD_ELEMENTS</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffCount</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>me</name> <operator>=</operator> <operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>next</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> <modifier>*</modifier></type><name>parent</name>
<init>= <expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffIndex</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffLevel</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>lastchild</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name><name>parent</name><operator>-&gt;</operator><name>lastchild</name></name></expr>]</index></name><operator>.</operator><name>nextsib</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>parent</name><operator>-&gt;</operator><name>childcnt</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>lastchild</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>childcnt</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>firstchild</name></name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>lastchild</name></name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>childcnt</name></name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>nextsib</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>next</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_node</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>src_node</name></decl></parameter>, <parameter><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
<parameter><decl><type><name>XML_Content</name> <modifier>*</modifier><modifier>*</modifier></type><name>contpos</name></decl></parameter>, <parameter><decl><type><name>XML_Char</name> <modifier>*</modifier><modifier>*</modifier></type><name>strpos</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>quant</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name><operator>.</operator><name>quant</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dest</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>XML_CTYPE_NAME</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <operator>*</operator><name>strpos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>strpos</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>*</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>src</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>numchildren</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cn</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>numchildren</name></name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name><operator>.</operator><name>childcnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <operator>*</operator><name>contpos</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>contpos</name> <operator>+=</operator> <name><name>dest</name><operator>-&gt;</operator><name>numchildren</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>cn</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name><operator>.</operator><name>firstchild</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dest</name><operator>-&gt;</operator><name>numchildren</name></name></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>cn</name> <operator>=</operator> <name><name>dtd</name><operator>-&gt;</operator><name>scaffold</name><index>[<expr><name>cn</name></expr>]</index></name><operator>.</operator><name>nextsib</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>build_node</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dest</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>contpos</name></expr></argument>, <argument><expr><name>strpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Content</name> <modifier>*</modifier></type>
<name>build_model</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Content</name> <modifier>*</modifier></type><name>cpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allocsize</name> <init>= <expr><operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>scaffCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Content</name></expr></argument>)</argument_list></sizeof>
<operator>+</operator> <operator>(</operator><name><name>dtd</name><operator>-&gt;</operator><name>contentStringLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>XML_Content</name> <operator>*</operator><operator>)</operator><call><name>MALLOC</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>allocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>XML_Char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>ret</name><index>[<expr><name><name>dtd</name><operator>-&gt;</operator><name>scaffCount</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cpos</name> <operator>=</operator> <operator>&amp;</operator><name><name>ret</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>build_node</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ELEMENT_TYPE</name> <modifier>*</modifier></type>
<name>getElementType</name><parameter_list>(<parameter><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DTD</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name><name>parser</name><operator>-&gt;</operator><name>m_dtd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ELEMENT_TYPE</name> <operator>*</operator><operator>)</operator><call><name>lookup</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>elementTypes</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtd</name><operator>-&gt;</operator><name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>setElementTypePrefix</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>XML_Char</name> <modifier>*</modifier></type>
<name>copyString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XML_Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> <modifier>*</modifier></type><name>memsuite</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>charsRequired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>


<while>while <condition>(<expr><name><name>s</name><index>[<expr><name>charsRequired</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>charsRequired</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>charsRequired</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>memsuite</name><operator>-&gt;</operator><name>malloc_fcn</name></name><argument_list>(<argument><expr><name>charsRequired</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>charsRequired</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
