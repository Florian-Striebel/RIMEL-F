<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/expat/lib/xmltok_impl.c">































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_TOK_IMPL_C</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IS_INVALID_CHAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INVALID_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (IS_INVALID_CHAR(enc, ptr, n)) { *(nextTokPtr) = (ptr); return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_CASES</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INVALID_LEAD_CASE(2, ptr, nextTokPtr) INVALID_LEAD_CASE(3, ptr, nextTokPtr) INVALID_LEAD_CASE(4, ptr, nextTokPtr) case BT_NONXML: case BT_MALFORM: case BT_TRAIL: *(nextTokPtr) = (ptr); return XML_TOK_INVALID;</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NAME_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (! IS_NAME_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NAME_CASES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_NONASCII: if (! IS_NAME_CHAR_MINBPC(enc, ptr)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } case BT_NMSTRT: case BT_HEX: case BT_DIGIT: case BT_NAME: case BT_MINUS: ptr += MINBPC(enc); break; CHECK_NAME_CASE(2, enc, ptr, end, nextTokPtr) CHECK_NAME_CASE(3, enc, ptr, end, nextTokPtr) CHECK_NAME_CASE(4, enc, ptr, end, nextTokPtr)</cpp:value></cpp:define>

















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NMSTRT_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (! IS_NMSTRT_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } ptr += n; break;</cpp:value></cpp:define>










<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NMSTRT_CASES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>nextTokPtr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_NONASCII: if (! IS_NMSTRT_CHAR_MINBPC(enc, ptr)) { *nextTokPtr = ptr; return XML_TOK_INVALID; } case BT_NMSTRT: case BT_HEX: ptr += MINBPC(enc); break; CHECK_NMSTRT_CASE(2, enc, ptr, end, nextTokPtr) CHECK_NMSTRT_CASE(3, enc, ptr, end, nextTokPtr) CHECK_NMSTRT_CASE(4, enc, ptr, end, nextTokPtr)</cpp:value></cpp:define>














<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<parameter><type><name>ident</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ident</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_CHARS</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(end - ptr &gt;= count * MINBPC(enc))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HAS_CHARS(enc, ptr, end, 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE_CHARS</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (! HAS_CHARS(enc, ptr, end, count)) { return XML_TOK_PARTIAL; } }</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQUIRE_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>REQUIRE_CHARS(enc, ptr, end, 1)</cpp:value></cpp:define>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanComment</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_MINUS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_MINUS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COMMENT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanDecl</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanComment</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_LSQB</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COND_SECT_OPEN</name></expr>;</return>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<expr_stmt><expr><call><name>REQUIRE_CHARS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>

<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DECL_OPEN</name></expr>;</return>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>checkPiTarget</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tokPtr</name> <operator>=</operator> <name>XML_TOK_PI</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>ptr</name> <operator>!=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_x</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ASCII_X</name></expr>:</case>
<expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_m</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ASCII_M</name></expr>:</case>
<expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_l</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ASCII_L</name></expr>:</case>
<expr_stmt><expr><name>upper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>upper</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>tokPtr</name> <operator>=</operator> <name>XML_TOK_XML_DECL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPi</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><call><name>PREFIX</name><argument_list>(<argument><expr><name>checkPiTarget</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><call><name>PREFIX</name><argument_list>(<argument><expr><name>checkPiTarget</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanCdataSection</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>CDATA_LSQB</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_C</name></expr>, <expr><name>ASCII_D</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_LSQB</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REQUIRE_CHARS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>CDATA_LSQB</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CDATA_SECT_OPEN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>cdataSectionTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> <operator>-</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CDATA_SECT_CLOSE</name></expr>;</return>
<case>case <expr><name>BT_CR</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BT_LF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n || IS_INVALID_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_DATA_CHARS; } ptr += n; break;</cpp:value></cpp:define>







<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONXML</name></expr>:</case>
<case>case <expr><name>BT_MALFORM</name></expr>:</case>
<case>case <expr><name>BT_TRAIL</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanEndTag</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<for>for <control>(<init><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BT_GT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_END_TAG</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>


<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BT_GT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_END_TAG</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanHexCharRef</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<for>for <control>(<init><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BT_SEMI</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CHAR_REF</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanCharRef</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanHexCharRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<for>for <control>(<init><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BT_SEMI</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CHAR_REF</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanRef</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_NUM</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanCharRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_SEMI</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_ENTITY_REF</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanAtts</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>hadColon</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>hadColon</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hadColon</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>BT_EQUALS</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>

<case>case <expr><name>BT_EQUALS</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>open</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>hadColon</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>open</name> <operator>=</operator> <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>open</name> <operator>==</operator> <name>BT_QUOT</name> <operator>||</operator> <name>open</name> <operator>==</operator> <name>BT_APOS</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>open</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>open</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_AMP</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>tok</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>BT_LT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<goto>goto <name>sol</name>;</goto>
<case>case <expr><name>BT_GT</name></expr>:</case>
<goto>goto <name>gt</name>;</goto>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<continue>continue;</continue>
<case>case <expr><name>BT_GT</name></expr>:</case>
<label><name>gt</name>:</label>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_START_TAG_WITH_ATTS</name></expr>;</return>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<label><name>sol</name>:</label>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_EMPTY_ELEMENT_WITH_ATTS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanLt</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>hadColon</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_EXCL</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanComment</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_LSQB</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanCdataSection</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPi</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanEndTag</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>hadColon</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>hadColon</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hadColon</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_GT</name></expr>:</case>
<goto>goto <name>gt</name>;</goto>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<goto>goto <name>sol</name>;</goto>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanAtts</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>BT_GT</name></expr>:</case>
<label><name>gt</name>:</label>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_START_TAG_NO_ATTS</name></expr>;</return>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<label><name>sol</name>:</label>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_EMPTY_ELEMENT_NO_ATTS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>contentTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> <operator>-</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_LT</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLt</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_AMP</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_CR</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BT_LF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_TRAILING_RSQB</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_TRAILING_RSQB</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>-=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n || IS_INVALID_CHAR(enc, ptr, n)) { *nextTokPtr = ptr; return XML_TOK_DATA_CHARS; } ptr += n; break;</cpp:value></cpp:define>







<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHARS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHARS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>BT_AMP</name></expr>:</case>
<case>case <expr><name>BT_LT</name></expr>:</case>
<case>case <expr><name>BT_NONXML</name></expr>:</case>
<case>case <expr><name>BT_MALFORM</name></expr>:</case>
<case>case <expr><name>BT_TRAIL</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPercent</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PERCENT</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_SEMI</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanPoundName</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NMSTRT_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_RPAR</name></expr>:</case>
<case>case <expr><name>BT_GT</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<case>case <expr><name>BT_VERBAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_POUND_NAME</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><name>XML_TOK_POUND_NAME</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>scanLit</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>open</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_QUOT</name></expr>:</case>
<case>case <expr><name>BT_APOS</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>open</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><name>XML_TOK_LITERAL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_GT</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<case>case <expr><name>BT_LSQB</name></expr>:</case>
<return>return <expr><name>XML_TOK_LITERAL</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>prologTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> <operator>-</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_QUOT</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLit</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>BT_QUOT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_APOS</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanLit</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>BT_APOS</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_LT</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_EXCL</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanDecl</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPi</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<case>case <expr><name>BT_NONASCII</name></expr>:</case>
<case>case <expr><name>BT_LEAD2</name></expr>:</case>
<case>case <expr><name>BT_LEAD3</name></expr>:</case>
<case>case <expr><name>BT_LEAD4</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INSTANCE_START</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>BT_CR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><name>XML_TOK_PROLOG_S</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>BT_CR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PROLOG_S</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_PROLOG_S</name></expr>;</return>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPercent</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>BT_COMMA</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COMMA</name></expr>;</return>
<case>case <expr><name>BT_LSQB</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OPEN_BRACKET</name></expr>;</return>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><name>XML_TOK_CLOSE_BRACKET</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>REQUIRE_CHARS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_COND_SECT_CLOSE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_BRACKET</name></expr>;</return>
<case>case <expr><name>BT_LPAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OPEN_PAREN</name></expr>;</return>
<case>case <expr><name>BT_RPAR</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><name>XML_TOK_CLOSE_PAREN</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_AST</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_ASTERISK</name></expr>;</return>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_QUESTION</name></expr>;</return>
<case>case <expr><name>BT_PLUS</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN_PLUS</name></expr>;</return>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_GT</name></expr>:</case>
<case>case <expr><name>BT_COMMA</name></expr>:</case>
<case>case <expr><name>BT_VERBAR</name></expr>:</case>
<case>case <expr><name>BT_RPAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_CLOSE_PAREN</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<case>case <expr><name>BT_VERBAR</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_OR</name></expr>;</return>
<case>case <expr><name>BT_GT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DECL_CLOSE</name></expr>;</return>
<case>case <expr><name>BT_NUM</name></expr>:</case>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPoundName</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: if (end - ptr &lt; n) return XML_TOK_PARTIAL_CHAR; if (IS_NMSTRT_CHAR(enc, ptr, n)) { ptr += n; tok = XML_TOK_NAME; break; } if (IS_NAME_CHAR(enc, ptr, n)) { ptr += n; tok = XML_TOK_NMTOKEN; break; } *nextTokPtr = ptr; return XML_TOK_INVALID;</cpp:value></cpp:define>















<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<case>case <expr><name>BT_NAME</name></expr>:</case>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BT_NONASCII</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NAME</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_GT</name></expr>:</case>
<case>case <expr><name>BT_RPAR</name></expr>:</case>
<case>case <expr><name>BT_COMMA</name></expr>:</case>
<case>case <expr><name>BT_VERBAR</name></expr>:</case>
<case>case <expr><name>BT_LSQB</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<case>case <expr><name>BT_S</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>tok</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>XML_TOK_NAME</name></expr>:</case>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_PREFIXED_NAME</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>CHECK_NAME_CASES</name><argument_list>(<argument>enc</argument>, <argument>ptr</argument>, <argument>end</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<default>default:</default>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>XML_TOK_PREFIXED_NAME</name></expr>:</case>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <name>XML_TOK_NMTOKEN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BT_PLUS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_NMTOKEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_PLUS</name></expr>;</return>
<case>case <expr><name>BT_AST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_NMTOKEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_ASTERISK</name></expr>;</return>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>XML_TOK_NMTOKEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_NAME_QUESTION</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><name>tok</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>attributeValueTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>





<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: ptr += n; break;</cpp:value></cpp:define>



<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_AMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_LT</name></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_INVALID</name></expr>;</return>
<case>case <expr><name>BT_LF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_CR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BT_LF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_S</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_ATTRIBUTE_VALUE_S</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>entityValueTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>





<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: ptr += n; break;</cpp:value></cpp:define>



<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_AMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanRef</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><call><name>PREFIX</name><argument_list>(<argument><expr><name>scanPercent</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>tok</name> <operator>==</operator> <name>XML_TOK_PERCENT</name><operator>)</operator></expr> ?</condition><then> <expr><name>XML_TOK_INVALID</name></expr> </then><else>: <expr><name>tok</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_LF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<case>case <expr><name>BT_CR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_TRAILING_CR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BT_LF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_NEWLINE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_DATA_CHARS</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>ignoreSectionTok</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>end</name> <operator>-</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>INVALID_CASES</name><argument_list>(<argument>ptr</argument>, <argument>nextTokPtr</argument>)</argument_list></macro>
<case>case <expr><name>BT_LT</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_EXCL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_LSQB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>level</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_RSQB</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_RSQB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>REQUIRE_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_GT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_IGNORE_SECT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name>level</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>isPublicId</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>badPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>-=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<case>case <expr><name>BT_APOS</name></expr>:</case>
<case>case <expr><name>BT_LPAR</name></expr>:</case>
<case>case <expr><name>BT_RPAR</name></expr>:</case>
<case>case <expr><name>BT_PLUS</name></expr>:</case>
<case>case <expr><name>BT_COMMA</name></expr>:</case>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<case>case <expr><name>BT_EQUALS</name></expr>:</case>
<case>case <expr><name>BT_QUEST</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_SEMI</name></expr>:</case>
<case>case <expr><name>BT_EXCL</name></expr>:</case>
<case>case <expr><name>BT_AST</name></expr>:</case>
<case>case <expr><name>BT_PERCNT</name></expr>:</case>
<case>case <expr><name>BT_NUM</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><name>BT_S</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_TAB</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_NAME</name></expr>:</case>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x7f</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<default>default:</default>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x24</literal></expr>:</case>
<case>case <expr><literal type="number">0x40</literal></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>getAtts</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attsMax</name></decl></parameter>,
<parameter><decl><type><name>ATTRIBUTE</name> <modifier>*</modifier></type><name>atts</name></decl></parameter>)</parameter_list> <block>{<block_content>
<enum>enum <block>{ <decl><name>other</name></decl>, <decl><name>inName</name></decl>, <decl><name>inValue</name></decl> }</block> <decl><name>state</name> <init>= <expr><name>inName</name></expr></init></decl>;</enum>
<decl_stmt><decl><type><name>int</name></type> <name>nAtts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>open</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init><condition>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>START_NAME</name></cpp:macro> <cpp:value>if (state == other) { if (nAtts &lt; attsMax) { atts[nAtts].name = ptr; atts[nAtts].normalized = 1; } state = inName; }</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: START_NAME ptr += (n - MINBPC(enc)); break;</cpp:value></cpp:define>



<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONASCII</name></expr>:</case>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<macro><name>START_NAME</name></macro>
<break>break;</break>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>START_NAME</name></cpp:undef>
<case>case <expr><name>BT_QUOT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>inValue</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>valuePtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>inValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>open</name> <operator>=</operator> <name>BT_QUOT</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>open</name> <operator>==</operator> <name>BT_QUOT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>other</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>valueEnd</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nAtts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_APOS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>inValue</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>valuePtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>inValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>open</name> <operator>=</operator> <name>BT_APOS</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>open</name> <operator>==</operator> <name>BT_APOS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>other</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>valueEnd</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nAtts</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_AMP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>normalized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_S</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>inName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>other</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>inValue</name> <operator>&amp;&amp;</operator> <name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name> <operator>&amp;&amp;</operator> <name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>normalized</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>ptr</name> <operator>==</operator> <name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>valuePtr</name>
<operator>||</operator> <call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ASCII_SPACE</name>
<operator>||</operator> <call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>ASCII_SPACE</name>
<operator>||</operator> <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>open</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>normalized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_LF</name></expr>:</case>


<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>inName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <name>other</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>inValue</name> <operator>&amp;&amp;</operator> <name>nAtts</name> <operator>&lt;</operator> <name>attsMax</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>atts</name><index>[<expr><name>nAtts</name></expr>]</index></name><operator>.</operator><name>normalized</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>BT_GT</name></expr>:</case>
<case>case <expr><name>BT_SOL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>inValue</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nAtts</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>charRefNumber</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_SEMI</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_0</name></expr>:</case>
<case>case <expr><name>ASCII_1</name></expr>:</case>
<case>case <expr><name>ASCII_2</name></expr>:</case>
<case>case <expr><name>ASCII_3</name></expr>:</case>
<case>case <expr><name>ASCII_4</name></expr>:</case>
<case>case <expr><name>ASCII_5</name></expr>:</case>
<case>case <expr><name>ASCII_6</name></expr>:</case>
<case>case <expr><name>ASCII_7</name></expr>:</case>
<case>case <expr><name>ASCII_8</name></expr>:</case>
<case>case <expr><name>ASCII_9</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name>ASCII_0</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ASCII_A</name></expr>:</case>
<case>case <expr><name>ASCII_B</name></expr>:</case>
<case>case <expr><name>ASCII_C</name></expr>:</case>
<case>case <expr><name>ASCII_D</name></expr>:</case>
<case>case <expr><name>ASCII_E</name></expr>:</case>
<case>case <expr><name>ASCII_F</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name>ASCII_A</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ASCII_a</name></expr>:</case>
<case>case <expr><name>ASCII_b</name></expr>:</case>
<case>case <expr><name>ASCII_c</name></expr>:</case>
<case>case <expr><name>ASCII_d</name></expr>:</case>
<case>case <expr><name>ASCII_e</name></expr>:</case>
<case>case <expr><name>ASCII_f</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>+=</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name>ASCII_a</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_SEMI</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>+=</operator> <operator>(</operator><name>c</name> <operator>-</operator> <name>ASCII_0</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;=</operator> <literal type="number">0x110000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>predefinedEntityName</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><operator>(</operator><name>end</name> <operator>-</operator> <name>ptr</name><operator>)</operator> <operator>/</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASCII_t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_l</name></expr>:</case>
<return>return <expr><name>ASCII_LT</name></expr>;</return>
<case>case <expr><name>ASCII_g</name></expr>:</case>
<return>return <expr><name>ASCII_GT</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ASCII_AMP</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<switch>switch <condition>(<expr><call><name>BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ASCII_q</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_u</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ASCII_QUOT</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ASCII_a</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ASCII_s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ASCII_APOS</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>nameMatchesAscii</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>ptr2</name></expr>;</condition> <incr><expr><name>ptr1</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><name>ptr2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>end1</name> <operator>-</operator> <name>ptr1</name> <operator>&lt;</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>





<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>CHAR_MATCHES</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>ptr1</name> <operator>==</operator> <name>end1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>nameLength</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: ptr += n; break;</cpp:value></cpp:define>



<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_NONASCII</name></expr>:</case>
<case>case <expr><name>BT_NMSTRT</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BT_COLON</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BT_HEX</name></expr>:</case>
<case>case <expr><name>BT_DIGIT</name></expr>:</case>
<case>case <expr><name>BT_NAME</name></expr>:</case>
<case>case <expr><name>BT_MINUS</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>start</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>PTRFASTCALL</name>
<name>PREFIX</name></type>(<name>skipS</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_LF</name></expr>:</case>
<case>case <expr><name>BT_CR</name></expr>:</case>
<case>case <expr><name>BT_S</name></expr>:</case>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name>
<name>PREFIX</name></type>(<name>updatePosition</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>POSITION</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEAD_CASE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case BT_LEAD##n: ptr += n; break;</cpp:value></cpp:define>



<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>LEAD_CASE</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LEAD_CASE</name></cpp:undef>
<case>case <expr><name>BT_LF</name></expr>:</case>
<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>columnNumber</name></name> <operator>=</operator> <operator>(</operator><name>XML_Size</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>lineNumber</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BT_CR</name></expr>:</case>
<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>lineNumber</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HAS_CHAR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BT_LF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>columnNumber</name></name> <operator>=</operator> <operator>(</operator><name>XML_Size</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>MINBPC</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>columnNumber</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DO_LEAD_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MULTIBYTE_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INVALID_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NAME_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NAME_CASES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NMSTRT_CASE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_NMSTRT_CASES</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
