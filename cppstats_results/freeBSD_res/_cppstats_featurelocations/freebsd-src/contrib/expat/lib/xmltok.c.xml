<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/expat/lib/xmltok.c">































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;=</operator> <literal type="number">1700</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bool</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>false</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>true</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winconfig.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXPAT_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat_config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat_external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nametab.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_SECTION_TOK_VTABLE</name></cpp:macro> <cpp:value>, PREFIX(ignoreSectionTok)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IGNORE_SECTION_TOK_VTABLE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE1</name></cpp:macro> <cpp:value>{PREFIX(prologTok), PREFIX(contentTok), PREFIX(cdataSectionTok) IGNORE_SECTION_TOK_VTABLE}, {PREFIX(attributeValueTok), PREFIX(entityValueTok)}, PREFIX(nameMatchesAscii), PREFIX(nameLength), PREFIX(skipS), PREFIX(getAtts), PREFIX(charRefNumber), PREFIX(predefinedEntityName), PREFIX(updatePosition), PREFIX(isPublicId)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, PREFIX(toUtf8), PREFIX(toUtf16)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCS2_GET_NAMING</name><parameter_list>(<parameter><type><name>pages</name></type></parameter>, <parameter><type><name>hi</name></type></parameter>, <parameter><type><name>lo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap[(pages[hi] &lt;&lt; 3) + ((lo) &gt;&gt; 5)] &amp; (1u &lt;&lt; ((lo)&amp;0x1F)))</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING2</name><parameter_list>(<parameter><type><name>pages</name></type></parameter>, <parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap[((pages)[(((byte)[0]) &gt;&gt; 2) &amp; 7] &lt;&lt; 3) + ((((byte)[0]) &amp; 3) &lt;&lt; 1) + ((((byte)[1]) &gt;&gt; 5) &amp; 1)] &amp; (1u &lt;&lt; (((byte)[1]) &amp; 0x1F)))</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING3</name><parameter_list>(<parameter><type><name>pages</name></type></parameter>, <parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(namingBitmap [((pages)[((((byte)[0]) &amp; 0xF) &lt;&lt; 4) + ((((byte)[1]) &gt;&gt; 2) &amp; 0xF)] &lt;&lt; 3) + ((((byte)[1]) &amp; 3) &lt;&lt; 1) + ((((byte)[2]) &gt;&gt; 5) &amp; 1)] &amp; (1u &lt;&lt; (((byte)[2]) &amp; 0x1F)))</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_GET_NAMING</name><parameter_list>(<parameter><type><name>pages</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n) == 2 ? UTF8_GET_NAMING2(pages, (const unsigned char *)(p)) : ((n) == 3 ? UTF8_GET_NAMING3(pages, (const unsigned char *)(p)) : 0))</cpp:value></cpp:define>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID2</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*p) &lt; 0xC2 || ((p)[1] &amp; 0x80) == 0 || ((p)[1] &amp; 0xC0) == 0xC0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID3</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((p)[2] &amp; 0x80) == 0 || ((*p) == 0xEF &amp;&amp; (p)[1] == 0xBF ? (p)[2] &gt; 0xBD : ((p)[2] &amp; 0xC0) == 0xC0) || ((*p) == 0xE0 ? (p)[1] &lt; 0xA0 || ((p)[1] &amp; 0xC0) == 0xC0 : ((p)[1] &amp; 0x80) == 0 || ((*p) == 0xED ? (p)[1] &gt; 0x9F : ((p)[1] &amp; 0xC0) == 0xC0)))</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTF8_INVALID4</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((p)[3] &amp; 0x80) == 0 || ((p)[3] &amp; 0xC0) == 0xC0 || ((p)[2] &amp; 0x80) == 0 || ((p)[2] &amp; 0xC0) == 0xC0 || ((*p) == 0xF0 ? (p)[1] &lt; 0x90 || ((p)[1] &amp; 0xC0) == 0xC0 : ((p)[1] &amp; 0x80) == 0 || ((*p) == 0xF4 ? (p)[1] &gt; 0x8F : ((p)[1] &amp; 0xC0) == 0xC0)))</cpp:value></cpp:define>







<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>isNever</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isName2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_GET_NAMING2</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isName3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_GET_NAMING3</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf8_isName4</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isNmstrt2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_GET_NAMING2</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isNmstrt3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_GET_NAMING3</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utf8_isNmstrt4</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_INVALID2</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid3</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_INVALID3</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>utf8_isInvalid4</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>UTF8_INVALID4</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>normal_encoding</name> <block>{
<decl_stmt><decl><type><name>ENCODING</name></type> <name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>type</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>byteType</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isNameMin</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isNmstrtMin</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>byteToAscii</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRCALL</name> <modifier>*</modifier><name>charMatches</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isName2</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isName3</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isName4</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isNmstrt2</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isNmstrt3</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isNmstrt4</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isInvalid2</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isInvalid3</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<name>PTRFASTCALL</name> <modifier>*</modifier><name>isInvalid4</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_NORMAL_ENCODING</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((const struct normal_encoding *)(enc))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD_VTABLE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>E##byteType, E##isNameMin, E##isNmstrtMin, E##byteToAscii, E##charMatches,</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD_VTABLE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMAL_VTABLE</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>E##isName2, E##isName3, E##isName4, E##isNmstrt2, E##isNmstrt3, E##isNmstrt4, E##isInvalid2, E##isInvalid3, E##isInvalid4</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NULL_VTABLE</name></cpp:macro> <cpp:value>NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL</cpp:value></cpp:define>




<function_decl><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type> <name>checkCharRefNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ascii.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sb_isNameMin</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sb_isNmstrtMin</name></cpp:macro> <cpp:value>isNever</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;minBytesPerChar)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SB_BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((struct normal_encoding *)(enc))-&gt;type[(unsigned char)*(p)])</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>sb_byteType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>SB_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;byteType(enc, p))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SB_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;byteToAscii(enc, p))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>sb_byteToAscii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>p</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(p))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isName##n(enc, p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNmstrt##n(enc, p))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_INVALID_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isInvalid##n(enc, p))</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNameMin(enc, p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;isNmstrtMin(enc, p))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(AS_NORMAL_ENCODING(enc)-&gt;charMatches(enc, p, c))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>sb_charMatches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>p</name> <operator>==</operator> <name>c</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(p) == c)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<parameter><type><name>ident</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>normal_##ident</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_IMPL_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XML_TOK_IMPL_C</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>

<enum>enum <block>{
<decl><name>UTF8_cval1</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,
<decl><name>UTF8_cval2</name> <init>= <expr><literal type="number">0xc0</literal></expr></init></decl>,
<decl><name>UTF8_cval3</name> <init>= <expr><literal type="number">0xe0</literal></expr></init></decl>,
<decl><name>UTF8_cval4</name> <init>= <expr><literal type="number">0xf0</literal></expr></init></decl>
}</block>;</enum>

<function><type><name>void</name></type>
<name>_INTERNAL_trim_to_complete_utf8_characters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromLimRef</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name> <init>= <expr><operator>*</operator><name>fromLimRef</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>walked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>fromLim</name> <operator>&gt;</operator> <name>from</name></expr>;</condition> <incr><expr><name>fromLim</name><operator>--</operator></expr><operator>,</operator> <expr><name>walked</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>prev</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>fromLim</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prev</name> <operator>&amp;</operator> <literal type="number">0xf8u</literal><operator>)</operator>
<operator>==</operator> <literal type="number">0xf0u</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>walked</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fromLim</name> <operator>+=</operator> <literal type="number">4</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>walked</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>prev</name> <operator>&amp;</operator> <literal type="number">0xf0u</literal><operator>)</operator>
<operator>==</operator> <literal type="number">0xe0u</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>walked</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fromLim</name> <operator>+=</operator> <literal type="number">3</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>walked</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>prev</name> <operator>&amp;</operator> <literal type="number">0xe0u</literal><operator>)</operator>
<operator>==</operator> <literal type="number">0xc0u</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>walked</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fromLim</name> <operator>+=</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>walked</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>prev</name> <operator>&amp;</operator> <literal type="number">0x80u</literal><operator>)</operator>
<operator>==</operator> <literal type="number">0x00u</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>fromLimRef</name> <operator>=</operator> <name>fromLim</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>utf8_toUtf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>input_incomplete</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>output_exhausted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>bytesAvailable</name> <init>= <expr><name>fromLim</name> <operator>-</operator> <operator>*</operator><name>fromP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>bytesStorable</name> <init>= <expr><name>toLim</name> <operator>-</operator> <operator>*</operator><name>toP</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytesAvailable</name> <operator>&gt;</operator> <name>bytesStorable</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fromLim</name> <operator>=</operator> <operator>*</operator><name>fromP</name> <operator>+</operator> <name>bytesStorable</name></expr>;</expr_stmt>
<expr_stmt><expr><name>output_exhausted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fromLimBefore</name> <init>= <expr><name>fromLim</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>_INTERNAL_trim_to_complete_utf8_characters</name><argument_list>(<argument><expr><operator>*</operator><name>fromP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fromLim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fromLim</name> <operator>&lt;</operator> <name>fromLimBefore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>input_incomplete</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>bytesToCopy</name> <init>= <expr><name>fromLim</name> <operator>-</operator> <operator>*</operator><name>fromP</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>toP</name></expr></argument>, <argument><expr><operator>*</operator><name>fromP</name></expr></argument>, <argument><expr><name>bytesToCopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromP</name> <operator>+=</operator> <name>bytesToCopy</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>toP</name> <operator>+=</operator> <name>bytesToCopy</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>output_exhausted</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>input_incomplete</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_INPUT_INCOMPLETE</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>utf8_toUtf16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>XML_Convert_Result</name></name></type> <name>res</name> <init>= <expr><name>XML_CONVERT_COMPLETED</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><operator>*</operator><name>toP</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><operator>*</operator><name>fromP</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>fromLim</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>&lt;</operator> <name>toLim</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator>struct <name>normal_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name><operator>)</operator><operator>-&gt;</operator><name><name>type</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>from</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BT_LEAD2</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>fromLim</name> <operator>-</operator> <name>from</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name></expr>;</expr_stmt>
<goto>goto <name>after</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>from</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BT_LEAD3</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>fromLim</name> <operator>-</operator> <name>from</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name></expr>;</expr_stmt>
<goto>goto <name>after</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><name><name>from</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BT_LEAD4</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>toLim</name> <operator>-</operator> <name>to</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</expr_stmt>
<goto>goto <name>after</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fromLim</name> <operator>-</operator> <name>from</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>XML_CONVERT_INPUT_INCOMPLETE</name></expr>;</expr_stmt>
<goto>goto <name>after</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><name><name>from</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>from</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>-=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xD800</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0x3FF</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xDC00</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>from</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>to</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>from</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>fromLim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>after</name>:</label>
<expr_stmt><expr><operator>*</operator><name>fromP</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>toP</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>utf8_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>utf8_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_utf8_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_utf8_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>utf8_toUtf8</name></expr>, <expr><name>utf8_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf8tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <macro><name>NORMAL_VTABLE</name><argument_list>(<argument>utf8_</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>latin1_toUtf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fromP</name> <operator>==</operator> <name>fromLim</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>*</operator><name>fromP</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>toLim</name> <operator>-</operator> <operator>*</operator><name>toP</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>UTF8_cval2</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>toP</name> <operator>==</operator> <name>toLim</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>latin1_toUtf16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>toP</name> <operator>&lt;</operator> <name>toLim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>toP</name> <operator>==</operator> <name>toLim</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>latin1_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>latin1_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>latin1_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>latin1_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>ascii_toUtf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>toP</name> <operator>&lt;</operator> <name>toLim</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>toP</name> <operator>==</operator> <name>toLim</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>ascii_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>ascii_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>

}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>ascii_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE1</name></expr>, <expr><name>ascii_toUtf8</name></expr>, <expr><name>latin1_toUtf16</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>

}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>sb_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unicode_byte_type</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>lo</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>hi</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0xD8</literal></expr>:</case>
<case>case <expr><literal type="number">0xD9</literal></expr>:</case>
<case>case <expr><literal type="number">0xDA</literal></expr>:</case>
<case>case <expr><literal type="number">0xDB</literal></expr>:</case>
<return>return <expr><name>BT_LEAD4</name></expr>;</return>

<case>case <expr><literal type="number">0xDC</literal></expr>:</case>
<case>case <expr><literal type="number">0xDD</literal></expr>:</case>
<case>case <expr><literal type="number">0xDE</literal></expr>:</case>
<case>case <expr><literal type="number">0xDF</literal></expr>:</case>
<return>return <expr><name>BT_TRAIL</name></expr>;</return>
<case>case <expr><literal type="number">0xFF</literal></expr>:</case>
<switch>switch <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>lo</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0xFF</literal></expr>:</case>
<case>case <expr><literal type="number">0xFE</literal></expr>:</case>
<return>return <expr><name>BT_NONXML</name></expr>;</return>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>BT_NONASCII</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_UTF16_TO_UTF8</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static enum XML_Convert_Result PTRCALL E##toUtf8( const ENCODING *enc, const char **fromP, const char *fromLim, char **toP, const char *toLim) { const char *from = *fromP; UNUSED_P(enc); fromLim = from + (((fromLim - from) &gt;&gt; 1) &lt;&lt; 1); for (; from &lt; fromLim; from += 2) { int plane; unsigned char lo2; unsigned char lo = GET_LO(from); unsigned char hi = GET_HI(from); switch (hi) { case 0: if (lo &lt; 0x80) { if (*toP == toLim) { *fromP = from; return XML_CONVERT_OUTPUT_EXHAUSTED; } *(*toP)++ = lo; break; } case 0x1: case 0x2: case 0x3: case 0x4: case 0x5: case 0x6: case 0x7: if (toLim - *toP &lt; 2) { *fromP = from; return XML_CONVERT_OUTPUT_EXHAUSTED; } *(*toP)++ = ((lo &gt;&gt; 6) | (hi &lt;&lt; 2) | UTF8_cval2); *(*toP)++ = ((lo &amp; 0x3f) | 0x80); break; default: if (toLim - *toP &lt; 3) { *fromP = from; return XML_CONVERT_OUTPUT_EXHAUSTED; } *(*toP)++ = ((hi &gt;&gt; 4) | UTF8_cval3); *(*toP)++ = (((hi &amp; 0xf) &lt;&lt; 2) | (lo &gt;&gt; 6) | 0x80); *(*toP)++ = ((lo &amp; 0x3f) | 0x80); break; case 0xD8: case 0xD9: case 0xDA: case 0xDB: if (toLim - *toP &lt; 4) { *fromP = from; return XML_CONVERT_OUTPUT_EXHAUSTED; } if (fromLim - from &lt; 4) { *fromP = from; return XML_CONVERT_INPUT_INCOMPLETE; } plane = (((hi &amp; 0x3) &lt;&lt; 2) | ((lo &gt;&gt; 6) &amp; 0x3)) + 1; *(*toP)++ = (char)((plane &gt;&gt; 2) | UTF8_cval4); *(*toP)++ = (((lo &gt;&gt; 2) &amp; 0xF) | ((plane &amp; 0x3) &lt;&lt; 4) | 0x80); from += 2; lo2 = GET_LO(from); *(*toP)++ = (((lo &amp; 0x3) &lt;&lt; 4) | ((GET_HI(from) &amp; 0x3) &lt;&lt; 2) | (lo2 &gt;&gt; 6) | 0x80); *(*toP)++ = ((lo2 &amp; 0x3f) | 0x80); break; } } *fromP = from; if (from &lt; fromLim) return XML_CONVERT_INPUT_INCOMPLETE; else return XML_CONVERT_COMPLETED; }</cpp:value></cpp:define>












































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_UTF16_TO_UTF16</name><parameter_list>(<parameter><type><name>E</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static enum XML_Convert_Result PTRCALL E##toUtf16( const ENCODING *enc, const char **fromP, const char *fromLim, unsigned short **toP, const unsigned short *toLim) { enum XML_Convert_Result res = XML_CONVERT_COMPLETED; UNUSED_P(enc); fromLim = *fromP + (((fromLim - *fromP) &gt;&gt; 1) &lt;&lt; 1); if (fromLim - *fromP &gt; ((toLim - *toP) &lt;&lt; 1) &amp;&amp; (GET_HI(fromLim - 2) &amp; 0xF8) == 0xD8) { fromLim -= 2; res = XML_CONVERT_INPUT_INCOMPLETE; } for (; *fromP &lt; fromLim &amp;&amp; *toP &lt; toLim; *fromP += 2) *(*toP)++ = (GET_HI(*fromP) &lt;&lt; 8) | GET_LO(*fromP); if ((*toP == toLim) &amp;&amp; (*fromP &lt; fromLim)) return XML_CONVERT_OUTPUT_EXHAUSTED; else return res; }</cpp:value></cpp:define>




















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET2</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((ptr)[0] = ((ch)&amp;0xff)), ((ptr)[1] = ((ch) &gt;&gt; 8)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LO</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[0])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HI</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[1])</cpp:value></cpp:define>

<macro><name>DEFINE_UTF16_TO_UTF8</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>
<macro><name>DEFINE_UTF16_TO_UTF16</name><argument_list>(<argument>little2_</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_LO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_HI</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET2</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((ptr)[0] = ((ch) &gt;&gt; 8)), ((ptr)[1] = ((ch)&amp;0xFF)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LO</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_HI</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)(ptr)[0])</cpp:value></cpp:define>

<macro><name>DEFINE_UTF16_TO_UTF8</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>
<macro><name>DEFINE_UTF16_TO_UTF16</name><argument_list>(<argument>big2_</argument>)</argument_list></macro>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET2</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_LO</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GET_HI</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 ? ((struct normal_encoding *)(enc))-&gt;type[(unsigned char)*(p)] : unicode_byte_type((p)[1], (p)[0]))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 ? (p)[0] : -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_CHAR_MATCHES</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[1] == 0 &amp;&amp; (p)[0] == c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(namePages, (unsigned char)p[1], (unsigned char)p[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LITTLE2_IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[1], (unsigned char)p[0])</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_byteType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>LITTLE2_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_byteToAscii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LITTLE2_BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>little2_charMatches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LITTLE2_CHAR_MATCHES</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_isNameMin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LITTLE2_IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>little2_isNmstrtMin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LITTLE2_IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VTABLE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, little2_toUtf8, little2_toUtf16</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<parameter><type><name>ident</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>little2_##ident</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_BYTE_TO_ASCII(p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_CHAR_MATCHES(p, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_IS_NAME_CHAR_MINBPC(p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LITTLE2_IS_NMSTRT_CHAR_MINBPC(p)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_IMPL_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XML_TOK_IMPL_C</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>little2_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>==</operator> <literal type="number">1234</literal></expr></cpp:if>
<expr><literal type="number">1</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>little2_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>==</operator> <literal type="number">1234</literal></expr></cpp:if>
<expr><literal type="number">1</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>!=</operator> <literal type="number">4321</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_little2_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_little2_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>little2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 ? ((struct normal_encoding *)(enc))-&gt;type[(unsigned char)(p)[1]] : unicode_byte_type((p)[0], (p)[1]))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 ? (p)[1] : -1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_CHAR_MATCHES</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[0] == 0 &amp;&amp; (p)[1] == c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(namePages, (unsigned char)p[0], (unsigned char)p[1])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIG2_IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UCS2_GET_NAMING(nmstrtPages, (unsigned char)p[0], (unsigned char)p[1])</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_byteType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>BIG2_BYTE_TYPE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_byteToAscii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>BIG2_BYTE_TO_ASCII</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRCALL</name></type>
<name>big2_charMatches</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>BIG2_CHAR_MATCHES</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_isNameMin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>BIG2_IS_NAME_CHAR_MINBPC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>big2_isNmstrtMin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>BIG2_IS_NMSTRT_CHAR_MINBPC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>VTABLE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VTABLE</name></cpp:macro> <cpp:value>VTABLE1, big2_toUtf8, big2_toUtf16</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name><parameter_list>(<parameter><type><name>ident</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>big2_##ident</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TYPE</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIG2_BYTE_TYPE(enc, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_TO_ASCII</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIG2_BYTE_TO_ASCII(p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MATCHES</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIG2_CHAR_MATCHES(p, c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIG2_IS_NAME_CHAR_MINBPC(p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NMSTRT_CHAR_MINBPC</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BIG2_IS_NMSTRT_CHAR_MINBPC(p)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_IMPL_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_impl.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XML_TOK_IMPL_C</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TYPE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BYTE_TO_ASCII</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHAR_MATCHES</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NAME_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_NMSTRT_CHAR_MINBPC</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_INVALID_CHAR</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>big2_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>==</operator> <literal type="number">4321</literal></expr></cpp:if>
<expr><literal type="number">1</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>big2_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>==</operator> <literal type="number">4321</literal></expr></cpp:if>
<expr><literal type="number">1</literal>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"asciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTEORDER</name> <operator>!=</operator> <literal type="number">1234</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_big2_encoding_ns</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>normal_encoding</name></name></type> <name>internal_big2_encoding</name>
<init>= <expr><block>{<expr><block>{<expr><name>VTABLE</name></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
<expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_COLON</name></cpp:macro> <cpp:value>BT_NMSTRT</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iasciitab.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_COLON</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"latin1tab.h"</cpp:file></cpp:include>
}</block></expr>,
<macro><name>STANDARD_VTABLE</name><argument_list>(<argument>big2_</argument>)</argument_list></macro> <expr><name>NULL_VTABLE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PREFIX</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>streqci</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c1</name> <init>= <expr><operator>*</operator><name>s1</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c2</name> <init>= <expr><operator>*</operator><name>s2</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ASCII_a</name> <operator>&lt;=</operator> <name>c1</name> <operator>&amp;&amp;</operator> <name>c1</name> <operator>&lt;=</operator> <name>ASCII_z</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c1</name> <operator>+=</operator> <name>ASCII_A</name> <operator>-</operator> <name>ASCII_a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ASCII_a</name> <operator>&lt;=</operator> <name>c2</name> <operator>&amp;&amp;</operator> <name>c2</name> <operator>&lt;=</operator> <name>ASCII_z</name></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><name>c2</name> <operator>+=</operator> <name>ASCII_A</name> <operator>-</operator> <name>ASCII_a</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>c1</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <name>PTRCALL</name></type>
<name>initUpdatePosition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><name>POSITION</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>normal_updatePosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>utf8_encoding</name><operator>.</operator><name>enc</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>toAscii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlUtf8Convert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>buf</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>isSpace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x20</literal></expr>:</case>
<case>case <expr><literal type="number">0xD</literal></expr>:</case>
<case>case <expr><literal type="number">0xA</literal></expr>:</case>
<case>case <expr><literal type="number">0x9</literal></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>parsePseudoAttribute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>namePtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nameEndPtr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>open</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>namePtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>namePtr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>namePtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>ASCII_EQUALS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nameEndPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nameEndPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name> <operator>=</operator> <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>ASCII_EQUALS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <operator>*</operator><name>namePtr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>ASCII_QUOT</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>ASCII_APOS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>open</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>valPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>open</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>ASCII_a</name> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>ASCII_z</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><name>ASCII_A</name> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>ASCII_Z</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><name>ASCII_0</name> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>ASCII_9</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>ASCII_PERIOD</name>
<operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>ASCII_MINUS</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>ASCII_UNDERSCORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_version</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_v</name></expr>, <expr><name>ASCII_e</name></expr>, <expr><name>ASCII_r</name></expr>, <expr><name>ASCII_s</name></expr>, <expr><name>ASCII_i</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_encoding</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_e</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_c</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_d</name></expr>,
<expr><name>ASCII_i</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_g</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_standalone</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_s</name></expr>, <expr><name>ASCII_t</name></expr>, <expr><name>ASCII_a</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_d</name></expr>, <expr><name>ASCII_a</name></expr>,
<expr><name>ASCII_l</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><name>ASCII_n</name></expr>, <expr><name>ASCII_e</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_yes</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_y</name></expr>, <expr><name>ASCII_e</name></expr>, <expr><name>ASCII_s</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_no</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ASCII_n</name></expr>, <expr><name>ASCII_o</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>doParseXmlDecl</name><parameter_list>(<parameter><function_decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>encodingFinder</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>isGeneralTextEntity</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>badPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>versionPtr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>versionEndPtr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>encodingName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier><modifier>*</modifier></type><name>encoding</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>standalone</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameEnd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">5</literal> <operator>*</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nameEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_version</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>isGeneralTextEntity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>versionPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>versionPtr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>versionEndPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>versionEndPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nameEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>isGeneralTextEntity</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name>ASCII_a</name> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>ASCII_z</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator> <operator>(</operator><name>ASCII_A</name> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>ASCII_Z</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encodingName</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>encodingName</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <call><name>encodingFinder</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>parsePseudoAttribute</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nameEnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameEnd</name></expr></argument>, <argument><expr><name>KW_standalone</name></expr></argument>)</argument_list></call>
<operator>||</operator> <name>isGeneralTextEntity</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>KW_yes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>standalone</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>standalone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>XmlNameMatchesAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ptr</name> <operator>-</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr></argument>, <argument><expr><name>KW_no</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>standalone</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>standalone</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><call><name>isSpace</name><argument_list>(<argument><expr><call><name>toAscii</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>enc</name><operator>-&gt;</operator><name>minBytesPerChar</name></name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>badPtr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>checkCharRefNumber</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>result</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0xD8</literal></expr>:</case>
<case>case <expr><literal type="number">0xD9</literal></expr>:</case>
<case>case <expr><literal type="number">0xDA</literal></expr>:</case>
<case>case <expr><literal type="number">0xDB</literal></expr>:</case>
<case>case <expr><literal type="number">0xDC</literal></expr>:</case>
<case>case <expr><literal type="number">0xDD</literal></expr>:</case>
<case>case <expr><literal type="number">0xDE</literal></expr>:</case>
<case>case <expr><literal type="number">0xDF</literal></expr>:</case>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>result</name></expr>]</index></name> <operator>==</operator> <name>BT_NONXML</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0xFF</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0xFFFE</literal> <operator>||</operator> <name>result</name> <operator>==</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>FASTCALL</name></type>
<name>XmlUtf8Encode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<enum>enum <block>{

<decl><name>min2</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>,
<decl><name>min3</name> <init>= <expr><literal type="number">0x800</literal></expr></init></decl>,
<decl><name>min4</name> <init>= <expr><literal type="number">0x10000</literal></expr></init></decl>
}</block>;</enum>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>min2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>c</name> <operator>|</operator> <name>UTF8_cval1</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>min3</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <name>UTF8_cval2</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>min4</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <name>UTF8_cval3</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x110000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>|</operator> <name>UTF8_cval4</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">4</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name> <name>FASTCALL</name></type>
<name>XmlUtf16Encode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>charNum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>charNum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>charNum</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><name>charNum</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>charNum</name> <operator>&lt;</operator> <literal type="number">0x110000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>charNum</name> <operator>-=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><name>charNum</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>+</operator> <literal type="number">0xD800</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><operator>(</operator><name>charNum</name> <operator>&amp;</operator> <literal type="number">0x3FF</literal><operator>)</operator> <operator>+</operator> <literal type="number">0xDC00</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>unknown_encoding</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>normal_encoding</name></name></type> <name>normal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONVERTER</name></type> <name>convert</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name><name>utf16</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>utf8</name><index>[<expr><literal type="number">256</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AS_UNKNOWN_ENCODING</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((const struct unknown_encoding *)(enc))</cpp:value></cpp:define>

<function><type><name>int</name></type>
<name>XmlSizeOfUnknownEncoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>unknown_encoding</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name><operator>-&gt;</operator><name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name><operator>-&gt;</operator><name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isNmstrt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name><operator>-&gt;</operator><name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name><operator>-&gt;</operator><name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>PTRFASTCALL</name></type>
<name>unknown_isInvalid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name><operator>-&gt;</operator><name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name><operator>-&gt;</operator><name>userData</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0xFFFF</literal><operator>)</operator> <operator>||</operator> <call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>unknown_toUtf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>XML_UTF8_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fromP</name> <operator>==</operator> <name>fromLim</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name><name>uenc</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>*</operator><name>fromP</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>*</operator><name>utf8</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>uenc</name><operator>-&gt;</operator><name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name><operator>-&gt;</operator><name>userData</name></name></expr></argument>, <argument><expr><operator>*</operator><name>fromP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>XmlUtf8Encode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>toLim</name> <operator>-</operator> <operator>*</operator><name>toP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromP</name> <operator>+=</operator> <operator>(</operator><call><name>AS_NORMAL_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>type</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>*</operator><name>fromP</name></expr>]</index></name>
<operator>-</operator> <operator>(</operator><name>BT_LEAD2</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>toLim</name> <operator>-</operator> <operator>*</operator><name>toP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>toP</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>toP</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>XML_Convert_Result</name></name> <name>PTRCALL</name></type>
<name>unknown_toUtf16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fromP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromLim</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier><modifier>*</modifier></type><name>toP</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>toLim</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>uenc</name> <init>= <expr><call><name>AS_UNKNOWN_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>toP</name> <operator>&lt;</operator> <name>toLim</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>c</name> <init>= <expr><name><name>uenc</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>*</operator><name>fromP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><call><name><name>uenc</name><operator>-&gt;</operator><name>convert</name></name><argument_list>(<argument><expr><name><name>uenc</name><operator>-&gt;</operator><name>userData</name></name></expr></argument>, <argument><expr><operator>*</operator><name>fromP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>fromP</name> <operator>+=</operator> <operator>(</operator><call><name>AS_NORMAL_ENCODING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>type</name><index>[<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>*</operator><name>fromP</name></expr>]</index></name>
<operator>-</operator> <operator>(</operator><name>BT_LEAD2</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>fromP</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>toP</name><operator>)</operator><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>toP</name> <operator>==</operator> <name>toLim</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>fromP</name> <operator>&lt;</operator> <name>fromLim</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_OUTPUT_EXHAUSTED</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>XML_CONVERT_COMPLETED</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>ENCODING</name> <modifier>*</modifier></type>
<name>XmlInitUnknownEncoding</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>unknown_encoding</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator>struct <name>unknown_encoding</name> <operator>*</operator><operator>)</operator><name>mem</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>latin1_encoding</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>normal_encoding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>BT_OTHER</name>
<operator>&amp;&amp;</operator> <name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>BT_NONXML</name> <operator>&amp;&amp;</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BT_MALFORM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>convert</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name>BT_LEAD2</name> <operator>-</operator> <operator>(</operator><name>c</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>BT_OTHER</name>
<operator>&amp;&amp;</operator> <name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>BT_NONXML</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>latin1_encoding</name><operator>.</operator><name>type</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0xFFFF</literal></expr> </then><else>: <expr><name>c</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>checkCharRefNumber</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BT_NONXML</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0xFFFF</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>nmstrtPages</name></expr></argument>, <argument><expr><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BT_NMSTRT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>UCS2_GET_NAMING</name><argument_list>(<argument><expr><name>namePages</name></expr></argument>, <argument><expr><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BT_NAME</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>type</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BT_OTHER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>XmlUtf8Encode</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>utf8</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>utf16</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>userData</name></name> <operator>=</operator> <name>userData</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>convert</name></name> <operator>=</operator> <name>convert</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>convert</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isName2</name></name> <operator>=</operator> <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isName3</name></name> <operator>=</operator> <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isName4</name></name> <operator>=</operator> <name>unknown_isName</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isNmstrt2</name></name> <operator>=</operator> <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isNmstrt3</name></name> <operator>=</operator> <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isNmstrt4</name></name> <operator>=</operator> <name>unknown_isNmstrt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isInvalid2</name></name> <operator>=</operator> <name>unknown_isInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isInvalid3</name></name> <operator>=</operator> <name>unknown_isInvalid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>isInvalid4</name></name> <operator>=</operator> <name>unknown_isInvalid</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>enc</name><operator>.</operator><name>utf8Convert</name></name> <operator>=</operator> <name>unknown_toUtf8</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>enc</name><operator>.</operator><name>utf16Convert</name></name> <operator>=</operator> <name>unknown_toUtf16</name></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>normal</name><operator>.</operator><name>enc</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<enum>enum <block>{
<decl><name>UNKNOWN_ENC</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>ISO_8859_1_ENC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>US_ASCII_ENC</name></decl>,
<decl><name>UTF_8_ENC</name></decl>,
<decl><name>UTF_16_ENC</name></decl>,
<decl><name>UTF_16BE_ENC</name></decl>,
<decl><name>UTF_16LE_ENC</name></decl>,

<decl><name>NO_ENC</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_ISO_8859_1</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_I</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><name>ASCII_O</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_8</name></expr>, <expr><name>ASCII_8</name></expr>,
<expr><name>ASCII_5</name></expr>, <expr><name>ASCII_9</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_US_ASCII</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_S</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_A</name></expr>, <expr><name>ASCII_S</name></expr>,
<expr><name>ASCII_C</name></expr>, <expr><name>ASCII_I</name></expr>, <expr><name>ASCII_I</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_8</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_8</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>, <expr><name>ASCII_6</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16BE</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>,
<expr><name>ASCII_6</name></expr>, <expr><name>ASCII_B</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KW_UTF_16LE</name><index>[]</index></name>
<init>= <expr><block>{<expr><name>ASCII_U</name></expr>, <expr><name>ASCII_T</name></expr>, <expr><name>ASCII_F</name></expr>, <expr><name>ASCII_MINUS</name></expr>, <expr><name>ASCII_1</name></expr>,
<expr><name>ASCII_6</name></expr>, <expr><name>ASCII_L</name></expr>, <expr><name>ASCII_E</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type>
<name>getEncodingIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encodingNames</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>KW_ISO_8859_1</name></expr>, <expr><name>KW_US_ASCII</name></expr>, <expr><name>KW_UTF_8</name></expr>, <expr><name>KW_UTF_16</name></expr>, <expr><name>KW_UTF_16BE</name></expr>, <expr><name>KW_UTF_16LE</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NO_ENC</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>encodingNames</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>encodingNames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>streqci</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>encodingNames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>UNKNOWN_ENC</name></expr>;</return>
</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ENC_INDEX</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)(enc)-&gt;initEnc.isUtf16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_INIT_ENC_INDEX</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;initEnc.isUtf16 = (char)i)</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <name>int</name></type>
<name>initScan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>encodingTable</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>INIT_ENCODING</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nextTokPtr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> <modifier>*</modifier><modifier>*</modifier></type><name>encPtr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_NONE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>encPtr</name> <operator>=</operator> <name><name>enc</name><operator>-&gt;</operator><name>encPtr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<switch>switch <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UTF_16_ENC</name></expr>:</case>
<case>case <expr><name>UTF_16LE_ENC</name></expr>:</case>
<case>case <expr><name>UTF_16BE_ENC</name></expr>:</case>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0xFE</literal></expr>:</case>
<case>case <expr><literal type="number">0xFF</literal></expr>:</case>
<case>case <expr><literal type="number">0xEF</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ISO_8859_1_ENC</name> <operator>&amp;&amp;</operator> <name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">0x00</literal></expr>:</case>
<case>case <expr><literal type="number">0x3C</literal></expr>:</case>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0xFEFF</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ISO_8859_1_ENC</name> <operator>&amp;&amp;</operator> <name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_16BE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>

<case>case <expr><literal type="number">0x3C00</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UTF_16BE_ENC</name>
<operator>||</operator> <call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UTF_16_ENC</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr><operator>*</operator><name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">0xFFFE</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ISO_8859_1_ENC</name> <operator>&amp;&amp;</operator> <name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>
<case>case <expr><literal type="number">0xEFBB</literal></expr>:</case>







<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>ISO_8859_1_ENC</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>UTF_16BE_ENC</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>UTF_16LE_ENC</name>
<operator>||</operator> <name>e</name> <operator>==</operator> <name>UTF_16_ENC</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>XML_TOK_PARTIAL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xBF</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>nextTokPtr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_8_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TOK_BOM</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name> <operator>&amp;&amp;</operator> <call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UTF_16LE_ENC</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_16BE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr><operator>*</operator><name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>









<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>XML_CONTENT_STATE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><name>UTF_16LE_ENC</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr><operator>*</operator><name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>encPtr</name> <operator>=</operator> <name><name>encodingTable</name><index>[<expr><call><name>INIT_ENC_INDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>XmlTok</name><argument_list>(<argument><expr><operator>*</operator><name>encPtr</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextTokPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NS_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_ns.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XML_TOK_NS_C</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ns</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x##NS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x##_ns</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_TOK_NS_C</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok_ns.c"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XML_TOK_NS_C</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ns</name></cpp:undef>

<function><type><name>ENCODING</name> <modifier>*</modifier></type>
<name>XmlInitUnknownEncodingNS</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>CONVERTER</name></type> <name>convert</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userData</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ENCODING</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>XmlInitUnknownEncoding</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>convert</name></expr></argument>, <argument><expr><name>userData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator>struct <name>normal_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name><operator>)</operator><operator>-&gt;</operator><name><name>type</name><index>[<expr><name>ASCII_COLON</name></expr>]</index></name> <operator>=</operator> <name>BT_COLON</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
