<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libevent/evmap.c">
























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event-config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"evconfig-private.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIN32_LEAN_AND_MEAN</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"evmap-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mm-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"changelist-internal.h"</cpp:file></cpp:include>




<struct>struct <name>evmap_io</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event_dlist</name></name></type> <name>events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint16_t</name></type> <name>nread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint16_t</name></type> <name>nwrite</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint16_t</name></type> <name>nclose</name></decl>;</decl_stmt>
}</block>;</struct>



<struct>struct <name>evmap_signal</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event_dlist</name></name></type> <name>events</name></decl>;</decl_stmt>
}</block>;</struct>








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>event_map_entry</name> <block>{
<macro><name>HT_ENTRY</name><argument_list>(<argument>event_map_entry</argument>)</argument_list></macro> <expr_stmt><expr><name>map_node</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl>;</decl_stmt>
<union>union <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name></type> <name>evmap_io</name></decl>;</decl_stmt>
}</block> <decl><name>ent</name></decl>;</union>
}</block>;</struct>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name></type>
<name>hashsocket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_map_entry</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>unsigned</name></type> <name>h</name> <init>= <expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name><name>e</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>h</name> <operator>+=</operator> <operator>(</operator><name>h</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>h</name> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>eqsocket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_map_entry</name></name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>event_map_entry</name></name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>e1</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name><name>e2</name><operator>-&gt;</operator><name>fd</name></name></expr>;</return>
</block_content>}</block></function>

<macro><name>HT_PROTOTYPE</name><argument_list>(<argument>event_io_map</argument>, <argument>event_map_entry</argument>, <argument>map_node</argument>, <argument>hashsocket</argument>, <argument>eqsocket</argument>)</argument_list></macro>
<macro><name>HT_GENERATE</name><argument_list>(<argument>event_io_map</argument>, <argument>event_map_entry</argument>, <argument>map_node</argument>, <argument>hashsocket</argument>, <argument>eqsocket</argument>,
<argument><literal type="number">0.5</literal></argument>, <argument>mm_malloc</argument>, <argument>mm_realloc</argument>, <argument>mm_free</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IO_SLOT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>map</name></type></parameter>, <parameter><type><name>slot</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { struct event_map_entry key_, *ent_; key_.fd = slot; ent_ = HT_FIND(event_io_map, map, &amp;key_); (x) = ent_ ? &amp;ent_-&gt;ent.type : NULL; } while (0);</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IO_SLOT_AND_CTOR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>map</name></type></parameter>, <parameter><type><name>slot</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>ctor</name></type></parameter>, <parameter><type><name>fdinfo_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { struct event_map_entry key_, *ent_; key_.fd = slot; HT_FIND_OR_INSERT_(event_io_map, map_node, hashsocket, map, event_map_entry, &amp;key_, ptr, { ent_ = *ptr; }, { ent_ = mm_calloc(1,sizeof(struct event_map_entry)+fdinfo_len); if (EVUTIL_UNLIKELY(ent_ == NULL)) return (-1); ent_-&gt;fd = slot; (ctor)(&amp;ent_-&gt;ent.type); HT_FOI_INSERT_(map_node, map, &amp;key_, ent_, ptr) }); (x) = &amp;ent_-&gt;ent.type; } while (0)</cpp:value></cpp:define>



















<function><type><name>void</name></type> <name>evmap_io_initmap_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HT_INIT</name><argument_list>(<argument><expr><name>event_io_map</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>evmap_io_clear_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_map_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ent</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>this</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>ent</name> <operator>=</operator> <call><name>HT_START</name><argument_list>(<argument><expr><name>event_io_map</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>ent</name></expr>;</condition> <incr><expr><name>ent</name> <operator>=</operator> <name>next</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>this</name> <operator>=</operator> <operator>*</operator><name>ent</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>HT_NEXT_RMV</name><argument_list>(<argument><expr><name>event_io_map</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mm_free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>HT_CLEAR</name><argument_list>(<argument><expr><name>event_io_map</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SIGNAL_SLOT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>map</name></type></parameter>, <parameter><type><name>slot</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = (struct type *)((map)-&gt;entries[slot])</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SIGNAL_SLOT_AND_CTOR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>map</name></type></parameter>, <parameter><type><name>slot</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>ctor</name></type></parameter>, <parameter><type><name>fdinfo_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((map)-&gt;entries[slot] == NULL) { (map)-&gt;entries[slot] = mm_calloc(1,sizeof(struct type)+fdinfo_len); if (EVUTIL_UNLIKELY((map)-&gt;entries[slot] == NULL)) return (-1); (ctor)((struct type *)(map)-&gt;entries[slot]); } (x) = (struct type *)((map)-&gt;entries[slot]); } while (0)</cpp:value></cpp:define>













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IO_SLOT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>map</name></type></parameter>,<parameter><type><name>slot</name></type></parameter>,<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GET_SIGNAL_SLOT(x,map,slot,type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_IO_SLOT_AND_CTOR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>map</name></type></parameter>,<parameter><type><name>slot</name></type></parameter>,<parameter><type><name>type</name></type></parameter>,<parameter><type><name>ctor</name></type></parameter>,<parameter><type><name>fdinfo_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GET_SIGNAL_SLOT_AND_CTOR(x,map,slot,type,ctor,fdinfo_len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FDINFO_OFFSET</name></cpp:macro> <cpp:value>sizeof(struct evmap_io)</cpp:value></cpp:define>
<function><type><name>void</name></type>
<name>evmap_io_initmap_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_io_map</name></name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>evmap_signal_initmap_</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>evmap_io_clear_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_io_map</name></name><modifier>*</modifier></type> <name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>evmap_signal_clear_</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_make_space</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>msize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&lt;=</operator> <name>slot</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nentries</name> <init>= <expr><ternary><condition><expr><name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr> ?</condition><then> <expr><name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr> </then><else>: <expr><literal type="number">32</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>nentries</name> <operator>&lt;=</operator> <name>slot</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nentries</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>mm_realloc</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>, <argument><expr><name>nentries</name> <operator>*</operator> <name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tmp</name><index>[<expr><name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>(</operator><name>nentries</name> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>nentries</name></name><operator>)</operator> <operator>*</operator> <name>msize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <name>nentries</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_signal_initmap_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_signal_clear_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mm_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>mm_free</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>evmap_io_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LIST_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nread</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nwrite</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nclose</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>evmap_io_add_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>io</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>io</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>nwrite</name></decl>, <decl><type ref="prev"/><name>nclose</name></decl>, <decl><type ref="prev"/><name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>old</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>old_ev</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>fd</name> <operator>==</operator> <name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <name><name>io</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>evmap_make_space</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>GET_IO_SLOT_AND_CTOR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>io</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>evmap_io</name></expr></argument>, <argument><expr><name>evmap_io_init</name></expr></argument>,
<argument><expr><name><name>evsel</name><operator>-&gt;</operator><name>fdinfo_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nread</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nread</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nwrite</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nwrite</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nclose</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nclose</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nread</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nwrite</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nclose</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_CLOSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_READ</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nread</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nwrite</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_CLOSED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>nclose</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_CLOSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EVUTIL_UNLIKELY</name><argument_list>(<argument><expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0xffff</literal> <operator>||</operator> <name>nwrite</name> <operator>&gt;</operator> <literal type="number">0xffff</literal> <operator>||</operator> <name>nclose</name> <operator>&gt;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_warnx</name><argument_list>(<argument><expr><literal type="string">"Too many events reading or writing on fd %d"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EVENT_DEBUG_MODE_IS_ON</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>old_ev</name> <operator>=</operator> <call><name>LIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>old_ev</name><operator>-&gt;</operator><name>ev_events</name></name><operator>&amp;</operator><name>EV_ET</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name><operator>&amp;</operator><name>EV_ET</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_warnx</name><argument_list>(<argument><expr><literal type="string">"Tried to mix edge-triggered and non-edge-triggered"</literal>
<literal type="string">" events on fd %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>add</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>,
<argument><expr><name>old</name></expr></argument>, <argument><expr><operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_ET</name><operator>)</operator> <operator>|</operator> <name>res</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nread</name></name> <operator>=</operator> <operator>(</operator><name>ev_uint16_t</name><operator>)</operator> <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nwrite</name></name> <operator>=</operator> <operator>(</operator><name>ev_uint16_t</name><operator>)</operator> <name>nwrite</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nclose</name></name> <operator>=</operator> <operator>(</operator><name>ev_uint16_t</name><operator>)</operator> <name>nclose</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>ev_io_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>evmap_io_del_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>io</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>io</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nread</name></decl>, <decl><type ref="prev"/><name>nwrite</name></decl>, <decl><type ref="prev"/><name>nclose</name></decl>, <decl><type ref="prev"/><name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>old</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>fd</name> <operator>==</operator> <name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <name><name>io</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>GET_IO_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>io</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>evmap_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nread</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nread</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nwrite</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nwrite</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nclose</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>nclose</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nread</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nwrite</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nclose</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>old</name> <operator>|=</operator> <name>EV_CLOSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_READ</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>nread</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nwrite</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>nwrite</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_CLOSED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nclose</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <name>EV_CLOSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>nclose</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>del</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nread</name></name> <operator>=</operator> <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nwrite</name></name> <operator>=</operator> <name>nwrite</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>nclose</name></name> <operator>=</operator> <name>nclose</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LIST_REMOVE</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>ev_io_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>retval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_io_active_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>io</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>io</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name><name>io</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>GET_IO_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>io</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>evmap_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;ctx-&gt;events</argument>, <argument>ev_io_next</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>events</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_active_nolock_</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>events</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>evmap_signal_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LIST_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>evmap_signal_add_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsigsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>sigmap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>evmap_make_space</name><argument_list>(
<argument><expr><name>map</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_signal</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>GET_SIGNAL_SLOT_AND_CTOR</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>evmap_signal</name></expr></argument>, <argument><expr><name>evmap_signal_init</name></expr></argument>,
<argument><expr><name><name>base</name><operator>-&gt;</operator><name>evsigsel</name><operator>-&gt;</operator><name>fdinfo_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIST_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>add</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>LIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name>ev_signal_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>evmap_signal_del_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsigsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>sigmap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GET_SIGNAL_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>evmap_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LIST_REMOVE</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>ev_signal_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>del</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_signal_active_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ncalls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>map</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>sigmap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sig</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>nentries</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>GET_SIGNAL_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>evmap_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;ctx-&gt;events</argument>, <argument>ev_signal_next</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>event_active_nolock_</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>, <argument><expr><name>ncalls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>evmap_io_get_fdinfo_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GET_IO_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>evmap_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>evmap_io_foreach_fd_cb</name>)<parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>














<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_io_foreach_fd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>evmap_io_foreach_fd_cb</name></type> <name>fn</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_io_map</name></name> <modifier>*</modifier></type><name>iomap</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>io</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVMAP_USE_HT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>event_map_entry</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>mapent</name></decl>;</decl_stmt>
<macro><name>HT_FOREACH</name><argument_list>(<argument>mapent</argument>, <argument>event_io_map</argument>, <argument>iomap</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>mapent</name><operator>)</operator><operator>-&gt;</operator><name><name>ent</name><operator>.</operator><name>evmap_io</name></name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>mapent</name><operator>)</operator><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fd</name> <operator>&lt;</operator> <name><name>iomap</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>fd</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>iomap</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>fd</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block>


<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>evmap_signal_foreach_signal_cb</name>)<parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>











<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_signal_foreach_signal</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>evmap_signal_foreach_signal_cb</name></type> <name>fn</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_signal_map</name></name> <modifier>*</modifier></type><name>sigmap</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>sigmap</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signum</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>signum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>signum</name> <operator>&lt;</operator> <name><name>sigmap</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>signum</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><name><name>sigmap</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>signum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_io_reinit_iter_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>extra</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nread</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>events</name> <operator>|=</operator> <name>EV_READ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nwrite</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>events</name> <operator>|=</operator> <name>EV_WRITE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>nclose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>events</name> <operator>|=</operator> <name>EV_CLOSED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>evsel</name><operator>-&gt;</operator><name>fdinfo_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>evsel</name><operator>-&gt;</operator><name>fdinfo_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ev</name> <operator>=</operator> <call><name>LIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_ET</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>events</name> <operator>|=</operator> <name>EV_ET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>add</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_signal_reinit_iter_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>eventop</name></name> <modifier>*</modifier></type><name>evsel</name> <init>= <expr><name><name>base</name><operator>-&gt;</operator><name>evsigsel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LIST_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>evsel</name><operator>-&gt;</operator><name>add</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>evmap_reinit_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evmap_io_foreach_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_io_reinit_iter_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>evmap_signal_foreach_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_signal_reinit_iter_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>delete_all_in_dlist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_dlist</name></name> <modifier>*</modifier></type><name>dlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>ev</name> <operator>=</operator> <call><name>LIST_FIRST</name><argument_list>(<argument><expr><name>dlist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_io_delete_all_iter_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>io_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>delete_all_in_dlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_info</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_signal_delete_all_iter_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>sig_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>delete_all_in_dlist</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sig_info</name><operator>-&gt;</operator><name>events</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_delete_all_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>evmap_signal_foreach_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_signal_delete_all_iter_fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evmap_io_foreach_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_io_delete_all_iter_fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<struct>struct <name>event_changelist_fdinfo</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>idxplus1</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><name>void</name></type>
<name>event_changelist_init_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type>
<name>event_change_get_fdinfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>change</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>change</name><operator>-&gt;</operator><name>read_change</name></name> <operator>&amp;</operator> <name>EV_CHANGE_SIGNAL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GET_SIGNAL_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>sigmap</name></name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>evmap_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_signal</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GET_IO_SLOT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>change</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>evmap_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ctx</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>ptr</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>event_changelist_assert_ok_foreach_iter_fn</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>changelist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator>
<operator>(</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>io</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>evmap_io</name></expr></argument>)</argument_list></sizeof> <operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>idxplus1</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><name><name>changelist</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name><name>f</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>event_changelist_assert_ok</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>changelist</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>&gt;=</operator> <name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>&amp;</operator><name><name>changelist</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>event_change_get_fdinfo</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>==</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>evmap_io_foreach_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>event_changelist_assert_ok_foreach_iter_fn</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_CHANGELIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>event_changelist_check</name><parameter_list>(<parameter><type><name>base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>event_changelist_assert_ok((base))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>event_changelist_check</name><parameter_list>(<parameter><type><name>base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>event_changelist_remove_all_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>ch</name> <init>= <expr><operator>&amp;</operator><name><name>changelist</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>fdinfo</name> <init>=
<expr><call><name>event_change_get_fdinfo</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>fdinfo</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>==</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fdinfo</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>event_changelist_freemem_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>changelist</name><operator>-&gt;</operator><name>changes</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mm_free</name><argument_list>(<argument><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_changelist_init_</name><argument_list>(<argument><expr><name>changelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>event_changelist_grow</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>new_changes</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>new_size</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>new_size</name> <operator>=</operator> <name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>new_changes</name> <operator>=</operator> <call><name>mm_realloc</name><argument_list>(<argument><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes</name></name></expr></argument>,
<argument><expr><name>new_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>event_change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>EVUTIL_UNLIKELY</name><argument_list>(<argument><expr><name>new_changes</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes</name></name> <operator>=</operator> <name>new_changes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type>
<name>event_changelist_get_or_construct</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name></decl></parameter>,
<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name>short</name></type> <name>old_events</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>fdinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fdinfo</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name> <operator>&lt;=</operator> <name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name> <operator>==</operator> <name><name>changelist</name><operator>-&gt;</operator><name>changes_size</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_changelist_grow</name><argument_list>(<argument><expr><name>changelist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>changelist</name><operator>-&gt;</operator><name>n_changes</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>change</name> <operator>=</operator> <operator>&amp;</operator><name><name>changelist</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fdinfo</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>change</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>event_change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>old_events</name></name> <operator>=</operator> <name>old_events</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>change</name> <operator>=</operator> <operator>&amp;</operator><name><name>changelist</name><operator>-&gt;</operator><name>changes</name><index>[<expr><name><name>fdinfo</name><operator>-&gt;</operator><name>idxplus1</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>change</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>change</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>event_changelist_add_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>old</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>changelist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>fdinfo</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>event_changelist_get_or_construct</name><argument_list>(<argument><expr><name>changelist</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>fdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>change</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <operator>(</operator><name>EV_READ</name><operator>|</operator><name>EV_SIGNAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>read_change</name></name> <operator>=</operator> <name>EV_CHANGE_ADD</name> <operator>|</operator>
<operator>(</operator><name>events</name> <operator>&amp;</operator> <operator>(</operator><name>EV_ET</name><operator>|</operator><name>EV_PERSIST</name><operator>|</operator><name>EV_SIGNAL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>write_change</name></name> <operator>=</operator> <name>EV_CHANGE_ADD</name> <operator>|</operator>
<operator>(</operator><name>events</name> <operator>&amp;</operator> <operator>(</operator><name>EV_ET</name><operator>|</operator><name>EV_PERSIST</name><operator>|</operator><name>EV_SIGNAL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>EV_CLOSED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>close_change</name></name> <operator>=</operator> <name>EV_CHANGE_ADD</name> <operator>|</operator>
<operator>(</operator><name>events</name> <operator>&amp;</operator> <operator>(</operator><name>EV_ET</name><operator>|</operator><name>EV_PERSIST</name><operator>|</operator><name>EV_SIGNAL</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>event_changelist_del_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>old</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist</name></name> <modifier>*</modifier></type><name>changelist</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><operator>-&gt;</operator><name>changelist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_changelist_fdinfo</name></name> <modifier>*</modifier></type><name>fdinfo</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_change</name></name> <modifier>*</modifier></type><name>change</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>change</name> <operator>=</operator> <call><name>event_changelist_get_or_construct</name><argument_list>(<argument><expr><name>changelist</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>fdinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>change</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
















<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <operator>(</operator><name>EV_READ</name><operator>|</operator><name>EV_SIGNAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>change</name><operator>-&gt;</operator><name>old_events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EV_READ</name> <operator>|</operator> <name>EV_SIGNAL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>read_change</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>read_change</name></name> <operator>=</operator> <name>EV_CHANGE_DEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>change</name><operator>-&gt;</operator><name>old_events</name></name> <operator>&amp;</operator> <name>EV_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>write_change</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>write_change</name></name> <operator>=</operator> <name>EV_CHANGE_DEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>events</name> <operator>&amp;</operator> <name>EV_CLOSED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>change</name><operator>-&gt;</operator><name>old_events</name></name> <operator>&amp;</operator> <name>EV_CLOSED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>close_change</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>change</name><operator>-&gt;</operator><name>close_change</name></name> <operator>=</operator> <name>EV_CHANGE_DEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>event_changelist_check</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_io_check_integrity_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>io_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n_write</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n_close</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>EVUTIL_ASSERT_LIST_OK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>io_info</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>ev_io_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;io_info-&gt;events</argument>, <argument>ev_io_next</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_flags</name></name> <operator>&amp;</operator> <name>EVLIST_INSERTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name> <operator>==</operator> <name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_SIGNAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name><operator>|</operator><name>EV_CLOSED</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_READ</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>n_read</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>n_write</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_CLOSED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>n_close</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>n_read</name> <operator>==</operator> <name><name>io_info</name><operator>-&gt;</operator><name>nread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>n_write</name> <operator>==</operator> <name><name>io_info</name><operator>-&gt;</operator><name>nwrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name>n_close</name> <operator>==</operator> <name><name>io_info</name><operator>-&gt;</operator><name>nclose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_signal_check_integrity_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>sig_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EVUTIL_ASSERT_LIST_OK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sig_info</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>ev_signal_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;sig_info-&gt;events</argument>, <argument>ev_io_next</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_flags</name></name> <operator>&amp;</operator> <name>EVLIST_INSERTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><name><name>ev</name><operator>-&gt;</operator><name>ev_fd</name></name> <operator>==</operator> <name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <name>EV_SIGNAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVUTIL_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>ev</name><operator>-&gt;</operator><name>ev_events</name></name> <operator>&amp;</operator> <operator>(</operator><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name><operator>|</operator><name>EV_CLOSED</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>evmap_check_integrity_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>evmap_io_foreach_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_io_check_integrity_fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evmap_signal_foreach_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_signal_check_integrity_fn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>base</name><operator>-&gt;</operator><name>evsel</name><operator>-&gt;</operator><name>add</name></name> <operator>==</operator> <name>event_changelist_add_</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_changelist_assert_ok</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<struct>struct <name>evmap_foreach_event_helper</name> <block>{
<decl_stmt><decl><type><name>event_base_foreach_event_cb</name></type> <name>fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
}</block>;</struct>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_io_foreach_event_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_io</name></name> <modifier>*</modifier></type><name>io_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_foreach_event_helper</name></name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;io_info-&gt;events</argument>, <argument>ev_io_next</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name><name>h</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>evmap_signal_foreach_event_fn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>evmap_signal</name></name> <modifier>*</modifier></type><name>sig_info</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_foreach_event_helper</name></name> <modifier>*</modifier></type><name>h</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<macro><name>LIST_FOREACH</name><argument_list>(<argument>ev</argument>, <argument>&amp;sig_info-&gt;events</argument>, <argument>ev_signal_next</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name><name>h</name><operator>-&gt;</operator><name>fn</name></name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>evmap_foreach_event_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
<parameter><decl><type><name>event_base_foreach_event_cb</name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evmap_foreach_event_helper</name></name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>h</name><operator>.</operator><name>fn</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>evmap_io_foreach_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_io_foreach_event_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>evmap_signal_foreach_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>evmap_signal_foreach_event_fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function></block_content></block></function>

</unit>
