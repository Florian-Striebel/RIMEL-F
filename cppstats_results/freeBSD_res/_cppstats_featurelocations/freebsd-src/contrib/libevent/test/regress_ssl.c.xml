<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libevent/test/regress_ssl.c">


























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>clang</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wdeprecated-declarations"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util-internal.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/bufferevent_ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/bufferevent_struct.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/listener.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tinytest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tinytest_macros.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/bio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/pem.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"openssl-compat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>read</name></cpp:macro> <cpp:value>_read</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write</name></cpp:macro> <cpp:value>_write</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>KEY</name><index>[]</index></name> <init>=
<expr><literal type="string">"-----BEGIN RSA PRIVATE KEY-----\n"</literal>
<literal type="string">"MIIEogIBAAKCAQEAtK07Ili0dkJb79m/sFmHoVJTWyLoveXex2yX/BtUzzcvZEOu\n"</literal>
<literal type="string">"QLon/++5YOA48kzZm5K9mIwZkZhui1ZgJ5Bjq0LGAWTZGIn+NXjLFshPYvTKpOCW\n"</literal>
<literal type="string">"uzL0Ir0LXMsBLYJQ5A4FomLNxs4I3H/dhDSGy/rSiJB1B4w2xNiwPK08/VL3zZqk\n"</literal>
<literal type="string">"V+GsSvGIIkzhTMbqPJy9K8pqyjwOU2pgORS794yXciTGxWYjTDzJPgQ35YMDATaG\n"</literal>
<literal type="string">"jr4HHo1zxU/Lj0pndSUK5rKLYxYQ3Uc8B3AVYDl9CP/GbOoQ4LBzS68JjcAUyp6i\n"</literal>
<literal type="string">"6NfXlc2D9S9XgqVqwI+JqgJs0eW/+zPY2UEDWwIDAQABAoIBAD2HzV66FOM9YDAD\n"</literal>
<literal type="string">"2RtGskEHV2nvLpIVadRCsFPkPvK+2X3s6rgSbbLkwh4y3lHuSCGKTNVZyQ9jeSos\n"</literal>
<literal type="string">"xVxT+Q2HFQW+gYyw2gj91TQyDY8mzKhv8AVaqff2p5r3a7RC8CdqexK9UVUGL9Bg\n"</literal>
<literal type="string">"H2F5vfpTtkVZ5PEoGDLblNFlMiMW/t1SobUeBVx+Msco/xqk9lFv1A9nnepGy0Gi\n"</literal>
<literal type="string">"D+i6YNGTBsX22YhoCZl/ICxCL8lgqPei4FvBr9dBVh/jQgjuUBm2jz55p2r7+7Aw\n"</literal>
<literal type="string">"khmXHReejoVokQ2+htgSgZNKlKuDy710ZpBqnDi8ynQi82Y2qCpyg/p/xcER54B6\n"</literal>
<literal type="string">"hSftaiECgYEA2RkSoxU+nWk+BClQEUZRi88QK5W/M8oo1DvUs36hvPFkw3Jk/gz0\n"</literal>
<literal type="string">"fgd5bnA+MXj0Fc0QHvbddPjIkyoI/evq9GPV+JYIuH5zabrlI3Jvya8q9QpAcEDO\n"</literal>
<literal type="string">"KkL/O09qXVEW52S6l05nh4PLejyI7aTyTIN5nbVLac/+M8MY/qOjZksCgYEA1Q1o\n"</literal>
<literal type="string">"L8kjSavU2xhQmSgZb9W62Do60sa3e73ljrDPoiyvbExldpSdziFYxHBD/Rep0ePf\n"</literal>
<literal type="string">"eVSGS3VSwevt9/jSGo2Oa83TYYns9agBm03oR/Go/DukESdI792NsEM+PRFypVNy\n"</literal>
<literal type="string">"AohWRLj0UU6DV+zLKp0VBavtx0ATeLFX0eN17TECgYBI2O/3Bz7uhQ0JSm+SjFz6\n"</literal>
<literal type="string">"o+2SInp5P2G57aWu4VQWWY3tQ2p+EQzNaWam10UXRrXoxtmc+ktPX9e2AgnoYoyB\n"</literal>
<literal type="string">"myqGcpnUhqHlnZAb999o9r1cYidDQ4uqhLauSTSwwXAFDzjJYsa8o03Y440y6QFh\n"</literal>
<literal type="string">"CVD6yYXXqLJs3g96CqDexwKBgAHxq1+0QCQt8zVElYewO/svQhMzBNJjic0RQIT6\n"</literal>
<literal type="string">"zAo4yij80XgxhvcYiszQEW6/xobpw2JCCS+rFGQ8mOFIXfJsFD6blDAxp/3d2JXo\n"</literal>
<literal type="string">"MhRl+hrDGI4ng5zcsqxHEMxR2m/zwPiQ8eiSn3gWdVBaEsiCwmxY00ScKxFQ3PJH\n"</literal>
<literal type="string">"Vw4hAoGAdZLd8KfjjG6lg7hfpVqavstqVi9LOgkHeCfdjn7JP+76kYrgLk/XdkrP\n"</literal>
<literal type="string">"N/BHhtFVFjOi/mTQfQ5YfZImkm/1ePBy7437DT8BDkOxspa50kK4HPggHnU64h1w\n"</literal>
<literal type="string">"lhdEOj7mAgHwGwwVZWOgs9Lq6vfztnSuhqjha1daESY6kDscPIQ=\n"</literal>
<literal type="string">"-----END RSA PRIVATE KEY-----\n"</literal></expr></init></decl>;</decl_stmt>

<function><type><name>EVP_PKEY</name> <modifier>*</modifier></type>
<name>ssl_getkey</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>bio</name></decl>;</decl_stmt>


<expr_stmt><expr><name>bio</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>KEY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>PEM_read_bio_PrivateKey</name><argument_list>(<argument><expr><name>bio</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>key</name></expr>;</return>
<label><name>end</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>X509</name> <modifier>*</modifier></type>
<name>ssl_getcert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>x509</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>ssl_getkey</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x509</name> <operator>=</operator> <call><name>X509_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <call><name>X509_set_version</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <call><name>ASN1_INTEGER_set</name><argument_list>(<argument><expr><call><name>X509_get_serialNumber</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>X509_NAME_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nid</name> <operator>=</operator> <call><name>OBJ_txt2nid</name><argument_list>(<argument><expr><literal type="string">"commonName"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>NID_undef</name> <operator>!=</operator> <name>nid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <call><name>X509_NAME_add_entry_by_NID</name><argument_list>(
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nid</name></expr></argument>, <argument><expr><name>MBSTRING_ASC</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"example.com"</literal></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>X509_set_subject_name</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>X509_set_issuer_name</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>X509_time_adj</name><argument_list>(<argument><expr><call><name>X509_get_notBefore</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>now</name> <operator>+=</operator> <literal type="number">3600</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>X509_time_adj</name><argument_list>(<argument><expr><call><name>X509_get_notAfter</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>X509_set_pubkey</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <call><name>X509_sign</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>EVP_sha1</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>x509</name></expr>;</return>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>disable_tls_11_and_12</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SSL_CTX</name> <modifier>*</modifier></type><name>the_ssl_ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>SSL_CTX</name> <modifier>*</modifier></type>
<name>get_ssl_ctx</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>the_ssl_ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>the_ssl_ctx</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>the_ssl_ctx</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>the_ssl_ctx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>disable_tls_11_and_12</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SSL_OP_NO_TLSv1_2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>the_ssl_ctx</name></expr></argument>, <argument><expr><name>SSL_OP_NO_TLSv1_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SSL_OP_NO_TLSv1_1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>the_ssl_ctx</name></expr></argument>, <argument><expr><name>SSL_OP_NO_TLSv1_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>the_ssl_ctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>init_ssl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> <operator>&lt;</operator> <literal type="number">0x10100000L</literal></expr></cpp:if>
<expr_stmt><expr><call><name>SSL_library_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERR_load_crypto_strings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSL_load_error_strings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OpenSSL_add_all_algorithms</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SSLeay</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OPENSSL_VERSION_NUMBER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TT_DECLARE</name><argument_list>(<argument><expr><literal type="string">"WARN"</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Version mismatch for openssl: compiled with %lx but running with %lx"</literal><operator>,</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>OPENSSL_VERSION_NUMBER</name><operator>,</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>SSLeay</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>test_is_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n_connected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>got_close</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>got_error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>got_timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>renegotiate_at</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>stop_when_connected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>pending_connect_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>exit_base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<enum>enum <name>regress_openssl_type</name>
<block>{
<decl><name>REGRESS_OPENSSL_SOCKETPAIR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_FILTER</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_RENEGOTIATE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_OPEN</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_DIRTY_SHUTDOWN</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_FD</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>,

<decl><name>REGRESS_OPENSSL_CLIENT</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_SERVER</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>,

<decl><name>REGRESS_OPENSSL_FREED</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_TIMEOUT</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>,
<decl><name>REGRESS_OPENSSL_SLEEP</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>,

<decl><name>REGRESS_OPENSSL_CLIENT_WRITE</name> <init>= <expr><literal type="number">2048</literal></expr></init></decl>,
}</block>;</enum>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bufferevent_openssl_check_fd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>bufferevent_getfd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>bufferevent_setfd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>bufferevent_getfd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>bufferevent_getfd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bufferevent_openssl_check_freed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bev</name><operator>-&gt;</operator><name>ev_read</name></name></expr></argument>, <argument><expr><name>EVLIST_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bev</name><operator>-&gt;</operator><name>ev_write</name></name></expr></argument>, <argument><expr><name>EVLIST_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>respond_to_number</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>bufferevent_get_input</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>regress_openssl_type</name><operator>)</operator><name>ctx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>evbuffer_readln</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EVBUFFER_EOL_LF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>line</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_FAIL</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Bad number: %s"</literal><operator>,</operator> <name>line</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"The number was %d"</literal><operator>,</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1001</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>test_is_done</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_CLIENT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <name>renegotiate_at</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SSL_renegotiate</name><argument_list>(<argument><expr><call><name>bufferevent_openssl_get_ssl</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evbuffer_add_printf</name><argument_list>(<argument><expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Done reading; now writing."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_disable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>done_writing_cb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evbuffer_get_length</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Done writing."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_disable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>eventcb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>regress_openssl_type</name><operator>)</operator><name>ctx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Got event %d"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>what</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>&amp;</operator> <name>BEV_EVENT_CONNECTED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>peer_cert</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name>n_connected</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ssl</name> <operator>=</operator> <call><name>bufferevent_openssl_get_ssl</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>peer_cert</name> <operator>=</operator> <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_SERVER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>peer_cert</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>peer_cert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stop_when_connected</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>pending_connect_events</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>exit_base</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_CLIENT_WRITE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_CLIENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evbuffer_add_printf</name><argument_list>(<argument><expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>what</name> <operator>&amp;</operator> <name>BEV_EVENT_EOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Got a good EOF"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>got_close</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_fd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FILTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FREED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_freed</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>what</name> <operator>&amp;</operator> <name>BEV_EVENT_ERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Got an error."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>got_error</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_fd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FILTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FREED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_freed</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>what</name> <operator>&amp;</operator> <name>BEV_EVENT_TIMEOUT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Got timeout."</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>got_timeout</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_fd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FILTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FREED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_openssl_check_freed</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>open_ssl_bufevs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>bev1_out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>bev2_out</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_open</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl1</name></decl></parameter>, <parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl2</name></decl></parameter>,
<parameter><decl><type><name>evutil_socket_t</name> <modifier>*</modifier></type><name>fd_pair</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>underlying_pair</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>state1</name> <init>= <expr><ternary><condition><expr><name>is_open</name></expr> ?</condition><then> <expr><name>BUFFEREVENT_SSL_OPEN</name></expr> </then><else>:<expr><name>BUFFEREVENT_SSL_CONNECTING</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state2</name> <init>= <expr><ternary><condition><expr><name>is_open</name></expr> ?</condition><then> <expr><name>BUFFEREVENT_SSL_OPEN</name></expr> </then><else>:<expr><name>BUFFEREVENT_SSL_ACCEPTING</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dirty_shutdown</name> <init>= <expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_DIRTY_SHUTDOWN</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd_pair</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>bev1_out</name> <operator>=</operator> <call><name>bufferevent_openssl_socket_new</name><argument_list>(
<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fd_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ssl1</name></expr></argument>, <argument><expr><name>state1</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bev2_out</name> <operator>=</operator> <call><name>bufferevent_openssl_socket_new</name><argument_list>(
<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fd_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ssl2</name></expr></argument>, <argument><expr><name>state2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>bev1_out</name> <operator>=</operator> <call><name>bufferevent_openssl_filter_new</name><argument_list>(
<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>underlying_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ssl1</name></expr></argument>, <argument><expr><name>state1</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bev2_out</name> <operator>=</operator> <call><name>bufferevent_openssl_filter_new</name><argument_list>(
<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>underlying_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ssl2</name></expr></argument>, <argument><expr><name>state2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>bufferevent_setcb</name><argument_list>(<argument><expr><operator>*</operator><name>bev1_out</name></expr></argument>, <argument><expr><name>respond_to_number</name></expr></argument>, <argument><expr><name>done_writing_cb</name></expr></argument>,
<argument><expr><name>eventcb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>REGRESS_OPENSSL_CLIENT</name> <operator>|</operator> <operator>(</operator><name>long</name><operator>)</operator><name>type</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_setcb</name><argument_list>(<argument><expr><operator>*</operator><name>bev2_out</name></expr></argument>, <argument><expr><name>respond_to_number</name></expr></argument>, <argument><expr><name>done_writing_cb</name></expr></argument>,
<argument><expr><name>eventcb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>REGRESS_OPENSSL_SERVER</name> <operator>|</operator> <operator>(</operator><name>long</name><operator>)</operator><name>type</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bufferevent_openssl_set_allow_dirty_shutdown</name><argument_list>(<argument><expr><operator>*</operator><name>bev1_out</name></expr></argument>, <argument><expr><name>dirty_shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_openssl_set_allow_dirty_shutdown</name><argument_list>(<argument><expr><operator>*</operator><name>bev2_out</name></expr></argument>, <argument><expr><name>dirty_shutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>regress_bufferevent_openssl</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ssl2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X509</name> <modifier>*</modifier></type><name>cert</name> <init>= <expr><call><name>ssl_getcert</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>ssl_getkey</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>BEV_OPT_DEFER_CALLBACKS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name><name>bev_ll</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name> <modifier>*</modifier></type><name>fd_pair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>regress_openssl_type</name><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_ssl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_RENEGOTIATE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SSLeay</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">0x10001000</literal> <operator>&amp;&amp;</operator>
<call><name>SSLeay</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0x1000104f</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>disable_tls_11_and_12</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>renegotiate_at</name> <operator>=</operator> <literal type="number">600</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ssl1</name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><call><name>get_ssl_ctx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ssl2</name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><call><name>get_ssl_ctx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SSL_use_certificate</name><argument_list>(<argument><expr><name>ssl2</name></expr></argument>, <argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSL_use_PrivateKey</name><argument_list>(<argument><expr><name>ssl2</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_OPEN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BEV_OPT_CLOSE_ON_FREE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FILTER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd_pair</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>pair</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>bev_ll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bufferevent_socket_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>BEV_OPT_CLOSE_ON_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bev_ll</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bufferevent_socket_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>BEV_OPT_CLOSE_ON_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>open_ssl_bufevs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bev2</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>ssl1</name></expr></argument>, <argument><expr><name>ssl2</name></expr></argument>,
<argument><expr><name>fd_pair</name></expr></argument>, <argument><expr><name>bev_ll</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_FILTER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>bufferevent_getfd</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>bufferevent_get_underlying</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>bev_ll</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_OPEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pending_connect_events</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>stop_when_connected</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>exit_base</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BEV_OPT_CLOSE_ON_FREE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_free</name><argument_list>(<argument><expr><name>bev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bev1</name> <operator>=</operator> <name>bev2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>open_ssl_bufevs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bev2</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>ssl1</name></expr></argument>, <argument><expr><name>ssl2</name></expr></argument>,
<argument><expr><name>fd_pair</name></expr></argument>, <argument><expr><name>bev_ll</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_TIMEOUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev2</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_CLIENT_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evbuffer_add_printf</name><argument_list>(<argument><expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>test_is_done</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>n_connected</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_DIRTY_SHUTDOWN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_close</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_error</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_error</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_timeout</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>t</name> <init>= <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_disable</name><argument_list>(<argument><expr><name>bev2</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bufferevent_set_timeouts</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_CLIENT_WRITE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evbuffer_add_printf</name><argument_list>(<argument><expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>test_is_done</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>n_connected</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_close</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_error</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_timeout</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>end</name>:</label>
<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>acceptcb_deferred</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>acceptcb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evconnlistener</name></name> <modifier>*</modifier></type><name>listener</name></decl></parameter>, <parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>socklen</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name> <init>= <expr><call><name>SSL_new</name><argument_list>(<argument><expr><call><name>get_ssl_ctx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>regress_openssl_type</name><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SSL_use_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><call><name>ssl_getcert</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSL_use_PrivateKey</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><call><name>ssl_getkey</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bev</name> <operator>=</operator> <call><name>bufferevent_openssl_socket_new</name><argument_list>(
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,
<argument><expr><name>fd</name></expr></argument>,
<argument><expr><name>ssl</name></expr></argument>,
<argument><expr><name>BUFFEREVENT_SSL_ACCEPTING</name></expr></argument>,
<argument><expr><name>BEV_OPT_CLOSE_ON_FREE</name><operator>|</operator><name>BEV_OPT_DEFER_CALLBACKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bufferevent_setcb</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>respond_to_number</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>eventcb</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>REGRESS_OPENSSL_SERVER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_SLEEP</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>when</name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>,
<argument><expr><name>acceptcb_deferred</name></expr></argument>, <argument><expr><name>bev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_disable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>evconnlistener_disable</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>rwcount</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>write</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bio_rwcount_new</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>BIO_set_init</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bio_rwcount_free</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BIO_get_shutdown</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIO_set_init</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bio_rwcount_read</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>outlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rwcount</name></name> <modifier>*</modifier></type><name>rw</name> <init>= <expr><call><name>BIO_get_data</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_ssize_t</name></type> <name>ret</name> <init>= <expr><call><name>recv</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>outlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name><name>rw</name><operator>-&gt;</operator><name>read</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>EVUTIL_ERR_RW_RETRIABLE</name><argument_list>(<argument><expr><call><name>EVUTIL_SOCKET_ERROR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIO_set_retry_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bio_rwcount_write</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rwcount</name></name> <modifier>*</modifier></type><name>rw</name> <init>= <expr><call><name>BIO_get_data</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_ssize_t</name></type> <name>ret</name> <init>= <expr><call><name>send</name><argument_list>(<argument><expr><name><name>rw</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>inlen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name><name>rw</name><operator>-&gt;</operator><name>write</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>EVUTIL_ERR_RW_RETRIABLE</name><argument_list>(<argument><expr><call><name>EVUTIL_SOCKET_ERROR</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BIO_set_retry_write</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>bio_rwcount_ctrl</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BIO_CTRL_GET_CLOSE</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>BIO_get_shutdown</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIO_CTRL_SET_CLOSE</name></expr>:</case>
<expr_stmt><expr><call><name>BIO_set_shutdown</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIO_CTRL_PENDING</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIO_CTRL_WPENDING</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BIO_CTRL_DUP</name></expr>:</case>
<case>case <expr><name>BIO_CTRL_FLUSH</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bio_rwcount_puts</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>bio_rwcount_write</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIO_TYPE_LIBEVENT_RWCOUNT</name></cpp:macro> <cpp:value>0xff1</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name> <modifier>*</modifier></type><name>methods_rwcount</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>BIO_METHOD</name> <modifier>*</modifier></type>
<name>BIO_s_rwcount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>methods_rwcount</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>methods_rwcount</name> <operator>=</operator> <call><name>BIO_meth_new</name><argument_list>(<argument><expr><name>BIO_TYPE_LIBEVENT_RWCOUNT</name></expr></argument>, <argument><expr><literal type="string">"rwcount"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>methods_rwcount</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_write</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_read</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_puts</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_puts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_ctrl</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_ctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_create</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_meth_set_destroy</name><argument_list>(<argument><expr><name>methods_rwcount</name></expr></argument>, <argument><expr><name>bio_rwcount_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>methods_rwcount</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>BIO</name> <modifier>*</modifier></type>
<name>BIO_new_rwcount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>close_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>result</name> <operator>=</operator> <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_rwcount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>BIO_set_init</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_shutdown</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>!</operator><operator>!</operator><name>close_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>regress_bufferevent_openssl_connect</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>evconnlistener</name></name> <modifier>*</modifier></type><name>listener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>bufferevent</name></name> <modifier>*</modifier></type><name>bev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name></type> <name>sin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>ss</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_socklen_t</name></type> <name>slen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>bio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rwcount</name></name></type> <name>rw</name> <init>= <expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>regress_openssl_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator>enum <name>regress_openssl_type</name><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_ssl</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name><operator>.</operator><name>sin_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sin</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><literal type="number">0x7f000001</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>listener</name> <operator>=</operator> <call><name>evconnlistener_new_bind</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>acceptcb</name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
<argument><expr><name>LEV_OPT_CLOSE_ON_FREE</name><operator>|</operator><name>LEV_OPT_REUSEABLE</name></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>evconnlistener_get_fd</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ssl</name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><call><name>get_ssl_ctx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bev</name> <operator>=</operator> <call><name>bufferevent_openssl_socket_new</name><argument_list>(
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ssl</name></expr></argument>,
<argument><expr><name>BUFFEREVENT_SSL_CONNECTING</name></expr></argument>,
<argument><expr><name>BEV_OPT_CLOSE_ON_FREE</name><operator>|</operator><name>BEV_OPT_DEFER_CALLBACKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bufferevent_setcb</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>respond_to_number</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>eventcb</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>REGRESS_OPENSSL_CLIENT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>getsockname</name><argument_list>(<argument><expr><call><name>evconnlistener_get_fd</name><argument_list>(<argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>slen</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name><operator>)</operator><operator>-&gt;</operator><name>sa_family</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator>
<call><name>bufferevent_socket_connect</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ss</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>REGRESS_OPENSSL_SLEEP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rw</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <call><name>bufferevent_getfd</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bio</name> <operator>=</operator> <call><name>BIO_new_rwcount</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SSL_set_bio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>bio</name></expr></argument>, <argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>evbuffer_add_printf</name><argument_list>(<argument><expr><call><name>bufferevent_get_output</name><argument_list>(<argument><expr><name>bev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bufferevent_enable</name><argument_list>(<argument><expr><name>bev</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>rw</name><operator>.</operator><name>read</name></name></expr></argument>, <argument><expr><operator>&lt;=</operator></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>rw</name><operator>.</operator><name>write</name></name></expr></argument>, <argument><expr><operator>&lt;=</operator></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>struct</name> <name>testcase_t</name></name></type> <name><name>ssl_testcases</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>T</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void *)(a))</cpp:value></cpp:define>
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_write_after_connect"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR|REGRESS_OPENSSL_CLIENT_WRITE</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter_write_after_connect"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER|REGRESS_OPENSSL_CLIENT_WRITE</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_renegotiate_socketpair"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_RENEGOTIATE</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_renegotiate_filter"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_RENEGOTIATE</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_startopen"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_OPEN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter_startopen"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_OPEN</argument>)</argument_list></macro> }</block></expr>,

<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_dirty_shutdown"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter_dirty_shutdown"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_renegotiate_socketpair_dirty_shutdown"</literal></expr>,
<expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>,
<expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_RENEGOTIATE | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_renegotiate_filter_dirty_shutdown"</literal></expr>,
<expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>,
<expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_RENEGOTIATE | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_startopen_dirty_shutdown"</literal></expr>,
<expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_OPEN | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter_startopen_dirty_shutdown"</literal></expr>,
<expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_OPEN | REGRESS_OPENSSL_DIRTY_SHUTDOWN</argument>)</argument_list></macro> }</block></expr>,

<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_fd"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FD</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_freed"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FREED</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_freed_fd"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_filter_freed_fd"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD</argument>)</argument_list></macro> }</block></expr>,

<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_timeout"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_TIMEOUT</argument>)</argument_list></macro> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_socketpair_timeout_freed_fd"</literal></expr>, <expr><name>regress_bufferevent_openssl</name></expr>,
<expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_TIMEOUT | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD</argument>)</argument_list></macro> }</block></expr>,

<expr><block>{ <expr><literal type="string">"bufferevent_connect"</literal></expr>, <expr><name>regress_bufferevent_openssl_connect</name></expr>,
<expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"bufferevent_connect_sleep"</literal></expr>, <expr><name>regress_bufferevent_openssl_connect</name></expr>,
<expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <macro><name>T</name><argument_list>(<argument>REGRESS_OPENSSL_SLEEP</argument>)</argument_list></macro> }</block></expr>,

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>T</name></cpp:undef>

<expr><name>END_OF_TESTCASES</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
