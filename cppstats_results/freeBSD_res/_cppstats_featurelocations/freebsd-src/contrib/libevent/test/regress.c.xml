<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libevent/test/regress.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util-internal.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event-config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event_struct.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/event_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/tag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/buffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/buffer_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event2/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"event-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"evthread-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"time-internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regress.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regress.gen.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name><name>pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>test_ok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>called</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>global_base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>wbuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>rbuf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>woff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>roff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>usepersist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>tset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>tcalled</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST1</name></cpp:macro> <cpp:value>"this is a test"</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>,<parameter><type><name>buf</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>send((fd),(buf),(int)(len),0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>read</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>,<parameter><type><name>buf</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>recv((fd),(buf),(int)(len),0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>basic_cb_args</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>eb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>callcount</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>called</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>called</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>basic_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_cb_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"read (callback)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>callcount</name></name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>tt_fail_msg</name><argument_list>(<argument><expr><literal type="string">"EOF before data read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_fail_msg</name><argument_list>(<argument><expr><literal type="string">"not all data read on first cycle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>tt_fail_msg</name><argument_list>(<argument><expr><literal type="string">"too many cycles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>ev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>eb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dummy_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_write_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>multiple_write_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>woff</name> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>woff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>wbuf</name> <operator>+</operator> <name>woff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: write\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>usepersist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>woff</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>woff</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>usepersist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>usepersist</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>multiple_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rbuf</name> <operator>+</operator> <name>roff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>roff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: read\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>usepersist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>roff</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>usepersist</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timeout_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tcalled</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>both</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nread</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>combined_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>both</name></name> <modifier>*</modifier></type><name>both</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: read\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>both</name><operator>-&gt;</operator><name>nread</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>both</name><operator>-&gt;</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>combined_write_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>both</name></name> <modifier>*</modifier></type><name>both</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>both</name><operator>-&gt;</operator><name>nread</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>both</name><operator>-&gt;</operator><name>nread</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'q'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: write\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>both</name><operator>-&gt;</operator><name>nread</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>both</name><operator>-&gt;</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setup_test</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!in_legacy_test_wrapper) { TT_FAIL(("Legacy test %s not wrapped properly", x)); return; } } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cleanup_test</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>setup_test("cleanup")</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simpleread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simple read: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>simple_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simplewrite</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simple write: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>simple_write_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>simpleread_multiple_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>called</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simpleread_multiple</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>one</name></decl>, <decl><type ref="prev"/><name>two</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simple read to multiple evens: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>simpleread_multiple_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>two</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>simpleread_multiple_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>two</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>have_closed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>premature_event</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simpleclose_close_fd_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>evutil_socket_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>fds</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Closing"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><operator>*</operator><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><operator>*</operator><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>fds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>have_closed</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>record_event_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>whatp</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_closed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>premature_event</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>whatp</name> <operator>=</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Recorded %d on socket %d"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>what</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simpleclose</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_base_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name><name>pair1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><init>=<expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name><name>pair2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name> <modifier>*</modifier></type><name><name>to_close</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>rev</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wev</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>closeev</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>got_read_on_close</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>got_write_on_close</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">99</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_SOCKETPAIR_AF</name></cpp:macro> <cpp:value>AF_INET</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCAL_SOCKETPAIR_AF</name></cpp:macro> <cpp:value>AF_UNIX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><call><name>evutil_socketpair</name><argument_list>(<argument><expr><name>LOCAL_SOCKETPAIR_AF</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pair1</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_DIE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"socketpair: %s"</literal><operator>,</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evutil_socketpair</name><argument_list>(<argument><expr><name>LOCAL_SOCKETPAIR_AF</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pair2</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_DIE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"socketpair: %s"</literal><operator>,</operator> <call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evutil_make_socket_nonblocking</name><argument_list>(<argument><expr><name><name>pair1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_DIE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"make_socket_nonblocking"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evutil_make_socket_nonblocking</name><argument_list>(<argument><expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_DIE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"make_socket_nonblocking"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name><operator>&lt;</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>evutil_socket_geterror</name><argument_list>(<argument><expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>EVUTIL_ERR_RW_RETRIABLE</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TT_DIE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"write failed strangely: %s"</literal><operator>,</operator>
<call><name>evutil_socket_error_to_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>to_close</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pair1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to_close</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>pair2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>closeev</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><name>simpleclose_close_fd_cb</name></expr></argument>,
<argument><expr><name>to_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rev</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>pair1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>record_event_cb</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>got_read_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Waiting for read on %d"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pair1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wev</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>record_event_cb</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>got_write_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Waiting for write on %d"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">100</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>closeev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>wev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">200</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_read_on_close</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>got_write_on_close</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>premature_event</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>pair1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>pair1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pair1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>pair1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pair2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>pair2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>pair2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>wev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>closeev</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>closeev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_multiple</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Multiple read/write: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>roff</name> <operator>=</operator> <name>woff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>usepersist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>multiple_write_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>multiple_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>roff</name> <operator>==</operator> <name>woff</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_persistent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Persist read/write: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>roff</name> <operator>=</operator> <name>woff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>usepersist</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>multiple_write_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>multiple_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>roff</name> <operator>==</operator> <name>woff</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>, <argument><expr><name>wbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_combined</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>both</name></name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>w1</name></decl>, <decl><type ref="prev"/><name>w2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Combined read/write: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>w2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>w2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>w1</name><operator>.</operator><name>nread</name></name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>w2</name><operator>.</operator><name>nread</name></name> <operator>=</operator> <literal type="number">8192</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r1</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>combined_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w1</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>combined_write_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r2</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>combined_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w2</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>combined_write_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r1</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w1</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r2</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w2</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r1</name><operator>.</operator><name>nread</name></name> <operator>==</operator> <literal type="number">8192</literal> <operator>&amp;&amp;</operator> <name><name>r2</name><operator>.</operator><name>nread</name></name> <operator>==</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simpletimeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simple timeout: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">200</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tcalled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>timeout_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcalled</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>periodic_timeout_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>count</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_persistent_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>global_base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>,
<argument><expr><name>periodic_timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_persistent_timeout_jump</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>msec100</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>msec50</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">50</literal> <operator>*</operator> <literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>msec300</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">300</literal> <operator>*</operator> <literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>periodic_timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msec100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_usleep_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msec300</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msec50</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>persist_active_timeout_called</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name><name>events</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>tvs</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>activate_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>persist_active_timeout_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>persist_active_timeout_called</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>n</name></name> <operator>&lt;</operator> <literal type="number">15</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>events</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>tvs</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>n</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>c</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_persistent_active_timeout</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>, <decl><type ref="prev"/><name>tv2</name></decl>, <decl><type ref="prev"/><name>tv_exit</name></decl>, <decl><type ref="prev"/><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>persist_active_timeout_called</name></name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">200</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>,
<argument><expr><name>persist_active_timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv2</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv2</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_once</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><name>activate_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv_exit</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv_exit</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">600</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv_exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>events</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>events</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>res</name><operator>.</operator><name>events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>tvs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>tvs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">300</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>tvs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>common_timeout_info</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>called_at</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>which</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>common_timeout_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>common_timeout_info</name></name> <modifier>*</modifier></type><name>ti</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name><name>ti</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ti</name><operator>-&gt;</operator><name>called_at</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ti</name><operator>-&gt;</operator><name>ev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_common_timeout</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>common_timeout_info</name></name></type> <name><name>info</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tmp_100_ms</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tmp_200_ms</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">200</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tmp_5_sec</name> <init>= <expr><block>{ <expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tmp_5M_usec</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">5</literal><operator>*</operator><literal type="number">1000</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>ms_100</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ms_200</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sec_5</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ms_100</name> <operator>=</operator> <call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_100_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ms_200</name> <operator>=</operator> <call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_200_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sec_5</name> <operator>=</operator> <call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_5_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ms_100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>sec_5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_200_ms</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_base_init_common_timeout</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_5M_usec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>sec_5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>ms_100</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>ms_200</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>sec_5</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>ms_100</name><operator>-&gt;</operator><name>tv_usec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">100000</literal><operator>|</operator><literal type="number">0x50000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>ms_200</name><operator>-&gt;</operator><name>tv_usec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">200000</literal><operator>|</operator><literal type="number">0x50100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>sec_5</name><operator>-&gt;</operator><name>tv_usec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal><operator>|</operator><literal type="number">0x50200000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">100</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>which</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>,
<argument><expr><name>common_timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name><operator>%</operator><literal type="number">20</literal><operator>)</operator><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_100_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>i</name><operator>%</operator><literal type="number">20</literal><operator>)</operator><operator>==</operator><literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_200_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>i</name><operator>%</operator><literal type="number">20</literal><operator>)</operator><operator>==</operator><literal type="number">5</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">10</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>called_at</name></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>called_at</name></expr></argument>, <argument><expr><literal type="number">800</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">100</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>, <argument><expr><name>ms_200</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>current_base</name></cpp:macro> <cpp:value>event_global_current_base_</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>current_base</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fork_signal_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type> <name><name>child_pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>simple_child_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>child_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>called</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>called</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_fork</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>, <decl><type ref="prev"/><name>sig_ev</name></decl>, <decl><type ref="prev"/><name>usr_ev</name></decl>, <decl><type ref="prev"/><name>existing_ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wait_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_WAITPID_WITH_WNOWAIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>wait_flags</name> <operator>|=</operator> <name>WNOWAIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"After fork: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>evutil_socketpair</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>child_pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: socketpair\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evutil_make_socket_nonblocking</name><argument_list>(<argument><expr><name><name>child_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"fcntl(O_NONBLOCK)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evthread_make_base_notifiable</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>simple_child_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig_ev</name></expr></argument>, <argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>fork_signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig_ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_ev</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>fork_signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>existing_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>existing_ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Before fork"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pid</name> <operator>=</operator> <call><name>regress_fork</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"In child, before reinit"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_reinit</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"FAILED (reinit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After reinit"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After assert-ok"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>fork_signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>called</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>current_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><ternary><condition><expr><name>test_ok</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>called</name> <operator>!=</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">76</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name><name>child_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Before waitpid"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>wait_flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"waitpid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After waitpid"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">76</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"FAILED (exit): %d\n"</literal></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: write\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>fork_signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usr_ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig_ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>test_ok</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>child_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>child_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>child_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>child_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>del_wait_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv_start</name></decl>, <decl><type ref="prev"/><name>tv_end</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><literal type="number">300</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>del_wait_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>delay</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">300</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Sleeping"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_usleep_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_del_wait</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pthread_t</name></type> <name>thread</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"event_del will wait: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>del_wait_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>del_wait_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>delay</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">30</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_usleep_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv_start</name></decl>, <decl><type ref="prev"/><name>tv_end</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><literal type="number">270</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name>thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_cb_sa</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simplesignal_impl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>find_reorder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>itimerval</name></name></type> <name>itv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>find_reorder</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>itv</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>itv</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>setitimer</name><argument_list>(<argument><expr><name>ITIMER_REAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>skip_simplesignal</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<label><name>skip_simplesignal</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simplestsignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simplest one signal: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_simplesignal_impl</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_simplesignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Simple signal: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_simplesignal_impl</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_multiplesignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev_one</name></decl>, <decl><type ref="prev"/><name>ev_two</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>itimerval</name></name></type> <name>itv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Multiple signal: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_one</name></expr></argument>, <argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev_one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_one</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_two</name></expr></argument>, <argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev_two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_two</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>itv</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>itv</name><operator>.</operator><name>it_value</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>setitimer</name><argument_list>(<argument><expr><name>ITIMER_REAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>itv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>skip_simplesignal</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>skip_simplesignal</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_one</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_two</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_immediatesignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loop</name><argument_list>(<argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_dealloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_pipeloss</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pipe1</name></decl>;</decl_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>base1</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pipe1</name> <operator>=</operator> <name><name>base1</name><operator>-&gt;</operator><name>sig</name><operator>.</operator><name>ev_signal_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>base2</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>pipe1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>errno</name><operator>!=</operator><name>EBADF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"signal pipe not closed. "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_switchbase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_kqueue</name></decl>;</decl_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>base1</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base2</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>is_kqueue</name> <operator>=</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><call><name>event_get_method</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"kqueue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_base_set</name><argument_list>(<argument><expr><name>base1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>event_base_set</name><argument_list>(<argument><expr><name>base2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: cannot set base, add\n"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_get_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_get_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>base2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base2</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_kqueue</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>test_ok</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base1</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_kqueue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base1</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base1</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base2</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_assert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGCONT</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>


if (base-&gt;sig.evsig_caught)
test_ok = 0;
else
test_ok = 1;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_restore</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SIGACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sa</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SIGACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>signal_cb_sa</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb_sa</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SIG_ERR</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>evsignal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evsignal_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>test_ok</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_cb_swp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>called</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>called</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_loopexit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>timeout_cb_swp</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>called</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name> <init>= <expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>called</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>(</operator>struct <name>event</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loopexit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_signal_while_processing</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_init</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>, <decl><type ref="prev"/><name>ev_timer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Receiving a signal while processing other signal: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>called</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>signal_cb_swp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_timer</name></expr></argument>, <argument><expr><name>timeout_cb_swp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev_timer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev_timer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_free_active_base</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>base1</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>base1</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>base1</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>,
<argument><expr><name>dummy_read_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_msg</name><argument_list>(<argument><expr><literal type="string">"failed to create event_base for test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>base1</name> <operator>=</operator> <call><name>event_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>base1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dummy_read_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_manipulate_active_events</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><name>dummy_read_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_TIMEOUT</name><operator>|</operator><name>EV_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_TIMEOUT</name><operator>|</operator><name>EV_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>event_selfarg_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>event_get_base</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_want</name><argument_list>(<argument><expr><name>ev</name> <operator>==</operator> <call><name>event_base_get_running_event</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_new_selfarg</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name> <init>= <expr><call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>event_selfarg_cb</name></expr></argument>,
<argument><expr><call><name>event_self_cbarg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_assign_selfarg</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>event_selfarg_cb</name></expr></argument>,
<argument><expr><call><name>event_self_cbarg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_base_get_num_events</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_virtual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_virtual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_virtual_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_added_virtual</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>qsec</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">100000</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>event_selfarg_cb</name></expr></argument>,
<argument><expr><call><name>event_self_cbarg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name><operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name><operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name><operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_add_virtual_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name><operator>|</operator><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_num_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name><operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name><operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_base_get_max_events</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_virtual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_virtual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_virtual_added</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>event_count_active_added_virtual</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>qsec</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">100000</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>event_selfarg_cb</name></expr></argument>,
<argument><expr><call><name>event_self_cbarg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>event_selfarg_cb</name></expr></argument>,
<argument><expr><call><name>event_self_cbarg</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_add_virtual_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_virtual_added</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_VIRTUAL</name> <operator>|</operator> <name>EVENT_BASE_COUNT_ADDED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>event_count_active_added_virtual</name> <operator>=</operator> <call><name>event_base_get_max_events</name><argument_list>(<argument><expr><name>base</name></expr></argument>,
<argument><expr><name>EVENT_BASE_COUNT_ACTIVE</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_ADDED</name> <operator>|</operator>
<name>EVENT_BASE_COUNT_VIRTUAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_virtual_added</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event_count_active_added_virtual</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bad_assign</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_SIGNAL</name><operator>|</operator><name>EV_READ</name></expr></argument>, <argument><expr><name>dummy_read_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><operator>==</operator></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>reentrant_cb_run</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bad_reentrant_run_loop_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>reentrant_cb_run</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_bad_reentrant</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bad_reentrant_run_loop_cb</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>reentrant_cb_run</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n_write_a_byte_cb</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n_read_and_drain_cb</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n_activate_other_event_cb</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_a_byte_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[]</index></name> <init>= <expr><literal type="string">"x"</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>n_write_a_byte_cb</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_and_drain_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name>n_read_and_drain_cb</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>activate_other_event_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>other_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev_activate</name> <init>= <expr><name>other_</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>++</operator><name>n_activate_other_event_cb</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active_later_</name><argument_list>(<argument><expr><name>ev_activate</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_active_later</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev3</name></decl>, <decl><type ref="prev"/><name>ev4</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>qsec</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">100000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>read_and_drain_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>write_a_byte_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev3</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>activate_other_event_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev4</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>activate_other_event_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active_later_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev3</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d write calls, %d read calls, %d activate-other calls."</literal><operator>,</operator>
<name>n_write_a_byte_cb</name><operator>,</operator> <name>n_read_and_drain_cb</name><operator>,</operator> <name>n_activate_other_event_cb</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n_write_a_byte_cb</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>n_activate_other_event_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n_write_a_byte_cb</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n_read_and_drain_cb</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n_activate_other_event_cb</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active_later_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev4</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev4</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>ev4</name><operator>.</operator><name>ev_flags</name></name> <operator>&amp;</operator> <name>EVLIST_ACTIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>ev4</name><operator>.</operator><name>ev_flags</name></name> <operator>&amp;</operator> <name>EVLIST_ACTIVE_LATER</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>event_active_later_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev3</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ev1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>incr_arg_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>intptr</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>fd</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><operator>*</operator><name>intptr</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_timers_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ep</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>fd</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_remove_timer</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_remove_timer</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>send_a_byte_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>evutil_socket_t</name> <modifier>*</modifier></type><name>sockp</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>fd</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>write</name><argument_list>(<argument><expr><operator>*</operator><name>sockp</name></expr></argument>, <argument><expr><literal type="string">"A"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<struct>struct <name>read_not_timeout_param</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>read_not_timeout_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>read_not_timeout_param</name></name> <modifier>*</modifier></type><name>rntp</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>fd</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rntp</name><operator>-&gt;</operator><name>events</name></name> <operator>|=</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>rntp</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><literal type="number">2</literal> <operator>==</operator> <name><name>rntp</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name><name>rntp</name><operator>-&gt;</operator><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_remove_timeout</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name><name>ev</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ev1_fired</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>ms25</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">25</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>,
<decl><type ref="prev"/><name>ms40</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">40</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>,
<decl><type ref="prev"/><name>ms75</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">75</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>,
<decl><type ref="prev"/><name>ms125</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">125</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>read_not_timeout_param</name></name></type> <name>rntp</name> <init>= <expr><block>{ <expr><name>ev</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>,
<argument><expr><name>read_not_timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rntp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>evtimer_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>incr_arg_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev1_fired</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>evtimer_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>remove_timers_cb</name></expr></argument>, <argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>evtimer_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>send_a_byte_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>evtimer_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>send_a_byte_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms25</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms40</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms75</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms75</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ms125</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>ev1_fired</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>rntp</name><operator>.</operator><name>events</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_base_new</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_cb_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>towrite</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><name>towrite</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_perror</name><argument_list>(<argument><expr><literal type="string">"initial write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>!=</operator> <name>towrite</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_printf</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"initial write fell short (%d of %d bytes)"</literal><operator>,</operator>
<name>len</name><operator>,</operator> <name>towrite</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_perror</name><argument_list>(<argument><expr><literal type="string">"initial write shutdown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_msg</name><argument_list>(<argument><expr><literal type="string">"failed to create event base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>eb</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>ev</name></name> <operator>=</operator> <operator>&amp;</operator><name>ev1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>callcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>basic_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_perror</name><argument_list>(<argument><expr><literal type="string">"initial event_add"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_abort_msg</name><argument_list>(<argument><expr><literal type="string">"unsuccessful exit from event loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_loopexit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>, <decl><type ref="prev"/><name>tv_start</name></decl>, <decl><type ref="prev"/><name>tv_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Loop exit: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">60</literal><operator>*</operator><literal type="number">60</literal><operator>*</operator><literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>timeout_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">300</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loopexit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evtimer_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>event_base_got_exit</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_base_got_break</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><literal type="number">300</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_loopexit_multiple</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>, <decl><type ref="prev"/><name>tv_start</name></decl>, <decl><type ref="prev"/><name>tv_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Loop Multiple exit: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">200</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>event_base_got_exit</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_base_got_break</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv_end</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>break_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loopbreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fail_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_loopbreak</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Loop break: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>break_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>fail_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_base_got_exit</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>event_base_got_break</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evtimer_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtimer_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>readd_test_event_last_added</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>re_add_read_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev_other</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_ssize_t</name></type> <name>n_read</name></decl>;</decl_stmt>

<expr_stmt><expr><name>readd_test_event_last_added</name> <operator>=</operator> <name>ev_other</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_read</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n_read</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopbreak</name><argument_list>(<argument><expr><call><name>event_get_base</name><argument_list>(<argument><expr><name>ev_other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev_other</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>test_ok</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_nonpersist_readd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev1</name></decl>, <decl><type ref="prev"/><name>ev2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Re-add nonpersistent events: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>re_add_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>re_add_read_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write(pair[0])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write(pair[1])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>test_ok</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_loop</name><argument_list>(<argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test_ok</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>readd_test_event_last_added</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>readd_test_event_last_added</name> <operator>==</operator> <operator>&amp;</operator><name>ev1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>event_pending</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>test_pri_event</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_priorities_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>test_pri_event</name></name> <modifier>*</modifier></type><name>pri</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pri</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_loopexit</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pri</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pri</name><operator>-&gt;</operator><name>ev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_priorities_impl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>npriorities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>test_pri_event</name></name></type> <name>one</name></decl>, <decl><type ref="prev"/><name>two</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Testing Priorities %d: "</literal><operator>,</operator> <name>npriorities</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_priority_init</name><argument_list>(<argument><expr><name>global_base</name></expr></argument>, <argument><expr><name>npriorities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>two</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>two</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>timeout_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>one</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>test_priorities_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_priority_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>one</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: failed to set priority"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>timeout_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>two</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>test_priorities_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_priority_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>two</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><name>npriorities</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: failed to set priority"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>one</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>two</name><operator>.</operator><name>ev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>one</name><operator>.</operator><name>ev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>two</name><operator>.</operator><name>ev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>npriorities</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>one</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>two</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>npriorities</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>one</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>two</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>one</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>two</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_priorities</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>test_priorities_impl</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test_ok</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>test_priorities_impl</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>test_ok</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>test_priorities_impl</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>n_pai_calls</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>event</name></name></type> <name><name>pai_events</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prio_active_inversion_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>call_order</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>call_order</name> <operator>=</operator> <name>n_pai_calls</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n_pai_calls</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_priority_active_inversion</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>data_</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>call_order</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_base_priority_init</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_pai_calls</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>call_order</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>call_order</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><literal type="number">3</literal></expr>;</condition><incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>event_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>prio_active_inversion_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>call_order</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>event_priority_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_priority_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_priority_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pai_events</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>n_pai_calls</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>call_order</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>call_order</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>call_order</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_multiple_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name>EV_READ</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name>EV_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>|=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_multiple_events_for_same_fd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>e1</name></decl>, <decl><type ref="prev"/><name>e2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Multiple events for same fd: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e1</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>test_multiple_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>test_multiple_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loop</name><argument_list>(<argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>event_loop</name><argument_list>(<argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>test_ok</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>evtag_decode_int</name><parameter_list>(<parameter><decl><type><name>ev_uint32_t</name> <modifier>*</modifier></type><name>pnumber</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>evbuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>evtag_decode_int64</name><parameter_list>(<parameter><decl><type><name>ev_uint64_t</name> <modifier>*</modifier></type><name>pnumber</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>evbuf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>evtag_encode_tag</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>evbuf</name></decl></parameter>, <parameter><decl><type><name>ev_uint32_t</name></type> <name>number</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>evtag_decode_tag</name><parameter_list>(<parameter><decl><type><name>ev_uint32_t</name> <modifier>*</modifier></type><name>pnumber</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>evbuf</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_once_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>called</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>test_ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>called</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_want_only_once</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setup_test</name><argument_list>(<argument><expr><literal type="string">"Want read only once: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">300</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_loopexit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>read_once_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>event_dispatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cleanup_test</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MAX_INT</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>evtag_int_test</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>evbuffer_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name><name>integers</name><index>[<expr><name>TEST_MAX_INT</name></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">0xaf0</literal></expr>, <expr><literal type="number">0x1000</literal></expr>, <expr><literal type="number">0x1</literal></expr>, <expr><literal type="number">0xdeadbeef</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xbef000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name>integer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint64_t</name></type> <name>big_int</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evtag_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_MAX_INT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldlen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtag_encode_int</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"encoded 0x%08x with %d bytes"</literal><operator>,</operator>
<operator>(</operator><name>unsigned</name><operator>)</operator><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <name>newlen</name> <operator>-</operator> <name>oldlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>big_int</name> <operator>=</operator> <name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>big_int</name> <operator>*=</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtag_encode_int64</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>big_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_MAX_INT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_decode_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>integer</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_uint_op</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_decode_int64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>big_int</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>(</operator><name>big_int</name> <operator>/</operator> <literal type="number">1000000000</literal><operator>)</operator> <operator>==</operator> <name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>tt_uint_op</name><argument_list>(<argument><expr><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>evbuffer_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>evtag_fuzz</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>evbuffer_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>not_failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evtag_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>test_weakrand</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>evbuffer_drain</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evbuffer_add</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evtag_unmarshal_timeval</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>not_failed</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>not_failed</name></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>evbuffer_drain</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evutil_timerclear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtag_marshal_timeval</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evbuffer_add</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>EVBUFFER_DATA</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>=</operator> <literal type="char">'\xff'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evtag_unmarshal_timeval</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_abort_msg</name><argument_list>(<argument><expr><literal type="string">"evtag_unmarshal_timeval should have failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>evbuffer_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>evtag_tag_encoding</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>evbuffer_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name><name>integers</name><index>[<expr><name>TEST_MAX_INT</name></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">0xaf0</literal></expr>, <expr><literal type="number">0x1000</literal></expr>, <expr><literal type="number">0x1</literal></expr>, <expr><literal type="number">0xdeadbeef</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xbef000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name>integer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evtag_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_MAX_INT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldlen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>oldlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtag_encode_tag</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"encoded 0x%08x with %d bytes"</literal><operator>,</operator>
<operator>(</operator><name>unsigned</name><operator>)</operator><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <name>newlen</name> <operator>-</operator> <name>oldlen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TEST_MAX_INT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_decode_tag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>integer</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_uint_op</name><argument_list>(<argument><expr><name>integer</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>integers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>tt_uint_op</name><argument_list>(<argument><expr><call><name>EVBUFFER_LENGTH</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>evbuffer_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>evtag_test_peek</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>evbuffer</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>evbuffer_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name>u32</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>evtag_marshal_int</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evtag_marshal_string</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><literal type="string">"Hello world"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_peek</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>u32</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_peek_length</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>u32</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_consume</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_peek</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>u32</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_peek_length</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>u32</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><literal type="number">1</literal><operator>+</operator><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>evtag_payload_length</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>u32</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<expr_stmt><expr><call><name>evbuffer_free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_methods</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>methods</name> <init>= <expr><call><name>event_get_supported_methods</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_config</name></name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_methods</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>methods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>backend</name> <operator>=</operator> <name><name>methods</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>methods</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Support method: %s"</literal><operator>,</operator> <operator>*</operator><name>methods</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>methods</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>n_methods</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cfg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_config_avoid_method</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_config_set_flag</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>EVENT_BASE_FLAG_IGNORE_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n_methods</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_str_op</name><argument_list>(<argument><expr><name>backend</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><call><name>event_base_get_method</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_version</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ev_uint32_t</name></type> <name>vint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>major</name></decl>, <decl><type ref="prev"/><name>minor</name></decl>, <decl><type ref="prev"/><name>patch</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>event_get_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vint</name> <operator>=</operator> <call><name>event_get_version_number</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>vint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_str_op</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>LIBEVENT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>vint</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>LIBEVENT_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><literal type="string">"%d.%d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>major</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">3</literal> <operator>==</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><operator>(</operator><name>vint</name><operator>&amp;</operator><literal type="number">0xffffff00</literal><operator>)</operator></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>major</name><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>minor</name><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>|</operator><operator>(</operator><name>patch</name><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_base_features</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_config</name></name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <call><name>event_config_require_features</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>EV_FEATURE_ET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>EV_FEATURE_ET</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>,
<argument><expr><call><name>event_base_get_features</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>EV_FEATURE_ET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_get_features</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>EV_FEATURE_ET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETENV_OK</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_SETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>o_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_snprintf</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,<argument><expr><name>k</name></expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETENV_OK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSETENV_OK</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_UNSETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unsetenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_snprintf</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s="</literal></expr></argument>,<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSETENV_OK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SETENV_OK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>UNSETENV_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>methodname_to_envvar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><literal type="string">"EVENT_NO%s"</literal></expr></argument>, <argument><expr><name>mname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><operator>++</operator><name>cp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <call><name>EVUTIL_TOUPPER_</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_base_environ</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_config</name></name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SETENV_OK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>UNSETENV_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>basenames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_methods</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>varbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defaultname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ignoreenvname</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"EVENT_NOWAFFLES"</literal></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><literal type="string">"EVENT_NOWAFFLES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"EVENT_NOWAFFLES"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>TT_DECLARE</name><argument_list>(<argument><expr><literal type="string">"NOTE"</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"Can't fake unsetenv; skipping test"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>TT_DECLARE</name><argument_list>(<argument><expr><literal type="string">"NOTE"</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="string">"unsetenv doesn't work; skipping test"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>tt_skip</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>basenames</name> <operator>=</operator> <call><name>event_get_supported_methods</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>basenames</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>methodname_to_envvar</name><argument_list>(<argument><expr><name><name>basenames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name>varbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>n_methods</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>defaultname</name> <operator>=</operator> <call><name>event_base_get_method</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TT_BLATHER</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"default is &lt;%s&gt;"</literal><operator>,</operator> <name>defaultname</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>defaultname</name></expr></argument>, <argument><expr><literal type="string">"epoll (with changelist)"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"EVENT_NOEPOLL"</literal></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ignoreenvname</name> <operator>=</operator> <literal type="string">"epoll"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>methodname_to_envvar</name><argument_list>(<argument><expr><name>defaultname</name></expr></argument>, <argument><expr><name>varbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><name>varbuf</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ignoreenvname</name> <operator>=</operator> <name>defaultname</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cfg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n_methods</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_str_op</name><argument_list>(<argument><expr><name>defaultname</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><call><name>event_base_get_method</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_config_set_flag</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>EVENT_BASE_FLAG_IGNORE_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_str_op</name><argument_list>(<argument><expr><name>ignoreenvname</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_get_method</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>tt_skip</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_called_once_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>called</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timeout_called_once_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>called</name> <operator>+=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>immediate_called_twice_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>called</name> <operator>+=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_once</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">50</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>called</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>,
<argument><expr><name>read_called_once_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>,
<argument><expr><name>timeout_called_once_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>,
<argument><expr><name>immediate_called_twice_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>,
<argument><expr><name>immediate_called_twice_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TEST1</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>TEST1</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_fail_perror</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EVUTIL_SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>called</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2101</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_once_never</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>called</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_once</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>,
<argument><expr><name>timeout_called_once_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">75</literal><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loopexit</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>called</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_pending</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>r</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>w</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>, <decl><type ref="prev"/><name>now</name></decl>, <decl><type ref="prev"/><name>tv2</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">500</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>simple_read_cb</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>simple_write_cb</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>evtimer_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>timeout_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>( <argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_pending</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_pending</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>( <argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>event_pending</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>( <argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>( <argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>evutil_timercmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>test_timeval_diff_eq</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dfd_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><name>data</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>e</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_closed_fd_poll</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>basic_test_data</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>event_base_get_method</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"poll"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tinytest_set_test_skipped_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>dfd_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">500</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>event_pending</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_dup_fd</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev1</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev2</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>dfd</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ev1_got</name></decl>, <decl><type ref="prev"/><name>ev2_got</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Hello world"</literal></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"Hello world"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>dfd</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>, <argument><expr><operator>&gt;=</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>dfd_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev1_got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>dfd</name></expr></argument>, <argument><expr><name>EV_READ</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>dfd_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2_got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev1_got</name> <operator>=</operator> <name>ev2_got</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>ev1_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>ev2_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_del</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev1_got</name> <operator>=</operator> <name>ev2_got</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_want_int_op</name><argument_list>(<argument><expr><name>ev1_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>ev2_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>dfd</name></expr></argument>, <argument><expr><name>EV_WRITE</name><operator>|</operator><name>EV_PERSIST</name></expr></argument>, <argument><expr><name>dfd_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ev2_got</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev1_got</name> <operator>=</operator> <name>ev2_got</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_want_int_op</name><argument_list>(<argument><expr><name>ev1_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>ev2_got</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ev1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>dfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__DISABLE_MM_REPLACEMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_mm_functions</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tinytest_set_test_skipped_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_dummy_mem_ok</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><name>mem_</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mem</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><literal type="string">"{[&lt;guardedram&gt;]}"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dummy_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><literal type="string">"{[&lt;guardedram&gt;]}"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>mem</name><operator>+</operator><literal type="number">16</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>dummy_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem_</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><name>mem_</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>dummy_malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tt_want</name><argument_list>(<argument><expr><call><name>check_dummy_mem_ok</name><argument_list>(<argument><expr><name>mem_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mem</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>mem</name><operator>+</operator><literal type="number">16</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dummy_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mem</name> <init>= <expr><name>mem_</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tt_want</name><argument_list>(<argument><expr><call><name>check_dummy_mem_ok</name><argument_list>(<argument><expr><name>mem_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mem</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_mm_functions</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_config</name></name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>event_set_mem_functions</name><argument_list>(<argument><expr><name>dummy_malloc</name></expr></argument>, <argument><expr><name>dummy_realloc</name></expr></argument>, <argument><expr><name>dummy_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_config_avoid_method</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><literal type="string">"Nonesuch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>check_dummy_mem_ok</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>many_event_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>calledp</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>calledp</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_many_events</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MANY</name></cpp:macro> <cpp:value>70</cpp:value></cpp:define>

<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>one_at_a_time</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name><name>sock</name><index>[<expr><name>MANY</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name><name>ev</name><index>[<expr><name>MANY</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>called</name><index>[<expr><name>MANY</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loopflags</name> <init>= <expr><name>EVLOOP_NONBLOCK</name></expr></init></decl>, <decl><type ref="prev"/><name>evflags</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>one_at_a_time</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>loopflags</name> <operator>|=</operator> <name>EVLOOP_ONCE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>evflags</name> <operator>=</operator> <name>EV_PERSIST</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>called</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>called</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MANY</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>



<expr_stmt><expr><name><name>sock</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name><name>sock</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>called</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>sock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name><operator>|</operator><name>evflags</name></expr></argument>,
<argument><expr><name>many_event_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>called</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>one_at_a_time</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>EVLOOP_NONBLOCK</name><operator>|</operator><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>loopflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MANY</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>one_at_a_time</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>called</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>MANY</name> <operator>-</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>called</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

<label><name>end</name>:</label>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MANY</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sock</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evutil_closesocket</name><argument_list>(<argument><expr><name><name>sock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MANY</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_struct_event_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>event_get_struct_event_size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&lt;=</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>event</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_get_assignment</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><literal type="string">"foo"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>what</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>event_callback_fn</name></type> <name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>dummy_read_cb</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_get_assignment</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>what</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>dummy_read_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name>cb_arg</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_get_assignment</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ev1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<struct>struct <name>foreach_helper</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>foreach_count_cb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>foreach_helper</name></name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>event_get_callback_arg</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_get_callback</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>timeout_cb</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><call><name>event_get_base</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name><name>tv</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>ev</name></name> <operator>=</operator> <name>ev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>end</name>:</label>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>foreach_find_cb</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ev_out</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>foreach_helper</name></name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>event_get_callback_arg</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>event_get_callback</name><argument_list>(<argument><expr><name>ev</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>timeout_cb</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">99</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ev_out</name> <operator>=</operator> <name>ev</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">101</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_event_foreach</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name><name>ev</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>foreach_helper</name></name></type> <name><name>visited</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>ten_sec</name> <init>= <expr><block>{<expr><literal type="number">10</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev_found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>visited</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>visited</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>timeout_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>visited</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_foreach_event</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>foreach_count_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_foreach_event</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ten_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ten_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ten_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_foreach_event</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>foreach_count_cb</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ten_sec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>visited</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>ev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>visited</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">99</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">101</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_foreach_event</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>foreach_find_cb</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ev_found</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_ptr_op</name><argument_list>(<argument><expr><name>ev_found</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>ev</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name><name>ev</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>cached_time_base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_time_reset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cached_time_sleep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cache_time_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_gettimeofday_cached</name><argument_list>(<argument><expr><name>cached_time_base</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cached_time_sleep</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>delay</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">30</literal><operator>*</operator><literal type="number">1000</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>evutil_usleep_</name><argument_list>(<argument><expr><operator>&amp;</operator><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cached_time_reset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_base_update_cache_time</name><argument_list>(<argument><expr><name>cached_time_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>end</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_gettimeofday_cached</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_config</name></name> <modifier>*</modifier></type><name>cfg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv1</name></decl>, <decl><type ref="prev"/><name>tv2</name></decl>, <decl><type ref="prev"/><name>tv3</name></decl>, <decl><type ref="prev"/><name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev1</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev2</name><init>=<expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev3</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cached_time_disable</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr></argument>, <argument><expr><literal type="string">"disable"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cfg</name> <operator>=</operator> <call><name>event_config_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cached_time_disable</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>event_config_set_flag</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>EVENT_BASE_FLAG_NO_CACHE_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cached_time_base</name> <operator>=</operator> <name>base</name> <operator>=</operator> <call><name>event_base_new_with_config</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>evutil_gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_gettimeofday_cached</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><call><name>event_base_gettimeofday_cached</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cached_time_reset</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr></argument>, <argument><expr><literal type="string">"reset"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cached_time_sleep</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>setup_data</name></name></expr></argument>, <argument><expr><literal type="string">"sleep"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cache_time_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cache_time_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev3</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cache_time_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_active</name><argument_list>(<argument><expr><name>ev3</name></expr></argument>, <argument><expr><name>EV_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_dispatch</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cached_time_reset</name> <operator>&amp;&amp;</operator> <name>cached_time_sleep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>labs</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>labs</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tv3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cached_time_disable</name> <operator>&amp;&amp;</operator> <name>cached_time_sleep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>labs</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><call><name>labs</name><argument_list>(<argument><expr><call><name>timeval_msec_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>tv3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator> <name>cached_time_disable</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>evutil_timercmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><call><name>evutil_timercmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv3</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ev1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_base_free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cfg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_config_free</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tabf_cb</name><parameter_list>(<parameter><decl><type><name>evutil_socket_t</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>what</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>+=</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_active_by_fd</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>basic_test_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>base</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>ev1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev3</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ev4</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>e1</name></decl>,<decl><type ref="prev"/><name>e2</name></decl>,<decl><type ref="prev"/><name>e3</name></decl>,<decl><type ref="prev"/><name>e4</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>event</name></name> <modifier>*</modifier></type><name>evsig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>es</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tenmin</name> <init>= <expr><block>{ <expr><literal type="number">600</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>event_base_active_by_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_base_active_by_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_base_active_by_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_active_by_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e1</name> <operator>=</operator> <name>e2</name> <operator>=</operator> <name>e3</name> <operator>=</operator> <name>e4</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ev1</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>tabf_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev2</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>, <argument><expr><name>tabf_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev3</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>tabf_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ev4</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>tabf_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ev3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>ev4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>evsig</name> <operator>=</operator> <call><name>event_new</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>EV_SIGNAL</name></expr></argument>, <argument><expr><name>tabf_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_assert</name><argument_list>(<argument><expr><name>evsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>evsig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tenmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tenmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev3</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_add</name><argument_list>(<argument><expr><name>ev4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tenmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>event_base_active_by_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>event_base_active_by_fd</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>event_base_active_by_signal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>event_base_assert_ok_</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>event_base_loop</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>EVLOOP_ONCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_WRITE</name> <operator>|</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>e3</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name> <operator>|</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><operator>(</operator><name>e4</name> <operator>&amp;</operator> <operator>~</operator><name>EV_WRITE</name><operator>)</operator></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_READ</name> <operator>|</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>tt_int_op</name><argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>EV_SIGNAL</name> <operator>|</operator> <literal type="number">0x10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>end</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ev1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ev4</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>ev4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>evsig</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>event_free</name><argument_list>(<argument><expr><name>evsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>struct</name> <name>testcase_t</name></name></type> <name><name>main_testcases</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="string">"methods"</literal></expr>, <expr><name>test_methods</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"version"</literal></expr>, <expr><name>test_version</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>base_features</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NO_LOGS</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"base_environ"</literal></expr>, <expr><name>test_base_environ</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_base_new</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>free_active_base</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>manipulate_active_events</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_new_selfarg</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_assign_selfarg</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_base_get_num_events</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_base_get_max_events</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>bad_assign</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NO_LOGS</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>bad_reentrant</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NO_LOGS</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>active_later</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_remove_timeout</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,


<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>persistent_timeout</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"persistent_timeout_jump"</literal></expr>, <expr><name>test_persistent_timeout_jump</name></expr>, <expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"persistent_active_timeout"</literal></expr>, <expr><name>test_persistent_active_timeout</name></expr>,
<expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>priorities</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>priority_active_inversion</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"common_timeout"</literal></expr>, <expr><name>test_common_timeout</name></expr>, <expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr>,
<expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,


<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simpleread</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simpleread_multiple</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simplewrite</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"simpleclose"</literal></expr>, <expr><name>test_simpleclose</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<expr><name>NULL</name></expr> }</block></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>multiple</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>persistent</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>combined</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simpletimeout</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>loopbreak</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>loopexit</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>loopexit_multiple</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>nonpersist_readd</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>multiple_events_for_same_fd</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>want_only_once</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"event_once"</literal></expr>, <expr><name>test_event_once</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"event_once_never"</literal></expr>, <expr><name>test_event_once_never</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"event_pending"</literal></expr>, <expr><name>test_event_pending</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"event_closed_fd_poll"</literal></expr>, <expr><name>test_event_closed_fd_poll</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>,
<expr><name>NULL</name></expr> }</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><literal type="string">"dup_fd"</literal></expr>, <expr><name>test_dup_fd</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{ <expr><literal type="string">"mm_functions"</literal></expr>, <expr><name>test_mm_functions</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"many_events"</literal></expr>, <expr><name>test_many_events</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"many_events_slow_add"</literal></expr>, <expr><name>test_many_events</name></expr>, <expr><name>TT_ISOLATED</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="string">"struct_event_size"</literal></expr>, <expr><name>test_struct_event_size</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>get_assignment</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>event_foreach</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name></expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><literal type="string">"gettimeofday_cached"</literal></expr>, <expr><name>test_gettimeofday_cached</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gettimeofday_cached_sleep"</literal></expr>, <expr><name>test_gettimeofday_cached</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">"sleep"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gettimeofday_cached_reset"</literal></expr>, <expr><name>test_gettimeofday_cached</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">"sleep reset"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gettimeofday_cached_disabled"</literal></expr>, <expr><name>test_gettimeofday_cached</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">"sleep disable"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"gettimeofday_cached_disabled_nosleep"</literal></expr>, <expr><name>test_gettimeofday_cached</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><operator>&amp;</operator><name>basic_setup</name></expr>, <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="string">"disable"</literal></expr> }</block></expr>,

<expr><call><name>BASIC</name><argument_list>(<argument><expr><name>active_by_fd</name></expr></argument>, <argument><expr><name>TT_FORK</name><operator>|</operator><name>TT_NEED_BASE</name><operator>|</operator><name>TT_NEED_SOCKETPAIR</name></expr></argument>)</argument_list></call></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>fork</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_PTHREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>del_wait</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name><operator>|</operator><name>TT_NEED_THREADS</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>END_OF_TESTCASES</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>testcase_t</name></name></type> <name><name>evtag_testcases</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"int"</literal></expr>, <expr><name>evtag_int_test</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"fuzz"</literal></expr>, <expr><name>evtag_fuzz</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"encoding"</literal></expr>, <expr><name>evtag_tag_encoding</name></expr>, <expr><name>TT_FORK</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"peek"</literal></expr>, <expr><name>evtag_test_peek</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><name>END_OF_TESTCASES</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>testcase_t</name></name></type> <name><name>signal_testcases</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simplestsignal</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>simplesignal</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>multiplesignal</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>immediatesignal</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_dealloc</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_pipeloss</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_switchbase</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name><operator>|</operator><name>TT_NO_LOGS</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_restore</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_assert</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LEGACY</name><argument_list>(<argument><expr><name>signal_while_processing</name></expr></argument>, <argument><expr><name>TT_ISOLATED</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><name>END_OF_TESTCASES</name></expr>
}</block></expr></init></decl>;</decl_stmt>

</unit>
