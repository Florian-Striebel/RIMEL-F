<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libevent/test/regress.h">

























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>REGRESS_H_INCLUDED_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGRESS_H_INCLUDED_</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tinytest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tinytest_macros.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>main_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>evtag_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>evbuffer_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>finalize_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>bufferevent_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>bufferevent_iocp_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>util_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>signal_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>http_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>dns_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>rpc_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>edgetriggered_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>minheap_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>iocp_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>ssl_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>listener_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>listener_iocp_testcases</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>testcase_t</name></name></type> <name><name>thread_testcases</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>evutil_weakrand_state</name></name></type> <name>test_weakrand_state</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>test_weakrand</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(evutil_weakrand_(&amp;test_weakrand_state))</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>regress_threads</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>test_bufferevent_zlib</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>extern</specifier> <name>evutil_socket_t</name></type> <name><name>pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>test_ok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>called</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>global_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>in_legacy_test_wrapper</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> <name>regress_make_tmpfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datalen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename_out</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>basic_test_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>event_base</name></name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>evutil_socket_t</name></type> <name><name>pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>legacy_test_fn</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>setup_data</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>testcase_setup_t</name></name></type> <name>basic_setup</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>testcase_setup_t</name></name></type> <name>legacy_setup</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>run_legacy_test_fn</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>libevent_tests_running_in_debug_mode</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_NEED_SOCKETPAIR</name></cpp:macro> <cpp:value>TT_FIRST_USER_FLAG</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_NEED_BASE</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_NEED_DNS</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_LEGACY</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_NEED_THREADS</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_NO_LOGS</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_ENABLE_IOCP_FLAG</name></cpp:macro> <cpp:value>(TT_FIRST_USER_FLAG&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_ENABLE_IOCP</name></cpp:macro> <cpp:value>(TT_ENABLE_IOCP_FLAG|TT_NEED_THREADS)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TT_ISOLATED</name></cpp:macro> <cpp:value>TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASIC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #name, test_##name, flags, &amp;basic_setup, NULL }</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEGACY</name><parameter_list>(<parameter><type><name>name</name></type></parameter>,<parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #name, run_legacy_test_fn, flags|TT_LEGACY, &amp;legacy_setup, test_##name }</cpp:value></cpp:define>



<struct_decl>struct <name>evutil_addrinfo</name>;</struct_decl>
<function_decl><type><name><name>struct</name> <name>evutil_addrinfo</name></name> <modifier>*</modifier></type><name>ai_find_by_family</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evutil_addrinfo</name></name> <modifier>*</modifier></type><name>ai</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>evutil_addrinfo</name></name> <modifier>*</modifier></type><name>ai_find_by_protocol</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>evutil_addrinfo</name></name> <modifier>*</modifier></type><name>ai</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>test_ai_eq_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>evutil_addrinfo</name></name> <modifier>*</modifier></type><name>ai</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sockaddr_port</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>socktype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>protocol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>test_ai_eq</name><parameter_list>(<parameter><type><name>ai</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>s</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (test_ai_eq_((ai), (str), (s), (p), __LINE__)&lt;0) goto end; } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>test_timeval_diff_leq</name><parameter_list>(<parameter><type><name>tv1</name></type></parameter>, <parameter><type><name>tv2</name></type></parameter>, <parameter><type><name>diff</name></type></parameter>, <parameter><type><name>tolerance</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>tt_int_op(labs(timeval_msec_diff((tv1), (tv2)) - diff), &lt;=, tolerance)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>test_timeval_diff_eq</name><parameter_list>(<parameter><type><name>tv1</name></type></parameter>, <parameter><type><name>tv2</name></type></parameter>, <parameter><type><name>diff</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>test_timeval_diff_leq((tv1), (tv2), (diff), 50)</cpp:value></cpp:define>


<function_decl><type><name>long</name></type> <name>timeval_msec_diff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>pid_t</name></type> <name>regress_fork</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVENT__HAVE_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<function_decl><type><name>EVP_PKEY</name> <modifier>*</modifier></type><name>ssl_getkey</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>X509</name> <modifier>*</modifier></type><name>ssl_getcert</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>get_ssl_ctx</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>init_ssl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
