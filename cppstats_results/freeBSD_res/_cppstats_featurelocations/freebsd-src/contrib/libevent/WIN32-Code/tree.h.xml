<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libevent/WIN32-Code/tree.h">

























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_SYS_TREE_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_SYS_TREE_H_</name></cpp:macro></cpp:define>




























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_HEAD</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct name { struct type *sph_root; }</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_INITIALIZER</name><parameter_list>(<parameter><type><name>root</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ NULL }</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_INIT</name><parameter_list>(<parameter><type><name>root</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (root)-&gt;sph_root = NULL; } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_ENTRY</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { struct type *spe_left; struct type *spe_right; }</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_LEFT</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.spe_left</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_RIGHT</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.spe_right</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_ROOT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(head)-&gt;sph_root</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_EMPTY</name><parameter_list>(<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SPLAY_ROOT(head) == NULL)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_ROTATE_RIGHT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { SPLAY_LEFT((head)-&gt;sph_root, field) = SPLAY_RIGHT(tmp, field); SPLAY_RIGHT(tmp, field) = (head)-&gt;sph_root; (head)-&gt;sph_root = tmp; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_ROTATE_LEFT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { SPLAY_RIGHT((head)-&gt;sph_root, field) = SPLAY_LEFT(tmp, field); SPLAY_LEFT(tmp, field) = (head)-&gt;sph_root; (head)-&gt;sph_root = tmp; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_LINKLEFT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { SPLAY_LEFT(tmp, field) = (head)-&gt;sph_root; tmp = (head)-&gt;sph_root; (head)-&gt;sph_root = SPLAY_LEFT((head)-&gt;sph_root, field); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_LINKRIGHT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { SPLAY_RIGHT(tmp, field) = (head)-&gt;sph_root; tmp = (head)-&gt;sph_root; (head)-&gt;sph_root = SPLAY_RIGHT((head)-&gt;sph_root, field); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_ASSEMBLE</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>left</name></type></parameter>, <parameter><type><name>right</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)-&gt;sph_root, field); SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)-&gt;sph_root, field);SPLAY_LEFT((head)-&gt;sph_root, field) = SPLAY_RIGHT(node, field); SPLAY_RIGHT((head)-&gt;sph_root, field) = SPLAY_LEFT(node, field); } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_PROTOTYPE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>field</name></type></parameter>, <parameter><type><name>cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void name##_SPLAY(struct name *, struct type *); void name##_SPLAY_MINMAX(struct name *, int); struct type *name##_SPLAY_INSERT(struct name *, struct type *); struct type *name##_SPLAY_REMOVE(struct name *, struct type *); static __inline struct type * name##_SPLAY_FIND(struct name *head, struct type *elm) { if (SPLAY_EMPTY(head)) return(NULL); name##_SPLAY(head, elm); if ((cmp)(elm, (head)-&gt;sph_root) == 0) return (head-&gt;sph_root); return (NULL); } static __inline struct type * name##_SPLAY_NEXT(struct name *head, struct type *elm) { name##_SPLAY(head, elm); if (SPLAY_RIGHT(elm, field) != NULL) { elm = SPLAY_RIGHT(elm, field); while (SPLAY_LEFT(elm, field) != NULL) { elm = SPLAY_LEFT(elm, field); } } else elm = NULL; return (elm); } static __inline struct type * name##_SPLAY_MIN_MAX(struct name *head, int val) { name##_SPLAY_MINMAX(head, val); return (SPLAY_ROOT(head)); }</cpp:value></cpp:define>









































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_GENERATE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>field</name></type></parameter>, <parameter><type><name>cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct type * name##_SPLAY_INSERT(struct name *head, struct type *elm) { if (SPLAY_EMPTY(head)) { SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL; } else { int __comp; name##_SPLAY(head, elm); __comp = (cmp)(elm, (head)-&gt;sph_root); if(__comp &lt; 0) { SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)-&gt;sph_root, field);SPLAY_RIGHT(elm, field) = (head)-&gt;sph_root; SPLAY_LEFT((head)-&gt;sph_root, field) = NULL; } else if (__comp &gt; 0) { SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)-&gt;sph_root, field);SPLAY_LEFT(elm, field) = (head)-&gt;sph_root; SPLAY_RIGHT((head)-&gt;sph_root, field) = NULL; } else return ((head)-&gt;sph_root); } (head)-&gt;sph_root = (elm); return (NULL); } struct type * name##_SPLAY_REMOVE(struct name *head, struct type *elm) { struct type *__tmp; if (SPLAY_EMPTY(head)) return (NULL); name##_SPLAY(head, elm); if ((cmp)(elm, (head)-&gt;sph_root) == 0) { if (SPLAY_LEFT((head)-&gt;sph_root, field) == NULL) { (head)-&gt;sph_root = SPLAY_RIGHT((head)-&gt;sph_root, field);} else { __tmp = SPLAY_RIGHT((head)-&gt;sph_root, field); (head)-&gt;sph_root = SPLAY_LEFT((head)-&gt;sph_root, field);name##_SPLAY(head, elm); SPLAY_RIGHT((head)-&gt;sph_root, field) = __tmp; } return (elm); } return (NULL); } void name##_SPLAY(struct name *head, struct type *elm) { struct type __node, *__left, *__right, *__tmp; int __comp; SPLAY_LEFT(&amp;__node, field) = SPLAY_RIGHT(&amp;__node, field) = NULL;__left = __right = &amp;__node; while ((__comp = (cmp)(elm, (head)-&gt;sph_root))) { if (__comp &lt; 0) { __tmp = SPLAY_LEFT((head)-&gt;sph_root, field); if (__tmp == NULL) break; if ((cmp)(elm, __tmp) &lt; 0){ SPLAY_ROTATE_RIGHT(head, __tmp, field); if (SPLAY_LEFT((head)-&gt;sph_root, field) == NULL)break; } SPLAY_LINKLEFT(head, __right, field); } else if (__comp &gt; 0) { __tmp = SPLAY_RIGHT((head)-&gt;sph_root, field); if (__tmp == NULL) break; if ((cmp)(elm, __tmp) &gt; 0){ SPLAY_ROTATE_LEFT(head, __tmp, field); if (SPLAY_RIGHT((head)-&gt;sph_root, field) == NULL)break; } SPLAY_LINKRIGHT(head, __left, field); } } SPLAY_ASSEMBLE(head, &amp;__node, __left, __right, field); } void name##_SPLAY_MINMAX(struct name *head, int __comp) { struct type __node, *__left, *__right, *__tmp; SPLAY_LEFT(&amp;__node, field) = SPLAY_RIGHT(&amp;__node, field) = NULL;__left = __right = &amp;__node; while (1) { if (__comp &lt; 0) { __tmp = SPLAY_LEFT((head)-&gt;sph_root, field); if (__tmp == NULL) break; if (__comp &lt; 0){ SPLAY_ROTATE_RIGHT(head, __tmp, field); if (SPLAY_LEFT((head)-&gt;sph_root, field) == NULL)break; } SPLAY_LINKLEFT(head, __right, field); } else if (__comp &gt; 0) { __tmp = SPLAY_RIGHT((head)-&gt;sph_root, field); if (__tmp == NULL) break; if (__comp &gt; 0) { SPLAY_ROTATE_LEFT(head, __tmp, field); if (SPLAY_RIGHT((head)-&gt;sph_root, field) == NULL)break; } SPLAY_LINKRIGHT(head, __left, field); } } SPLAY_ASSEMBLE(head, &amp;__node, __left, __right, field); }</cpp:value></cpp:define>




















































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_NEGINF</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_INF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_INSERT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_SPLAY_INSERT(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_REMOVE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_SPLAY_REMOVE(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_FIND</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_SPLAY_FIND(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_NEXT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_SPLAY_NEXT(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_MIN</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SPLAY_EMPTY(x) ? NULL : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_MAX</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SPLAY_EMPTY(x) ? NULL : name##_SPLAY_MIN_MAX(x, SPLAY_INF))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLAY_FOREACH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for ((x) = SPLAY_MIN(name, head); (x) != NULL; (x) = SPLAY_NEXT(name, head, x))</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_HEAD</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct name { struct type *rbh_root; }</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_INITIALIZER</name><parameter_list>(<parameter><type><name>root</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ NULL }</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_INIT</name><parameter_list>(<parameter><type><name>root</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (root)-&gt;rbh_root = NULL; } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_BLACK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_RED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ENTRY</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>struct { struct type *rbe_left; struct type *rbe_right; struct type *rbe_parent; int rbe_color; }</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_LEFT</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.rbe_left</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_RIGHT</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.rbe_right</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_PARENT</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.rbe_parent</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_COLOR</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(elm)-&gt;field.rbe_color</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ROOT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(head)-&gt;rbh_root</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_EMPTY</name><parameter_list>(<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RB_ROOT(head) == NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_SET</name><parameter_list>(<parameter><type><name>elm</name></type></parameter>, <parameter><type><name>parent</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { RB_PARENT(elm, field) = parent; RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL; RB_COLOR(elm, field) = RB_RED; } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_SET_BLACKRED</name><parameter_list>(<parameter><type><name>black</name></type></parameter>, <parameter><type><name>red</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { RB_COLOR(black, field) = RB_BLACK; RB_COLOR(red, field) = RB_RED; } while (0)</cpp:value></cpp:define>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RB_AUGMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_AUGMENT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ROTATE_LEFT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>elm</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (tmp) = RB_RIGHT(elm, field); if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) { RB_PARENT(RB_LEFT(tmp, field), field) = (elm); } RB_AUGMENT(elm); if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) { if ((elm) == RB_LEFT(RB_PARENT(elm, field), field)) RB_LEFT(RB_PARENT(elm, field), field) = (tmp); else RB_RIGHT(RB_PARENT(elm, field), field) = (tmp); } else (head)-&gt;rbh_root = (tmp); RB_LEFT(tmp, field) = (elm); RB_PARENT(elm, field) = (tmp); RB_AUGMENT(tmp); if ((RB_PARENT(tmp, field))) RB_AUGMENT(RB_PARENT(tmp, field)); } while (0)</cpp:value></cpp:define>



















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_ROTATE_RIGHT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>, <parameter><type><name>elm</name></type></parameter>, <parameter><type><name>tmp</name></type></parameter>, <parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (tmp) = RB_LEFT(elm, field); if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) { RB_PARENT(RB_RIGHT(tmp, field), field) = (elm); } RB_AUGMENT(elm); if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) { if ((elm) == RB_LEFT(RB_PARENT(elm, field), field)) RB_LEFT(RB_PARENT(elm, field), field) = (tmp); else RB_RIGHT(RB_PARENT(elm, field), field) = (tmp); } else (head)-&gt;rbh_root = (tmp); RB_RIGHT(tmp, field) = (elm); RB_PARENT(elm, field) = (tmp); RB_AUGMENT(tmp); if ((RB_PARENT(tmp, field))) RB_AUGMENT(RB_PARENT(tmp, field)); } while (0)</cpp:value></cpp:define>




















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_PROTOTYPE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>field</name></type></parameter>, <parameter><type><name>cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void name##_RB_INSERT_COLOR(struct name *, struct type *); void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);struct type *name##_RB_REMOVE(struct name *, struct type *); struct type *name##_RB_INSERT(struct name *, struct type *); struct type *name##_RB_FIND(struct name *, struct type *); struct type *name##_RB_NEXT(struct type *); struct type *name##_RB_MINMAX(struct name *, int);</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_GENERATE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>field</name></type></parameter>, <parameter><type><name>cmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void name##_RB_INSERT_COLOR(struct name *head, struct type *elm) { struct type *parent, *gparent, *tmp; while ((parent = RB_PARENT(elm, field)) &amp;&amp; RB_COLOR(parent, field) == RB_RED) { gparent = RB_PARENT(parent, field); if (parent == RB_LEFT(gparent, field)) { tmp = RB_RIGHT(gparent, field); if (tmp &amp;&amp; RB_COLOR(tmp, field) == RB_RED) { RB_COLOR(tmp, field) = RB_BLACK; RB_SET_BLACKRED(parent, gparent, field);elm = gparent; continue; } if (RB_RIGHT(parent, field) == elm) { RB_ROTATE_LEFT(head, parent, tmp, field);tmp = parent; parent = elm; elm = tmp; } RB_SET_BLACKRED(parent, gparent, field); RB_ROTATE_RIGHT(head, gparent, tmp, field); } else { tmp = RB_LEFT(gparent, field); if (tmp &amp;&amp; RB_COLOR(tmp, field) == RB_RED) { RB_COLOR(tmp, field) = RB_BLACK; RB_SET_BLACKRED(parent, gparent, field);elm = gparent; continue; } if (RB_LEFT(parent, field) == elm) { RB_ROTATE_RIGHT(head, parent, tmp, field);tmp = parent; parent = elm; elm = tmp; } RB_SET_BLACKRED(parent, gparent, field); RB_ROTATE_LEFT(head, gparent, tmp, field); } } RB_COLOR(head-&gt;rbh_root, field) = RB_BLACK; } void name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) { struct type *tmp; while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &amp;&amp; elm != RB_ROOT(head)) { if (RB_LEFT(parent, field) == elm) { tmp = RB_RIGHT(parent, field); if (RB_COLOR(tmp, field) == RB_RED) { RB_SET_BLACKRED(tmp, parent, field); RB_ROTATE_LEFT(head, parent, tmp, field);tmp = RB_RIGHT(parent, field); } if ((RB_LEFT(tmp, field) == NULL || RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &amp;&amp;(RB_RIGHT(tmp, field) == NULL || RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {RB_COLOR(tmp, field) = RB_RED; elm = parent; parent = RB_PARENT(elm, field); } else { if (RB_RIGHT(tmp, field) == NULL || RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {struct type *oleft; if ((oleft = RB_LEFT(tmp, field)))RB_COLOR(oleft, field) = RB_BLACK;RB_COLOR(tmp, field) = RB_RED; RB_ROTATE_RIGHT(head, tmp, oleft, field);tmp = RB_RIGHT(parent, field); } RB_COLOR(tmp, field) = RB_COLOR(parent, field);RB_COLOR(parent, field) = RB_BLACK; if (RB_RIGHT(tmp, field)) RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;RB_ROTATE_LEFT(head, parent, tmp, field);elm = RB_ROOT(head); break; } } else { tmp = RB_LEFT(parent, field); if (RB_COLOR(tmp, field) == RB_RED) { RB_SET_BLACKRED(tmp, parent, field); RB_ROTATE_RIGHT(head, parent, tmp, field);tmp = RB_LEFT(parent, field); } if ((RB_LEFT(tmp, field) == NULL || RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &amp;&amp;(RB_RIGHT(tmp, field) == NULL || RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {RB_COLOR(tmp, field) = RB_RED; elm = parent; parent = RB_PARENT(elm, field); } else { if (RB_LEFT(tmp, field) == NULL || RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {struct type *oright; if ((oright = RB_RIGHT(tmp, field)))RB_COLOR(oright, field) = RB_BLACK;RB_COLOR(tmp, field) = RB_RED; RB_ROTATE_LEFT(head, tmp, oright, field);tmp = RB_LEFT(parent, field); } RB_COLOR(tmp, field) = RB_COLOR(parent, field);RB_COLOR(parent, field) = RB_BLACK; if (RB_LEFT(tmp, field)) RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;RB_ROTATE_RIGHT(head, parent, tmp, field);elm = RB_ROOT(head); break; } } } if (elm) RB_COLOR(elm, field) = RB_BLACK; } struct type * name##_RB_REMOVE(struct name *head, struct type *elm) { struct type *child, *parent, *old = elm; int color; if (RB_LEFT(elm, field) == NULL) child = RB_RIGHT(elm, field); else if (RB_RIGHT(elm, field) == NULL) child = RB_LEFT(elm, field); else { struct type *left; elm = RB_RIGHT(elm, field); while ((left = RB_LEFT(elm, field))) elm = left; child = RB_RIGHT(elm, field); parent = RB_PARENT(elm, field); color = RB_COLOR(elm, field); if (child) RB_PARENT(child, field) = parent; if (parent) { if (RB_LEFT(parent, field) == elm) RB_LEFT(parent, field) = child; else RB_RIGHT(parent, field) = child; RB_AUGMENT(parent); } else RB_ROOT(head) = child; if (RB_PARENT(elm, field) == old) parent = elm; (elm)-&gt;field = (old)-&gt;field; if (RB_PARENT(old, field)) { if (RB_LEFT(RB_PARENT(old, field), field) == old)RB_LEFT(RB_PARENT(old, field), field) = elm;else RB_RIGHT(RB_PARENT(old, field), field) = elm;RB_AUGMENT(RB_PARENT(old, field)); } else RB_ROOT(head) = elm; RB_PARENT(RB_LEFT(old, field), field) = elm; if (RB_RIGHT(old, field)) RB_PARENT(RB_RIGHT(old, field), field) = elm; if (parent) { left = parent; do { RB_AUGMENT(left); } while ((left = RB_PARENT(left, field))); } goto color; } parent = RB_PARENT(elm, field); color = RB_COLOR(elm, field); if (child) RB_PARENT(child, field) = parent; if (parent) { if (RB_LEFT(parent, field) == elm) RB_LEFT(parent, field) = child; else RB_RIGHT(parent, field) = child; RB_AUGMENT(parent); } else RB_ROOT(head) = child; color: if (color == RB_BLACK) name##_RB_REMOVE_COLOR(head, parent, child); return (old); } struct type * name##_RB_INSERT(struct name *head, struct type *elm) { struct type *tmp; struct type *parent = NULL; int comp = 0; tmp = RB_ROOT(head); while (tmp) { parent = tmp; comp = (cmp)(elm, parent); if (comp &lt; 0) tmp = RB_LEFT(tmp, field); else if (comp &gt; 0) tmp = RB_RIGHT(tmp, field); else return (tmp); } RB_SET(elm, parent, field); if (parent != NULL) { if (comp &lt; 0) RB_LEFT(parent, field) = elm; else RB_RIGHT(parent, field) = elm; RB_AUGMENT(parent); } else RB_ROOT(head) = elm; name##_RB_INSERT_COLOR(head, elm); return (NULL); } struct type * name##_RB_FIND(struct name *head, struct type *elm) { struct type *tmp = RB_ROOT(head); int comp; while (tmp) { comp = cmp(elm, tmp); if (comp &lt; 0) tmp = RB_LEFT(tmp, field); else if (comp &gt; 0) tmp = RB_RIGHT(tmp, field); else return (tmp); } return (NULL); } struct type * name##_RB_NEXT(struct type *elm) { if (RB_RIGHT(elm, field)) { elm = RB_RIGHT(elm, field); while (RB_LEFT(elm, field)) elm = RB_LEFT(elm, field); } else { if (RB_PARENT(elm, field) &amp;&amp; (elm == RB_LEFT(RB_PARENT(elm, field), field))) elm = RB_PARENT(elm, field); else { while (RB_PARENT(elm, field) &amp;&amp; (elm == RB_RIGHT(RB_PARENT(elm, field), field)))elm = RB_PARENT(elm, field); elm = RB_PARENT(elm, field); } } return (elm); } struct type * name##_RB_MINMAX(struct name *head, int val) { struct type *tmp = RB_ROOT(head); struct type *parent = NULL; while (tmp) { parent = tmp; if (val &lt; 0) tmp = RB_LEFT(tmp, field); else tmp = RB_RIGHT(tmp, field); } return (parent); }</cpp:value></cpp:define>
















































































































































































































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_NEGINF</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_INF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_INSERT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_INSERT(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_REMOVE</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_REMOVE(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_FIND</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_FIND(x, y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_NEXT</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_NEXT(y)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_MIN</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_MINMAX(x, RB_NEGINF)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_MAX</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name##_RB_MINMAX(x, RB_INF)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_FOREACH</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for ((x) = RB_MIN(name, head); (x) != NULL; (x) = name##_RB_NEXT(x))</cpp:value></cpp:define>




<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
