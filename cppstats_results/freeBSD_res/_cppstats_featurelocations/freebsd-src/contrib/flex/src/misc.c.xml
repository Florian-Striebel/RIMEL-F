<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/flex/src/misc.c">































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"flexdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tables.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_TABLES_SER</name></cpp:macro> <cpp:value>"%if-tables-serialization"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_TABLES_YYDMAP</name></cpp:macro> <cpp:value>"%tables-yydmap"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_DEFINE_YYTABLES</name></cpp:macro> <cpp:value>"%define-yytables"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_CPP_ONLY</name></cpp:macro> <cpp:value>"%if-c++-only"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_C_ONLY</name></cpp:macro> <cpp:value>"%if-c-only"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_C_OR_CPP</name></cpp:macro> <cpp:value>"%if-c-or-c++"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_NOT_FOR_HEADER</name></cpp:macro> <cpp:value>"%not-for-header"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_OK_FOR_HEADER</name></cpp:macro> <cpp:value>"%ok-for-header"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_PUSH</name></cpp:macro> <cpp:value>"%push"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_POP</name></cpp:macro> <cpp:value>"%pop"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_REENTRANT</name></cpp:macro> <cpp:value>"%if-reentrant"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_NOT_REENTRANT</name></cpp:macro> <cpp:value>"%if-not-reentrant"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_BISON_BRIDGE</name></cpp:macro> <cpp:value>"%if-bison-bridge"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_IF_NOT_BISON_BRIDGE</name></cpp:macro> <cpp:value>"%if-not-bison-bridge"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_ENDIF</name></cpp:macro> <cpp:value>"%endif"</cpp:value></cpp:define>


<struct>struct <name>sko_state</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>dc</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>sko_state</name></name> <modifier>*</modifier></type><name>sko_stack</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sko_len</name><init>=<expr><literal type="number">0</literal></expr></init></decl>,<decl><type ref="prev"/><name>sko_sz</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sko_push</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>dc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sko_stack</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>sko_sz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sko_stack</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sko_state</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>sko_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sko_stack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"allocation of sko_stack failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sko_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>sko_len</name> <operator>&gt;=</operator> <name>sko_sz</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name>sko_sz</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sko_stack</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>sko_stack</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sko_state</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>sko_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sko_stack</name><index>[<expr><name>sko_len</name></expr>]</index></name><operator>.</operator><name>dc</name> <operator>=</operator> <name>dc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sko_len</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sko_peek</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>sko_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flex_die</name><argument_list>(<argument><expr><literal type="string">"peek attempt when sko stack is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>dc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>dc</name> <operator>=</operator> <name><name>sko_stack</name><index>[<expr><name>sko_len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>dc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sko_pop</name><parameter_list>(<parameter><decl><type><name>bool</name><modifier>*</modifier></type> <name>dc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>sko_peek</name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sko_len</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>sko_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flex_die</name><argument_list>(<argument><expr><literal type="string">"popped too many times in skeleton."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>action_define</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>defname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXLINE</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>format_pinpoint_message</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"name \"%s\" ridiculously long"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"#define %s %d\n"</literal></expr></argument>, <argument><expr><name>defname</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_action</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>cpy</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>buf_append</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>defs_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>add_action</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>new_text</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name> <operator>+</operator> <name>action_index</name> <operator>&gt;=</operator> <name>action_size</name> <operator>-</operator> <literal type="number">10</literal></expr> )</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><name>action_size</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name>action_size</name> <operator>+=</operator> <name>action_size</name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>action_size</name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>action_array</name> <operator>=</operator>
<call><name>reallocate_character_array</name> <argument_list>(<argument><expr><name>action_array</name></expr></argument>,
<argument><expr><name>action_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>action_array</name><index>[<expr><name>action_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>new_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>action_index</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name> <modifier>*</modifier></type><name>allocate_array</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>element_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_REALLOCARRAY</name></expr></cpp:if>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>reallocarray</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name></expr></argument>, <argument><expr><name>element_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bytes</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name> <operator>*</operator> <name>element_size</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>size</name> <operator>&amp;&amp;</operator> <name>SIZE_MAX</name> <operator>/</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name> <operator>&lt;</operator> <name>element_size</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
<expr><call><name>malloc</name><argument_list>(<argument><expr><name>num_bytes</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"memory allocation failed in allocate_array()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>mem</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>all_lower</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isascii</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>islower</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>all_upper</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isascii</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>isupper</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator> <name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>str</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>intcmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>-</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>check_char</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>CSIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lerr</name> <argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad character '%s' detected in check_char()"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>readable_form</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>csize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lerr</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"scanner requires -8 flag to use the character %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>readable_form</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><name>unsigned</name> <name>char</name></type> <name>clower</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><call><name>isascii</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isupper</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name>tolower</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>char</name> <modifier>*</modifier></type><name>xstrdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s2</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"memory allocation failure in xstrdup()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>s2</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>cclcmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>a</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else
if <condition>(<expr><operator>!</operator><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>-</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>dataend</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dataflush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><literal type="string">" } ;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dataline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datapos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>dataflush</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>dataline</name> <operator>&gt;=</operator> <name>NUMDATALINES</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dataline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>datapos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>flexerror</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>program_name</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flexend</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>flexfatal</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s: fatal internal error, %s\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>program_name</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FLEX_EXIT</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>lerr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>errmsg</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name> <argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flexerror</name> <argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>lerr_fatal</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>errmsg</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vsnprintf</name> <argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>line_directive_out</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>output_file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_infile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>directive</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>filename</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>line_fmt</name><index>[]</index></name> <init>= <expr><literal type="string">"#line %d \"%s\"\n"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gen_line_dirs</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <ternary><condition><expr><name>do_infile</name></expr> ?</condition><then> <expr><name>infilename</name></expr> </then><else>: <expr><literal type="string">"M4_YY_OUTFILE_NAME"</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_infile</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>s1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <literal type="string">"&lt;stdin&gt;"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s3</name> <operator>=</operator> <operator>&amp;</operator><name><name>filename</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s2</name> <operator>&lt;</operator> <name>s3</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <operator>*</operator><name>s1</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>s2</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>s2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s1</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>s2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_infile</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>directive</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>directive</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>line_fmt</name></expr></argument>, <argument><expr><name>linenum</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>directive</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>directive</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>line_fmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>output_file</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fputs</name> <argument_list>(<argument><expr><name>directive</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_action</name> <argument_list>(<argument><expr><name>directive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>mark_defs1</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>defs1_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>action_array</name><index>[<expr><name>action_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>action_offset</name> <operator>=</operator> <name>prolog_offset</name> <operator>=</operator> <name>action_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>action_array</name><index>[<expr><name>action_index</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>mark_prolog</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>action_array</name><index>[<expr><name>action_index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>action_offset</name> <operator>=</operator> <name>action_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>action_array</name><index>[<expr><name>action_index</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>mk2data</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>&gt;=</operator> <name>NUMDATAITEMS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dataflush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>out</name> <argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>datapos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_dec</name> <argument_list>(<argument><expr><literal type="string">"%5d"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>mkdata</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>&gt;=</operator> <name>NUMDATAITEMS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dataflush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>out</name> <argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>datapos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_dec</name> <argument_list>(<argument><expr><literal type="string">"%5d"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>myctoi</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sscanf</name> <argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name></type> <name>myesc</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name><name>array</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>esc_char</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>array</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<return>return <expr><literal type="char">'\b'</literal></expr>;</return>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<return>return <expr><literal type="char">'\f'</literal></expr>;</return>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<return>return <expr><literal type="char">'\n'</literal></expr>;</return>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<return>return <expr><literal type="char">'\r'</literal></expr>;</return>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<return>return <expr><literal type="char">'\t'</literal></expr>;</return>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<return>return <expr><literal type="char">'\a'</literal></expr>;</return>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<return>return <expr><literal type="char">'\v'</literal></expr>;</return>
<case>case <expr><literal type="char">'0'</literal></expr>:</case>
<case>case <expr><literal type="char">'1'</literal></expr>:</case>
<case>case <expr><literal type="char">'2'</literal></expr>:</case>
<case>case <expr><literal type="char">'3'</literal></expr>:</case>
<case>case <expr><literal type="char">'4'</literal></expr>:</case>
<case>case <expr><literal type="char">'5'</literal></expr>:</case>
<case>case <expr><literal type="char">'6'</literal></expr>:</case>
<case>case <expr><literal type="char">'7'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sptr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>sptr</name> <operator>&lt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
<name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>sptr</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>esc_char</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <call><name>strtoul</name> <argument_list>(<argument><expr><name>array</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<return>return <expr><name>esc_char</name></expr>;</return>
</block_content>}</block>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sptr</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>sptr</name> <operator>&lt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>isxdigit</name> <argument_list>(<argument><expr><name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><operator>++</operator><name>sptr</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>esc_char</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <call><name>strtoul</name> <argument_list>(<argument><expr><name>array</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><index>[<expr><name>sptr</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<return>return <expr><name>esc_char</name></expr>;</return>
</block_content>}</block>

<default>default:</default>
<return>return <expr><name><name>array</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>out</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputs</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_dec</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_dec2</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_hex</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_str</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>str</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_str3</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>s1</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>s2</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>s3</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>s3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>out_str_dec</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>str</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>,<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>outc</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputc</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>outn</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputs</name> <argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>out_m4_define</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>def</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>fmt</name> <init>= <expr><literal type="string">"m4_define( [[%s]], [[%s]])m4_dnl\n"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><ternary><condition><expr><name>val</name></expr>?</condition><then><expr><name>val</name></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>char</name> <modifier>*</modifier></type><name>readable_form</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>rform</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>||</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\b"</literal></expr>;</return>
<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\f"</literal></expr>;</return>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\n"</literal></expr>;</return>
<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\r"</literal></expr>;</return>
<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\t"</literal></expr>;</return>
<case>case <expr><literal type="char">'\a'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\a"</literal></expr>;</return>
<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
<return>return <expr><literal type="string">"\\v"</literal></expr>;</return>
<default>default:</default>
<if_stmt><if>if<condition>(<expr><name>trace_hex</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>rform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rform</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\\x%.2x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>rform</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rform</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\\%.3o"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>rform</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="string">"' '"</literal></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>
<expr_stmt><expr><name><name>rform</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rform</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>rform</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><name>void</name> <modifier>*</modifier></type><name>reallocate_array</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>element_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>new_array</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_REALLOCARRAY</name></expr></cpp:if>

<expr_stmt><expr><name>new_array</name> <operator>=</operator> <call><name>reallocarray</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name></expr></argument>, <argument><expr><name>element_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>size_t</name></type> <name>num_bytes</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name> <operator>*</operator> <name>element_size</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>new_array</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>size</name> <operator>&amp;&amp;</operator> <name>SIZE_MAX</name> <operator>/</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name> <operator>&lt;</operator> <name>element_size</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>:
<expr><call><name>realloc</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>num_bytes</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_array</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"attempt to increase array size failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>new_array</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>skelout</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf_storage</name><index>[<expr><name>MAXLINE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>buf_storage</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>do_copy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if<condition>(<expr><name>sko_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sko_peek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sko_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name><operator>=</operator><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<while>while <condition>(<expr><ternary><condition><expr><name>skelfile</name></expr> ?</condition><then>
<expr><operator>(</operator><call><name>fgets</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXLINE</name></expr></argument>, <argument><expr><name>skelfile</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> </then><else>:
<expr><operator>(</operator><operator>(</operator><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>skel</name><index>[<expr><name>skel_ind</name><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>skelfile</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>chomp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ddebug</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>out_str</name> <argument_list>(<argument><expr><literal type="string">"/* %s */\\\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>out_str</name> <argument_list>(<argument><expr><literal type="string">"/* %s */\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cmd_match</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(strncmp(buf,(s),strlen(s))==0)</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_PUSH</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>ddebug</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>out_str</name><argument_list>(<argument><expr><literal type="string">"/*(state = (%s) */"</literal></expr></argument>,<argument><expr><ternary><condition><expr><name>do_copy</name></expr>?</condition><then><expr><literal type="string">"true"</literal></expr></then><else>:<expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>out_str</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>buf</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator><literal type="char">'\\'</literal></expr> ?</condition><then> <expr><literal type="string">"\\"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_POP</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>ddebug</name></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>out_str</name><argument_list>(<argument><expr><literal type="string">"/*(state = (%s) */"</literal></expr></argument>,<argument><expr><ternary><condition><expr><name>do_copy</name></expr>?</condition><then><expr><literal type="string">"true"</literal></expr></then><else>:<expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>out_str</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>buf</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator><literal type="char">'\\'</literal></expr> ?</condition><then> <expr><literal type="string">"\\"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_REENTRANT</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <name>reentrant</name> <operator>&amp;&amp;</operator> <name>do_copy</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_NOT_REENTRANT</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <operator>!</operator><name>reentrant</name> <operator>&amp;&amp;</operator> <name>do_copy</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name><argument_list>(<argument><expr><name>CMD_IF_BISON_BRIDGE</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <name>bison_bridge_lval</name> <operator>&amp;&amp;</operator> <name>do_copy</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name><argument_list>(<argument><expr><name>CMD_IF_NOT_BISON_BRIDGE</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <operator>!</operator><name>bison_bridge_lval</name> <operator>&amp;&amp;</operator> <name>do_copy</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_ENDIF</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<expr_stmt><expr><call><name>sko_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_TABLES_SER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <name>do_copy</name> <operator>&amp;&amp;</operator> <name>tablesext</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_TABLES_YYDMAP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tablesext</name> <operator>&amp;&amp;</operator> <name><name>yydmap_buf</name><operator>.</operator><name>elts</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>yydmap_buf</name><operator>.</operator><name>elts</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_DEFINE_YYTABLES</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>out_str</name><argument_list>(<argument><expr><literal type="string">"#define YYTABLES_NAME \"%s\"\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>tablesname</name></expr>?</condition><then><expr><name>tablesname</name></expr></then><else>:<expr><literal type="string">"yytables"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_CPP_ONLY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <name>C_plus_plus</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_C_ONLY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <operator>!</operator><name>C_plus_plus</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_IF_C_OR_CPP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sko_push</name><argument_list>(<argument><expr><name>do_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_copy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_NOT_FOR_HEADER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>OUT_BEGIN_CODE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>cmd_match</name> <argument_list>(<argument><expr><name>CMD_OK_FOR_HEADER</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>OUT_END_CODE</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad line in skeleton file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>do_copy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>transition_struct_out</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>element_v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>element_n</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>out_dec2</name> <argument_list>(<argument><expr><literal type="string">" {%4d,%4d },"</literal></expr></argument>, <argument><expr><name>element_v</name></expr></argument>, <argument><expr><name>element_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>datapos</name> <operator>+=</operator> <name>TRANS_STRUCT_PRINT_LENGTH</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>datapos</name> <operator>&gt;=</operator> <literal type="number">79</literal> <operator>-</operator> <name>TRANS_STRUCT_PRINT_LENGTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>dataline</name> <operator>%</operator> <literal type="number">10</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>datapos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name> <modifier>*</modifier></type><name>yy_flex_xmalloc</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"memory allocation failed in yy_flex_xmalloc()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>char</name> <modifier>*</modifier></type><name>chomp</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>str</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>--</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>
</unit>
