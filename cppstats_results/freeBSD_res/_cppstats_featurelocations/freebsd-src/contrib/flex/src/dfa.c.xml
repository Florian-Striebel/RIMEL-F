<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/flex/src/dfa.c">






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"flexdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tables.h"</cpp:file></cpp:include>



<function_decl><type><name>void</name></type> <name>dump_associated_rules</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>dump_transitions</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>sympartition</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>symfollowset</name><parameter_list>(<parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>int</name><index>[]</index></name></type></decl></parameter>)</parameter_list>;</function_decl>











<function><type><name>void</name></type> <name>check_for_backing_up</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>state</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>reject</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dfaacc</name><index>[<expr><name>ds</name></expr>]</index></name><operator>.</operator><name>dfaacc_set</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>reject</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dfaacc</name><index>[<expr><name>ds</name></expr>]</index></name><operator>.</operator><name>dfaacc_state</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>num_backing_up</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>backing_up_report</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>backing_up_file</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"State #%d is non-accepting -\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>dump_associated_rules</name> <argument_list>(<argument><expr><name>backing_up_file</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>dump_transitions</name> <argument_list>(<argument><expr><name>backing_up_file</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>backing_up_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
























<function><type><name>void</name></type> <name>check_trailing_context</name> <parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nfa_states</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_states</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>accset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nacc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_states</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ns</name> <init>= <expr><name><name>nfa_states</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><name><name>state_type</name><index>[<expr><name>ns</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ar</name> <init>= <expr><name><name>assoc_rule</name><index>[<expr><name>ns</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STATE_NORMAL</name> <operator>||</operator> <name><name>rule_type</name><index>[<expr><name>ar</name></expr>]</index></name> <operator>!=</operator> <name>RULE_VARIABLE</name></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>STATE_TRAILING_CONTEXT</name></expr>)</condition> <block>{<block_content>






<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>nacc</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>accset</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <name>YY_TRAILING_HEAD_MASK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>line_warning</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"dangerous trailing context"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>rule_linenum</name><index>[<expr><name>ar</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>dump_associated_rules</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_associated_rules</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>rule_set</name><index>[<expr><name>MAX_ASSOC_RULES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dset</name> <init>= <expr><name><name>dss</name><index>[<expr><name>ds</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>dfasiz</name><index>[<expr><name>ds</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rule_num</name> <init>= <expr><name><name>rule_linenum</name><index>[<expr><name><name>assoc_rule</name><index>[<expr><name><name>dset</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>num_associated_rules</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>rule_num</name> <operator>==</operator> <name><name>rule_set</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>num_associated_rules</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>num_associated_rules</name> <operator>&lt;</operator> <name>MAX_ASSOC_RULES</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>rule_set</name><index>[<expr><operator>++</operator><name>num_associated_rules</name></expr>]</index></name> <operator>=</operator>
<name>rule_num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>qsort</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>rule_set</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>num_associated_rules</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>rule_set</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>intcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" associated rule line numbers:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_associated_rules</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">8</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"\t%d"</literal></expr></argument>, <argument><expr><name><name>rule_set</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>putc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><name>void</name></type> <name>dump_transitions</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>state</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>out_char_set</name><index>[<expr><name>CSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>ABS</name> <argument_list>(<argument><expr><name><name>ecgroup</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out_char_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><index>[<expr><name>ec</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" out-transitions: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_character_set</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>out_char_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>csize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>out_char_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>!</operator><name><name>out_char_set</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n jam-transitions: EOF "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_character_set</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>out_char_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putc</name> <argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






















<function><type><name>int</name> <modifier>*</modifier></type><name>epsclosure</name> <parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ns_addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>accset</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nacc_addr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hv_addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>stkpos</name></decl>, <decl><type ref="prev"/><name>ns</name></decl>, <decl><type ref="prev"/><name>tsp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numstates</name> <init>= <expr><operator>*</operator><name>ns_addr</name></expr></init></decl>, <decl><type ref="prev"/><name>nacc</name></decl>, <decl><type ref="prev"/><name>hashval</name></decl>, <decl><type ref="prev"/><name>transsym</name></decl>, <decl><type ref="prev"/><name>nfaccnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stkend</name></decl>, <decl><type ref="prev"/><name>nstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>did_stk_init</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stk</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARK_STATE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do{ trans1[state] = trans1[state] - MARKER_DIFFERENCE;} while(0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MARKED</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(trans1[state] &lt; 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNMARK_STATE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do{ trans1[state] = trans1[state] + MARKER_DIFFERENCE;} while(0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ACCEPT</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do{ nfaccnum = accptnum[state]; if ( nfaccnum != NIL ) accset[++nacc] = nfaccnum; }while(0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_REALLOCATION</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { current_max_dfa_size += MAX_DFA_SIZE_INCREMENT; ++num_reallocs; t = reallocate_integer_array( t, current_max_dfa_size ); stk = reallocate_integer_array( stk, current_max_dfa_size ); }while(0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUT_ON_STACK</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ( ++stkend &gt;= current_max_dfa_size ) DO_REALLOCATION(); stk[stkend] = state; MARK_STATE(state); }while(0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADD_STATE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ( ++numstates &gt;= current_max_dfa_size ) DO_REALLOCATION(); t[numstates] = state; hashval += state; }while(0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_STATE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { PUT_ON_STACK(state); CHECK_ACCEPT(state); if ( nfaccnum != NIL || transchar[state] != SYM_EPSILON ) ADD_STATE(state); }while(0)</cpp:value></cpp:define>








<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_stk_init</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stk</name> <operator>=</operator> <call><name>allocate_integer_array</name> <argument_list>(<argument><expr><name>current_max_dfa_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>did_stk_init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nacc</name> <operator>=</operator> <name>stkend</name> <operator>=</operator> <name>hashval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>nstate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>nstate</name> <operator>&lt;=</operator> <name>numstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>nstate</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ns</name> <operator>=</operator> <name><name>t</name><index>[<expr><name>nstate</name></expr>]</index></name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_MARKED</name> <argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PUT_ON_STACK</name> <argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_ACCEPT</name> <argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hashval</name> <operator>+=</operator> <name>ns</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>stkpos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>stkpos</name> <operator>&lt;=</operator> <name>stkend</name></expr>;</condition> <incr><expr><operator>++</operator><name>stkpos</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ns</name> <operator>=</operator> <name><name>stk</name><index>[<expr><name>stkpos</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>transsym</name> <operator>=</operator> <name><name>transchar</name><index>[<expr><name>ns</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>transsym</name> <operator>==</operator> <name>SYM_EPSILON</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tsp</name> <operator>=</operator> <name><name>trans1</name><index>[<expr><name>ns</name></expr>]</index></name> <operator>+</operator> <name>MARKER_DIFFERENCE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tsp</name> <operator>!=</operator> <name>NO_TRANSITION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_MARKED</name> <argument_list>(<argument><expr><name>tsp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STACK_STATE</name> <argument_list>(<argument><expr><name>tsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tsp</name> <operator>=</operator> <name><name>trans2</name><index>[<expr><name>ns</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tsp</name> <operator>!=</operator> <name>NO_TRANSITION</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_MARKED</name> <argument_list>(<argument><expr><name>tsp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STACK_STATE</name> <argument_list>(<argument><expr><name>tsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>



<for>for <control>(<init><expr><name>stkpos</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>stkpos</name> <operator>&lt;=</operator> <name>stkend</name></expr>;</condition> <incr><expr><operator>++</operator><name>stkpos</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IS_MARKED</name> <argument_list>(<argument><expr><name><name>stk</name><index>[<expr><name>stkpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>UNMARK_STATE</name> <argument_list>(<argument><expr><name><name>stk</name><index>[<expr><name>stkpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"consistency check failed in epsclosure()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>ns_addr</name> <operator>=</operator> <name>numstates</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>hv_addr</name> <operator>=</operator> <name>hashval</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nacc_addr</name> <operator>=</operator> <name>nacc</name></expr>;</expr_stmt>

<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>increase_max_dfas</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>current_max_dfas</name> <operator>+=</operator> <name>MAX_DFAS_INCREMENT</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>num_reallocs</name></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>def</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dfasiz</name> <operator>=</operator> <call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>dfasiz</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accsiz</name> <operator>=</operator> <call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>accsiz</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dhash</name> <operator>=</operator> <call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>dhash</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dss</name> <operator>=</operator> <call><name>reallocate_int_ptr_array</name> <argument_list>(<argument><expr><name>dss</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dfaacc</name> <operator>=</operator> <call><name>reallocate_dfaacc_union</name> <argument_list>(<argument><expr><name>dfaacc</name></expr></argument>, <argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nultrans</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nultrans</name> <operator>=</operator>
<call><name>reallocate_integer_array</name> <argument_list>(<argument><expr><name>nultrans</name></expr></argument>,
<argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>ntod</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>accset</name></decl>, <decl><type ref="prev"/><name>ds</name></decl>, <decl><type ref="prev"/><name>nacc</name></decl>, <decl><type ref="prev"/><name>newds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sym</name></decl>, <decl><type ref="prev"/><name>hashval</name></decl>, <decl><type ref="prev"/><name>numstates</name></decl>, <decl><type ref="prev"/><name>dsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_full_table_rows</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>nset</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>targptr</name></decl>, <decl><type ref="prev"/><name>totaltrans</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>comstate</name></decl>, <decl><type ref="prev"/><name>comfreq</name></decl>, <decl><type ref="prev"/><name>targ</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>symlist</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_start_states</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>todo_head</name></decl>, <decl><type ref="prev"/><name>todo_next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>yytbl_data</name></name> <modifier>*</modifier></type><name>yynxt_tbl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>flex_int32_t</name> <modifier>*</modifier></type><name>yynxt_data</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>yynxt_curr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>








<decl_stmt><decl><type><name>int</name></type> <name><name>duplist</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>state</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>targfreq</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name><name>targstate</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>




<expr_stmt><expr><name>accset</name> <operator>=</operator> <call><name>allocate_integer_array</name> <argument_list>(<argument><expr><operator>(</operator><name>num_rules</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nset</name> <operator>=</operator> <call><name>allocate_integer_array</name> <argument_list>(<argument><expr><name>current_max_dfa_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name>todo_head</name> <operator>=</operator> <name>todo_next</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>csize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>duplist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_rules</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dumpnfa</name> <argument_list>(<argument><expr><name><name>scset</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name> <argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n\nDFA Dump:\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>inittbl</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

































<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fullspd</name> <operator>&amp;&amp;</operator> <name><name>ecgroup</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>numecs</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>int</name></type> <name>use_NUL_table</name> <init>= <expr><operator>(</operator><name>numecs</name> <operator>==</operator> <name>csize</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fulltbl</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_NUL_table</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>numecs</name> <operator>&lt;=</operator> <name>csize</name> <operator>&amp;&amp;</operator> <call><name>is_power_of_2</name><argument_list>(<argument><expr><name>numecs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>use_NUL_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>use_NUL_table</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nultrans</name> <operator>=</operator>
<call><name>allocate_integer_array</name> <argument_list>(<argument><expr><name>current_max_dfas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>fullspd</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numecs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>place_state</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>dfaacc_state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>fulltbl</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nultrans</name></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name>num_full_table_rows</name> <operator>=</operator> <name>numecs</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>




<expr_stmt><expr><name>num_full_table_rows</name> <operator>=</operator> <name>numecs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>







<expr_stmt><expr><name>yynxt_tbl</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>yytbl_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>yytbl_data_init</name> <argument_list>(<argument><expr><name>yynxt_tbl</name></expr></argument>, <argument><expr><name>YYTD_ID_NXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_hilen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_lolen</name></name> <operator>=</operator> <operator>(</operator><name>flex_uint32_t</name><operator>)</operator> <name>num_full_table_rows</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_data</name></name> <operator>=</operator> <name>yynxt_data</name> <operator>=</operator>
<call><name>calloc</name><argument_list>(<argument><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_lolen</name></name> <operator>*</operator>
<name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_hilen</name></name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flex_int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yynxt_curr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>buf_prints</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>yydmap_buf</name></expr></argument>,
<argument><expr><literal type="string">"\t{YYTD_ID_NXT, (void**)&amp;yy_nxt, sizeof(%s)},\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>long_align</name></expr> ?</condition><then> <expr><literal type="string">"flex_int32_t"</literal></expr> </then><else>: <expr><literal type="string">"flex_int16_t"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>out_str_dec</name>
<argument_list>(<argument><expr><literal type="string">"static const %s yy_nxt[][%d] =\n {\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>long_align</name></expr> ?</condition><then> <expr><literal type="string">"flex_int32_t"</literal></expr> </then><else>: <expr><literal type="string">"flex_int16_t"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>num_full_table_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>out_dec</name> <argument_list>(<argument><expr><literal type="string">"#undef YY_NXT_LOLEN\n#define YY_NXT_LOLEN (%d)\n"</literal></expr></argument>, <argument><expr><name>num_full_table_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>out_str</name> <argument_list>(<argument><expr><literal type="string">"static const %s *yy_nxt =0;\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>long_align</name></expr> ?</condition><then> <expr><literal type="string">"flex_int32_t"</literal></expr> </then><else>: <expr><literal type="string">"flex_int16_t"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><literal type="string">" {"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_full_table_rows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>mk2data</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_data</name><index>[<expr><name>yynxt_curr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dataflush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><literal type="string">" },\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>num_start_states</name> <operator>=</operator> <name>lastsc</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_start_states</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>numstates</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nset</name><index>[<expr><name>numstates</name></expr>]</index></name> <operator>=</operator> <name><name>scset</name><index>[<expr><operator>(</operator><name>i</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nset</name><index>[<expr><name>numstates</name></expr>]</index></name> <operator>=</operator>
<call><name>mkbranch</name> <argument_list>(<argument><expr><name><name>scbol</name><index>[<expr><name>i</name> <operator>/</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>scset</name><index>[<expr><name>i</name> <operator>/</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>nset</name> <operator>=</operator> <call><name>epsclosure</name> <argument_list>(<argument><expr><name>nset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numstates</name></expr></argument>, <argument><expr><name>accset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nacc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>hashval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>snstods</name> <argument_list>(<argument><expr><name>nset</name></expr></argument>, <argument><expr><name>numstates</name></expr></argument>, <argument><expr><name>accset</name></expr></argument>, <argument><expr><name>nacc</name></expr></argument>, <argument><expr><name>hashval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>numas</name> <operator>+=</operator> <name>nacc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>totnst</name> <operator>+=</operator> <name>numstates</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>todo_next</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>variable_trailing_context_rules</name> <operator>&amp;&amp;</operator> <name>nacc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_trailing_context</name> <argument_list>(<argument><expr><name>nset</name></expr></argument>, <argument><expr><name>numstates</name></expr></argument>,
<argument><expr><name>accset</name></expr></argument>, <argument><expr><name>nacc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fullspd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>snstods</name> <argument_list>(<argument><expr><name>nset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>accset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_of_buffer_state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"could not create unique end-of-buffer state"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>numas</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>num_start_states</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>todo_next</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><name>todo_head</name> <operator>&lt;</operator> <name>todo_next</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>targptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>totaltrans</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numecs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>++</operator><name>todo_head</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dset</name> <operator>=</operator> <name><name>dss</name><index>[<expr><name>ds</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dsize</name> <operator>=</operator> <name><name>dfasiz</name><index>[<expr><name>ds</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>trace</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"state #%d:\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sympartition</name> <argument_list>(<argument><expr><name>dset</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>, <argument><expr><name>symlist</name></expr></argument>, <argument><expr><name>duplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>sym</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>sym</name> <operator>&lt;=</operator> <name>numecs</name></expr>;</condition> <incr><expr><operator>++</operator><name>sym</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>symlist</name><index>[<expr><name>sym</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>sym</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>duplist</name><index>[<expr><name>sym</name></expr>]</index></name> <operator>==</operator> <name>NIL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>numstates</name> <operator>=</operator>
<call><name>symfollowset</name> <argument_list>(<argument><expr><name>dset</name></expr></argument>, <argument><expr><name>dsize</name></expr></argument>,
<argument><expr><name>sym</name></expr></argument>, <argument><expr><name>nset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nset</name> <operator>=</operator> <call><name>epsclosure</name> <argument_list>(<argument><expr><name>nset</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>numstates</name></expr></argument>,
<argument><expr><name>accset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nacc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>hashval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>snstods</name>
<argument_list>(<argument><expr><name>nset</name></expr></argument>, <argument><expr><name>numstates</name></expr></argument>, <argument><expr><name>accset</name></expr></argument>, <argument><expr><name>nacc</name></expr></argument>,
<argument><expr><name>hashval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>totnst</name> <operator>=</operator> <name>totnst</name> <operator>+</operator>
<name>numstates</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>todo_next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numas</name> <operator>+=</operator> <name>nacc</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>variable_trailing_context_rules</name> <operator>&amp;&amp;</operator> <name>nacc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_trailing_context</name>
<argument_list>(<argument><expr><name>nset</name></expr></argument>,
<argument><expr><name>numstates</name></expr></argument>,
<argument><expr><name>accset</name></expr></argument>,
<argument><expr><name>nacc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><index>[<expr><name>sym</name></expr>]</index></name> <operator>=</operator> <name>newds</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>trace</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>sym</name></expr></argument>,
<argument><expr><name>newds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>targfreq</name><index>[<expr><operator>++</operator><name>targptr</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>targstate</name><index>[<expr><name>targptr</name></expr>]</index></name> <operator>=</operator> <name>newds</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>numuniq</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else <block>{<block_content>




<expr_stmt><expr><name>targ</name> <operator>=</operator> <name><name>state</name><index>[<expr><name><name>duplist</name><index>[<expr><name>sym</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>sym</name></expr>]</index></name> <operator>=</operator> <name>targ</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>trace</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>sym</name></expr></argument>,
<argument><expr><name>targ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>targstate</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>!=</operator> <name>targ</name></expr>)</condition><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></while>

<expr_stmt><expr><operator>++</operator><name><name>targfreq</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>numdup</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>totaltrans</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>duplist</name><index>[<expr><name>sym</name></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>numsnpairs</name> <operator>+=</operator> <name>totaltrans</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ds</name> <operator>&gt;</operator> <name>num_start_states</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_for_backing_up</name> <argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nultrans</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nultrans</name><index>[<expr><name>ds</name></expr>]</index></name> <operator>=</operator> <name><name>state</name><index>[<expr><name>NUL_ec</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>NUL_ec</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fulltbl</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_hilen</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_data</name></name> <operator>=</operator> <name>yynxt_data</name> <operator>=</operator>
<call><name>realloc</name> <argument_list>(<argument><expr><name>yynxt_data</name></expr></argument>,
<argument><expr><name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_hilen</name></name> <operator>*</operator>
<name><name>yynxt_tbl</name><operator>-&gt;</operator><name>td_lolen</name></name> <operator>*</operator>
<sizeof>sizeof <argument_list>(<argument><expr><name>flex_int32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><literal type="string">" {"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>ds</name> <operator>==</operator> <name>end_of_buffer_state</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mk2data</name> <argument_list>(<argument><expr><operator>-</operator><name>end_of_buffer_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_data</name><index>[<expr><name>yynxt_curr</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
<operator>-</operator><name>end_of_buffer_state</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>mk2data</name> <argument_list>(<argument><expr><name>end_of_buffer_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_data</name><index>[<expr><name>yynxt_curr</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
<name>end_of_buffer_state</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_full_table_rows</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>



<expr_stmt><expr><call><name>mk2data</name> <argument_list>(<argument><expr><ternary><condition><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name>ds</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yynxt_data</name><index>[<expr><name>yynxt_curr</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
<ternary><condition><expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>state</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><name>ds</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>dataflush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gentables</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outn</name> <argument_list>(<argument><expr><literal type="string">" },\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>fullspd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>place_state</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>totaltrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ds</name> <operator>==</operator> <name>end_of_buffer_state</name></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><call><name>stack1</name> <argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>JAMSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>





<expr_stmt><expr><name>comfreq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>comstate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>targptr</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>targfreq</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>comfreq</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>comfreq</name> <operator>=</operator> <name><name>targfreq</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>comstate</name> <operator>=</operator> <name><name>targstate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>bldtbl</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>ds</name></expr></argument>, <argument><expr><name>totaltrans</name></expr></argument>, <argument><expr><name>comstate</name></expr></argument>, <argument><expr><name>comfreq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>fulltbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dataend</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tablesext</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yytbl_data_compress</name> <argument_list>(<argument><expr><name>yynxt_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>yytbl_data_fwrite</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>tableswr</name></expr></argument>, <argument><expr><name>yynxt_tbl</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>flexerror</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"Could not write yynxt_tbl[][]"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>yynxt_tbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yytbl_data_destroy</name> <argument_list>(<argument><expr><name>yynxt_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yynxt_tbl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>fullspd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cmptmps</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>




<while>while <condition>(<expr><name>onesp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>mk1tbl</name> <argument_list>(<argument><expr><name><name>onestate</name><index>[<expr><name>onesp</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>onesym</name><index>[<expr><name>onesp</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>onenext</name><index>[<expr><name>onesp</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>onedef</name><index>[<expr><name>onesp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>onesp</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>mkdeftbl</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>accset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><name>int</name></type> <name>snstods</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>sns</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>accset</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nacc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashval</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newds_addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>didsort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldsns</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>lastdfa</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>hashval</name> <operator>==</operator> <name><name>dhash</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>numstates</name> <operator>==</operator> <name><name>dfasiz</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldsns</name> <operator>=</operator> <name><name>dss</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>didsort</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>qsort</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sns</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>numstates</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>sns</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>intcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>didsort</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>numstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>sns</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>oldsns</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>numstates</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>dfaeql</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>newds_addr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>hshcol</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>hshsave</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>



<if_stmt><if>if <condition>(<expr><operator>++</operator><name>lastdfa</name> <operator>&gt;=</operator> <name>current_max_dfas</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>increase_max_dfas</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newds</name> <operator>=</operator> <name>lastdfa</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dss</name><index>[<expr><name>newds</name></expr>]</index></name> <operator>=</operator> <call><name>allocate_integer_array</name> <argument_list>(<argument><expr><name>numstates</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>didsort</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>qsort</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sns</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>numstates</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>sns</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>intcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dss</name><index>[<expr><name>newds</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>dfasiz</name><index>[<expr><name>newds</name></expr>]</index></name> <operator>=</operator> <name>numstates</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dhash</name><index>[<expr><name>newds</name></expr>]</index></name> <operator>=</operator> <name>hashval</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nacc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reject</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><name>newds</name></expr>]</index></name><operator>.</operator><name>dfaacc_set</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><name>newds</name></expr>]</index></name><operator>.</operator><name>dfaacc_state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>accsiz</name><index>[<expr><name>newds</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>reject</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>qsort</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>accset</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>nacc</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>accset</name> <index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>intcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><name>newds</name></expr>]</index></name><operator>.</operator><name>dfaacc_set</name> <operator>=</operator>
<call><name>allocate_integer_array</name> <argument_list>(<argument><expr><name>nacc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nacc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><name>newds</name></expr>]</index></name><operator>.</operator><name><name>dfaacc_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name>num_rules</name></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name><name>rule_useful</name><index>[<expr><name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>accsiz</name><index>[<expr><name>newds</name></expr>]</index></name> <operator>=</operator> <name>nacc</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else <block>{<block_content>



<expr_stmt><expr><name>j</name> <operator>=</operator> <name>num_rules</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nacc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>accset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name><name>dfaacc</name><index>[<expr><name>newds</name></expr>]</index></name><operator>.</operator><name>dfaacc_state</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <name>num_rules</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>rule_useful</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>newds_addr</name> <operator>=</operator> <name>newds</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>symfollowset</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>ds</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>transsym</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>nset</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>, <decl><type ref="prev"/><name>tsp</name></decl>, <decl><type ref="prev"/><name>sym</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>lenccl</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>, <decl><type ref="prev"/><name>numstates</name></decl>, <decl><type ref="prev"/><name>ccllist</name></decl>;</decl_stmt>

<expr_stmt><expr><name>numstates</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>dsize</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ns</name> <operator>=</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <name><name>transchar</name><index>[<expr><name>ns</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tsp</name> <operator>=</operator> <name><name>trans1</name><index>[<expr><name>ns</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <operator>-</operator><name>sym</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ccllist</name> <operator>=</operator> <name><name>cclmap</name><index>[<expr><name>sym</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lenccl</name> <operator>=</operator> <name><name>ccllen</name><index>[<expr><name>sym</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cclng</name><index>[<expr><name>sym</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lenccl</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>



<expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>ccltbl</name><index>[<expr><name>ccllist</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NUL_ec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <name>transsym</name></expr>)</condition><block type="pseudo"><block_content>



<break>break;</break></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>transsym</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>bottom</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>nset</name><index>[<expr><operator>++</operator><name>numstates</name></expr>]</index></name> <operator>=</operator> <name>tsp</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>lenccl</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name><name>ccltbl</name><index>[<expr><name>ccllist</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>NUL_ec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <name>transsym</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>transsym</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nset</name><index>[<expr><operator>++</operator><name>numstates</name></expr>]</index></name> <operator>=</operator> <name>tsp</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for></block_content></block></else></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>sym</name> <operator>==</operator> <name>SYM_EPSILON</name></expr>)</condition> <block>{<block_content>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ABS</name> <argument_list>(<argument><expr><name><name>ecgroup</name><index>[<expr><name>sym</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>transsym</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nset</name><index>[<expr><operator>++</operator><name>numstates</name></expr>]</index></name> <operator>=</operator> <name>tsp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>bottom</name>:</label><empty_stmt>;</empty_stmt>
</block_content>}</block></for>

<return>return <expr><name>numstates</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>sympartition</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>ds</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numstates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>symlist</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>duplist</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tch</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>ns</name></decl>, <decl><type ref="prev"/><name><name>dupfwd</name><index>[<expr><name>CSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>lenccl</name></decl>, <decl><type ref="prev"/><name>cclp</name></decl>, <decl><type ref="prev"/><name>ich</name></decl>;</decl_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numecs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>duplist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dupfwd</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>duplist</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dupfwd</name><index>[<expr><name>numecs</name></expr>]</index></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>numstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ns</name> <operator>=</operator> <name><name>ds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tch</name> <operator>=</operator> <name><name>transchar</name><index>[<expr><name>ns</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tch</name> <operator>!=</operator> <name>SYM_EPSILON</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tch</name> <operator>&lt;</operator> <operator>-</operator><name>lastccl</name> <operator>||</operator> <name>tch</name> <operator>&gt;=</operator> <name>csize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>flexfatal</name> <argument_list>(<argument><expr><call><name>_</name>
<argument_list>(<argument><expr><literal type="string">"bad transition character detected in sympartition()"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tch</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ec</name> <init>= <expr><name><name>ecgroup</name><index>[<expr><name>tch</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mkechar</name> <argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>dupfwd</name></expr></argument>, <argument><expr><name>duplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>ec</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else <block>{<block_content>
<expr_stmt><expr><name>tch</name> <operator>=</operator> <operator>-</operator><name>tch</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lenccl</name> <operator>=</operator> <name><name>ccllen</name><index>[<expr><name>tch</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cclp</name> <operator>=</operator> <name><name>cclmap</name><index>[<expr><name>tch</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mkeccl</name> <argument_list>(<argument><expr><name>ccltbl</name> <operator>+</operator> <name>cclp</name></expr></argument>, <argument><expr><name>lenccl</name></expr></argument>, <argument><expr><name>dupfwd</name></expr></argument>,
<argument><expr><name>duplist</name></expr></argument>, <argument><expr><name>numecs</name></expr></argument>, <argument><expr><name>NUL_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cclng</name><index>[<expr><name>tch</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>lenccl</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ich</name> <operator>=</operator> <name><name>ccltbl</name><index>[<expr><name>cclp</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ich</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ich</name> <operator>=</operator> <name>NUL_ec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><operator>++</operator><name>j</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ich</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>

<for>for <control>(<init><expr><operator>++</operator><name>j</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>numecs</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>lenccl</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ich</name> <operator>=</operator> <name><name>ccltbl</name><index>[<expr><name>cclp</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ich</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ich</name> <operator>=</operator> <name>NUL_ec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>symlist</name><index>[<expr><name>ich</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
</unit>
