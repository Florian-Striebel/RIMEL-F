<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/tools/ctf/dump/dump.c">

























<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctf_headers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symbol.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WARN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ warn(x); return (E_ERROR); }</cpp:value></cpp:define>















<enum><specifier>static</specifier> enum <block>{
<decl><name>F_DATA</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,
<decl><name>F_FUNC</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,
<decl><name>F_HDR</name> <init>= <expr><literal type="number">0x04</literal></expr></init></decl>,
<decl><name>F_STR</name> <init>= <expr><literal type="number">0x08</literal></expr></init></decl>,
<decl><name>F_TYPES</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>F_STATS</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
<decl><name>F_LABEL</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>,
<decl><name>F_ALL</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>,
<decl><name>F_ALLMSK</name> <init>= <expr><literal type="number">0xff</literal></expr></init></decl>
}</block> <decl><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</enum>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_ndata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_argmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_ntypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name><name>s_types</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nsmem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nsbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_smmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_sbmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_numem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nubytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_ummax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_ubmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nemem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_emmax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>s_nstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_strlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_strmax</name></decl>;</decl_stmt>
}</block> <decl><name>stats</name></decl>;</struct>

<typedef>typedef <type><struct>struct <name>ctf_data</name> <block>{
<decl_stmt><decl><type><name>caddr_t</name></type> <name>cd_ctfdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>cd_ctflen</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>cd_symdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>cd_strdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cd_nsyms</name></decl>;</decl_stmt>
}</block></struct></type> <name>ctf_data_t</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ref_to_str</name><parameter_list>(<parameter><decl><type><name>uint_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>CTF_NAME_OFFSET</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CTF_NAME_STID</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTF_STRTAB_0</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">"&lt;&lt; ??? - name in external strtab &gt;&gt;"</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">"&lt;&lt; ??? - name exceeds strlab len &gt;&gt;"</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name>offset</name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">"&lt;&lt; ??? - file truncated &gt;&gt;"</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="string">"(anon)"</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>s</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>int_encoding_to_str</name><parameter_list>(<parameter><decl><type><name>uint_t</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>encoding</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>CTF_INT_SIGNED</name> <operator>|</operator> <name>CTF_INT_CHAR</name> <operator>|</operator>
<name>CTF_INT_BOOL</name> <operator>|</operator> <name>CTF_INT_VARARGS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">" 0x%x"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&amp;</operator> <name>CTF_INT_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" SIGNED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&amp;</operator> <name>CTF_INT_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" CHAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&amp;</operator> <name>CTF_INT_BOOL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" BOOL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&amp;</operator> <name>CTF_INT_VARARGS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" VARARGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>buf</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fp_encoding_to_str</name><parameter_list>(<parameter><decl><type><name>uint_t</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>encs</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>NULL</name></expr>, <expr><literal type="string">"SINGLE"</literal></expr>, <expr><literal type="string">"DOUBLE"</literal></expr>, <expr><literal type="string">"COMPLEX"</literal></expr>, <expr><literal type="string">"DCOMPLEX"</literal></expr>, <expr><literal type="string">"LDCOMPLEX"</literal></expr>,
<expr><literal type="string">"LDOUBLE"</literal></expr>, <expr><literal type="string">"INTERVAL"</literal></expr>, <expr><literal type="string">"DINTERVAL"</literal></expr>, <expr><literal type="string">"LDINTERVAL"</literal></expr>, <expr><literal type="string">"IMAGINARY"</literal></expr>,
<expr><literal type="string">"DIMAGINARY"</literal></expr>, <expr><literal type="string">"LDIMAGINARY"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>encoding</name> <operator>&gt;=</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>encs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>encs</name><index>[<expr><name>encoding</name></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>line</name><index>[]</index></name> <init>= <expr><literal type="string">"----------------------------------------"</literal>
<literal type="string">"----------------------------------------"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n%s%.*s\n\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">78</literal> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>print_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- CTF Header "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_magic = 0x%04x\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_version = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_flags = 0x%02x\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_parlabel = %s\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_parlabel</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_parname = %s\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_parname</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_lbloff = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_objtoff = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_funcoff = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_typeoff = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_stroff = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" cth_strlen = %u\n"</literal></expr></argument>, <argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>print_labeltable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_lblent_t</name> <modifier>*</modifier></type><name>ctl</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><operator>(</operator><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name> <operator>-</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name><operator>)</operator> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- Label Table "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"cth_lbloff is not aligned properly\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_lbloff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_objtoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_lbloff</name></name> <operator>&gt;</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is corrupt -- cth_lbloff &gt; cth_objtoff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ctl</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %5u %s\n"</literal></expr></argument>, <argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>ctl_typeidx</name></name></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>ctl</name><operator>-&gt;</operator><name>ctl_label</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>next_sym</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>symidx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uchar_t</name></type> <name>matchtype</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>namep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>symidx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_nsyms</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cd_symdata</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_strdata</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>sym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>matchtype</name> <operator>||</operator> <call><name>ignore_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>namep</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>i</name><operator>)</operator></expr>;</return>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_data</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ushort_t</name> <modifier>*</modifier></type><name>idp</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>n</name> <init>= <expr><operator>(</operator><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name> <operator>-</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name><operator>)</operator> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ushort_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- Data Objects "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"cth_objtoff is not aligned properly\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_objtoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_funcoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_objtoff</name></name> <operator>&gt;</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is corrupt -- cth_objtoff &gt; cth_funcoff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>symidx</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>symidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nextsym</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>cd_symdata</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>nextsym</name> <operator>=</operator> <call><name>next_sym</name><argument_list>(<argument><expr><name>cd</name></expr></argument>,
<argument><expr><name>symidx</name></expr></argument>, <argument><expr><name>STT_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>symidx</name> <operator>=</operator> <name>nextsym</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%u] %u"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>*</operator><name>idp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%*s%s (%u)"</literal></expr></argument>, <argument><expr><operator>(</operator><literal type="number">15</literal> <operator>-</operator> <name>len</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>symidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_ndata</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_funcs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ushort_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ushort_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ulong_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symidx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- Functions "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"cth_funcoff is not aligned properly\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_funcoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_typeoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_funcoff</name></name> <operator>&gt;</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is corrupt -- cth_funcoff &gt; cth_typeoff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>symidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fp</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ushort_t</name></type> <name>info</name> <init>= <expr><operator>*</operator><name>fp</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushort_t</name></type> <name>kind</name> <init>= <expr><call><name>CTF_INFO_KIND</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushort_t</name></type> <name>n</name> <init>= <expr><call><name>CTF_INFO_VLEN</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushort_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>-&gt;</operator><name>cd_symdata</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>nextsym</name> <operator>=</operator> <call><name>next_sym</name><argument_list>(<argument><expr><name>cd</name></expr></argument>, <argument><expr><name>symidx</name></expr></argument>,
<argument><expr><name>STT_FUNC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>symidx</name> <operator>=</operator> <name>nextsym</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_FUNCTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%lu] unexpected kind -- %u\n"</literal></expr></argument>,
<argument><expr><name>id</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>E_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>+</operator> <name>n</name> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%lu] vlen %u extends past section "</literal>
<literal type="string">"boundary\n"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>E_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%lu] FUNC "</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(%s) "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"returns: %u args: ("</literal></expr></argument>, <argument><expr><operator>*</operator><name>fp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>*</operator><name>fp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">", %u"</literal></expr></argument>, <argument><expr><operator>*</operator><name>fp</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fp</name> <operator>+=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nfunc</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nargs</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_argmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_argmax</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_types</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_type_t</name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_type_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ulong_t</name></type> <name>id</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- Types "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name> <operator>&amp;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"cth_typeoff is not aligned properly\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_typeoff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_stroff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_typeoff</name></name> <operator>&gt;</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is corrupt -- cth_typeoff &gt; cth_stroff\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_parlabel</name></name> <operator>||</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_parname</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>id</name> <operator>+=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CTF_PARENT_SHIFT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>tp</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ulong_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name>CTF_INFO_VLEN</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>increment</name></decl>, <decl><type ref="prev"/><name>vlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name> <init>= <expr><call><name>CTF_INFO_KIND</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<union>union <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_array_t</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_member_t</name> <modifier>*</modifier></type><name>mp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_lmember_t</name> <modifier>*</modifier></type><name>lmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_enum_t</name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ushort_t</name> <modifier>*</modifier></type><name>argp</name></decl>;</decl_stmt>
}</block> <decl><name>u</name></decl>;</union>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %c%lu%c "</literal></expr></argument>,
<argument><expr><literal type="string">"[&lt;"</literal><index>[<expr><call><name>CTF_INFO_ISROOT</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_info</name></name></expr></argument>)</argument_list></call></expr>]</index></expr></argument>, <argument><expr><name>id</name></expr></argument>,
<argument><expr><literal type="string">"]&gt;"</literal><index>[<expr><call><name>CTF_INFO_ISROOT</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_info</name></name></expr></argument>)</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_size</name></name> <operator>==</operator> <name>CTF_LSIZE_SENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>increment</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_type_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><call><name>CTF_TYPE_LSIZE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>increment</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_stype_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>ctt_size</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>u</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>tp</name> <operator>+</operator> <name>increment</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTF_K_INTEGER</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>encoding</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>uint_t</name> <operator>*</operator><operator>)</operator><name><name>u</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"INTEGER %s encoding=%s offset=%u"</literal>
<literal type="string">" bits=%u"</literal></expr></argument>, <argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>,
<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int_encoding_to_str</name><argument_list>(
<argument><expr><call><name>CTF_INT_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CTF_INT_OFFSET</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CTF_INT_BITS</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_FLOAT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>encoding</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>uint_t</name> <operator>*</operator><operator>)</operator><name><name>u</name><operator>.</operator><name>ptr</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FLOAT %s encoding=%s offset=%u "</literal>
<literal type="string">"bits=%u"</literal></expr></argument>, <argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>,
<argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fp_encoding_to_str</name><argument_list>(
<argument><expr><call><name>CTF_FP_ENCODING</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CTF_FP_OFFSET</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CTF_FP_BITS</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_POINTER</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"POINTER %s refers to %u"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_ARRAY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ARRAY %s content: %u index: %u "</literal>
<literal type="string">"nelems: %u\n"</literal></expr></argument>, <argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>,
<argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>ap</name><operator>-&gt;</operator><name>cta_contents</name></name></expr></argument>,
<argument><expr><name><name>u</name><operator>.</operator><name>ap</name><operator>-&gt;</operator><name>cta_index</name></name></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>ap</name><operator>-&gt;</operator><name>cta_nelems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_array_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_FUNCTION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FUNCTION %s returns: %u args: ("</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>u</name><operator>.</operator><name>argp</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name><name>u</name><operator>.</operator><name>argp</name></name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">", %u"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>u</name><operator>.</operator><name>argp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ushort_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>n</name> <operator>+</operator> <operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_STRUCT</name></expr>:</case>
<case>case <expr><name>CTF_K_UNION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_STRUCT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nsmem</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_smmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_smmax</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nsbytes</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_sbmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_sbmax</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"STRUCT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_numem</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_ummax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_ummax</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nubytes</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_ubmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_ubmax</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"UNION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s (%zd bytes)\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;=</operator> <name>CTF_LSTRUCT_THRESH</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name><name>u</name><operator>.</operator><name>lmp</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"\t%s type=%u off=%llu\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>u</name><operator>.</operator><name>lmp</name><operator>-&gt;</operator><name>ctlm_name</name></name></expr></argument>,
<argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>lmp</name><operator>-&gt;</operator><name>ctlm_type</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator>
<call><name>CTF_LMEM_OFFSET</name><argument_list>(<argument><expr><name><name>u</name><operator>.</operator><name>lmp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name><name>u</name><operator>.</operator><name>mp</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"\t%s type=%u off=%u\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>u</name><operator>.</operator><name>mp</name><operator>-&gt;</operator><name>ctm_name</name></name></expr></argument>,
<argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>mp</name><operator>-&gt;</operator><name>ctm_type</name></name></expr></argument>,
<argument><expr><name><name>u</name><operator>.</operator><name>mp</name><operator>-&gt;</operator><name>ctm_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vlen</name> <operator>=</operator> <name>n</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>size</name> <operator>&gt;=</operator> <name>CTF_LSTRUCT_THRESH</name></expr> ?</condition><then>
<expr><sizeof>sizeof <argument_list>(<argument><expr><name>ctf_lmember_t</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>ctf_member_t</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_ENUM</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ENUM %s\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name><name>u</name><operator>.</operator><name>ep</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t%s = %d\n"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>u</name><operator>.</operator><name>ep</name><operator>-&gt;</operator><name>cte_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>u</name><operator>.</operator><name>ep</name><operator>-&gt;</operator><name>cte_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nemem</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_emmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_emmax</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_enum_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_FORWARD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"FORWARD %s"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_TYPEDEF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"TYPEDEF %s refers to %u"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_VOLATILE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"VOLATILE %s refers to %u"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_CONST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"CONST %s refers to %u"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_RESTRICT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"RESTRICT %s refers to %u"</literal></expr></argument>,
<argument><expr><call><name>ref_to_str</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_name</name></name></expr></argument>, <argument><expr><name>hp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>ctt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CTF_K_UNKNOWN</name></expr>:</case>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unexpected kind %u\n"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>E_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_ntypes</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>kind</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>(</operator><name>ctf_type_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tp</name> <operator>+</operator> <name>increment</name> <operator>+</operator> <name>vlen</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_strtab</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ctf_data_t</name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>off</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cd_ctfdata</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- String Table "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>&gt;=</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_stroff is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name> <operator>&gt;</operator> <name><name>cd</name><operator>-&gt;</operator><name>cd_ctflen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>WARN</name><argument_list>(<argument><expr><literal type="string">"file is truncated or cth_strlen is corrupt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>off</name> <operator>+=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>F_STATS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" [%lu] %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ulong_t</name><operator>)</operator><name>off</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr> ?</condition><then> <expr><literal type="string">"\\0"</literal></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_nstr</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_strlen</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stats</name><operator>.</operator><name>s_strmax</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name><name>stats</name><operator>.</operator><name>s_strmax</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>long_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ulong_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-36s= %lu\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fp_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %-36s= %.2f\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>print_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>print_line</name><argument_list>(<argument><expr><literal type="string">"- CTF Statistics "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of data objects"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_ndata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of functions"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of function arguments"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum argument list length"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_argmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>s_nfunc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average argument list length"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nargs</name></name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of types"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_ntypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of integers"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_INTEGER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of floats"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_FLOAT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of pointers"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_POINTER</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of arrays"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_ARRAY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of func types"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_FUNCTION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of structs"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_STRUCT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of unions"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_UNION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of enums"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_ENUM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of forward tags"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_FORWARD</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of typedefs"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_TYPEDEF</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of volatile types"</literal></expr></argument>,
<argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_VOLATILE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of const types"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_CONST</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of restrict types"</literal></expr></argument>,
<argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_RESTRICT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of unknowns (holes)"</literal></expr></argument>,
<argument><expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_UNKNOWN</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of struct members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nsmem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum number of struct members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_smmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total size of all structs"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nsbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum size of a struct"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_sbmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_STRUCT</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average number of struct members"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nsmem</name></name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_STRUCT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average size of a struct"</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nsbytes</name></name> <operator>/</operator>
<operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_STRUCT</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of union members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_numem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum number of union members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_ummax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total size of all unions"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nubytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum size of a union"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_ubmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_UNION</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average number of union members"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_numem</name></name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_UNION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average size of a union"</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nubytes</name></name> <operator>/</operator>
<operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_UNION</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of enum members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nemem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum number of enum members"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_emmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_ENUM</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average number of enum members"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nemem</name></name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_types</name><index>[<expr><name>CTF_K_ENUM</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"total number of unique strings"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_nstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"bytes of string data"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>long_stat</name><argument_list>(<argument><expr><literal type="string">"maximum string length"</literal></expr></argument>, <argument><expr><name><name>stats</name><operator>.</operator><name>s_strmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>.</operator><name>s_nstr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fp_stat</name><argument_list>(<argument><expr><literal type="string">"average string length"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_strlen</name></name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name><name>stats</name><operator>.</operator><name>s_nstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>E_SUCCESS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>print_usage</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"Usage: %s [-dfhlsSt] [-u file] file\n"</literal></expr></argument>, <argument><expr><call><name>getpname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"\t-d dump data object section\n"</literal>
<literal type="string">"\t-f dump function section\n"</literal>
<literal type="string">"\t-h dump file header\n"</literal>
<literal type="string">"\t-l dump label table\n"</literal>
<literal type="string">"\t-s dump string table\n"</literal>
<literal type="string">"\t-S dump statistics\n"</literal>
<literal type="string">"\t-t dump type section\n"</literal>
<literal type="string">"\t-u save uncompressed CTF to a file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>E_USAGE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Elf_Scn</name> <modifier>*</modifier></type>
<name>findelfscn</name><parameter_list>(<parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>GElf_Ehdr</name> <modifier>*</modifier></type><name>ehdr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>secname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>scn</name> <operator>=</operator> <name>NULL</name></expr>;</init> <condition><expr><operator>(</operator><name>scn</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>scn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>name</name> <operator>=</operator>
<call><name>elf_strptr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>ehdr</name><operator>-&gt;</operator><name>e_shstrndx</name></name></expr></argument>, <argument><expr><name><name>shdr</name><operator>.</operator><name>sh_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>secname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>scn</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ufile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>fd</name></decl>, <decl><type ref="prev"/><name>ufd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ctf_data_t</name></type> <name>cd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ctf_preamble_t</name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_header_t</name> <modifier>*</modifier></type><name>hp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>opterr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>optind</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"dfhlsStu:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>EOF</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_DATA</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_FUNC</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_HDR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_LABEL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_STR</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_STATS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_TYPES</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><name>ufile</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>optopt</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>print_usage</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"illegal option -- %c\n"</literal></expr></argument>, <argument><expr><name>optopt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>print_usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>optind</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>print_usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>optind</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>print_usage</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ufile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_ALLMSK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to open %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>gelf_getehdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ehdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>ctfscn</name> <init>= <expr><call><name>findelfscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ehdr</name></expr></argument>, <argument><expr><literal type="string">".SUNW_ctf"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>symscn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>ctfshdr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ctfscn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>dp</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>ctfscn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s does not contain .SUNW_ctf data\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>ctfscn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctfshdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>ctfshdr</name><operator>.</operator><name>sh_link</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symscn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>ctfshdr</name><operator>.</operator><name>sh_link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>symscn</name> <operator>=</operator> <call><name>findelfscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ehdr</name></expr></argument>, <argument><expr><literal type="string">".symtab"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>symscn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>symstrscn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>symscn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symstrscn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>shdr</name><operator>.</operator><name>sh_link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_nsyms</name></name> <operator>=</operator> <name><name>shdr</name><operator>.</operator><name>sh_size</name></name> <operator>/</operator> <name><name>shdr</name><operator>.</operator><name>sh_entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_symdata</name></name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>symscn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_strdata</name></name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>symstrscn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to fstat %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>,
<argument><expr><name>MAP_PRIVATE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to mmap %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_preamble_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s does not contain a CTF preamble\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>ctp_magic</name></name> <operator>!=</operator> <name>CTF_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s does not appear to contain CTF data\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pp</name><operator>-&gt;</operator><name>ctp_version</name></name> <operator>==</operator> <name>CTF_VERSION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hp</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>=</operator> <operator>(</operator><name>caddr_t</name><operator>)</operator><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_header_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ctf_header_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s does not contain a v%d CTF header\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name>CTF_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"%s contains unsupported CTF version %d\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name><name>pp</name><operator>-&gt;</operator><name>ctp_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>hp</name><operator>-&gt;</operator><name>cth_flags</name></name> <operator>&amp;</operator> <name>CTF_F_COMPRESS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>z_stream</name></type> <name>zstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to allocate decompression buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstr</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstr</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstr</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zstr</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>inflateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to initialize zlib: %s\n"</literal></expr></argument>, <argument><expr><call><name>zError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstr</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to decompress CTF data: %s\n"</literal></expr></argument>, <argument><expr><call><name>zError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zstr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"failed to finish decompression: %s\n"</literal></expr></argument>, <argument><expr><call><name>zError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zstr</name><operator>.</operator><name>total_out</name></name> <operator>!=</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><literal type="string">"CTF data is corrupt -- short decompression\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name> <operator>=</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_stroff</name></name> <operator>+</operator> <name><name>hp</name><operator>-&gt;</operator><name>cth_strlen</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_HDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>print_header</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_LABEL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>print_labeltable</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_DATA</name> <operator>|</operator> <name>F_STATS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>read_data</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_FUNC</name> <operator>|</operator> <name>F_STATS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>read_funcs</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_TYPES</name> <operator>|</operator> <name>F_STATS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>read_types</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_STR</name> <operator>|</operator> <name>F_STATS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>read_strtab</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_STATS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <call><name>print_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name>ufile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ctf_header_t</name></type> <name>h</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>hp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>.</operator><name>cth_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CTF_F_COMPRESS</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ufd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>ufile</name></expr></argument>, <argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>O_TRUNC</name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>write</name><argument_list>(<argument><expr><name>ufd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<call><name>write</name><argument_list>(<argument><expr><name>ufd</name></expr></argument>, <argument><expr><name><name>cd</name><operator>.</operator><name>cd_ctfdata</name></name></expr></argument>, <argument><expr><name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>cd</name><operator>.</operator><name>cd_ctflen</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"failed to write CTF data to '%s'"</literal></expr></argument>, <argument><expr><name>ufile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>|=</operator> <name>E_ERROR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>ufd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>elf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>error</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
