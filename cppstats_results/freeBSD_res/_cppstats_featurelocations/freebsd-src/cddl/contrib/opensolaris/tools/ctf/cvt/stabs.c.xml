<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/cddl/contrib/opensolaris/tools/ctf/cvt/stabs.c">
























<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ctftools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"traverse.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curhdr</name></decl>;</decl_stmt>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>resolve_tou_node</name><parameter_list>(<parameter><decl><type><name>tdesc_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>tdesc_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodep</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>private</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>tdesc_t</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Trying to resolve %s (%d)\n"</literal></expr></argument>, <argument><expr><call><name>tdesc_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>lookup</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>new</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>terminate</name><argument_list>(<argument><expr><literal type="string">"Couldn't resolve type %d\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">" Resolving to %d\n"</literal></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nodep</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>resolve_fwd_node</name><parameter_list>(<parameter><decl><type><name>tdesc_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>tdesc_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodep</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>private</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>tdesc_t</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>lookupname</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>t_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Trying to unforward %s (%d)\n"</literal></expr></argument>, <argument><expr><call><name>tdesc_name</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name> <operator>||</operator> <operator>(</operator><name><name>new</name><operator>-&gt;</operator><name>t_type</name></name> <operator>!=</operator> <name>STRUCT</name> <operator>&amp;&amp;</operator> <name><name>new</name><operator>-&gt;</operator><name>t_type</name></name> <operator>!=</operator> <name>UNION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">" Unforwarded to %d\n"</literal></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>t_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nodep</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>tdtrav_cb_f</name></type> <name><name>resolve_cbs</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>resolve_fwd_node</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>resolve_tou_node</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resolve_nodes</name><parameter_list>(<parameter><decl><type><name>tdata_t</name> <modifier>*</modifier></type><name>td</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"Resolving unresolved stabs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>iitraverse_hash</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>td_iihash</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>td</name><operator>-&gt;</operator><name>td_curvgen</name></name></expr></argument>, <argument><expr><name>resolve_cbs</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>concat</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s2strip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>savelen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>s2strip</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>s1</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>savelen</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>out</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>savelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><name>savelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>out</name><index>[<expr><name>newlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>out</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>fnarg_add</name><parameter_list>(<parameter><decl><type><name>iidesc_t</name> <modifier>*</modifier></type><name>curfun</name></decl></parameter>, <parameter><decl><type><name>iidesc_t</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_nargs</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_nargs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_args</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>tdesc_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>FUNCARG_DEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_nargs</name></name> <operator>&gt;</operator> <name>FUNCARG_DEF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_args</name></name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_args</name></name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>tdesc_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>curfun</name><operator>-&gt;</operator><name>ii_nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_args</name><index>[<expr><name><name>curfun</name><operator>-&gt;</operator><name>ii_nargs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>ii_dtype</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>ii_dtype</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fnarg_free</name><parameter_list>(<parameter><decl><type><name>iidesc_t</name> <modifier>*</modifier></type><name>ii</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_nargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_args</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>stabs_read</name><parameter_list>(<parameter><decl><type><name>tdata_t</name> <modifier>*</modifier></type><name>td</name></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stab_t</name> <modifier>*</modifier></type><name>stab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stk_t</name> <modifier>*</modifier></type><name>file_stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>iidesc_t</name> <modifier>*</modifier></type><name>iidescp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>iidesc_t</name> <modifier>*</modifier></type><name>curfun</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>curpath</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>curfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fstr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ofstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stabidx</name></decl>, <decl><type ref="prev"/><name>stabstridx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nstabs</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scope</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>stabidx</name> <operator>=</operator> <call><name>findelfsecidx</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".stab.excl"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>stabstridx</name> <operator>=</operator> <call><name>findelfsecidx</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".stab.exclstr"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><operator>(</operator><name>stabidx</name> <operator>=</operator> <call><name>findelfsecidx</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".stab"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>stabstridx</name> <operator>=</operator> <call><name>findelfsecidx</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">".stabstr"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>file_stack</name> <operator>=</operator> <call><name>stack_new</name><argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>stack_push</name><argument_list>(<argument><expr><name>file_stack</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curhdr</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Found stabs in %d, strings in %d\n"</literal></expr></argument>, <argument><expr><name>stabidx</name></expr></argument>, <argument><expr><name>stabstridx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>stabidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name>scn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nstabs</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>d_size</name></name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>stab_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>parse_init</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstabs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>stab</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>stab_t</name> <operator>*</operator><operator>)</operator><name><name>data</name><operator>-&gt;</operator><name>d_buf</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_LBRAC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scope</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"stab %d: opening scope (%d)\n"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_RBRAC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scope</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"stab %d: closing scope (%d)\n"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_EINCL</name></expr>)</condition> <block>{<block_content>








<if_stmt><if>if <condition>(<expr><call><name>stack_level</name><argument_list>(<argument><expr><name>file_stack</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>stack_pop</name><argument_list>(<argument><expr><name>file_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curhdr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>stack_peek</name><argument_list>(<argument><expr><name>file_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_FUN</name> <operator>||</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_GSYM</name> <operator>||</operator>
<name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_LCSYM</name> <operator>||</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_LSYM</name> <operator>||</operator>
<name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_PSYM</name> <operator>||</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_ROSYM</name> <operator>||</operator>
<name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_RSYM</name> <operator>||</operator>
<name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_STSYM</name> <operator>||</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_BINCL</name> <operator>||</operator>
<name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_SO</name> <operator>||</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_OPT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>=</operator> <call><name>elf_strptr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>stabstridx</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>stab</name><operator>-&gt;</operator><name>n_strx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>terminate</name><argument_list>(<argument><expr><literal type="string">"%s: Can't find string at %u for stab %d\n"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_strx</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_BINCL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>curhdr</name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stack_push</name><argument_list>(<argument><expr><name>file_stack</name></expr></argument>, <argument><expr><name>curhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_SO</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>curpath</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curfile</name> <operator>=</operator> <call><name>basename</name><argument_list>(<argument><expr><name>curpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_OPT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"gcc2_compiled."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>terminate</name><argument_list>(<argument><expr><literal type="string">"%s: GCC-generated stabs are "</literal>
<literal type="string">"unsupported. Use DWARF instead.\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fstr</name> <operator>=</operator> <call><name>concat</name><argument_list>(<argument><expr><name>fstr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fstr</name> <operator>=</operator> <call><name>concat</name><argument_list>(<argument><expr><name>fstr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"%4d: .stabs \"%s\", %#x, %d, %hd, %d (from %s)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>fstr</name></expr></argument>, <argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_desc</name></name></expr></argument>,
<argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_value</name></name></expr></argument>, <argument><expr><name>curhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>debug_level</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>check_hash</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>ofstr</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>fstr</name></expr></argument>, <argument><expr><name>ofstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>debug</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"Stutter stab\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ofstr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ofstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ofstr</name> <operator>=</operator> <name>fstr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>iidescp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>parse_stab</name><argument_list>(<argument><expr><name>stab</name></expr></argument>, <argument><expr><name>fstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iidescp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>terminate</name><argument_list>(<argument><expr><literal type="string">"%s: Couldn't parse stab \"%s\" "</literal>
<literal type="string">"(source file %s)\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>curhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>parse_loop_end</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>!=</operator> <name>N_FUN</name> <operator>||</operator> <operator>(</operator><name><name>iidescp</name><operator>-&gt;</operator><name>ii_type</name></name> <operator>!=</operator> <name>II_GFUN</name> <operator>&amp;&amp;</operator>
<name><name>iidescp</name><operator>-&gt;</operator><name>ii_type</name></name> <operator>!=</operator> <name>II_SFUN</name><operator>)</operator> <operator>||</operator> <name>scope</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&amp;&amp;</operator> <name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name> <operator>!=</operator> <name>N_PSYM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>iidescp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>iidesc_free</name><argument_list>(<argument><expr><name>iidescp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>parse_loop_end</name>;</goto>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>iidescp</name><operator>-&gt;</operator><name>ii_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>II_SFUN</name></expr>:</case>
<expr_stmt><expr><name><name>iidescp</name><operator>-&gt;</operator><name>ii_owner</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>curfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>II_GFUN</name></expr>:</case>
<expr_stmt><expr><name>curfun</name> <operator>=</operator> <name>iidescp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fnarg_free</name><argument_list>(<argument><expr><name>iidescp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iidesc_add</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>td_iihash</name></name></expr></argument>, <argument><expr><name>iidescp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>II_SVAR</name></expr>:</case>
<expr_stmt><expr><name><name>iidescp</name><operator>-&gt;</operator><name>ii_owner</name></name> <operator>=</operator> <call><name>xstrdup</name><argument_list>(<argument><expr><name>curfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>II_GVAR</name></expr>:</case>
<case>case <expr><name>II_TYPE</name></expr>:</case>
<case>case <expr><name>II_SOU</name></expr>:</case>
<expr_stmt><expr><call><name>iidesc_add</name><argument_list>(<argument><expr><name><name>td</name><operator>-&gt;</operator><name>td_iihash</name></name></expr></argument>, <argument><expr><name>iidescp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>II_PSYM</name></expr>:</case>
<expr_stmt><expr><call><name>fnarg_add</name><argument_list>(<argument><expr><name>curfun</name></expr></argument>, <argument><expr><name>iidescp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iidesc_free</name><argument_list>(<argument><expr><name>iidescp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>aborterr</name><argument_list>(<argument><expr><literal type="string">"invalid ii_type %d for stab type %d"</literal></expr></argument>,
<argument><expr><name><name>iidescp</name><operator>-&gt;</operator><name>ii_type</name></name></expr></argument>, <argument><expr><name><name>stab</name><operator>-&gt;</operator><name>n_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<label><name>parse_loop_end</name>:</label>
<expr_stmt><expr><name>fstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ofstr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ofstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>resolve_nodes</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>resolve_typed_bitfields</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_finish</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cvt_fixstabs</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cvt_fixups</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><call><name>elf_ptrsz</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
